<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>二叉树的遍历 · 60km/h</title><meta name="description" content="二叉树的遍历 - 60kmlh"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/gandalfr.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/monokai.min.css"><link rel="search" type="application/opensearchdescription+xml" href="http://60kmlh.github.io/atom.xml" title="60km/h"></head><body><div class="wrap"><header><div class="title_wrap"><p>60km/h</p><span class="subtitle typing">好记性不如烂笔头</span></div><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">二叉树的遍历</h1><div class="tags"><a href="/tags/js/" class="tag-title">#js</a><a href="/tags/tree/" class="tag-title">#tree</a></div><div class="post-info">2018年3月17日</div><div class="post-content"><h2 id="二叉树的结构"><a href="#二叉树的结构" class="headerlink" title="二叉树的结构"></a>二叉树的结构</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = &#123;</span><br><span class="line">  val:<span class="string">'F'</span>,</span><br><span class="line">  left: &#123;</span><br><span class="line">    val: <span class="string">'B'</span>,</span><br><span class="line">    left: &#123;<span class="attr">val</span>: <span class="string">'A'</span>&#125;,</span><br><span class="line">    right: &#123;</span><br><span class="line">      val: <span class="string">'D'</span>,</span><br><span class="line">      left: &#123;<span class="attr">val</span>: <span class="string">'C'</span>&#125;,</span><br><span class="line">      right: &#123;<span class="attr">val</span>: <span class="string">'E'</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  right: &#123;</span><br><span class="line">    val: <span class="string">'G'</span>,</span><br><span class="line">    right: &#123;</span><br><span class="line">      val: <span class="string">'I'</span>,</span><br><span class="line">      left:&#123;<span class="attr">val</span>: <span class="string">'H'</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。</p>
<p>常见的做法是采用栈（LIFO）或队列（FIFO）。由于树本身是一种自我引用（即递归定义）的数据结构，因此很自然也可以用递归方式，或者更准确地说，用corecursion，来实现延迟节点的保存。这时（采用递归的情况）这些节点被保存在call stack中。</p>
<h3 id="前序遍历-Pre-Order-Traversal"><a href="#前序遍历-Pre-Order-Traversal" class="headerlink" title="前序遍历(Pre-Order Traversal)"></a>前序遍历(Pre-Order Traversal)</h3><p>指先访问根，然后访问左子树，再访问右子树的遍历方式。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Sorted_binary_tree_preorder.svg/220px-Sorted_binary_tree_preorder.svg.png" alt="深度优先遍历 - 前序遍历：F, B, A, D, C, E, G, I, H."></p>
<p>遍历顺序：F, B, A, D, C, E, G, I, H</p>
<ul>
<li>使用递归</li>
</ul>
<p>递归调用遍历方法，唯一的区别只是在于访问自身节点的位置不同：前序在所有节点之前，后序在所有节点之后，中序则是在两节点之间。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pre_order_traversal_recursion</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(root.val)</span><br><span class="line">    pre_order_traversal_recursion(root.left)</span><br><span class="line">    pre_order_traversal_recursion(root.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>非递归 使用栈</li>
</ul>
<p>栈的特点是先进后出，所以进栈是要先进根节点，出栈的时候访问，再进右子节点再进左子节点，再出栈访问，重复以上操作，直到栈空。</p>
<p>在入栈前判定空节点，这样可以减少出入栈的次数，也减少内存使用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pre_order_traversal</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    stack.push(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//console.log(stack.map(item =&gt; item.val))</span></span><br><span class="line">      root = stack.pop()</span><br><span class="line">      <span class="built_in">console</span>.log(root.val)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(root.right) &#123;</span><br><span class="line">        stack.push(root.right)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(root.left) &#123;</span><br><span class="line">        stack.push(root.left)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="中序遍历-In-Order-Traversal"><a href="#中序遍历-In-Order-Traversal" class="headerlink" title="中序遍历(In-Order Traversal)"></a>中序遍历(In-Order Traversal)</h3><p>指先访问左（右）子树，然后访问根，最后访问右（左）子树的遍历方式。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Sorted_binary_tree_inorder.svg/220px-Sorted_binary_tree_inorder.svg.png" alt="深度优先遍历 - 中序遍历：A, B, C, D, E, F, G, H, I."></p>
<p>遍历顺序：A, B, C, D, E, F, G, H, I.</p>
<ul>
<li><p>使用递归</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">in_order_traversal_recursion</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root) &#123;</span><br><span class="line">    in_order_traversal_recursion(root.left)</span><br><span class="line">    <span class="built_in">console</span>.log(root.val)</span><br><span class="line">    in_order_traversal_recursion(root.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>非递归 使用栈<br>中序遍历的非递归实现需要不停地将左子节点入栈，直到遇到空节点为止。然后就可以出栈输出一个节点进行访问，之后将转向其右子节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">in_order_traversal</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span> || !!root) &#123;</span><br><span class="line">      <span class="comment">//console.log(stack.map(item =&gt; item.val))</span></span><br><span class="line">      <span class="keyword">if</span>(root) &#123;</span><br><span class="line">        stack.push(root)</span><br><span class="line">        root = root.left</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        root = stack.pop()</span><br><span class="line">        <span class="built_in">console</span>.log(root.val)</span><br><span class="line">        root = root.right</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="后序遍历-Post-Order-Traversal"><a href="#后序遍历-Post-Order-Traversal" class="headerlink" title="后序遍历(Post-Order Traversal)"></a>后序遍历(Post-Order Traversal)</h3><p>指先访问子树，然后访问根的遍历方式</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Sorted_binary_tree_postorder.svg/220px-Sorted_binary_tree_postorder.svg.png" alt="深度优先搜索 - 后序遍历：A, C, E, D, B, H, I, G, F."></p>
<p>遍历顺序：A, C, E, D, B, H, I, G, F.</p>
<ul>
<li><p>使用递归</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">post_order_traversal_recursion</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root) &#123;</span><br><span class="line">    post_order_traversal_recursion(root.left)</span><br><span class="line">    post_order_traversal_recursion(root.right)</span><br><span class="line">    <span class="built_in">console</span>.log(root.val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>非递归 使用栈</p>
</li>
</ul>
<p>使用一个栈实现</p>
<p>对于任一节点，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的节点，此时该节点出现在栈顶，但是此时不能将其出栈并访问，因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该节点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个节点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该节点是否是第一次出现在栈顶。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">post_order_traversal</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    stack.push(root)</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//console.log(stack.map(item =&gt; item.val))</span></span><br><span class="line">      tmp = stack[stack.length - <span class="number">1</span>]</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(tmp.left &amp;&amp; root !== tmp.left &amp;&amp; root !== tmp.right) &#123;</span><br><span class="line">        stack.push(tmp.left)</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp.right &amp;&amp; root !== tmp.right) &#123;</span><br><span class="line">        stack.push(tmp.right)</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(stack.pop().val)</span><br><span class="line">        root = tmp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用两个栈实现</p>
<p>后序遍历的结构，相当于前序遍历访问左右子树的顺序互换，再把最后的结构前后反一下就可以了。</p>
<p>此方式是先遍历根节点，再遍历右子树，最后遍历左子树。</p>
<p>再借助第二个栈，将顺序倒转过来访问，就是后序遍历的顺序了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">post_order_traversal_two_stack</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack1 = []</span><br><span class="line">    <span class="keyword">let</span> stack2 = []</span><br><span class="line">    stack1.push(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(stack1.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// console.log('stack1:',stack1.map(item =&gt; item.val))</span></span><br><span class="line">      <span class="comment">// console.log('stack2:',stack2.map(item =&gt; item.val))</span></span><br><span class="line">      root = stack1.pop()</span><br><span class="line">      stack2.push(root)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(root.left) &#123;</span><br><span class="line">        stack1.push(root.left)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(root.right) &#123;</span><br><span class="line">        stack1.push(root.right)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(stack2.length !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(stack2.pop().val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>和深度优先遍历不同，广度优先遍历会先访问离根节点最近的节点。二叉树的广度优先遍历又称按层次遍历。算法借助队列实现。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d1/Sorted_binary_tree_breadth-first_traversal.svg/220px-Sorted_binary_tree_breadth-first_traversal.svg.png" alt="广度优先遍历 - 层次遍历：F, B, G, A, D, I, C, E, H."></p>
<p>使用数组模拟队列。首先将根节点归入队列。当队列不为空的时候，执行循环：取出队列的一个节点，如果该节点的左子树为非空，则将该节点的左子树入队列；如果该节点的右子树为非空，则将该节点的右子树入队列。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">layer_traversal</span>(<span class="params">note</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!node) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Empty Tree'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> que = []</span><br><span class="line">  que.push(node)</span><br><span class="line">  <span class="keyword">while</span>(que.length !== <span class="number">0</span>) &#123;</span><br><span class="line">    node = que.shift()</span><br><span class="line">    <span class="built_in">console</span>.log(node.value)</span><br><span class="line">    <span class="keyword">if</span>(node.left) que.push(node.left)</span><br><span class="line">    <span class="keyword">if</span>(node.right) que.push(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86" target="_blank" rel="noopener">树的遍历</a></li>
<li><a href="https://blog.csdn.net/fansongy/article/details/6798278" target="_blank" rel="noopener">二叉树 前序、中序、后序、层次遍历及非递归实现 查找、统计个数、比较、求深度的递归实现</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/04/21/使用队列解决两道题目/" class="prev">上一篇</a><a href="/2018/02/28/实现数组的flat方法/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 - 2022 <a href="http://60kmlh.github.io">60kmlh</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/MikeCoder/hexo-theme-gandalfr" target="_blank">hexo-theme-gandalfr</a>.</p></div></footer></div><script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js" crossorigin="anonymous"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.js" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-147983033-1",'auto');ga('send','pageview');</script><script>$(document).ready(function() { hljs.configure({useBR: true}); $('pre').each(function(i, block) { hljs.highlightBlock(block); }); });</script></body></html>