<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>前端路由的原理和实现 · 60km/h</title><meta name="description" content="前端路由的原理和实现 - 60kmlh"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/gandalfr.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/monokai.min.css"><link rel="search" type="application/opensearchdescription+xml" href="http://60kmlh.github.io/atom.xml" title="60km/h"></head><body><div class="wrap"><header><div class="title_wrap"><p>60km/h</p><span class="subtitle typing">好记性不如烂笔头</span></div><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">前端路由的原理和实现</h1><div class="tags"><a href="/tags/路由/" class="tag-title">#路由</a></div><div class="post-info">2018年6月22日</div><div class="post-content"><h2 id="什么是前端路由"><a href="#什么是前端路由" class="headerlink" title="什么是前端路由"></a>什么是前端路由</h2><p>路由是根据不同的 url 地址展示不同的内容或页面。</p>
<p>早期的路由都是后端直接根据 url 来 reload 页面实现的，即后端控制路由。后来页面越来越复杂，服务器压力越来越大，随着 ajax（异步刷新技术） 的出现，页面实现非 reload 就能刷新数据，让前端也可以控制 url 自行管理，前端路由由此而生。</p>
<p>单页面应用的实现，就是因为有了前端路由这个概念。<br><a id="more"></a></p>
<h2 id="前端路由的两种模式"><a href="#前端路由的两种模式" class="headerlink" title="前端路由的两种模式"></a>前端路由的两种模式</h2><h3 id="Hash路由"><a href="#Hash路由" class="headerlink" title="Hash路由"></a>Hash路由</h3><p>hash就是指在 url 中看到 #， 以及其后面的字符。这个 # 有两种情况，一个是我们所谓的锚点，本身是用来做页面定位的，它可以使对应 id 的元素显示在可视区域内。而路由里的 # 不叫锚点，我们称之为 hash。hash满足以下几个特性，才使得其可以实现前端路由：</p>
<ol>
<li>url中hash值的变化并不会重新加载页面，因为hash是用来指导浏览器行为的，对服务端是无用的，所以不会包括在http请求中。</li>
<li>hash值的改变，都会在浏览器的访问历史中增加一个记录，也就是能通过浏览器的回退、前进按钮控制hash的切换</li>
<li>我们可以通过hashchange事件，监听到hash值的变化，从而响应不同路径的逻辑处理。</li>
</ol>
<p>触发hash值的变化有2种方法:</p>
<ol>
<li>一种是通过a标签，设置href属性，当标签点击之后，地址栏会改变，同时会触发hashchange事件</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#index"</span>&gt;</span>to index<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>一种是通过js直接赋值给location.hash，也会改变url，触发hashchange事件。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location.hash=<span class="string">"#index"</span></span><br></pre></td></tr></table></figure>
<h3 id="History路由"><a href="#History路由" class="headerlink" title="History路由"></a>History路由</h3><p>HTML5的 History API 为浏览器的全局history对象增加了扩展方法。</p>
<p>window对象提供了onpopstate事件来监听历史栈的改变,一旦历史栈信息发生改变,便会触发该事件。</p>
<p><strong>特别注意的是,调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件。</strong></p>
<p>history提供了两个操作历史栈的API:history.pushState 和 history.replaceState,这两个API都接收三个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"http://www.google.com"</span>);</span><br><span class="line"><span class="built_in">window</span>.history.replaceState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"http://www.google.com"</span>);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>状态对象（state object），一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，会触发popstate事件，并能在事件中使用该对象。</li>
<li>标题（title） ：传入一个短标题给当前state。现在大多数浏览器不支持或者会忽略此参数，最好传入null代替；</li>
<li>地址（URL）：新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。</li>
</ul>
<p>这两个API的相同之处是都会操作浏览器的历史记录，而不会引起页面的刷新。不同之处在于，pushState会增加一条新的历史记录，而replaceState则会替换当前的历史记录。这两个api，加上state改变触发的popstate事件，提供了单页应该的另一种路由方式。</p>
<p><strong>当我们使用history模式时，如果服务器没有进行配置,刷新页面会出现404。</strong></p>
<p>原因是因为history模式的url是真实的url,服务器会对url的文件路径进行资源查找,找不到资源就会返回404。</p>
<p>解决方法就是对服务器进行配置，将所有向服务器请求的URL资源，都重定向到index.html返回给客户端。</p>
<ul>
<li>在nignx环境下：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location /&#123;</span><br><span class="line">    root   /data/nginx/html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">    error_page 404 /index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>http-server下：</li>
</ul>
<p>安装npm包 spa-http-server，启动时增加 –push-state 参数<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-server --push-state</span><br></pre></td></tr></table></figure></p>
<ul>
<li>webpack开发环境下：</li>
</ul>
<p>使用webpack-dev-server的里的historyApiFallback属性来支持HTML5 History Mode。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    devServer: &#123;</span><br><span class="line">        <span class="comment">//在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html (解决histroy mode 404)</span></span><br><span class="line">        historyApiFallback: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>出现兼容性问题主要是在IE下面，hash路由在IE8及以上可用，而history路由在IE10及以上才可用。</p>
<h2 id="实现一个简单的路由"><a href="#实现一个简单的路由" class="headerlink" title="实现一个简单的路由"></a>实现一个简单的路由</h2><p>先构造一个myRouter类，根据不同的mode参数，分别为这两种方式创建对应的类,并进行实例化,完成myRouter类的实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myRouter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(opts) &#123;</span><br><span class="line">    <span class="keyword">this</span>.router = opts.mode !== <span class="string">'hash'</span> ? <span class="keyword">new</span> HistoryRouter(opts) : <span class="keyword">new</span> HashRouter(opts)</span><br><span class="line">    <span class="keyword">this</span>.router.init()</span><br><span class="line">  &#125;</span><br><span class="line">  push(path) &#123;</span><br><span class="line">    <span class="keyword">this</span>.router.push(path)</span><br><span class="line">  &#125;</span><br><span class="line">  replace(path) &#123;</span><br><span class="line">    <span class="keyword">this</span>.router.replace(path)</span><br><span class="line">  &#125;</span><br><span class="line">  go(num) &#123;</span><br><span class="line">    <span class="keyword">this</span>.router.go(num)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hashRouter"><a href="#hashRouter" class="headerlink" title="hashRouter"></a>hashRouter</h3><ul>
<li>初始化</li>
</ul>
<p>插件在被调用的时候进行初始化，作用是注册路由以及绑定对应的路由切换事件的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">init() &#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 注册路由</span></span><br><span class="line">  <span class="keyword">this</span>.initRouter()</span><br><span class="line">  <span class="comment">// debugger</span></span><br><span class="line">  <span class="comment">// 页面加载匹配路由</span></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      that.urlChange()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 路由切换</span></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      that.urlChange()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>路由注册</li>
</ul>
<p>将路由对象数组参数在初始化的时候就做好路由匹配。this.routers用来存储路由对象，执行每一个路由的callback函数就是加载对应的js文件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">initRouter() &#123;</span><br><span class="line">  <span class="comment">// debugger</span></span><br><span class="line">  (<span class="keyword">this</span>.opts.routes || []).forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.map(item)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个路由注册</span></span><br><span class="line">map(item) &#123;</span><br><span class="line">  <span class="keyword">let</span> path = item.path.replace(<span class="regexp">/\s*/g</span>, <span class="string">''</span>)<span class="comment">// 过滤空格</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.routers[path] = &#123;</span><br><span class="line">    callback: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.asyncFun(item.url, state)</span><br><span class="line">    &#125; <span class="comment">// 回调</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>asyncFun函数</li>
</ul>
<p>异步加载目标js文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由异步懒加载js文件</span></span><br><span class="line">asyncFun(file, transition) &#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> _body = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">var</span> scriptEle = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  scriptEle.type = <span class="string">'text/javascript'</span></span><br><span class="line">  scriptEle.src = file</span><br><span class="line">  scriptEle.async = <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">  scriptEle.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    that.opts.afterFun &amp;&amp; that.opts.afterFun(transition)</span><br><span class="line">  &#125;</span><br><span class="line">  _body.appendChild(scriptEle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>render函数</li>
</ul>
<p>作用就是渲染页面，在这里也就是执行加载路由对应的js文件。如果存在beforeFun钩子的话，则由beforeFun钩子触发render函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染视图(执行匹配到的js代码)</span></span><br><span class="line">render(currentPath) &#123;</span><br><span class="line">  <span class="keyword">this</span>.currentPath = currentPath</span><br><span class="line">  <span class="comment">// 全局路由守护</span></span><br><span class="line">  <span class="keyword">let</span> pathObj = <span class="keyword">this</span>.routers[currentPath.path]</span><br><span class="line">  <span class="keyword">if</span>(!pathObj) &#123;</span><br><span class="line">    alert(<span class="string">'404'</span>)</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.opts.beforeFun) &#123;</span><br><span class="line">    <span class="keyword">this</span>.opts.beforeFun(&#123;</span><br><span class="line">      to: &#123;</span><br><span class="line">        path: currentPath.path,</span><br><span class="line">        query: currentPath.query</span><br><span class="line">      &#125;,</span><br><span class="line">      next() &#123;</span><br><span class="line">        <span class="comment">// 执行目标路由对应的js代码（相当于是组件渲染）</span></span><br><span class="line">        pathObj.callback(currentPath)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pathObj.callback(currentPath)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="historyRouter"><a href="#historyRouter" class="headerlink" title="historyRouter"></a>historyRouter</h3><p>historyRouter的实现与HashRouter的实现也是很类似的，下面只写下不同之处：</p>
<ul>
<li>路由监听</li>
</ul>
<ol>
<li>historyRouter</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    that.urlChange()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>HashRouter</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    that.urlChange()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>获取当前路由和参数</li>
</ul>
<ol>
<li>historyRouter</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前hash</span></span><br><span class="line">getPath() &#123;</span><br><span class="line">  <span class="keyword">var</span> hash = <span class="built_in">window</span>.location.pathname</span><br><span class="line">  <span class="keyword">return</span> hash </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取参数</span></span><br><span class="line">getParams() &#123;</span><br><span class="line">  <span class="keyword">var</span> paramsStr = <span class="built_in">window</span>.location.search</span><br><span class="line">  <span class="keyword">var</span> index = paramsStr.indexOf(<span class="string">'?'</span>)</span><br><span class="line">  <span class="keyword">var</span> params = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(index !== <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = paramsStr.slice(<span class="number">1</span>).split(<span class="string">'&amp;'</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">      <span class="keyword">let</span> data = arr[i].split(<span class="string">"="</span>)</span><br><span class="line">      <span class="keyword">if</span>(data.length == <span class="number">2</span>)&#123;</span><br><span class="line">          params[data[<span class="number">0</span>]] = data[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> params</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>HashRouter</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前hash</span></span><br><span class="line">getHash() &#123;</span><br><span class="line">  <span class="keyword">var</span> hash = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">var</span> index = hash.indexOf(<span class="string">'?'</span>)</span><br><span class="line">  <span class="keyword">if</span>(hash === <span class="string">''</span>) <span class="keyword">return</span> <span class="string">'/'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(index !== <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> hash.slice(<span class="number">0</span>, index)</span><br><span class="line">  &#125;   </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> hash </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取参数</span></span><br><span class="line">getParams() &#123;</span><br><span class="line">  <span class="keyword">var</span> hash = <span class="built_in">window</span>.location.hash</span><br><span class="line">  <span class="keyword">var</span> index = hash.indexOf(<span class="string">'?'</span>)</span><br><span class="line">  <span class="keyword">var</span> params = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(index !== <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = hash.slice(index + <span class="number">1</span>).split(<span class="string">'&amp;'</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">      <span class="keyword">let</span> data = arr[i].split(<span class="string">"="</span>)</span><br><span class="line">      <span class="keyword">if</span>(data.length == <span class="number">2</span>)&#123;</span><br><span class="line">          params[data[<span class="number">0</span>]] = data[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> params</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>push方法，压入history栈，进行路由跳转</li>
</ul>
<ol>
<li>historyRouter</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push(path) &#123;</span><br><span class="line">    <span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, path)</span><br><span class="line">    <span class="keyword">this</span>.urlChange() <span class="comment">//手动触发</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>HashRouter</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push(path) &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.hash = path</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><a href="https://github.com/60kmlh/router" target="_blank" rel="noopener">router</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://juejin.im/post/5c380afde51d4552232fb077" target="_blank" rel="noopener">[实践系列] 前端路由</a></li>
<li><a href="https://github.com/kaola-fed/blog/issues/137" target="_blank" rel="noopener">浅谈前端路由</a></li>
<li><a href="https://juejin.im/post/5c4bbeaae51d453ba8104f39" target="_blank" rel="noopener">JS 专题系列-前端路由</a></li>
<li><a href="https://juejin.im/post/5b45c878f265da0f783c89a6" target="_blank" rel="noopener">前端路由实现及 react-router v4 源码分析</a></li>
<li><a href="http://web.jobbole.com/86407/" target="_blank" rel="noopener">前端路由实现与 react-router 源码分析</a></li>
<li><a href="https://www.npmjs.com/package/spa-http-server" target="_blank" rel="noopener">spa-http-server</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/21/浏览器的Event Loop机制/" class="prev">上一篇</a><a href="/2018/06/09/常见排序算法的JavaScript实现/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 - 2022 <a href="http://60kmlh.github.io">60kmlh</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/MikeCoder/hexo-theme-gandalfr" target="_blank">hexo-theme-gandalfr</a>.</p></div></footer></div><script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js" crossorigin="anonymous"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.js" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-147983033-1",'auto');ga('send','pageview');</script><script>$(document).ready(function() { hljs.configure({useBR: true}); $('pre').each(function(i, block) { hljs.highlightBlock(block); }); });</script></body></html>