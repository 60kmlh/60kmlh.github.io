<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>react服务端渲染的实现 · 60km/h</title><meta name="description" content="react服务端渲染的实现 - 60kmlh"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/gandalfr.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/monokai.min.css"><link rel="search" type="application/opensearchdescription+xml" href="http://60kmlh.github.io/atom.xml" title="60km/h"></head><body><div class="wrap"><header><div class="title_wrap"><p>60km/h</p><span class="subtitle typing">好记性不如烂笔头</span></div><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">react服务端渲染的实现</h1><div class="tags"><a href="/tags/react/" class="tag-title">#react</a><a href="/tags/js/" class="tag-title">#js</a><a href="/tags/ssr/" class="tag-title">#ssr</a></div><div class="post-info">2018年8月11日</div><div class="post-content"><h2 id="什么时候需要服务端渲染（Server-Side-Render）"><a href="#什么时候需要服务端渲染（Server-Side-Render）" class="headerlink" title="什么时候需要服务端渲染（Server Side Render）"></a>什么时候需要服务端渲染（Server Side Render）</h2><ol>
<li>现代前端应用的页面内容由ajax请求数据之后，再在客户端进行页面的动态渲染，而一般搜索引擎或网页爬虫只对ajax渲染前的HTML文件进行爬取，这种形式不利于网站的SEO。</li>
<li>单页应用通过请求js和ajax请求数据之后，再进行页面结构和数据的渲染，降低了首屏的展示速度。<a id="more"></a>
因此，通过服务端渲染的方式，将渲染结果以HTML结构的形式返回给客户端，可以优化以上两个主要的问题。</li>
</ol>
<h2 id="react中和SSR相关的API"><a href="#react中和SSR相关的API" class="headerlink" title="react中和SSR相关的API"></a>react中和SSR相关的API</h2><ul>
<li>renderToString()</li>
</ul>
<p>将 React 元素渲染为初始 HTML。React 将返回一个 HTML 字符串。你可以使用此方法在服务端生成 HTML。</p>
<ul>
<li>renderToStaticMarkup()</li>
</ul>
<p>此方法与 renderToString 相似，但此方法不会在 React 内部创建的额外 DOM 属性，例如 data-reactroot。如果你希望把 React 当作静态页面生成器来使用，此方法会非常有用，因为去除额外的属性可以节省一些字节。</p>
<p>如果你计划在前端使用 React 以使得标记可交互，请不要使用此方法。你可以在服务端上使用 renderToString 或在前端上使用 ReactDOM.hydrate() 来代替此方法。</p>
<p><strong>以上两个API可以被使用在服务端和浏览器环境。</strong></p>
<p><strong>下述附加方法依赖一个只能在服务端使用的 package（stream）。它们在浏览器中不起作用。</strong></p>
<ul>
<li>renderToNodeStream()</li>
</ul>
<p>将一个 React 元素渲染成其初始 HTML。返回一个可输出 HTML 字符串的可读流。通过可读流输出的 HTML 完全等同于 ReactDOMServer.renderToString 返回的 HTML。</p>
<ul>
<li>renderToStaticNodeStream()</li>
</ul>
<p>此方法与 renderToNodeStream 相似，但此方法不会在 React 内部创建的额外 DOM 属性，例如 data-reactroot。如果你希望把 React 当作静态页面生成器来使用，此方法会非常有用，因为去除额外的属性可以节省一些字节。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>下面借助 renderToString() 方法实现一个简单的服务端渲染例子。</p>
<h3 id="引入服务端框架"><a href="#引入服务端框架" class="headerlink" title="引入服务端框架"></a>引入服务端框架</h3><p>这里我们采用 express 框架。<br>新建一个 React 组件.</p>
<p><strong>App.js</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        首页</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;button onClick=&#123;() =&gt; &#123;<span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;)&#125;&#125;&gt;+&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">          &lt;div&gt;&#123;this.state.count&#125;&lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure></p>
<p><strong>server.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./src/App'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> renderedString = renderToString(</span><br><span class="line">        &lt;App/&gt;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  fs.readFile(path.resolve(<span class="string">'index.html'</span>), <span class="string">'utf8'</span>, (error, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(error) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(error)</span><br><span class="line">      res.send(<span class="string">'&lt;p&gt;Error!&lt;/p&gt;'</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span></span><br><span class="line">    res.send(<span class="string">`<span class="subst">$&#123;data.replace(<span class="string">'&lt;div id="app"&gt;&lt;/div&gt;'</span>, <span class="string">`&lt;div id="app"&gt;<span class="subst">$&#123;renderedString&#125;</span>&lt;/div&gt;`</span>)&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>
<p>然后运行 node server.js。这个时候会发现，启动报错。原因在于我们在 node 里面使用了 ES6 Module 和 React JSX，node并不支持。</p>
<p>引入 babel-node 来解决这个问题。</p>
<p>安装完成 babel-node 以及 babel-core，babel-cli，babel-preset-react 等相关工具之后，执行<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"start"</span>: <span class="string">"babel-node ./server.js --presets es2015,stage-0,react"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>访问 localhost:8000,就可以看到页面效果了。</p>
<p><img src="https://i.loli.net/2019/03/22/5c944d96a9ea0.png" alt="服务端渲染"></p>
<h3 id="客户端React组件的实例化"><a href="#客户端React组件的实例化" class="headerlink" title="客户端React组件的实例化"></a>客户端React组件的实例化</h3><p>上面的App组件中，点击 + 按钮，并不会生效，这个页面只是一个静态的HTML页面，没有在客户端渲染React组件并初始化React实例。只有在初始化React实例后，才能更新组件的state和props，初始化React的事件系统，执行虚拟DOM的重新渲染机制。</p>
<p>那么这里可能会有疑问，服务器端已经渲染了一次React组件，如果在客户端中再渲染一次 React 组件，会不会渲染两次 React 组件。答案当然是不会的。</p>
<p>在 React16 版本以前，如果使用renderToString渲染组件，会在组件的第一个DOM带有data-react-checksum属性，当客户端渲染React组件时，首先计算出组件的checksum值，然后检索HTML DOM看看是否存在数值相同的data-react-checksum属性，如果存在，则组件只会渲染一次，如果不存在，则会抛出一个warning异常。</p>
<p>也就是说，当服务器端和客户端渲染具有相同的props和相同DOM结构的组件时，该React组件只会渲染一次。</p>
<p>在服务器端使用renderToStaticMarkup渲染的组件不会带有data-react-checksum属性，此时客户端会重新渲染组件，覆盖掉服务器端的组件。因此，当页面不是渲染一个静态的页面时，最好还是使用renderToString方法。</p>
<p>接着根据 data-reactid 属性，找到需要绑定的事件元素，进行事件绑定的处理。</p>
<blockquote>
<p>React v16 版本里，ReactDOMServer 渲染的内容不再有 data-react 的属性，而是尽可能复用 SSR 的 HTML 结构。这就带来了一个问题，ReactDOM.render 不再能够简单地用 data-react-checksum 的存在性来判断是否应该尝试复用，如果每次 ReactDOM.render 都要尽可能尝试复用，性能和语义都会出现问题。所以， ReactDOM 提供了一个新的 API， ReactDOM.hydrate() 。<br>在 React v17 版本里，ReactDOM.render 则直接不再具有复用 SSR 内容的功能。</p>
</blockquote>
<p>实践发现，v16 版本里面，render() 方法会将整个 DOM 结构重新渲染， 而使用 hydrate 则不会。</p>
<p>加上在客户端渲染的代码<br><strong>index.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App /&gt;</span><br><span class="line">, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure>
<p>这个时候，我们需要引入 webpack，将要在客户端执行的代码用 webpack 打包到 dist 文件夹。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"start"</span>: <span class="string">"npm run build &amp;&amp; babel-node ./server.js --presets es2015,stage-0,react"</span>,</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"webpack"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>在 html 模板里手动引入js，<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/app.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>再次启动项目，这个时候会发现，请求回来的 app.js 的内容变成了 html.index 文件。</p>
<p><img src="https://i.loli.net/2019/03/22/5c944e3cb98ad.png" alt="服务端渲染"><br>原因在于请求 /dist/app.js 被当成了普通的路由了，没有被当成一个静态资源来返回有效的 JavaScript 代码，解决方案就是在 express 中添加一个静态资源服务。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line">app.use(express.static(<span class="string">'dist'</span>));</span><br></pre></td></tr></table></figure></p>
<p>同时将 html 的 script 路径修改下，<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/app.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样就可以客户端就可以正确地获取到 app.js 的内容了，然后在客户端进行 React 组件的实例化，这个时候点击 + 按钮也有效果了。</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>接下来添加路由功能</p>
<p>服务端匹配路由的时候，不能用 BrowserRouter，要使用无状态的 StaticRouter，并结合 location 和 context 两个属性。</p>
<p>给App组件添加路由。</p>
<p><strong>App.js</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Switch, Route, Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span> </span><br><span class="line"><span class="keyword">import</span> PageA <span class="keyword">from</span> <span class="string">'./component/PageA'</span></span><br><span class="line"><span class="keyword">import</span> PageB <span class="keyword">from</span> <span class="string">'./component/PageB'</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        首页</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;button onClick=&#123;() =&gt; &#123;<span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;)&#125;&#125;&gt;+&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">          &lt;div&gt;&#123;this.state.count&#125;&lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Link to='/</span><span class="string">'&gt;跳转到pageA&lt;/Link&gt;</span></span><br><span class="line"><span class="string">        &lt;br/&gt;</span></span><br><span class="line"><span class="string">        &lt;Link to='</span>/pageb<span class="string">'&gt;跳转到pageB&lt;/Link&gt;</span></span><br><span class="line"><span class="string">        &lt;Switch&gt;</span></span><br><span class="line"><span class="string">          &lt;Route exact path="/" component=&#123; PageA &#125; /&gt;</span></span><br><span class="line"><span class="string">          &lt;Route exact path="/pageb" component=&#123; PageB &#125; /&gt;</span></span><br><span class="line"><span class="string">        &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">//...</span></span><br></pre></td></tr></table></figure></p>
<p>服务端加入路由匹配。这里默认浏览器 url 和 配置的路由地址一样，也可以把路由抽成单独的配置文件，借助 react-router-dom 路由模块的 matchPath 方法来匹配路由。</p>
<p><strong>server.js</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; StaticRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> renderedString = renderToString(</span><br><span class="line">    &lt;StaticRouter location=&#123; req.url &#125;&gt;</span><br><span class="line">      &lt;App /&gt;</span><br><span class="line">    &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/...</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，已经实现了路由功能。</p>
<p><img src="https://i.loli.net/2019/03/22/5c9455e9e0e31.png" alt="服务端渲染"><br><img src="https://i.loli.net/2019/03/22/5c9455e9df280.png" alt="服务端渲染"></p>
<h3 id="服务端异步获取数据"><a href="#服务端异步获取数据" class="headerlink" title="服务端异步获取数据"></a>服务端异步获取数据</h3><p>当服务端渲染的html文件数据需要通过请求另外的接口获取时，这个时候就需要服务端去请求数据，再将渲染完的 html 页面返回给客户端。</p>
<p>模拟接口返回数据。</p>
<p><strong>fetchData.js</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getInitCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="number">10</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务端请求完数据之后，需要将给数据 React 组件使用。可以采用两种方式：</p>
<ol>
<li>通过 React 组件的 props 传入。</li>
<li>通过 Router 的 context 传入，React 组件中再通过 props.staticContext 获取到。</li>
</ol>
<p><strong>server.js</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getInitCount &#125; <span class="keyword">from</span> <span class="string">'./src/utils/fetchData'</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">app.get(<span class="string">'/*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> renderedString = renderToString(</span><br><span class="line">    &lt;StaticRouter location=&#123; req.url &#125;&gt;</span><br><span class="line">      &lt;App initCount=&#123;resData&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/...</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure></p>
<p><strong>App.js</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: props.initCount || <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样可以看到服务器返回的 html 文件内容，已经将 count 的初始值 10 渲染进去了。</p>
<p><img src="https://i.loli.net/2019/03/22/5c948522154ca.jpg" alt="服务端渲染"></p>
<p>但是此时页面显示的count值还是0，原因在于虽然使用了 hydrate() 方法，并不会将 html 结构重新渲染，但是 React 组件还是会走一遍生命周期流程，App 组件的 props.initCount 依旧是 0。</p>
<p>为了让客户端和服务端的props保持一致，需要将一个服务器生成的首屏 props 赋给客户端的全局变量。</p>
<p>修改下server.js 和 index.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  getInitCount().then(<span class="function"><span class="params">resData</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> renderedString = renderToString(</span><br><span class="line">        &lt;StaticRouter location=&#123;req.url&#125;&gt;</span><br><span class="line">          &lt;App initCount=&#123;resData&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    fs.readFile(path.resolve('index.html'), 'utf8', (error, data) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/...</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      res.send(`$&#123;data</span></span><br><span class="line"><span class="regexp">        .replace('&lt;div id="app"&gt;&lt;/</span>div&gt;<span class="string">', `&lt;div id="app"&gt;$&#123;renderedString&#125;&lt;/div&gt;`)</span></span><br><span class="line"><span class="string">        .replace('</span>&lt;<span class="regexp">/body&gt;', `&lt;/</span>body&gt;<span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.__initCount__ = $&#123;<span class="built_in">JSON</span>.stringify(resData)&#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><span class="string">`)&#125;`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.hydrate(</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;App initCount=&#123;<span class="built_in">window</span>.__initCount__&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    , document.getElementById('app'))</span></span><br></pre></td></tr></table></figure>
<p>注意 window.<strong>initCount</strong> 需要在 app.js 前面加载。</p>
<p><img src="https://i.loli.net/2019/03/22/5c9487b39b46b.png" alt="服务端渲染"></p>
<h3 id="服务端无法支持图片、css等资源文件"><a href="#服务端无法支持图片、css等资源文件" class="headerlink" title="服务端无法支持图片、css等资源文件"></a>服务端无法支持图片、css等资源文件</h3><p>如果代码中我们 import 了图片, svg, css 等非 js 资源，在客户端 webpack 的各种 loader 帮我们处理了这些资源，而 node 环境下只能识别 js。由于之前的例子没有引入额外的静态资源，所以没有出现这样的问题。</p>
<p>试着在 pageB 组件中引入图片。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;B页面&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;img src=&#123;require('../</span>assets/img/hat.jpg<span class="string">')&#125; alt=""/&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>运行便报错了。</p>
<p>引入 webpack-isomorphic-tools 工具来解决这个问题。</p>
<p>webpack-isomorphic-tools 完成了两件事：</p>
<ol>
<li>以webpack插件的形式，预编译less（不局限于less，还支持图片文件、字体文件等），将其转换为一个 assets.json 文件保存到项目目录下。</li>
<li>require hook，所有less文件的引入，代理到生成的 JSON 文件中，匹配文件路径，返回一个预先编译好的 JSON 对象。</li>
</ol>
<p>实现步骤：</p>
<ol>
<li>修改webpack.config.js</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> WebpackIsomorphicToolsPlugin = <span class="built_in">require</span>(<span class="string">'webpack-isomorphic-tools/plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> webpackIsomorphicToolsPlugin = </span><br><span class="line">  <span class="comment">// webpack-isomorphic-tools settings reside in a separate .js file </span></span><br><span class="line">  <span class="comment">// (because they will be used in the web server code too).</span></span><br><span class="line">  <span class="keyword">new</span> WebpackIsomorphicToolsPlugin(<span class="built_in">require</span>(<span class="string">'./webpack-isomorphic-tools-configuration'</span>))</span><br><span class="line">  <span class="comment">// also enter development mode since it's a development webpack configuration</span></span><br><span class="line">  <span class="comment">// (see below for explanation)</span></span><br><span class="line">  .development()</span><br><span class="line"></span><br><span class="line"><span class="comment">// usual Webpack configuration</span></span><br><span class="line"><span class="built_in">module</span>.exports =</span><br><span class="line">&#123;</span><br><span class="line">  context: <span class="string">'(required) your project path here'</span>,</span><br><span class="line">  <span class="built_in">module</span>:</span><br><span class="line">  &#123;</span><br><span class="line">    loaders:</span><br><span class="line">    [</span><br><span class="line">      <span class="comment">//...,</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: webpackIsomorphicToolsPlugin.regularExpression(<span class="string">'images'</span>),</span><br><span class="line">        loader: <span class="string">'url-loader?limit=1024'</span>, <span class="comment">// any image below or equal to 10K will be converted to inline base64 instead</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins:</span><br><span class="line">  [</span><br><span class="line">    <span class="comment">//...,</span></span><br><span class="line">    webpackIsomorphicToolsPlugin</span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>添加 webpack-isomorphic-tools 配置文件 webpack-isomorphic-config.js</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = </span><br><span class="line">&#123;</span><br><span class="line">  assets:</span><br><span class="line">  &#123;</span><br><span class="line">    images:</span><br><span class="line">    &#123;</span><br><span class="line">      extensions: [<span class="string">'png'</span>, <span class="string">'jpg'</span>, <span class="string">'gif'</span>, <span class="string">'ico'</span>, <span class="string">'svg'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>webpack-isomorphic-tools 启动时，会先等待指定目录下 assets.json 文件生成，只有该文件就绪后，require hook 才会进行，进而触发 server 回调，只有在此回调中执行的代码，才能保证进行了require hook。所以 server.js 文件变成了回调，需要新增额外的入口文件。</p>
<ol start="3">
<li>增加mian.js</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> WebpackIsomorphicTools = <span class="built_in">require</span>(<span class="string">'webpack-isomorphic-tools'</span>);</span><br><span class="line"></span><br><span class="line">global.webpackIsomorphicTools = <span class="keyword">new</span> WebpackIsomorphicTools(<span class="built_in">require</span>(<span class="string">'./webpack-isomorphic-config'</span>))</span><br><span class="line">    .server(<span class="string">'./'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//回调</span></span><br><span class="line">        <span class="built_in">require</span>(<span class="string">'./server.js'</span>) <span class="comment">//启动 server</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>同时修改启动脚本<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"start"</span>: <span class="string">"npm run build &amp;&amp; babel-node ./main.js --presets es2015,stage-0,react"</span>,</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"webpack"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>启动，会先生成 webpack-assets.json 文件, 通过映射关系可以正确处理非 js 文件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"javascript"</span>: &#123;</span><br><span class="line">    <span class="string">"app"</span>: <span class="string">"app.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"styles"</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">"assets"</span>: &#123;</span><br><span class="line">    <span class="string">"./src/assets/img/hat.jpg"</span>: <span class="string">"a80196c0daaadce1c8ef8446cc8212d5.jpg"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"webpack"</span>: &#123;</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"4.29.6"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样子页面也能正确加载图片了。</p>
<p><img src="https://i.loli.net/2019/03/22/5c9495e4cd31b.png" alt="服务端渲染"></p>
<p>带来的问题: webpack-isomorphic-tools 这种 hook 方式，将整个Express Server置于自身的回调中，仿佛劫持了整个server，总不是显得那么的优雅。</p>
<h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><ul>
<li><a href="https://github.com/60kmlh/react-ssr" target="_blank" rel="noopener">react-ssr</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://juejin.im/post/5c18c34ef265da615114ae78" target="_blank" rel="noopener">如何用 React 做服务端渲染</a></li>
<li><a href="https://juejin.im/post/5b399412e51d4558dc4ae82d" target="_blank" rel="noopener">React16.x中的服务端渲染（SSR）</a></li>
<li><a href="https://zh-hans.reactjs.org/docs/react-dom-server.html" target="_blank" rel="noopener">ReactDOMServer</a></li>
<li><a href="https://www.zhihu.com/question/66068748" target="_blank" rel="noopener">react中出现的”hydrate”这个单词到底是什么意思?</a></li>
<li><a href="https://github.com/catamphetamine/webpack-isomorphic-tools" target="_blank" rel="noopener">webpack-isomorphic-tools</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/09/22/React高阶组件原理与应用/" class="prev">上一篇</a><a href="/2018/07/21/浏览器的Event Loop机制/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 - 2022 <a href="http://60kmlh.github.io">60kmlh</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/MikeCoder/hexo-theme-gandalfr" target="_blank">hexo-theme-gandalfr</a>.</p></div></footer></div><script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js" crossorigin="anonymous"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.js" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-147983033-1",'auto');ga('send','pageview');</script><script>$(document).ready(function() { hljs.configure({useBR: true}); $('pre').each(function(i, block) { hljs.highlightBlock(block); }); });</script></body></html>