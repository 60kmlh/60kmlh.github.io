{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/ganda/source/css/gandalfr.css.map","path":"css/gandalfr.css.map","modified":1,"renderable":1},{"_id":"themes/ganda/source/css/gandalfr.css","path":"css/gandalfr.css","modified":1,"renderable":1},{"_id":"themes/ganda/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":1,"renderable":1},{"_id":"themes/ganda/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/ganda/source/scss/gandalfr.scss","path":"scss/gandalfr.scss","modified":1,"renderable":1},{"_id":"themes/ganda/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"d956ec462e841a1031e50c5183ba36f08c8871a9","modified":1649859247637},{"_id":"themes/ganda/LICENSE","hash":"e80157fea03e4ee45500ea818fceaf6ca388c17d","modified":1649859248139},{"_id":"themes/ganda/TODO.md","hash":"c20ea4cb6aec891d53fc60707f6102e049e7955c","modified":1649859248148},{"_id":"themes/ganda/README.md","hash":"b60c04f45cebaef0c8cf721aa88c662aaf051c9f","modified":1649859248143},{"_id":"themes/ganda/_config.yml.example","hash":"b651f982ee554ef597451e07e6f8c86048d0cade","modified":1649859248156},{"_id":"themes/ganda/_config.yml","hash":"e5c6c4e092874da0c6c65e1048fed98e1a7e74d2","modified":1649859248152},{"_id":"themes/ganda/package.json","hash":"694fd825847a2b330db53be5c2f68f28086f865f","modified":1649859248266},{"_id":"themes/ganda/gulpfile.js","hash":"cb1123f7f21b8d37a651599f2f40b7bc4d11963b","modified":1649859248161},{"_id":"source/_posts/FormData笔记.md","hash":"3b4affdf728555f0a789e63b388ee00af951db31","modified":1649859247639},{"_id":"source/_posts/JavaScript模块化规范.md","hash":"beeea1476a5481db098ad0e27218ba24d64651ad","modified":1649859247692},{"_id":"source/_posts/Google Drive 文件通过 js 下载的方法.md","hash":"fed856a0bd81ad7e8bdc87ab9d980d7944db59f8","modified":1649903247740},{"_id":"source/_posts/JavaScript的继承.md","hash":"11e5eadb97fd64b8f644aacfb6c6fb24ddd48ef8","modified":1649859247705},{"_id":"source/_posts/TypeScript 中 const enum 和 enum 的区别.md","hash":"993c1619bae3c7e2bf02bb2d29de9db553ac94b6","modified":1649903330146},{"_id":"source/_posts/Promise的规范和实现.md","hash":"66b76b7d80b37c542d1c3589e9e571445bd254b9","modified":1649859247720},{"_id":"source/_posts/banner export default.md","hash":"a211079ff8df2a396ee68a55768f2d0d02455dd9","modified":1649903188599},{"_id":"source/_posts/filter this undefined.md","hash":"4bffb77eb7a040e124876f937a464a0af0ec7671","modified":1649903208039},{"_id":"source/_posts/fix top code.md","hash":"d8ca94010c667708733d8220ad75dbd1a9ea47e9","modified":1649903229592},{"_id":"source/_posts/babel常用配置记录.md","hash":"4cb2c96b4e2ef1f884ef26e5682d7f179e1a8eca","modified":1649859247764},{"_id":"source/_posts/git proxy.md","hash":"b5a6275907ca3aae3866412ea7daebdc64014cab","modified":1649859247769},{"_id":"source/_posts/html标签语义化的区别.md","hash":"0c6c20a28da2abd5adb96605a91f84400a984a7f","modified":1649859247773},{"_id":"source/_posts/React高阶组件原理与应用.md","hash":"6c6fb89f27ba02c807fbe016f46aec121df37220","modified":1649859247751},{"_id":"source/_posts/iOS的iframe宽度bug.md","hash":"dd39c18e1ac78bbfe2641321537303be72a32974","modified":1649859247778},{"_id":"source/_posts/React服务端渲染的实现.md","hash":"88d2159f4e76fb9bafc0d051bee70b9a41b7c7da","modified":1649859247734},{"_id":"source/_posts/multilang.md","hash":"b722087ac1b7dc8e5a6c42b061bf7310c22af537","modified":1649903262281},{"_id":"source/_posts/switch case中使用let进行声明.md","hash":"a395ccd609b05b85df6f1ed00456584f10aadd49","modified":1649903290690},{"_id":"source/_posts/ts-index.md","hash":"afdf0814ca7b24eb3216cc73bb6341298c84700d","modified":1649903316879},{"_id":"source/_posts/inline-block元素间距问题.md","hash":"5d0f97a0f2eaab0f7ff05e2c8cdceaa15e9eaa7d","modified":1649859247784},{"_id":"source/_posts/vue的Runtime   Compiler vs. Runtime-only.md","hash":"cdcd71231c07097f9c0c82d08b4a90ba3987c42c","modified":1649859247830},{"_id":"source/_posts/vue项目总结.md","hash":"48235f4a41b668792a98fb0025d0122ba2d885f3","modified":1649859247835},{"_id":"source/_posts/《图解http》第一章笔记.md","hash":"2b155d9c35a4edd8e0987fb9a6b04db3331bbc3a","modified":1649859247839},{"_id":"source/_posts/《图解http》第三章笔记.md","hash":"ab23498b0b30a6a52b79553478b5ab4d35d4ec44","modified":1649859247846},{"_id":"source/_posts/javascripts权威指南笔记-6.md","hash":"ee2120b56d21dd36d04a20fe66023b71b09e0732","modified":1649859247788},{"_id":"source/_posts/promise.md","hash":"668b8ddf4fe2f96417b8af596d7fed19178f94dd","modified":1649859247815},{"_id":"source/_posts/javascripts权威指南笔记-8.md","hash":"a69ee45e7236d42241e4faf5042701033380373c","modified":1649859247801},{"_id":"source/_posts/《图解http》第二章笔记.md","hash":"7552f9ba0f6f059ce0b7ed50355eeceac9dbfa3d","modified":1649859247850},{"_id":"source/_posts/《图解http》第五章笔记.md","hash":"43a3575cda6f2689317ec9b3560e68bcb3feb273","modified":1649859247856},{"_id":"source/_posts/《图解http》第六章笔记.md","hash":"b048c8e1ecaf76fb894ea4c2b7b9c575fec512f2","modified":1649859247864},{"_id":"source/_posts/《精通正则表达式》第一章笔记.md","hash":"9a24324e7c68420cae902877036bb5f94beb438b","modified":1649859247873},{"_id":"source/_posts/《图解http》第四章笔记.md","hash":"c07fc0b1e39c29d4cd68207f28ae3242f443dbb1","modified":1649859247869},{"_id":"source/_posts/二叉树的遍历.md","hash":"03ca48c81c86ca75d7aabc40bc81872f3cab87ed","modified":1649859247879},{"_id":"source/_posts/使用karma+mocha+chai为vue组件进行单元测试.md","hash":"c41cf348f22dd78abb15b929357968743c79a214","modified":1649859247957},{"_id":"source/_posts/使用gulp为静态资源添加版本号.md","hash":"dc406ae8c30fcb6f9e9232fa6edbbe0674639efb","modified":1649859247891},{"_id":"source/_posts/使用react和vue实现支付宝微信风格的密码输入框.md","hash":"91ad0a53e4db6c595b3b98e2b43c6fba0709608b","modified":1649859247971},{"_id":"source/_posts/关于npm依赖包版本号的规则.md","hash":"14db2f57b06ce662bcef13b14c18cd5583a31eaa","modified":1649859248002},{"_id":"source/_posts/借助webpack实现前端代码的懒加载.md","hash":"e4c8291d70b7fd60a8817bbbc0af5c48a0321df1","modified":1649859247990},{"_id":"source/_posts/使用队列解决两道题目.md","hash":"bd9b89e710d603007390a7de2e700a5ad8568bc6","modified":1649859247975},{"_id":"source/_posts/关于页面自动播放音频文件.md","hash":"4fcca46fe31829a5140d8d3d7308c68276976475","modified":1649859248006},{"_id":"source/_posts/前端动画.md","hash":"b6a446694f1bf6110f8ae2ff4e5c33f15c8218f1","modified":1649859248020},{"_id":"source/_posts/使用gulp移动打包的静态资源到java项目.md","hash":"3acb59d91c242b2042b50010254599db4e7ae999","modified":1649859247920},{"_id":"source/_posts/前端路由的原理与实现.md","hash":"e75a390f84cfdd01875297cca47d83b8cfe67d8c","modified":1649859248025},{"_id":"source/_posts/基于vue-router的管理系统权限控制的实现.md","hash":"2b06ae6caa665e330b218786aeff230b743dfe0a","modified":1649859248046},{"_id":"source/_posts/实现开发静态页面的热更新.md","hash":"c6319d0b0c1d2474c119f02b64b4c60fc8b736b3","modified":1649859248057},{"_id":"source/_posts/实现数组的flat方法.md","hash":"f70eb5eff5738109ddfdbdb9b957ecbf693b81b8","modified":1649859248066},{"_id":"source/_posts/打造属于自己的栅格系统（翻译）.md","hash":"3a83fee108f8fd27a16958a15b5b7e7eaadc3ca8","modified":1649859248086},{"_id":"source/_posts/浏览器缓存原理.md","hash":"a344206e4f7ce70708f887dea90b36a6939adbcb","modified":1649859248104},{"_id":"source/_posts/常见排序算法的JavaScript实现.md","hash":"b8d3fd89ea7cd638399b5fa39d05b480ff606801","modified":1649859248075},{"_id":"source/_posts/浏览器的Event Loop机制.md","hash":"4f6fa03da92522999166aff90c751a7c1803c0dd","modified":1649859248092},{"_id":"source/about/index.md","hash":"ccbfe78a461f7f5365d6419a24ebf194bfd7f465","modified":1649859248135},{"_id":"themes/ganda/languages/en.yml","hash":"40292f2a48e4e6361132033a47c516cb33127b6c","modified":1649859248168},{"_id":"source/_posts/防抖与节流.md","hash":"fd0604c1b85ba48531f19b5b78b5d3d972ea8d24","modified":1649859248123},{"_id":"themes/ganda/languages/zh-cn.yml","hash":"9e4b03e14c094000257ea254fd660dde4c7af63c","modified":1649859248173},{"_id":"source/_posts/视网膜屏下的canvas清晰度处理.md","hash":"16c8bd3eb1a2cb01d5a8fb13366f6a79f7c96dcc","modified":1649859248109},{"_id":"themes/ganda/layout/index.jade","hash":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1649859248183},{"_id":"themes/ganda/layout/archive.jade","hash":"a37648fcd0b85e21cd2656e2c097175217ff3070","modified":1649859248178},{"_id":"themes/ganda/layout/post.jade","hash":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1649859248252},{"_id":"themes/ganda/package-lock.json","hash":"4822e32d22c6d5ab2717eac3fd7019bd7a69fa0c","modified":1649859248258},{"_id":"themes/ganda/layout/partial/copyright.jade","hash":"3f2a357c9d4861386f81d97a97cde9b6817e35cc","modified":1649859248210},{"_id":"themes/ganda/layout/mixins/paginator.jade","hash":"bc949683bea9183a3c7df22d97ebb133a422cb27","modified":1649859248188},{"_id":"themes/ganda/layout/partial/comment.jade","hash":"0496d9e93fc9ab7889f086f80916d7220ed19694","modified":1649859248201},{"_id":"themes/ganda/layout/mixins/post.jade","hash":"4475dd99479cb6c2a122b0fe353e451e4a056575","modified":1649859248192},{"_id":"themes/ganda/layout/partial/layout.jade","hash":"ecb9d12eb0b831a3f9b52f215e3179a76add4487","modified":1649859248219},{"_id":"themes/ganda/layout/partial/head.jade","hash":"d32a970c293bd0297ecf326b213871021e2565a5","modified":1649859248215},{"_id":"themes/ganda/layout/partial/nav.jade","hash":"f4842d9d3d763fbb823d112a6f49f24cc42a0ad4","modified":1649859248223},{"_id":"themes/ganda/source/css/gandalfr.css.map","hash":"f1409020d0553fc0b3e6fb9254c9eb3be18099c4","modified":1649859248276},{"_id":"themes/ganda/source/css/gandalfr.css","hash":"b29d0280208f3af136a0812bb1c69bd89de385b3","modified":1649859248271},{"_id":"themes/ganda/layout/partial/scripts.jade","hash":"90b7952204f660b065a3e3edb81424253166aecd","modified":1649859248227},{"_id":"themes/ganda/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1649859248286},{"_id":"themes/ganda/source/favicon.ico","hash":"ff97e9eeb291dcd407982d438f482280aa25a6d9","modified":1649859248281},{"_id":"themes/ganda/source/scss/gandalfr.scss","hash":"eb7e4dd5949defa1795b90d8ff5e09f553cea53d","modified":1649859248425},{"_id":"themes/ganda/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1649859248290},{"_id":"themes/ganda/source/scss/_partial/archive-post-list.scss","hash":"b173328f07795f64769fe552b5c2749f4159d050","modified":1649859248366},{"_id":"themes/ganda/source/scss/_partial/base.scss","hash":"a9a624a14d593ec986cc5d7eada07394f57be41d","modified":1649859248370},{"_id":"themes/ganda/source/scss/_partial/copyright.scss","hash":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1649859248375},{"_id":"themes/ganda/source/scss/_partial/footer.scss","hash":"b43533758fb58af67b3d8d2d33208daed56d9592","modified":1649859248384},{"_id":"themes/ganda/source/scss/_partial/header.scss","hash":"c213efabe720b76bc75a7ac08a7bb850d5eb0921","modified":1649859248391},{"_id":"themes/ganda/source/scss/_partial/home-post-list.scss","hash":"0021e88b04c51aca45627272bc7e3584ba2480b9","modified":1649859248398},{"_id":"themes/ganda/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1649859248413},{"_id":"themes/ganda/source/scss/_partial/mq.scss","hash":"59efc06258ed63251691c8f1c68807f11fbeb230","modified":1649859248404},{"_id":"themes/ganda/source/scss/_partial/post.scss","hash":"b34397e869bc55c95337c86c35169b376168f237","modified":1649859248420},{"_id":"themes/ganda/source/scss/.sass-cache/da13e05a1b978f7086fbb85a1cd34897f999b372/archive-post-list.scssc","hash":"4968d4aec8a8f9abedf621a527b8165bdc57eaa5","modified":1649859248304},{"_id":"themes/ganda/source/scss/.sass-cache/59fc1bda1a8180f04d134000fd621d1edfae4095/gandalfr.scssc","hash":"40e7103a2fc1c8dc05d75efe0b74d2cae1d65815","modified":1649859248298},{"_id":"themes/ganda/source/scss/.sass-cache/da13e05a1b978f7086fbb85a1cd34897f999b372/base.scssc","hash":"1fba2453f35f7b7da43ae6d9d68e857d4055945b","modified":1649859248309},{"_id":"themes/ganda/source/scss/.sass-cache/da13e05a1b978f7086fbb85a1cd34897f999b372/copyright.scssc","hash":"1913715c3a56030729ba5640214807e2f86a1326","modified":1649859248317},{"_id":"themes/ganda/source/scss/.sass-cache/da13e05a1b978f7086fbb85a1cd34897f999b372/home-post-list.scssc","hash":"ae0bd33b15ad61e0692e56a4ce7d294d9a0fedc3","modified":1649859248336},{"_id":"themes/ganda/source/scss/.sass-cache/da13e05a1b978f7086fbb85a1cd34897f999b372/header.scssc","hash":"dfc7112e61df0666a60266ad2f928b062af8d065","modified":1649859248326},{"_id":"themes/ganda/source/scss/.sass-cache/da13e05a1b978f7086fbb85a1cd34897f999b372/mq.scssc","hash":"bf528e2d007c1946ee828f6b5e132ad3f2efd5e5","modified":1649859248341},{"_id":"themes/ganda/source/scss/.sass-cache/da13e05a1b978f7086fbb85a1cd34897f999b372/footer.scssc","hash":"4f5e7b3263a6c6a19dc18a81acb0f349b8304d47","modified":1649859248322},{"_id":"themes/ganda/source/scss/.sass-cache/da13e05a1b978f7086fbb85a1cd34897f999b372/normalize.scssc","hash":"bcdeba715651822c89ffdb7e3a9fb9030891e1b9","modified":1649859248350},{"_id":"themes/ganda/source/scss/.sass-cache/da13e05a1b978f7086fbb85a1cd34897f999b372/post.scssc","hash":"cd5646b927954f1c0b9d34936fac06aa0a7e83ce","modified":1649859248357},{"_id":"public/about/index.html","hash":"8539da87721874e94592ff759f88d2a0f1d84e66","modified":1649903382783},{"_id":"public/2021/11/13/TypeScript 中 const enum 和 enum 的区别/index.html","hash":"f9d2377225e23db75894b8680c0b3d4c05be1641","modified":1649903382783},{"_id":"public/2021/07/15/ts-index/index.html","hash":"d86a801bb236f4cb3ab5af7e0864ffd2c1e61c00","modified":1649903382783},{"_id":"public/2021/03/04/switch case中使用let进行声明/index.html","hash":"a2ea58fa65728321e160204882c1b200df58bdbf","modified":1649903382783},{"_id":"public/2020/05/09/Google Drive 文件通过 js 下载的方法/index.html","hash":"efd4651a9b5fb652b045e1db5a454c4cf6cecfaf","modified":1649903382783},{"_id":"public/2020/01/21/fix top code/index.html","hash":"8fc4e03cb916e224051939492085b54981cc6237","modified":1649903382783},{"_id":"public/2019/05/18/banner export default/index.html","hash":"5e4bd679c7b241d7aa5a9c85c97ce5b7b615d928","modified":1649903382784},{"_id":"public/2018/05/19/前端动画/index.html","hash":"3e5223a06008dc7e431521c20f15f2597aeaa888","modified":1649903382784},{"_id":"public/2018/02/28/实现数组的flat方法/index.html","hash":"8725d52e55eea689db3fd7072231d8a68ea0386d","modified":1649903382784},{"_id":"public/2017/11/05/inline-block元素间距问题/index.html","hash":"e5c8f7249629173cd8ab66256301d1a7789d0a62","modified":1649903382784},{"_id":"public/2017/10/20/html标签语义化的区别/index.html","hash":"191aac28433a0282865c1c02f88f5d79676f55a7","modified":1649903382784},{"_id":"public/2017/10/12/vue的Runtime   Compiler vs. Runtime-only/index.html","hash":"7806974749ef487b7777b153b9b62c1e40790bf1","modified":1649903382784},{"_id":"public/2017/10/08/使用react和vue实现支付宝微信风格的密码输入框/index.html","hash":"c6555ab64663f1bad103011063b6874bf1769c17","modified":1649903382784},{"_id":"public/2017/09/30/iOS的iframe宽度bug/index.html","hash":"c4d2d899f6095f7f124952bcaabf974171687978","modified":1649903382784},{"_id":"public/2017/09/24/《图解http》第五章笔记/index.html","hash":"b69657955eb282605f5b6809a5e6f22e796cffde","modified":1649903382784},{"_id":"public/2017/09/23/《图解http》第四章笔记/index.html","hash":"e2c8d59aefb4ae21817910397e4b2fbb295f4748","modified":1649903382784},{"_id":"public/2017/09/16/《图解http》第三章笔记/index.html","hash":"f8157308797a660f0bf6daef1ace9c84224adb3d","modified":1649903382784},{"_id":"public/2017/09/16/《图解http》第二章笔记/index.html","hash":"64330001f6e3f9d0b75eadc8f7dbc7996d88e923","modified":1649903382784},{"_id":"public/2017/09/15/《图解http》第一章笔记/index.html","hash":"481a0bea5c28780a941a3a5ea364ff3abb45b295","modified":1649903382784},{"_id":"public/2017/09/08/《精通正则表达式》第一章笔记/index.html","hash":"67c1821e58c4a143b4241825cca6770e89fae160","modified":1649903382784},{"_id":"public/2017/09/01/视网膜屏下的canvas清晰度处理/index.html","hash":"01bef70db40fba5a25f20bae4b453d7bf1e582e9","modified":1649903382784},{"_id":"public/2017/08/27/babel常用配置记录/index.html","hash":"d621a7ad9c5f8ec3cb4aa9b4ec294a78153a0a12","modified":1649903382784},{"_id":"public/2017/08/05/关于npm依赖包版本号的规则/index.html","hash":"5b8177efea052d906bcc73507fdf6a3b5a9fd695","modified":1649903382784},{"_id":"public/2017/07/16/git proxy/index.html","hash":"11754f15fd0d5fc31eb3e8a35f6e1fae542aec8a","modified":1649903382784},{"_id":"public/2017/06/10/vue项目总结/index.html","hash":"d8bcda619fe2b69f0b25be8fb76e3fc52d0a6b94","modified":1649903382784},{"_id":"public/2017/05/06/FormData笔记/index.html","hash":"23147b8596e4f0f2f2e44cd786987ba9cc6edabf","modified":1649903382784},{"_id":"public/2017/04/18/关于页面自动播放音频文件/index.html","hash":"7dfaff61e62e7123d8dfa4098931965e9f13814f","modified":1649903382784},{"_id":"public/2017/04/08/实现开发静态页面的热更新/index.html","hash":"c1302299ab2eb6d6fc0883548a25127d46891bcf","modified":1649903382785},{"_id":"public/archives/index.html","hash":"3f66c15a8d48124ff639e120c899935de4af0ce1","modified":1649903382785},{"_id":"public/archives/page/2/index.html","hash":"c9202f57e62c8a3c0bb3f167247c4930156e1682","modified":1649903382785},{"_id":"public/archives/page/3/index.html","hash":"931e42740ad04bb1e3b75cd7c6426654754d012c","modified":1649903382785},{"_id":"public/archives/page/4/index.html","hash":"627ae91bde766931cd285e6bd980b7f38a4fdfce","modified":1649903382785},{"_id":"public/archives/page/5/index.html","hash":"3d9f7016e77e0d634d219555ab00f5327dd2db1e","modified":1649903382785},{"_id":"public/archives/2017/index.html","hash":"9cc8b110ca2942baf91e1a7539de0c461bcc5263","modified":1649903382785},{"_id":"public/archives/2017/page/2/index.html","hash":"3ed29c87e9ff726370aab7778b0bc97965c46f7b","modified":1649903382785},{"_id":"public/archives/2017/page/3/index.html","hash":"de240b19d5ed1ad49ec66fe8d6c62c452e1da288","modified":1649903382785},{"_id":"public/archives/2017/page/4/index.html","hash":"3f37082db21e80cf51f4513a3f3a3d0f2ff769cf","modified":1649903382785},{"_id":"public/archives/2017/04/index.html","hash":"135e8b67de458d75f545b73aa60a876a6b9fa92f","modified":1649903382785},{"_id":"public/archives/2017/03/index.html","hash":"52cefe081b0f53c37236739f3b2b5d5244692099","modified":1649903382785},{"_id":"public/archives/2017/05/index.html","hash":"bc38146cb2b1ee538d74af65c925a20fbd03e5f7","modified":1649903382785},{"_id":"public/archives/2017/06/index.html","hash":"70b38b5e7a295b13138295ab1dd82a85909b36e7","modified":1649903382785},{"_id":"public/archives/2017/07/index.html","hash":"1858a702de5f201fda07a79eb3de7e16a63d4d1b","modified":1649903382785},{"_id":"public/archives/2017/08/index.html","hash":"9c873afc77fc87ed9ec57d8014d0832263777f16","modified":1649903382785},{"_id":"public/archives/2017/09/index.html","hash":"a2c24b1f7b53db27d2eee9c024823c48c1ab83dc","modified":1649903382785},{"_id":"public/archives/2017/10/index.html","hash":"d47949a72d9fdf49fbf30201240e12386f6e6e32","modified":1649903382785},{"_id":"public/archives/2017/11/index.html","hash":"d88d627f63cdea586adb99c40345c7b60e3e8bb4","modified":1649903382785},{"_id":"public/archives/2017/12/index.html","hash":"0caafeefdfa758aa332b84774913ee65f153fc50","modified":1649903382785},{"_id":"public/archives/2018/index.html","hash":"6141174a2a904cd576e8d492475716c2387415da","modified":1649903382785},{"_id":"public/archives/2018/page/2/index.html","hash":"4bada0206b811b2b1e79354edf83e0bc8c907fd5","modified":1649903382785},{"_id":"public/archives/2018/01/index.html","hash":"a45d572312c6792926ec1c57958835907e402d47","modified":1649903382786},{"_id":"public/archives/2018/02/index.html","hash":"54009fbba9f360c92388a7c643b0a5dd51fb0a9b","modified":1649903382786},{"_id":"public/archives/2018/03/index.html","hash":"84a6280b37e309549676de12d1ed3a661c488ccd","modified":1649903382786},{"_id":"public/archives/2018/04/index.html","hash":"12d4032358a178148d3bba6443628b5b57793111","modified":1649903382786},{"_id":"public/archives/2018/05/index.html","hash":"811180d782d12041482f54eec48e8b5a19afbb34","modified":1649903382786},{"_id":"public/archives/2018/06/index.html","hash":"0029fd4dfc719b7358e3c5d17a7a9f444a4ff761","modified":1649903382786},{"_id":"public/archives/2018/07/index.html","hash":"705b0a7a62e14b44f01b5621283b8f487f507118","modified":1649903382786},{"_id":"public/archives/2018/08/index.html","hash":"e270747cfcc40b8007a836e2349eef49bddda802","modified":1649903382786},{"_id":"public/archives/2018/09/index.html","hash":"cfd9093f6a368c20932c810a1bf7c6dce7d5dd2c","modified":1649903382786},{"_id":"public/archives/2018/10/index.html","hash":"42d00c8497d9a6be552f3ec71f46198f134ce963","modified":1649903382786},{"_id":"public/archives/2018/11/index.html","hash":"4bf8d8bb2adae15760461c743d37f356a689b152","modified":1649903382786},{"_id":"public/archives/2019/index.html","hash":"d68f0c4cde1f6886b8d628505fc2203a8c18234b","modified":1649903382786},{"_id":"public/archives/2019/05/index.html","hash":"d68f0c4cde1f6886b8d628505fc2203a8c18234b","modified":1649903382786},{"_id":"public/archives/2020/index.html","hash":"3e1f8e309dce08f599a7b6c9a9bcfa2c049adc2c","modified":1649903382786},{"_id":"public/archives/2020/01/index.html","hash":"394d03cfc9b221f6453256140b1c2c6aaf48494a","modified":1649903382786},{"_id":"public/archives/2020/05/index.html","hash":"b79b795f56a81025f8a66844592c950caab7c6bc","modified":1649903382786},{"_id":"public/archives/2021/index.html","hash":"12a3dc3a4ab40d0347a66110413bbd2df064fd99","modified":1649903382786},{"_id":"public/archives/2021/03/index.html","hash":"77ac9c104be55444fe8f2ff219e2c0ce25623582","modified":1649903382786},{"_id":"public/archives/2021/07/index.html","hash":"db5237bb825bc53a5f21da1a67ab10b18ff2616e","modified":1649903382786},{"_id":"public/archives/2021/11/index.html","hash":"d93e398dc108595d3c5b29e202c1a727283ca4e9","modified":1649903382786},{"_id":"public/index.html","hash":"ab0754045e5a1ce82b4fa02e46785f98256826b6","modified":1649903382786},{"_id":"public/page/2/index.html","hash":"00d8e3246eb6fc7def0015b2c34eec51e5bf343d","modified":1649903382786},{"_id":"public/page/3/index.html","hash":"5e33bbfb5cd3a4c29ead7d87df0232b18762939f","modified":1649903382786},{"_id":"public/page/4/index.html","hash":"ce5da61224bc4014945969ec457afec72c2f3d78","modified":1649903382786},{"_id":"public/page/5/index.html","hash":"9a9a5664c0ff3f344e6acf5965fa47a52c6a0121","modified":1649903382787},{"_id":"public/tags/模块化/index.html","hash":"a45d572312c6792926ec1c57958835907e402d47","modified":1649903382787},{"_id":"public/tags/js/index.html","hash":"6e7b5009bf3fe52dd8850e680371a79fdbeaf9d4","modified":1649903382787},{"_id":"public/tags/google-drive/index.html","hash":"b79b795f56a81025f8a66844592c950caab7c6bc","modified":1649903382787},{"_id":"public/tags/inherit/index.html","hash":"0caafeefdfa758aa332b84774913ee65f153fc50","modified":1649903382787},{"_id":"public/tags/promise/index.html","hash":"d3bf22f54f5c0fd6b6e85b453c0bbe3312f4339c","modified":1649903382787},{"_id":"public/tags/es6/index.html","hash":"bb6a8225f602d93763a164bc58ec7f36f7b8b3c4","modified":1649903382787},{"_id":"public/tags/typescript/index.html","hash":"d614960e38b74e9ef151fbdf9b013ef7f872d121","modified":1649903382787},{"_id":"public/tags/吸顶/index.html","hash":"394d03cfc9b221f6453256140b1c2c6aaf48494a","modified":1649903382787},{"_id":"public/tags/FormData/index.html","hash":"bf9fcf573584abc8e67df99073ef8a1c4df8fff3","modified":1649903382787},{"_id":"public/tags/babel/index.html","hash":"cb6dfbf78e36916287d2db10c2a22889bd01cfa2","modified":1649903382787},{"_id":"public/tags/proxy/index.html","hash":"004e797b62babd649a09574a102f9b2a8bd1398f","modified":1649903382787},{"_id":"public/tags/git/index.html","hash":"004e797b62babd649a09574a102f9b2a8bd1398f","modified":1649903382787},{"_id":"public/tags/react/index.html","hash":"5405e71d8a0c495b51a65b0588b680b06745d3dd","modified":1649903382787},{"_id":"public/tags/hoc/index.html","hash":"cfd9093f6a368c20932c810a1bf7c6dce7d5dd2c","modified":1649903382787},{"_id":"public/tags/ssr/index.html","hash":"e270747cfcc40b8007a836e2349eef49bddda802","modified":1649903382787},{"_id":"public/tags/html/index.html","hash":"97c0744541109f775f63e3959d9c9e65903d3433","modified":1649903382787},{"_id":"public/tags/语意化/index.html","hash":"97c0744541109f775f63e3959d9c9e65903d3433","modified":1649903382787},{"_id":"public/tags/css/index.html","hash":"3e6816bff17557cc712fbcd3bbe32873baf78157","modified":1649903382787},{"_id":"public/tags/vue/index.html","hash":"f210898fbe34501c503942c38ddbb577fe48f3db","modified":1649903382787},{"_id":"public/tags/http/index.html","hash":"9b62f4a6dbe9a1a5cd9e19cbc4374490c8d0c363","modified":1649903382787},{"_id":"public/tags/switch-case/index.html","hash":"77ac9c104be55444fe8f2ff219e2c0ce25623582","modified":1649903382787},{"_id":"public/tags/object/index.html","hash":"18a32363a0eb9ac918c596b64c0d71b06fd3284d","modified":1649903382787},{"_id":"public/tags/正则表达式/index.html","hash":"2006db6215048a86d80e5ccf1a6b2d5577283533","modified":1649903382787},{"_id":"public/tags/tree/index.html","hash":"84a6280b37e309549676de12d1ed3a661c488ccd","modified":1649903382787},{"_id":"public/tags/karma/index.html","hash":"1da486c573c40a50aea825f414584f9ea2e7e764","modified":1649903382788},{"_id":"public/tags/mocha/index.html","hash":"1da486c573c40a50aea825f414584f9ea2e7e764","modified":1649903382788},{"_id":"public/tags/chai/index.html","hash":"1da486c573c40a50aea825f414584f9ea2e7e764","modified":1649903382788},{"_id":"public/tags/gulp/index.html","hash":"3ce5100143f0988a67f3695335e33649ce5f372a","modified":1649903382788},{"_id":"public/tags/效率/index.html","hash":"f2070e71bac02bbb36ea3f586f5a405d43c0fb8f","modified":1649903382788},{"_id":"public/tags/npm/index.html","hash":"f19d931df7b3f375fa8abff85b1bdad36b3dedb7","modified":1649903382788},{"_id":"public/tags/版本/index.html","hash":"f19d931df7b3f375fa8abff85b1bdad36b3dedb7","modified":1649903382788},{"_id":"public/tags/webpack/index.html","hash":"6e93057add783302c90eedfb74652ad29dd9ceb5","modified":1649903382788},{"_id":"public/tags/性能优化/index.html","hash":"6e93057add783302c90eedfb74652ad29dd9ceb5","modified":1649903382788},{"_id":"public/tags/queue/index.html","hash":"12d4032358a178148d3bba6443628b5b57793111","modified":1649903382788},{"_id":"public/tags/audio/index.html","hash":"31036654350d98bca6bcc3303ef739438af5e1c6","modified":1649903382788},{"_id":"public/tags/用户体验/index.html","hash":"31036654350d98bca6bcc3303ef739438af5e1c6","modified":1649903382788},{"_id":"public/tags/animation/index.html","hash":"811180d782d12041482f54eec48e8b5a19afbb34","modified":1649903382788},{"_id":"public/tags/vue-router/index.html","hash":"dc20790be7eae61a3c3abbaeb927fe4b9dee5ad8","modified":1649903382788},{"_id":"public/tags/路由/index.html","hash":"a78cb4a268b834615109321aca276fe99521973b","modified":1649903382788},{"_id":"public/tags/管理系统/index.html","hash":"dc20790be7eae61a3c3abbaeb927fe4b9dee5ad8","modified":1649903382788},{"_id":"public/tags/权限控制/index.html","hash":"dc20790be7eae61a3c3abbaeb927fe4b9dee5ad8","modified":1649903382788},{"_id":"public/tags/‘效率’/index.html","hash":"4456af2756ef5abffbdd080d87bc1da72ad892e5","modified":1649903382788},{"_id":"public/tags/array/index.html","hash":"54009fbba9f360c92388a7c643b0a5dd51fb0a9b","modified":1649903382788},{"_id":"public/tags/flat/index.html","hash":"54009fbba9f360c92388a7c643b0a5dd51fb0a9b","modified":1649903382788},{"_id":"public/tags/function/index.html","hash":"2113a55995c7f968d8f2b6eb3c0b0488a907a6fe","modified":1649903382788},{"_id":"public/tags/grid/index.html","hash":"11758f0ecaae185e8cf3f5809a068c79891a1108","modified":1649903382788},{"_id":"public/tags/responsive/index.html","hash":"11758f0ecaae185e8cf3f5809a068c79891a1108","modified":1649903382788},{"_id":"public/tags/排序/index.html","hash":"407757590e91168f0783fbdbf578e2c904418cdc","modified":1649903382788},{"_id":"public/tags/浏览器/index.html","hash":"bd7e527d4d1cf0dc12579b2aecdbc4c94f4f62ea","modified":1649903382789},{"_id":"public/tags/eventloop/index.html","hash":"705b0a7a62e14b44f01b5621283b8f487f507118","modified":1649903382789},{"_id":"public/tags/debounce/index.html","hash":"758f4da91f33db8bf05897413ea068ba3ccafc07","modified":1649903382789},{"_id":"public/tags/iOS/index.html","hash":"ca982b0b8977ea71f395d5410e85ddd8f45b41e2","modified":1649903382789},{"_id":"public/tags/iframe/index.html","hash":"ca982b0b8977ea71f395d5410e85ddd8f45b41e2","modified":1649903382789},{"_id":"public/tags/bug/index.html","hash":"ca982b0b8977ea71f395d5410e85ddd8f45b41e2","modified":1649903382789},{"_id":"public/tags/cache/index.html","hash":"4bf8d8bb2adae15760461c743d37f356a689b152","modified":1649903382789},{"_id":"public/tags/canvas/index.html","hash":"a08e19e98ede146ae8652cb94683ede0f95d8ea1","modified":1649903382789},{"_id":"public/tags/dpr/index.html","hash":"a08e19e98ede146ae8652cb94683ede0f95d8ea1","modified":1649903382789},{"_id":"public/categories/规范/index.html","hash":"70240f7cce7843ae2254dec82315c7dab1bcdd73","modified":1649903382789},{"_id":"public/categories/笔记/index.html","hash":"756d20a881007d5b8d9b3b51f94fcf787eb85588","modified":1649903382789},{"_id":"public/categories/笔记/page/2/index.html","hash":"0c1d6aff8fa9c5d52f93e8bfebbb03a3116362f6","modified":1649903382789},{"_id":"public/categories/typescript/index.html","hash":"d93e398dc108595d3c5b29e202c1a727283ca4e9","modified":1649903382789},{"_id":"public/categories/javascript/index.html","hash":"b9af65f01638ed8788a529d6fbd24d634ca0a288","modified":1649903382789},{"_id":"public/categories/git/index.html","hash":"004e797b62babd649a09574a102f9b2a8bd1398f","modified":1649903382789},{"_id":"public/categories/react/index.html","hash":"f0ed1db1d80a2c3fd8835a3d7a81aaeb1ac6135d","modified":1649903382789},{"_id":"public/categories/css/index.html","hash":"c21746fe279bbcf608c5610234fd45b2727e7c88","modified":1649903382789},{"_id":"public/categories/工作总结/index.html","hash":"ae4e36614798ececd07ad46a8c41fe4c99178d7d","modified":1649903382789},{"_id":"public/categories/算法/index.html","hash":"6d64a1bab2d142c7eabe1ca374cc857f4cb67708","modified":1649903382789},{"_id":"public/categories/测试/index.html","hash":"1da486c573c40a50aea825f414584f9ea2e7e764","modified":1649903382789},{"_id":"public/categories/工具/index.html","hash":"c3290b508bad04454dd900622b91bfe2c3fbdfb6","modified":1649903382789},{"_id":"public/categories/公共组件/index.html","hash":"e1eab7aecd36a66ff4b3c08415b07d7f9b8e468a","modified":1649903382789},{"_id":"public/categories/动画/index.html","hash":"811180d782d12041482f54eec48e8b5a19afbb34","modified":1649903382789},{"_id":"public/categories/路由/index.html","hash":"a78cb4a268b834615109321aca276fe99521973b","modified":1649903382790},{"_id":"public/categories/array/index.html","hash":"54009fbba9f360c92388a7c643b0a5dd51fb0a9b","modified":1649903382790},{"_id":"public/categories/翻译/index.html","hash":"11758f0ecaae185e8cf3f5809a068c79891a1108","modified":1649903382790},{"_id":"public/categories/浏览器/index.html","hash":"bd7e527d4d1cf0dc12579b2aecdbc4c94f4f62ea","modified":1649903382790},{"_id":"public/categories/性能/index.html","hash":"758f4da91f33db8bf05897413ea068ba3ccafc07","modified":1649903382790},{"_id":"public/2018/11/10/浏览器缓存原理/index.html","hash":"42cc7146d45d5ab416080b9eeff01d1d5cfc9dd8","modified":1649903382790},{"_id":"public/2018/10/06/Promise的规范和实现/index.html","hash":"4d5dc7350e71e5bdebacad28a4db8da9542d8b40","modified":1649903382790},{"_id":"public/2018/09/22/React高阶组件原理与应用/index.html","hash":"f3f7fe0b4368fb5ae22738b98a869d38c07f0f46","modified":1649903382790},{"_id":"public/2018/08/11/React服务端渲染的实现/index.html","hash":"5c4688b3334b1b353337307b7e0e4cb60e35bbe5","modified":1649903382790},{"_id":"public/2018/07/21/浏览器的Event Loop机制/index.html","hash":"94274ccbb89ac3ed0aa62296cfa6c9162013da1e","modified":1649903382790},{"_id":"public/2018/06/22/前端路由的原理与实现/index.html","hash":"e6fd3d1fd7ba51066211ce9c5d3a938ba3ddb0bb","modified":1649903382790},{"_id":"public/2018/06/09/常见排序算法的JavaScript实现/index.html","hash":"fa382166c5202eb24b19c7441ce55db9652fe0a7","modified":1649903382790},{"_id":"public/2018/04/21/使用队列解决两道题目/index.html","hash":"e28053a24d9b6385f06a1d811f10b66c7c7797c2","modified":1649903382790},{"_id":"public/2018/03/17/二叉树的遍历/index.html","hash":"8814f0a0480681838169b0866887628ce9700159","modified":1649903382790},{"_id":"public/2018/01/06/JavaScript模块化规范/index.html","hash":"cf391be149c60de819236880fe7f11a33093e6b6","modified":1649903382791},{"_id":"public/2017/12/16/JavaScript的继承/index.html","hash":"24ae579d62dc951cc714ddd9e03d68b8fd5305d9","modified":1649903382791},{"_id":"public/2017/11/18/防抖与节流/index.html","hash":"3a18a3da44c9c6529cf766d8f6a2560fee538c1c","modified":1649903382791},{"_id":"public/2017/10/20/《图解http》第六章笔记/index.html","hash":"40b8215497f98b40e839fa8c1537105f25c25066","modified":1649903382791},{"_id":"public/2017/10/05/打造属于自己的栅格系统（翻译）/index.html","hash":"58e564860c5fbe53c3bfeb3a1d8a6feb63876fdb","modified":1649903382791},{"_id":"public/2017/08/26/借助webpack实现前端代码的懒加载/index.html","hash":"1dbccaeb68a1c0a5c584dc9266cd8ddf28306fdb","modified":1649903382791},{"_id":"public/2017/07/08/基于vue-router的管理系统权限控制的实现/index.html","hash":"7624068d5ce583dd2193f98b36836c7674b8bceb","modified":1649903382791},{"_id":"public/2017/06/24/使用karma+mocha+chai为vue组件进行单元测试/index.html","hash":"26c782b8300eaada11c556dc73480e34839040c6","modified":1649903382791},{"_id":"public/2017/05/20/使用gulp为静态资源添加版本号/index.html","hash":"0bba6186d4384df516cdfa4b0b53fbb609ff2b9f","modified":1649903382792},{"_id":"public/2017/03/25/使用gulp移动打包的静态资源到java项目/index.html","hash":"ac5b14d53a836d66a5ee7f041a8763640910db42","modified":1649903382792},{"_id":"public/2017/03/18/javascripts权威指南笔记-8/index.html","hash":"286c6eb33633621f26cc19d231fe43c73cbfdef9","modified":1649903382792},{"_id":"public/2017/03/11/javascripts权威指南笔记-6/index.html","hash":"85bb3a704c87ac00a9da48bbe6031a137b622668","modified":1649903382792},{"_id":"public/2017/03/04/promise/index.html","hash":"840c656988a988d40ac40875ebc0586372b86125","modified":1649903382792},{"_id":"public/CNAME","hash":"d956ec462e841a1031e50c5183ba36f08c8871a9","modified":1649903382796},{"_id":"public/css/gandalfr.css.map","hash":"f1409020d0553fc0b3e6fb9254c9eb3be18099c4","modified":1649903382796},{"_id":"public/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1649903382797},{"_id":"public/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1649903382852},{"_id":"public/favicon.ico","hash":"ff97e9eeb291dcd407982d438f482280aa25a6d9","modified":1649903382852},{"_id":"public/scss/gandalfr.css","hash":"b5ef3639778ef7eff8e68168214eac8dacb12a34","modified":1649903382855},{"_id":"public/css/gandalfr.css","hash":"b29d0280208f3af136a0812bb1c69bd89de385b3","modified":1649903382855}],"Category":[{"name":"规范","_id":"cl1ydvfee0002g3t8203bw6bp"},{"name":"笔记","_id":"cl1ydvfej0007g3t8br07s6p0"},{"name":"typescript","_id":"cl1ydvfem000cg3t87vtph4nl"},{"name":"javascript","_id":"cl1ydvfep000jg3t8zzrvrtig"},{"name":"git","_id":"cl1ydvff70019g3t8yg0ysypw"},{"name":"react","_id":"cl1ydvffb001gg3t8d2gph7pf"},{"name":"css","_id":"cl1ydvffg001rg3t8tgk3tgx0"},{"name":"工作总结","_id":"cl1ydvffi0020g3t8kiv5ke3n"},{"name":"算法","_id":"cl1ydvffs002tg3t86robo40z"},{"name":"测试","_id":"cl1ydvffv0031g3t8p765w95o"},{"name":"工具","_id":"cl1ydvffx0039g3t8zk4wjbeo"},{"name":"公共组件","_id":"cl1ydvfg0003fg3t8yb3trpym"},{"name":"动画","_id":"cl1ydvfg70040g3t8t2j033um"},{"name":"路由","_id":"cl1ydvfga0048g3t8mal0wyd2"},{"name":"array","_id":"cl1ydvfgd004fg3t8e0zu75mq"},{"name":"翻译","_id":"cl1ydvfgf004mg3t8qq545z4q"},{"name":"浏览器","_id":"cl1ydvfgg004rg3t83mpwcrk3"},{"name":"性能","_id":"cl1ydvfgi004vg3t86fist92s"}],"Data":[],"Page":[{"title":"about","date":"2016-11-03T09:04:50.000Z","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-11-03 17:04:50\ncomments: false\n---","updated":"2022-04-13T14:14:08.135Z","path":"about/index.html","layout":"page","_id":"cl1ydvff40015g3t8ano5z5fp","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"JavaScript模块化规范","date":"2018-01-05T16:00:00.000Z","_content":"## 模块化的进化过程\n* 全局function模式：将不同的功能封装成不同的全局函数\n\n  缺点：污染全局命名空间，容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系。\n<!--more-->\n````javascript\nfunction m1(){\n  //...\n}\nfunction m2(){\n  //...\n}\n````\n* namespace模式：简单对象封装\n\n  缺点：数据不安全(外部可以直接修改模块内部的数据)、\n````javascript\nlet myModule = {\n  data: 'original data',\n  print() {\n    console.log(`data: ${this.data}`)\n  }\n}\nmyModule.data = 'changed data' //能直接修改模块内部的数据\nmyModule.foo() // data: changed data\n````\n* IIFE模式：匿名函数自调用(闭包)\n\n  将数据和行为封装到一个函数内部，通过给window添加属性来向外暴露接口，数据是私有的，外部只能通过暴露的方法操作。\n\n  缺点：无法解决模块间依赖关系的问题。\n````javascript\n// module.js文件\n(function(window) {\n  let data = 'original data'\n  \n  function print() {\n    console.log(`data: ${data}`)\n    privateFn()\n  }\n\n  function privateFn() {\n    //内部私有的函数\n    console.log('privateFn')\n  }\n  //往window暴露模块\n  window.myModule = { print }\n})(window)\n````\n````html\n<!-- index.html文件  -->\n<script type=\"text/javascript\" src=\"module.js\"></script>\n<script type=\"text/javascript\">\n    myModule.print()\n    console.log(myModule.data) //undefined 不能访问模块内部数据\n    myModule.data = 'changed data' //不是修改的模块内部的data\n    myModule.print() //original data 没有改变\n</script>\n````\n* IIFE模式增强：引入依赖\n \n  解决了模块间依赖关系的问题\n````javascript\n// module.js文件\n(function(window, $) {\n  let data = 'original data'\n  \n  function print() {\n    console.log(`data：${data}`)\n    $('body').css('background', 'red')\n  }\n  //往window暴露模块\n  window.myModule = { foo, bar }\n})(window, jQuery)\n````\n````html\n  <!-- index.html文件  -->\n  <!-- 引入的js必须有一定顺序 -->\n  <script type=\"text/javascript\" src=\"jquery-1.10.1.js\"></script>\n  <script type=\"text/javascript\" src=\"module.js\"></script>\n  <script type=\"text/javascript\">\n    myModule.print()\n  </script>\n````\n必须先引入jQuery库，就把这个库当作参数传入。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。\n\n引入多个&lt;script&gt;后出现出现问题：\n\n* 请求过多\n\n  首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多\n\n* 依赖模糊\n\n  我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。\n\n* 难以维护\n\n  以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。\n## 模块化规范\n### CommonJS\n\nNode 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。\n\n1. 基本语法\n\n* 定义暴露模块：\n\n  module.exports = value\n\n  为了方便，Node为每个模块提供一个exports变量，指向\n  module.exports。因此也可以使用exports.xxx = value\n\n  注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。\n\n* 引入模块：\n\n  require(xxx),如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径\n\n2. 加载机制\n\nCommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n````javascript\n// lib.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n````\n````javascript\n// main.js\nvar counter = require('./lib').counter;\nvar incCounter = require('./lib').incCounter;\n\nconsole.log(counter);  // 3\nincCounter();\nconsole.log(counter); // 3\n\n````\n上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了\n\n3.require()的内部处理流程\n\nrequire命令是CommonJS规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的module.require命令，而后者又调用Node的内部命令Module._load。\n\n````javascript\nModule._load = function(request, parent, isMain) {\n  // 1. 检查 Module._cache，是否缓存之中有指定模块\n  // 2. 如果缓存之中没有，就创建一个新的Module实例\n  // 3. 将它保存到缓存\n  // 4. 使用 module.load() 加载指定的模块文件，\n  //    读取文件内容之后，使用 module.compile() 执行文件代码\n  // 5. 如果加载/解析过程报错，就从缓存删除该模块\n  // 6. 返回该模块的 module.exports\n};\n````\n上面的第4步，采用module.compile()执行指定模块的脚本，逻辑如下。\n````javascript\nModule.prototype._compile = function(content, filename) {\n  // 1. 生成一个require函数，指向module.require\n  // 2. 加载其他辅助方法到require\n  // 3. 将文件内容放到一个函数之中，该函数可调用 require\n  // 4. 执行该函数\n};\n````\n### AMD\n\nAMD是\"Asynchronous Module Definition\"的缩写，意思就是\"异步模块定义\"。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。\n\nRequireJS是AMD规范的一种实现。\n\n1. 基本语法\n\n* 定义暴露模块:\n如果被定义的模块是一个独立模块，不需要依赖任何其他模块，可以直接用define方法生成。\n\n````javascript\ndefine({\n    method1: function() {},\n    method2: function() {},\n});\n````\n另一种等价的写法是，把对象写成一个函数，该函数的返回值就是输出的模块。\n````javascript\ndefine(function () {\n\treturn {\n\t    method1: function() {},\n\t\t  method2: function() {},\n    };\n});\n````\n如果被定义的模块需要依赖其他模块，则define方法必须采用下面的格式。\n\ndefine方法的第二个参数是一个函数，当前面数组的所有成员加载成功后，它将被调用。它的参数与数组的成员一一对应。\n````javascript\ndefine(['module1', 'module2'], function(m1, m2) {\n    return {\n        method: function() {\n          m1.methodA();\n\t\t\t    m2.methodB();\n        }\n    };\n});\n````\n如果依赖的模块很多，参数与模块一一对应的写法非常麻烦。\n\n为了避免像上面代码那样繁琐的写法，RequireJS提供一种更简单的写法。\n````javascript\ndefine(\n    function (require) {\n        var dep1 = require('dep1'),\n            dep2 = require('dep2'),\n            dep3 = require('dep3'),\n            dep4 = require('dep4'),\n            dep5 = require('dep5'),\n            dep6 = require('dep6'),\n            dep7 = require('dep7'),\n            dep8 = require('dep8');\n            ...\n    }\n});\n````\n* 引入模块\n````javascript\nrequire(['foo', 'bar'], function ( foo, bar ) {\n        foo.doSomething();\n});\n````\nrequire方法也可以用在define方法内部。\n````javascript\ndefine(function (require) {\n   var otherModule = require('otherModule');\n});\n````\n### CMD\n\nCMD 是 [sea.js](https://github.com/seajs/seajs) 在推广过程中对模块定义的规范化产出。\n\nCMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。\n1. 基本语法\n* 暴露模块：\n````javascript\n//定义没有依赖的模块\ndefine(function(require, exports, module){\n  exports.xxx = value\n  module.exports = value\n})\n\n//定义有依赖的模块\ndefine(function(require, exports, module){\n  //引入依赖模块(同步)\n  var module2 = require('./module2')\n  //引入依赖模块(异步)\n    require.async('./module3', function (m3) {\n    })\n  //暴露模块\n  exports.xxx = value\n})\n````\n* 引入模块\n````javascript\ndefine(function (require) {\n  var m1 = require('./module1')\n  var m4 = require('./module4')\n  m1.show()\n  m4.show()\n})\n````\n2. AMD 与 CMD 的区别\n\n* 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从2.0开始，也改成了可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.\n\n* CMD 推崇依赖就近，AMD 推崇依赖前置\n### ES6模块化规范\n\nES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。\n\n1. 基本语法\nexport命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。\n````javascript\n/** 定义模块 math.js **/\nvar basicNum = 0;\nvar add = function (a, b) {\n    return a + b;\n};\nexport { basicNum, add };\n/** 引用模块 **/\nimport { basicNum, add } from './math';\nfunction test(ele) {\n    ele.textContent = add(99 + basicNum);\n}\n````\n2. import()\n\nimport命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（import命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。\n````javascript\n// 报错\nif (x === 2) {\n  import MyModual from './myModual';\n}\n````\n上面代码中，引擎处理import语句是在编译时，这时不会去分析或执行if语句，所以import语句放在if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。\n\n因此，有一个提案，建议引入import()函数，完成动态加载。import()返回一个 Promise 对象。\n````javascript\nbutton.addEventListener('click', event => {\n  import('./dialogBox.js')\n  .then(dialogBox => {\n    dialogBox.open();\n  })\n  .catch(error => {\n    /* Error handling */\n  })\n});\n````\n3. ES6 模块与 CommonJS 模块的差异\n\n* CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\n\n* CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\n\n## 参考资料\n\n* [前端模块化详解](https://juejin.im/post/5c17ad756fb9a049ff4e0a62)\n* [CommonJS规范](http://javascript.ruanyifeng.com/nodejs/module.html)\n* [RequireJS和AMD规范](http://javascript.ruanyifeng.com/tool/requirejs.html)\n* [ES6入门-Module的语法](http://es6.ruanyifeng.com/#docs/module)","source":"_posts/JavaScript模块化规范.md","raw":"---\ntitle: JavaScript模块化规范\ndate: 2018-01-06\ntags: ['模块化', 'js']\ncategories: ['规范']\n---\n## 模块化的进化过程\n* 全局function模式：将不同的功能封装成不同的全局函数\n\n  缺点：污染全局命名空间，容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系。\n<!--more-->\n````javascript\nfunction m1(){\n  //...\n}\nfunction m2(){\n  //...\n}\n````\n* namespace模式：简单对象封装\n\n  缺点：数据不安全(外部可以直接修改模块内部的数据)、\n````javascript\nlet myModule = {\n  data: 'original data',\n  print() {\n    console.log(`data: ${this.data}`)\n  }\n}\nmyModule.data = 'changed data' //能直接修改模块内部的数据\nmyModule.foo() // data: changed data\n````\n* IIFE模式：匿名函数自调用(闭包)\n\n  将数据和行为封装到一个函数内部，通过给window添加属性来向外暴露接口，数据是私有的，外部只能通过暴露的方法操作。\n\n  缺点：无法解决模块间依赖关系的问题。\n````javascript\n// module.js文件\n(function(window) {\n  let data = 'original data'\n  \n  function print() {\n    console.log(`data: ${data}`)\n    privateFn()\n  }\n\n  function privateFn() {\n    //内部私有的函数\n    console.log('privateFn')\n  }\n  //往window暴露模块\n  window.myModule = { print }\n})(window)\n````\n````html\n<!-- index.html文件  -->\n<script type=\"text/javascript\" src=\"module.js\"></script>\n<script type=\"text/javascript\">\n    myModule.print()\n    console.log(myModule.data) //undefined 不能访问模块内部数据\n    myModule.data = 'changed data' //不是修改的模块内部的data\n    myModule.print() //original data 没有改变\n</script>\n````\n* IIFE模式增强：引入依赖\n \n  解决了模块间依赖关系的问题\n````javascript\n// module.js文件\n(function(window, $) {\n  let data = 'original data'\n  \n  function print() {\n    console.log(`data：${data}`)\n    $('body').css('background', 'red')\n  }\n  //往window暴露模块\n  window.myModule = { foo, bar }\n})(window, jQuery)\n````\n````html\n  <!-- index.html文件  -->\n  <!-- 引入的js必须有一定顺序 -->\n  <script type=\"text/javascript\" src=\"jquery-1.10.1.js\"></script>\n  <script type=\"text/javascript\" src=\"module.js\"></script>\n  <script type=\"text/javascript\">\n    myModule.print()\n  </script>\n````\n必须先引入jQuery库，就把这个库当作参数传入。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。\n\n引入多个&lt;script&gt;后出现出现问题：\n\n* 请求过多\n\n  首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多\n\n* 依赖模糊\n\n  我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。\n\n* 难以维护\n\n  以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。\n## 模块化规范\n### CommonJS\n\nNode 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。\n\n1. 基本语法\n\n* 定义暴露模块：\n\n  module.exports = value\n\n  为了方便，Node为每个模块提供一个exports变量，指向\n  module.exports。因此也可以使用exports.xxx = value\n\n  注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。\n\n* 引入模块：\n\n  require(xxx),如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径\n\n2. 加载机制\n\nCommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n````javascript\n// lib.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n````\n````javascript\n// main.js\nvar counter = require('./lib').counter;\nvar incCounter = require('./lib').incCounter;\n\nconsole.log(counter);  // 3\nincCounter();\nconsole.log(counter); // 3\n\n````\n上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了\n\n3.require()的内部处理流程\n\nrequire命令是CommonJS规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的module.require命令，而后者又调用Node的内部命令Module._load。\n\n````javascript\nModule._load = function(request, parent, isMain) {\n  // 1. 检查 Module._cache，是否缓存之中有指定模块\n  // 2. 如果缓存之中没有，就创建一个新的Module实例\n  // 3. 将它保存到缓存\n  // 4. 使用 module.load() 加载指定的模块文件，\n  //    读取文件内容之后，使用 module.compile() 执行文件代码\n  // 5. 如果加载/解析过程报错，就从缓存删除该模块\n  // 6. 返回该模块的 module.exports\n};\n````\n上面的第4步，采用module.compile()执行指定模块的脚本，逻辑如下。\n````javascript\nModule.prototype._compile = function(content, filename) {\n  // 1. 生成一个require函数，指向module.require\n  // 2. 加载其他辅助方法到require\n  // 3. 将文件内容放到一个函数之中，该函数可调用 require\n  // 4. 执行该函数\n};\n````\n### AMD\n\nAMD是\"Asynchronous Module Definition\"的缩写，意思就是\"异步模块定义\"。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。\n\nRequireJS是AMD规范的一种实现。\n\n1. 基本语法\n\n* 定义暴露模块:\n如果被定义的模块是一个独立模块，不需要依赖任何其他模块，可以直接用define方法生成。\n\n````javascript\ndefine({\n    method1: function() {},\n    method2: function() {},\n});\n````\n另一种等价的写法是，把对象写成一个函数，该函数的返回值就是输出的模块。\n````javascript\ndefine(function () {\n\treturn {\n\t    method1: function() {},\n\t\t  method2: function() {},\n    };\n});\n````\n如果被定义的模块需要依赖其他模块，则define方法必须采用下面的格式。\n\ndefine方法的第二个参数是一个函数，当前面数组的所有成员加载成功后，它将被调用。它的参数与数组的成员一一对应。\n````javascript\ndefine(['module1', 'module2'], function(m1, m2) {\n    return {\n        method: function() {\n          m1.methodA();\n\t\t\t    m2.methodB();\n        }\n    };\n});\n````\n如果依赖的模块很多，参数与模块一一对应的写法非常麻烦。\n\n为了避免像上面代码那样繁琐的写法，RequireJS提供一种更简单的写法。\n````javascript\ndefine(\n    function (require) {\n        var dep1 = require('dep1'),\n            dep2 = require('dep2'),\n            dep3 = require('dep3'),\n            dep4 = require('dep4'),\n            dep5 = require('dep5'),\n            dep6 = require('dep6'),\n            dep7 = require('dep7'),\n            dep8 = require('dep8');\n            ...\n    }\n});\n````\n* 引入模块\n````javascript\nrequire(['foo', 'bar'], function ( foo, bar ) {\n        foo.doSomething();\n});\n````\nrequire方法也可以用在define方法内部。\n````javascript\ndefine(function (require) {\n   var otherModule = require('otherModule');\n});\n````\n### CMD\n\nCMD 是 [sea.js](https://github.com/seajs/seajs) 在推广过程中对模块定义的规范化产出。\n\nCMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。\n1. 基本语法\n* 暴露模块：\n````javascript\n//定义没有依赖的模块\ndefine(function(require, exports, module){\n  exports.xxx = value\n  module.exports = value\n})\n\n//定义有依赖的模块\ndefine(function(require, exports, module){\n  //引入依赖模块(同步)\n  var module2 = require('./module2')\n  //引入依赖模块(异步)\n    require.async('./module3', function (m3) {\n    })\n  //暴露模块\n  exports.xxx = value\n})\n````\n* 引入模块\n````javascript\ndefine(function (require) {\n  var m1 = require('./module1')\n  var m4 = require('./module4')\n  m1.show()\n  m4.show()\n})\n````\n2. AMD 与 CMD 的区别\n\n* 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从2.0开始，也改成了可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.\n\n* CMD 推崇依赖就近，AMD 推崇依赖前置\n### ES6模块化规范\n\nES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。\n\n1. 基本语法\nexport命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。\n````javascript\n/** 定义模块 math.js **/\nvar basicNum = 0;\nvar add = function (a, b) {\n    return a + b;\n};\nexport { basicNum, add };\n/** 引用模块 **/\nimport { basicNum, add } from './math';\nfunction test(ele) {\n    ele.textContent = add(99 + basicNum);\n}\n````\n2. import()\n\nimport命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（import命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。\n````javascript\n// 报错\nif (x === 2) {\n  import MyModual from './myModual';\n}\n````\n上面代码中，引擎处理import语句是在编译时，这时不会去分析或执行if语句，所以import语句放在if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。\n\n因此，有一个提案，建议引入import()函数，完成动态加载。import()返回一个 Promise 对象。\n````javascript\nbutton.addEventListener('click', event => {\n  import('./dialogBox.js')\n  .then(dialogBox => {\n    dialogBox.open();\n  })\n  .catch(error => {\n    /* Error handling */\n  })\n});\n````\n3. ES6 模块与 CommonJS 模块的差异\n\n* CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\n\n* CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\n\n## 参考资料\n\n* [前端模块化详解](https://juejin.im/post/5c17ad756fb9a049ff4e0a62)\n* [CommonJS规范](http://javascript.ruanyifeng.com/nodejs/module.html)\n* [RequireJS和AMD规范](http://javascript.ruanyifeng.com/tool/requirejs.html)\n* [ES6入门-Module的语法](http://es6.ruanyifeng.com/#docs/module)","slug":"JavaScript模块化规范","published":1,"updated":"2022-04-13T14:14:07.692Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfe80000g3t8i6dumvua","content":"<h2 id=\"模块化的进化过程\"><a href=\"#模块化的进化过程\" class=\"headerlink\" title=\"模块化的进化过程\"></a>模块化的进化过程</h2><ul>\n<li><p>全局function模式：将不同的功能封装成不同的全局函数</p>\n<p>缺点：污染全局命名空间，容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>namespace模式：简单对象封装</p>\n<p>缺点：数据不安全(外部可以直接修改模块内部的数据)、</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myModule = &#123;</span><br><span class=\"line\">  data: <span class=\"string\">'original data'</span>,</span><br><span class=\"line\">  print() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`data: <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.data&#125;</span>`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">myModule.data = <span class=\"string\">'changed data'</span> <span class=\"comment\">//能直接修改模块内部的数据</span></span><br><span class=\"line\">myModule.foo() <span class=\"comment\">// data: changed data</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>IIFE模式：匿名函数自调用(闭包)</p>\n<p>将数据和行为封装到一个函数内部，通过给window添加属性来向外暴露接口，数据是私有的，外部只能通过暴露的方法操作。</p>\n<p>缺点：无法解决模块间依赖关系的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// module.js文件</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">window</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> data = <span class=\"string\">'original data'</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`data: <span class=\"subst\">$&#123;data&#125;</span>`</span>)</span><br><span class=\"line\">    privateFn()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">privateFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//内部私有的函数</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'privateFn'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//往window暴露模块</span></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.myModule = &#123; print &#125;</span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- index.html文件  --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"module.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\">    myModule.print()</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(myModule.data) <span class=\"comment\">//undefined 不能访问模块内部数据</span></span></span><br><span class=\"line\"><span class=\"javascript\">    myModule.data = <span class=\"string\">'changed data'</span> <span class=\"comment\">//不是修改的模块内部的data</span></span></span><br><span class=\"line\"><span class=\"javascript\">    myModule.print() <span class=\"comment\">//original data 没有改变</span></span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>IIFE模式增强：引入依赖</p>\n<p>解决了模块间依赖关系的问题</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// module.js文件</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">window, $</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> data = <span class=\"string\">'original data'</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`data：<span class=\"subst\">$&#123;data&#125;</span>`</span>)</span><br><span class=\"line\">    $(<span class=\"string\">'body'</span>).css(<span class=\"string\">'background'</span>, <span class=\"string\">'red'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//往window暴露模块</span></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.myModule = &#123; foo, bar &#125;</span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>, jQuery)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- index.html文件  --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 引入的js必须有一定顺序 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"jquery-1.10.1.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"module.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\">  myModule.print()</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>必须先引入jQuery库，就把这个库当作参数传入。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p>\n<p>引入多个&lt;script&gt;后出现出现问题：</p>\n<ul>\n<li><p>请求过多</p>\n<p>首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多</p>\n</li>\n<li><p>依赖模糊</p>\n<p>我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。</p>\n</li>\n<li><p>难以维护</p>\n<p>以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。</p>\n<h2 id=\"模块化规范\"><a href=\"#模块化规范\" class=\"headerlink\" title=\"模块化规范\"></a>模块化规范</h2><h3 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h3></li>\n</ul>\n<p>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</p>\n<ol>\n<li>基本语法</li>\n</ol>\n<ul>\n<li><p>定义暴露模块：</p>\n<p>module.exports = value</p>\n<p>为了方便，Node为每个模块提供一个exports变量，指向<br>module.exports。因此也可以使用exports.xxx = value</p>\n<p>注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</p>\n</li>\n<li><p>引入模块：</p>\n<p>require(xxx),如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>加载机制</li>\n</ol>\n<p>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lib.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> counter = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incCounter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  counter++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  counter: counter,</span><br><span class=\"line\">  incCounter: incCounter,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> counter = <span class=\"built_in\">require</span>(<span class=\"string\">'./lib'</span>).counter;</span><br><span class=\"line\"><span class=\"keyword\">var</span> incCounter = <span class=\"built_in\">require</span>(<span class=\"string\">'./lib'</span>).incCounter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(counter);  <span class=\"comment\">// 3</span></span><br><span class=\"line\">incCounter();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(counter); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了</p>\n<p>3.require()的内部处理流程</p>\n<p>require命令是CommonJS规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的module.require命令，而后者又调用Node的内部命令Module._load。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Module._load = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">request, parent, isMain</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 检查 Module._cache，是否缓存之中有指定模块</span></span><br><span class=\"line\">  <span class=\"comment\">// 2. 如果缓存之中没有，就创建一个新的Module实例</span></span><br><span class=\"line\">  <span class=\"comment\">// 3. 将它保存到缓存</span></span><br><span class=\"line\">  <span class=\"comment\">// 4. 使用 module.load() 加载指定的模块文件，</span></span><br><span class=\"line\">  <span class=\"comment\">//    读取文件内容之后，使用 module.compile() 执行文件代码</span></span><br><span class=\"line\">  <span class=\"comment\">// 5. 如果加载/解析过程报错，就从缓存删除该模块</span></span><br><span class=\"line\">  <span class=\"comment\">// 6. 返回该模块的 module.exports</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面的第4步，采用module.compile()执行指定模块的脚本，逻辑如下。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Module.prototype._compile = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content, filename</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 生成一个require函数，指向module.require</span></span><br><span class=\"line\">  <span class=\"comment\">// 2. 加载其他辅助方法到require</span></span><br><span class=\"line\">  <span class=\"comment\">// 3. 将文件内容放到一个函数之中，该函数可调用 require</span></span><br><span class=\"line\">  <span class=\"comment\">// 4. 执行该函数</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h3><p>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。</p>\n<p>RequireJS是AMD规范的一种实现。</p>\n<ol>\n<li>基本语法</li>\n</ol>\n<ul>\n<li>定义暴露模块:<br>如果被定义的模块是一个独立模块，不需要依赖任何其他模块，可以直接用define方法生成。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(&#123;</span><br><span class=\"line\">    method1: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">    method2: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>另一种等价的写法是，把对象写成一个函数，该函数的返回值就是输出的模块。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t    method1: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">\t\t  method2: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>如果被定义的模块需要依赖其他模块，则define方法必须采用下面的格式。</p>\n<p>define方法的第二个参数是一个函数，当前面数组的所有成员加载成功后，它将被调用。它的参数与数组的成员一一对应。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">'module1'</span>, <span class=\"string\">'module2'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m1, m2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        method: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          m1.methodA();</span><br><span class=\"line\">\t\t\t    m2.methodB();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>如果依赖的模块很多，参数与模块一一对应的写法非常麻烦。</p>\n<p>为了避免像上面代码那样繁琐的写法，RequireJS提供一种更简单的写法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> dep1 = <span class=\"built_in\">require</span>(<span class=\"string\">'dep1'</span>),</span><br><span class=\"line\">            dep2 = <span class=\"built_in\">require</span>(<span class=\"string\">'dep2'</span>),</span><br><span class=\"line\">            dep3 = <span class=\"built_in\">require</span>(<span class=\"string\">'dep3'</span>),</span><br><span class=\"line\">            dep4 = <span class=\"built_in\">require</span>(<span class=\"string\">'dep4'</span>),</span><br><span class=\"line\">            dep5 = <span class=\"built_in\">require</span>(<span class=\"string\">'dep5'</span>),</span><br><span class=\"line\">            dep6 = <span class=\"built_in\">require</span>(<span class=\"string\">'dep6'</span>),</span><br><span class=\"line\">            dep7 = <span class=\"built_in\">require</span>(<span class=\"string\">'dep7'</span>),</span><br><span class=\"line\">            dep8 = <span class=\"built_in\">require</span>(<span class=\"string\">'dep8'</span>);</span><br><span class=\"line\">            ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>引入模块<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'foo'</span>, <span class=\"string\">'bar'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"> foo, bar </span>) </span>&#123;</span><br><span class=\"line\">        foo.doSomething();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>require方法也可以用在define方法内部。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> otherModule = <span class=\"built_in\">require</span>(<span class=\"string\">'otherModule'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h3><p>CMD 是 <a href=\"https://github.com/seajs/seajs\" target=\"_blank\" rel=\"noopener\">sea.js</a> 在推广过程中对模块定义的规范化产出。</p>\n<p>CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。</p>\n<ol>\n<li>基本语法</li>\n</ol>\n<ul>\n<li><p>暴露模块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义没有依赖的模块</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>)</span>&#123;</span><br><span class=\"line\">  exports.xxx = value</span><br><span class=\"line\">  <span class=\"built_in\">module</span>.exports = value</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义有依赖的模块</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//引入依赖模块(同步)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> module2 = <span class=\"built_in\">require</span>(<span class=\"string\">'./module2'</span>)</span><br><span class=\"line\">  <span class=\"comment\">//引入依赖模块(异步)</span></span><br><span class=\"line\">    <span class=\"built_in\">require</span>.async(<span class=\"string\">'./module3'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">m3</span>) </span>&#123;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  <span class=\"comment\">//暴露模块</span></span><br><span class=\"line\">  exports.xxx = value</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>引入模块</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> m1 = <span class=\"built_in\">require</span>(<span class=\"string\">'./module1'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> m4 = <span class=\"built_in\">require</span>(<span class=\"string\">'./module4'</span>)</span><br><span class=\"line\">  m1.show()</span><br><span class=\"line\">  m4.show()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"2\">\n<li>AMD 与 CMD 的区别</li>\n</ol>\n<ul>\n<li><p>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从2.0开始，也改成了可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</p>\n</li>\n<li><p>CMD 推崇依赖就近，AMD 推崇依赖前置</p>\n<h3 id=\"ES6模块化规范\"><a href=\"#ES6模块化规范\" class=\"headerlink\" title=\"ES6模块化规范\"></a>ES6模块化规范</h3></li>\n</ul>\n<p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>\n<ol>\n<li><p>基本语法<br>export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 定义模块 math.js **/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> basicNum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; basicNum, add &#125;;</span><br><span class=\"line\"><span class=\"comment\">/** 引用模块 **/</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; basicNum, add &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./math'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">ele</span>) </span>&#123;</span><br><span class=\"line\">    ele.textContent = add(<span class=\"number\">99</span> + basicNum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>import()</p>\n</li>\n</ol>\n<p>import命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（import命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (x === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">import</span> MyModual <span class=\"keyword\">from</span> <span class=\"string\">'./myModual'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，引擎处理import语句是在编译时，这时不会去分析或执行if语句，所以import语句放在if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。</p>\n<p>因此，有一个提案，建议引入import()函数，完成动态加载。import()返回一个 Promise 对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.addEventListener(<span class=\"string\">'click'</span>, event =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">import</span>(<span class=\"string\">'./dialogBox.js'</span>)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">dialogBox</span> =&gt;</span> &#123;</span><br><span class=\"line\">    dialogBox.open();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Error handling */</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\">\n<li>ES6 模块与 CommonJS 模块的差异</li>\n</ol>\n<ul>\n<li><p>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</p>\n</li>\n<li><p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</p>\n</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://juejin.im/post/5c17ad756fb9a049ff4e0a62\" target=\"_blank\" rel=\"noopener\">前端模块化详解</a></li>\n<li><a href=\"http://javascript.ruanyifeng.com/nodejs/module.html\" target=\"_blank\" rel=\"noopener\">CommonJS规范</a></li>\n<li><a href=\"http://javascript.ruanyifeng.com/tool/requirejs.html\" target=\"_blank\" rel=\"noopener\">RequireJS和AMD规范</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/module\" target=\"_blank\" rel=\"noopener\">ES6入门-Module的语法</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"模块化的进化过程\"><a href=\"#模块化的进化过程\" class=\"headerlink\" title=\"模块化的进化过程\"></a>模块化的进化过程</h2><ul>\n<li><p>全局function模式：将不同的功能封装成不同的全局函数</p>\n<p>缺点：污染全局命名空间，容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系。</p>","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>namespace模式：简单对象封装</p>\n<p>缺点：数据不安全(外部可以直接修改模块内部的数据)、</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myModule = &#123;</span><br><span class=\"line\">  data: <span class=\"string\">'original data'</span>,</span><br><span class=\"line\">  print() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`data: <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.data&#125;</span>`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">myModule.data = <span class=\"string\">'changed data'</span> <span class=\"comment\">//能直接修改模块内部的数据</span></span><br><span class=\"line\">myModule.foo() <span class=\"comment\">// data: changed data</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>IIFE模式：匿名函数自调用(闭包)</p>\n<p>将数据和行为封装到一个函数内部，通过给window添加属性来向外暴露接口，数据是私有的，外部只能通过暴露的方法操作。</p>\n<p>缺点：无法解决模块间依赖关系的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// module.js文件</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">window</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> data = <span class=\"string\">'original data'</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`data: <span class=\"subst\">$&#123;data&#125;</span>`</span>)</span><br><span class=\"line\">    privateFn()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">privateFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//内部私有的函数</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'privateFn'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//往window暴露模块</span></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.myModule = &#123; print &#125;</span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- index.html文件  --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"module.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\">    myModule.print()</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(myModule.data) <span class=\"comment\">//undefined 不能访问模块内部数据</span></span></span><br><span class=\"line\"><span class=\"javascript\">    myModule.data = <span class=\"string\">'changed data'</span> <span class=\"comment\">//不是修改的模块内部的data</span></span></span><br><span class=\"line\"><span class=\"javascript\">    myModule.print() <span class=\"comment\">//original data 没有改变</span></span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>IIFE模式增强：引入依赖</p>\n<p>解决了模块间依赖关系的问题</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// module.js文件</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">window, $</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> data = <span class=\"string\">'original data'</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`data：<span class=\"subst\">$&#123;data&#125;</span>`</span>)</span><br><span class=\"line\">    $(<span class=\"string\">'body'</span>).css(<span class=\"string\">'background'</span>, <span class=\"string\">'red'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//往window暴露模块</span></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.myModule = &#123; foo, bar &#125;</span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>, jQuery)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- index.html文件  --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 引入的js必须有一定顺序 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"jquery-1.10.1.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"module.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br><span class=\"line\">  myModule.print()</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>必须先引入jQuery库，就把这个库当作参数传入。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p>\n<p>引入多个&lt;script&gt;后出现出现问题：</p>\n<ul>\n<li><p>请求过多</p>\n<p>首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多</p>\n</li>\n<li><p>依赖模糊</p>\n<p>我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。</p>\n</li>\n<li><p>难以维护</p>\n<p>以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。</p>\n<h2 id=\"模块化规范\"><a href=\"#模块化规范\" class=\"headerlink\" title=\"模块化规范\"></a>模块化规范</h2><h3 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h3></li>\n</ul>\n<p>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</p>\n<ol>\n<li>基本语法</li>\n</ol>\n<ul>\n<li><p>定义暴露模块：</p>\n<p>module.exports = value</p>\n<p>为了方便，Node为每个模块提供一个exports变量，指向<br>module.exports。因此也可以使用exports.xxx = value</p>\n<p>注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</p>\n</li>\n<li><p>引入模块：</p>\n<p>require(xxx),如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>加载机制</li>\n</ol>\n<p>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lib.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> counter = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incCounter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  counter++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  counter: counter,</span><br><span class=\"line\">  incCounter: incCounter,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> counter = <span class=\"built_in\">require</span>(<span class=\"string\">'./lib'</span>).counter;</span><br><span class=\"line\"><span class=\"keyword\">var</span> incCounter = <span class=\"built_in\">require</span>(<span class=\"string\">'./lib'</span>).incCounter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(counter);  <span class=\"comment\">// 3</span></span><br><span class=\"line\">incCounter();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(counter); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了</p>\n<p>3.require()的内部处理流程</p>\n<p>require命令是CommonJS规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的module.require命令，而后者又调用Node的内部命令Module._load。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Module._load = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">request, parent, isMain</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 检查 Module._cache，是否缓存之中有指定模块</span></span><br><span class=\"line\">  <span class=\"comment\">// 2. 如果缓存之中没有，就创建一个新的Module实例</span></span><br><span class=\"line\">  <span class=\"comment\">// 3. 将它保存到缓存</span></span><br><span class=\"line\">  <span class=\"comment\">// 4. 使用 module.load() 加载指定的模块文件，</span></span><br><span class=\"line\">  <span class=\"comment\">//    读取文件内容之后，使用 module.compile() 执行文件代码</span></span><br><span class=\"line\">  <span class=\"comment\">// 5. 如果加载/解析过程报错，就从缓存删除该模块</span></span><br><span class=\"line\">  <span class=\"comment\">// 6. 返回该模块的 module.exports</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面的第4步，采用module.compile()执行指定模块的脚本，逻辑如下。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Module.prototype._compile = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content, filename</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 生成一个require函数，指向module.require</span></span><br><span class=\"line\">  <span class=\"comment\">// 2. 加载其他辅助方法到require</span></span><br><span class=\"line\">  <span class=\"comment\">// 3. 将文件内容放到一个函数之中，该函数可调用 require</span></span><br><span class=\"line\">  <span class=\"comment\">// 4. 执行该函数</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h3><p>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。</p>\n<p>RequireJS是AMD规范的一种实现。</p>\n<ol>\n<li>基本语法</li>\n</ol>\n<ul>\n<li>定义暴露模块:<br>如果被定义的模块是一个独立模块，不需要依赖任何其他模块，可以直接用define方法生成。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(&#123;</span><br><span class=\"line\">    method1: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">    method2: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>另一种等价的写法是，把对象写成一个函数，该函数的返回值就是输出的模块。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t    method1: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">\t\t  method2: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>如果被定义的模块需要依赖其他模块，则define方法必须采用下面的格式。</p>\n<p>define方法的第二个参数是一个函数，当前面数组的所有成员加载成功后，它将被调用。它的参数与数组的成员一一对应。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">'module1'</span>, <span class=\"string\">'module2'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m1, m2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        method: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          m1.methodA();</span><br><span class=\"line\">\t\t\t    m2.methodB();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>如果依赖的模块很多，参数与模块一一对应的写法非常麻烦。</p>\n<p>为了避免像上面代码那样繁琐的写法，RequireJS提供一种更简单的写法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> dep1 = <span class=\"built_in\">require</span>(<span class=\"string\">'dep1'</span>),</span><br><span class=\"line\">            dep2 = <span class=\"built_in\">require</span>(<span class=\"string\">'dep2'</span>),</span><br><span class=\"line\">            dep3 = <span class=\"built_in\">require</span>(<span class=\"string\">'dep3'</span>),</span><br><span class=\"line\">            dep4 = <span class=\"built_in\">require</span>(<span class=\"string\">'dep4'</span>),</span><br><span class=\"line\">            dep5 = <span class=\"built_in\">require</span>(<span class=\"string\">'dep5'</span>),</span><br><span class=\"line\">            dep6 = <span class=\"built_in\">require</span>(<span class=\"string\">'dep6'</span>),</span><br><span class=\"line\">            dep7 = <span class=\"built_in\">require</span>(<span class=\"string\">'dep7'</span>),</span><br><span class=\"line\">            dep8 = <span class=\"built_in\">require</span>(<span class=\"string\">'dep8'</span>);</span><br><span class=\"line\">            ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>引入模块<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'foo'</span>, <span class=\"string\">'bar'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"> foo, bar </span>) </span>&#123;</span><br><span class=\"line\">        foo.doSomething();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>require方法也可以用在define方法内部。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> otherModule = <span class=\"built_in\">require</span>(<span class=\"string\">'otherModule'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h3><p>CMD 是 <a href=\"https://github.com/seajs/seajs\" target=\"_blank\" rel=\"noopener\">sea.js</a> 在推广过程中对模块定义的规范化产出。</p>\n<p>CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。</p>\n<ol>\n<li>基本语法</li>\n</ol>\n<ul>\n<li><p>暴露模块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义没有依赖的模块</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>)</span>&#123;</span><br><span class=\"line\">  exports.xxx = value</span><br><span class=\"line\">  <span class=\"built_in\">module</span>.exports = value</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义有依赖的模块</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//引入依赖模块(同步)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> module2 = <span class=\"built_in\">require</span>(<span class=\"string\">'./module2'</span>)</span><br><span class=\"line\">  <span class=\"comment\">//引入依赖模块(异步)</span></span><br><span class=\"line\">    <span class=\"built_in\">require</span>.async(<span class=\"string\">'./module3'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">m3</span>) </span>&#123;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  <span class=\"comment\">//暴露模块</span></span><br><span class=\"line\">  exports.xxx = value</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>引入模块</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> m1 = <span class=\"built_in\">require</span>(<span class=\"string\">'./module1'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> m4 = <span class=\"built_in\">require</span>(<span class=\"string\">'./module4'</span>)</span><br><span class=\"line\">  m1.show()</span><br><span class=\"line\">  m4.show()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"2\">\n<li>AMD 与 CMD 的区别</li>\n</ol>\n<ul>\n<li><p>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从2.0开始，也改成了可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</p>\n</li>\n<li><p>CMD 推崇依赖就近，AMD 推崇依赖前置</p>\n<h3 id=\"ES6模块化规范\"><a href=\"#ES6模块化规范\" class=\"headerlink\" title=\"ES6模块化规范\"></a>ES6模块化规范</h3></li>\n</ul>\n<p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>\n<ol>\n<li><p>基本语法<br>export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 定义模块 math.js **/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> basicNum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; basicNum, add &#125;;</span><br><span class=\"line\"><span class=\"comment\">/** 引用模块 **/</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; basicNum, add &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./math'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">ele</span>) </span>&#123;</span><br><span class=\"line\">    ele.textContent = add(<span class=\"number\">99</span> + basicNum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>import()</p>\n</li>\n</ol>\n<p>import命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（import命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (x === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">import</span> MyModual <span class=\"keyword\">from</span> <span class=\"string\">'./myModual'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，引擎处理import语句是在编译时，这时不会去分析或执行if语句，所以import语句放在if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。</p>\n<p>因此，有一个提案，建议引入import()函数，完成动态加载。import()返回一个 Promise 对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.addEventListener(<span class=\"string\">'click'</span>, event =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">import</span>(<span class=\"string\">'./dialogBox.js'</span>)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">dialogBox</span> =&gt;</span> &#123;</span><br><span class=\"line\">    dialogBox.open();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Error handling */</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\">\n<li>ES6 模块与 CommonJS 模块的差异</li>\n</ol>\n<ul>\n<li><p>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</p>\n</li>\n<li><p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</p>\n</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://juejin.im/post/5c17ad756fb9a049ff4e0a62\" target=\"_blank\" rel=\"noopener\">前端模块化详解</a></li>\n<li><a href=\"http://javascript.ruanyifeng.com/nodejs/module.html\" target=\"_blank\" rel=\"noopener\">CommonJS规范</a></li>\n<li><a href=\"http://javascript.ruanyifeng.com/tool/requirejs.html\" target=\"_blank\" rel=\"noopener\">RequireJS和AMD规范</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/module\" target=\"_blank\" rel=\"noopener\">ES6入门-Module的语法</a></li>\n</ul>"},{"title":"Google Drive 文件通过 js 下载的方法","date":"2020-05-08T16:00:00.000Z","_content":"\n## Google Docs: 分享的文档链接形式为：\n\nhttps://docs.google.com/document/d/FILE_ID/edit?usp=sharing\n\n## 将 /edit 用 /export 替换掉，然后添加上文件的格式，例如 doc，xlsx，pdf 等，然后该文件就能被保存了。\n\nhttps://docs.google.com/document/d/FILE_ID/export?format=xlsx\n\n## Google 电子表格: 公开的电子表格链接格式为：\n\nhttps://docs.google.com/spreadsheets/d/FILE_ID/edit?usp=sharing\n\n其下载链接格式为：https://docs.google.com/spreadsheets/d/FILE_ID/export?format=xlsx\n\n## Google 演示文稿: 演示文稿的分享链接形式是这样的格式：\n\nhttps://docs.google.com/presentation/d/FILE_ID/edit?usp=sharing\n\n如果下载 PPT（.pptx）和 PDF 格式的链接如下：\n\nhttps://docs.google.com/presentation/d/FILE_ID/export/pptx\n\nhttps://docs.google.com/presentation/d/FILE_ID/export/pdf\n\n## 代码\n\n```js\nwindow.open(\"https://docs.google.com/spreadsheets/d/FILE_ID/export?format=xlsx \", \"_blank\");\n```\n","source":"_posts/Google Drive 文件通过 js 下载的方法.md","raw":"---\ntitle: Google Drive 文件通过 js 下载的方法\ndate: 2020-05-09\ntags: [\"google drive\"]\ncategories: [\"\"]\n---\n\n## Google Docs: 分享的文档链接形式为：\n\nhttps://docs.google.com/document/d/FILE_ID/edit?usp=sharing\n\n## 将 /edit 用 /export 替换掉，然后添加上文件的格式，例如 doc，xlsx，pdf 等，然后该文件就能被保存了。\n\nhttps://docs.google.com/document/d/FILE_ID/export?format=xlsx\n\n## Google 电子表格: 公开的电子表格链接格式为：\n\nhttps://docs.google.com/spreadsheets/d/FILE_ID/edit?usp=sharing\n\n其下载链接格式为：https://docs.google.com/spreadsheets/d/FILE_ID/export?format=xlsx\n\n## Google 演示文稿: 演示文稿的分享链接形式是这样的格式：\n\nhttps://docs.google.com/presentation/d/FILE_ID/edit?usp=sharing\n\n如果下载 PPT（.pptx）和 PDF 格式的链接如下：\n\nhttps://docs.google.com/presentation/d/FILE_ID/export/pptx\n\nhttps://docs.google.com/presentation/d/FILE_ID/export/pdf\n\n## 代码\n\n```js\nwindow.open(\"https://docs.google.com/spreadsheets/d/FILE_ID/export?format=xlsx \", \"_blank\");\n```\n","slug":"Google Drive 文件通过 js 下载的方法","published":1,"updated":"2022-04-14T02:27:27.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfec0001g3t83veewh0i","content":"<h2 id=\"Google-Docs-分享的文档链接形式为：\"><a href=\"#Google-Docs-分享的文档链接形式为：\" class=\"headerlink\" title=\"Google Docs: 分享的文档链接形式为：\"></a>Google Docs: 分享的文档链接形式为：</h2><p><a href=\"https://docs.google.com/document/d/FILE_ID/edit?usp=sharing\" target=\"_blank\" rel=\"noopener\">https://docs.google.com/document/d/FILE_ID/edit?usp=sharing</a></p>\n<h2 id=\"将-edit-用-export-替换掉，然后添加上文件的格式，例如-doc，xlsx，pdf-等，然后该文件就能被保存了。\"><a href=\"#将-edit-用-export-替换掉，然后添加上文件的格式，例如-doc，xlsx，pdf-等，然后该文件就能被保存了。\" class=\"headerlink\" title=\"将 /edit 用 /export 替换掉，然后添加上文件的格式，例如 doc，xlsx，pdf 等，然后该文件就能被保存了。\"></a>将 /edit 用 /export 替换掉，然后添加上文件的格式，例如 doc，xlsx，pdf 等，然后该文件就能被保存了。</h2><p><a href=\"https://docs.google.com/document/d/FILE_ID/export?format=xlsx\" target=\"_blank\" rel=\"noopener\">https://docs.google.com/document/d/FILE_ID/export?format=xlsx</a></p>\n<h2 id=\"Google-电子表格-公开的电子表格链接格式为：\"><a href=\"#Google-电子表格-公开的电子表格链接格式为：\" class=\"headerlink\" title=\"Google 电子表格: 公开的电子表格链接格式为：\"></a>Google 电子表格: 公开的电子表格链接格式为：</h2><p><a href=\"https://docs.google.com/spreadsheets/d/FILE_ID/edit?usp=sharing\" target=\"_blank\" rel=\"noopener\">https://docs.google.com/spreadsheets/d/FILE_ID/edit?usp=sharing</a></p>\n<p>其下载链接格式为：<a href=\"https://docs.google.com/spreadsheets/d/FILE_ID/export?format=xlsx\" target=\"_blank\" rel=\"noopener\">https://docs.google.com/spreadsheets/d/FILE_ID/export?format=xlsx</a></p>\n<h2 id=\"Google-演示文稿-演示文稿的分享链接形式是这样的格式：\"><a href=\"#Google-演示文稿-演示文稿的分享链接形式是这样的格式：\" class=\"headerlink\" title=\"Google 演示文稿: 演示文稿的分享链接形式是这样的格式：\"></a>Google 演示文稿: 演示文稿的分享链接形式是这样的格式：</h2><p><a href=\"https://docs.google.com/presentation/d/FILE_ID/edit?usp=sharing\" target=\"_blank\" rel=\"noopener\">https://docs.google.com/presentation/d/FILE_ID/edit?usp=sharing</a></p>\n<p>如果下载 PPT（.pptx）和 PDF 格式的链接如下：</p>\n<p><a href=\"https://docs.google.com/presentation/d/FILE_ID/export/pptx\" target=\"_blank\" rel=\"noopener\">https://docs.google.com/presentation/d/FILE_ID/export/pptx</a></p>\n<p><a href=\"https://docs.google.com/presentation/d/FILE_ID/export/pdf\" target=\"_blank\" rel=\"noopener\">https://docs.google.com/presentation/d/FILE_ID/export/pdf</a></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.open(<span class=\"string\">\"https://docs.google.com/spreadsheets/d/FILE_ID/export?format=xlsx \"</span>, <span class=\"string\">\"_blank\"</span>);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Google-Docs-分享的文档链接形式为：\"><a href=\"#Google-Docs-分享的文档链接形式为：\" class=\"headerlink\" title=\"Google Docs: 分享的文档链接形式为：\"></a>Google Docs: 分享的文档链接形式为：</h2><p><a href=\"https://docs.google.com/document/d/FILE_ID/edit?usp=sharing\" target=\"_blank\" rel=\"noopener\">https://docs.google.com/document/d/FILE_ID/edit?usp=sharing</a></p>\n<h2 id=\"将-edit-用-export-替换掉，然后添加上文件的格式，例如-doc，xlsx，pdf-等，然后该文件就能被保存了。\"><a href=\"#将-edit-用-export-替换掉，然后添加上文件的格式，例如-doc，xlsx，pdf-等，然后该文件就能被保存了。\" class=\"headerlink\" title=\"将 /edit 用 /export 替换掉，然后添加上文件的格式，例如 doc，xlsx，pdf 等，然后该文件就能被保存了。\"></a>将 /edit 用 /export 替换掉，然后添加上文件的格式，例如 doc，xlsx，pdf 等，然后该文件就能被保存了。</h2><p><a href=\"https://docs.google.com/document/d/FILE_ID/export?format=xlsx\" target=\"_blank\" rel=\"noopener\">https://docs.google.com/document/d/FILE_ID/export?format=xlsx</a></p>\n<h2 id=\"Google-电子表格-公开的电子表格链接格式为：\"><a href=\"#Google-电子表格-公开的电子表格链接格式为：\" class=\"headerlink\" title=\"Google 电子表格: 公开的电子表格链接格式为：\"></a>Google 电子表格: 公开的电子表格链接格式为：</h2><p><a href=\"https://docs.google.com/spreadsheets/d/FILE_ID/edit?usp=sharing\" target=\"_blank\" rel=\"noopener\">https://docs.google.com/spreadsheets/d/FILE_ID/edit?usp=sharing</a></p>\n<p>其下载链接格式为：<a href=\"https://docs.google.com/spreadsheets/d/FILE_ID/export?format=xlsx\" target=\"_blank\" rel=\"noopener\">https://docs.google.com/spreadsheets/d/FILE_ID/export?format=xlsx</a></p>\n<h2 id=\"Google-演示文稿-演示文稿的分享链接形式是这样的格式：\"><a href=\"#Google-演示文稿-演示文稿的分享链接形式是这样的格式：\" class=\"headerlink\" title=\"Google 演示文稿: 演示文稿的分享链接形式是这样的格式：\"></a>Google 演示文稿: 演示文稿的分享链接形式是这样的格式：</h2><p><a href=\"https://docs.google.com/presentation/d/FILE_ID/edit?usp=sharing\" target=\"_blank\" rel=\"noopener\">https://docs.google.com/presentation/d/FILE_ID/edit?usp=sharing</a></p>\n<p>如果下载 PPT（.pptx）和 PDF 格式的链接如下：</p>\n<p><a href=\"https://docs.google.com/presentation/d/FILE_ID/export/pptx\" target=\"_blank\" rel=\"noopener\">https://docs.google.com/presentation/d/FILE_ID/export/pptx</a></p>\n<p><a href=\"https://docs.google.com/presentation/d/FILE_ID/export/pdf\" target=\"_blank\" rel=\"noopener\">https://docs.google.com/presentation/d/FILE_ID/export/pdf</a></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.open(<span class=\"string\">\"https://docs.google.com/spreadsheets/d/FILE_ID/export?format=xlsx \"</span>, <span class=\"string\">\"_blank\"</span>);</span><br></pre></td></tr></table></figure>\n"},{"title":"JavaScript的继承","date":"2017-12-15T16:00:00.000Z","_content":"## 原型链继承\n原理： 将父类的实例作为子类的原型。\n<!--more-->\n\n````javascript\nfunction Parent() {\n  this.name = 'Tom'\n}\n\nParent.prototype.getName = function() {\n  return this.name\n}\n\nfunction Child() {\n\n}\n\nChild.prototype = new Parent()\n\n//demo\nvar child1 = new Child()\nconsole.log(child1.getName()) // 'Tom'\n````\n\n缺点：\n\n1. 原型中引用类型的属性被所有实例共享，改变一个会影响另一个实例的属性，存在篡改的可能。\n2. 在创建 Child 的实例时，不能向Parent传参。\n\n````javascript\nfunction Parent () {\n    this.names = ['Tom', 'Jack'];\n}\n\nfunction Child () {\n\n}\n\nChild.prototype = new Parent();\n\n//demo\nvar child1 = new Child();\n\nchild1.names.push('Danny');\n\nconsole.log(child1.names); // [\"Tom\", \"Jack\", \"Danny\"]\n\nvar child2 = new Child();\n\nconsole.log(child2.names); // [\"Tom\", \"Jack\", \"Danny\"]\n````\n\n## 借用构造函数继承\n\n原理：使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）。\n\n借用构造函数继承的核心就在于Parent.call(this, name)，“借调”了Parent构造函数，这样，Child的每个实例都会将Parent中的属性复制一份。\n\n````javascript\nfunction Parent(name) {\n  this.name = name\n  this.colors = [\"red\", \"blue\"]\n}\n\nfunction Child(name, age) {\n  Parent.call(this, name)\n  this.age = age\n}\n\n//demo\nvar child1 = new Child('Jack', 10)\nchild1.colors.push(\"green\")\nconsole.log(child1.name) // Jack\nconsole.log(child1.age) // 10\nconsole.log(child1.colors) // [\"red\", \"blue\", \"green\"]\n\nvar child2 = new Child('Tom', 20)\nconsole.log(child2.name) // Tom\nconsole.log(child2.age) // 20\nconsole.log(child2.colors) // [\"red\", \"blue\"]\n````\n\n优点：\n\n1. 避免了引用类型的属性被所有实例共享。\n2. 可以在 Child 中向 Parent 传参。\n\n缺点：\n\n1. 只能继承父类的实例属性和方法，不能继承原型属性/方法。\n2. 无法实现复用，方法都在构造函数中定义，每次创建实例都会创建一遍方法，每个子类都有父类实例函数的副本，影响性能。\n\n## 组合继承\n\n原理：结合原型链继承和构造函数继承通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。\n\n其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承，这样，既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。\n\n````javascript\nfunction Parent(name) {\n  this.name = name\n  this.colors = ['red', 'blue', 'green']\n  \n}\n\nParent.prototype.getName = function() {\n  return this.name\n}\n\nParent.prototype.getAge = function() {\n  return this.age\n}\n\nfunction Child(name, age) {\n  Parent.call(this, name)\n  this.age = age\n}\n\nChild.prototype = new Parent()\nChild.prototype.constructor = Child\n\n//demo\nvar child1 = new Child('Tom', 20)\nchild1.colors.push('yellow')\nconsole.log(child1.colors) // [\"red\", \"blue\", \"green\", \"yellow\"]\nconsole.log(child1.getName()) // Tom\nconsole.log(child1.getAge()) //20\n\nvar child2 = new Child('Jack', 10)\nchild2.colors.push('pink')\nconsole.log(child2.colors) // [\"red\", \"blue\", \"green\", \"pink\"]\nconsole.log(child2.getName()) //Jack\nconsole.log(child2.getAge()) //10\n````\n\n优点：\n1. 融合原型链继承和构造函数的优点。\n\n缺点：\n\n1. 父类中的实例属性和方法既存在于子类的实例中（复制父类实例而来），又存在于子类的原型中（继承父类实例而来）。因此，在使用子类创建实例对象时，会调用两次父构造函数，其原型中会存在两份相同的属性/方法。\n## 原型式继承\n\n原理：直接将某个对象直接赋值给构造函数的原型。\n\nobject()对传入其中的对象执行了一次浅复制，将F的原型直接指向传入的对象\n\n````javascript\nfunction object(obj) {\n  function F() {}\n  F.prototype = obj\n  return new F()\n}\n\n//demo\nvar person = {\n  name: 'Tom',\n  colors: ['red', 'green']\n}\n\nvar person1 = object(person)\nperson1.name = 'Jack'\nperson1.colors.push('blue')\n\nvar person2 = object(person)\nperson2.name = 'Danny'\nperson1.colors.push('yellow')\n\nconsole.log(person1.colors) // [\"red\", \"green\", \"blue\", \"yellow\"]\nconsole.log(person2.colors) // [\"red\", \"green\", \"blue\", \"yellow\"]\nconsole.log(person.colors) // [\"red\", \"green\", \"blue\", \"yellow\"]\n\n````\n\n缺点：\n\n1. 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。\n2. 无法传递参数。\n\n另外，ES5中存在Object.create()的方法，能够代替上面的object方法。\n## 寄生式继承\n\n原理：在原型式继承的基础上，增强对象，返回构造函数。\n\n````javascript\nfunction createObj(o) {\n  var clone = object(o) //通过调用函数创建一个新对象\n  clone.sayHi = function() { //以某种方式增强这个对象\n    return 'Hi'\n  }\n  return clone\n}\n\n//demo\nvar person = {\n  name: 'Tom',\n  colors: ['red', 'green']\n}\n\nvar person1 = createObj(person)\nconsole.log(person1.name) // Tom\nconsole.log(person1.colors) // [\"red\", \"green\"]\nconsole.log(person1.sayHi()) // Hi\n````\n\n缺点：\n\n1. 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能\n2. 无法传递参数\n\n## 组合寄生式继承\n原理：结合借用构造函数传递参数和寄生模式实现继承。\n\n````javascript\nfunction object(o) {\n  function F() {}\n  F.prototype = o\n  return new F()\n}\n\nfunction inherit(child, parent) {\n  var prototype = object(parent.prototype) //创建对象\n  prototype.constructor = child // 增强对象\n  child.prototype = prototype // 指定对象\n}\n\n\n//demo\nfunction Parent(name) {\n  this.name = name\n  this.colors = ['red', 'green']\n}\nParent.prototype.getName = function() {\n  return this.name\n}\n\nfunction Child(name, age) {\n  Parent.call(this, name)\n  this.age = age\n}\n\ninherit(Child, Parent)\n\nChild.prototype.getAge = function() {\n  return this.age\n}\n\nvar child1 = new Child('Tom', 20)\nchild1.colors.push('yellow')\nconsole.log(child1.colors) // [\"red\", \"blue\", \"green\", \"yellow\"]\nconsole.log(child1.getName()) // Tom\nconsole.log(child1.getAge()) //20\n\nvar child2 = new Child('Jack', 10)\nchild2.colors.push('pink')\nconsole.log(child2.colors) // [\"red\", \"blue\", \"green\", \"pink\"]\nconsole.log(child2.getName()) //Jack\nconsole.log(child2.getAge()) //10\n````\n\n优点：\n\n1. 只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。\n2. 原型链能保持不变，能够正常使用 instanceof 和 isPrototypeOf。\n### 参考资料\n* [《javascript高级程序设计》笔记：继承](https://segmentfault.com/a/1190000011917606)\n* [JavaScript深入之继承的多种方式和优缺点](https://github.com/mqyqingfeng/Blog/issues/16)","source":"_posts/JavaScript的继承.md","raw":"---\ntitle: JavaScript的继承\ndate: 2017-12-16\ntags: ['inherit', 'js']\ncategories: ['笔记']\n---\n## 原型链继承\n原理： 将父类的实例作为子类的原型。\n<!--more-->\n\n````javascript\nfunction Parent() {\n  this.name = 'Tom'\n}\n\nParent.prototype.getName = function() {\n  return this.name\n}\n\nfunction Child() {\n\n}\n\nChild.prototype = new Parent()\n\n//demo\nvar child1 = new Child()\nconsole.log(child1.getName()) // 'Tom'\n````\n\n缺点：\n\n1. 原型中引用类型的属性被所有实例共享，改变一个会影响另一个实例的属性，存在篡改的可能。\n2. 在创建 Child 的实例时，不能向Parent传参。\n\n````javascript\nfunction Parent () {\n    this.names = ['Tom', 'Jack'];\n}\n\nfunction Child () {\n\n}\n\nChild.prototype = new Parent();\n\n//demo\nvar child1 = new Child();\n\nchild1.names.push('Danny');\n\nconsole.log(child1.names); // [\"Tom\", \"Jack\", \"Danny\"]\n\nvar child2 = new Child();\n\nconsole.log(child2.names); // [\"Tom\", \"Jack\", \"Danny\"]\n````\n\n## 借用构造函数继承\n\n原理：使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）。\n\n借用构造函数继承的核心就在于Parent.call(this, name)，“借调”了Parent构造函数，这样，Child的每个实例都会将Parent中的属性复制一份。\n\n````javascript\nfunction Parent(name) {\n  this.name = name\n  this.colors = [\"red\", \"blue\"]\n}\n\nfunction Child(name, age) {\n  Parent.call(this, name)\n  this.age = age\n}\n\n//demo\nvar child1 = new Child('Jack', 10)\nchild1.colors.push(\"green\")\nconsole.log(child1.name) // Jack\nconsole.log(child1.age) // 10\nconsole.log(child1.colors) // [\"red\", \"blue\", \"green\"]\n\nvar child2 = new Child('Tom', 20)\nconsole.log(child2.name) // Tom\nconsole.log(child2.age) // 20\nconsole.log(child2.colors) // [\"red\", \"blue\"]\n````\n\n优点：\n\n1. 避免了引用类型的属性被所有实例共享。\n2. 可以在 Child 中向 Parent 传参。\n\n缺点：\n\n1. 只能继承父类的实例属性和方法，不能继承原型属性/方法。\n2. 无法实现复用，方法都在构造函数中定义，每次创建实例都会创建一遍方法，每个子类都有父类实例函数的副本，影响性能。\n\n## 组合继承\n\n原理：结合原型链继承和构造函数继承通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。\n\n其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承，这样，既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。\n\n````javascript\nfunction Parent(name) {\n  this.name = name\n  this.colors = ['red', 'blue', 'green']\n  \n}\n\nParent.prototype.getName = function() {\n  return this.name\n}\n\nParent.prototype.getAge = function() {\n  return this.age\n}\n\nfunction Child(name, age) {\n  Parent.call(this, name)\n  this.age = age\n}\n\nChild.prototype = new Parent()\nChild.prototype.constructor = Child\n\n//demo\nvar child1 = new Child('Tom', 20)\nchild1.colors.push('yellow')\nconsole.log(child1.colors) // [\"red\", \"blue\", \"green\", \"yellow\"]\nconsole.log(child1.getName()) // Tom\nconsole.log(child1.getAge()) //20\n\nvar child2 = new Child('Jack', 10)\nchild2.colors.push('pink')\nconsole.log(child2.colors) // [\"red\", \"blue\", \"green\", \"pink\"]\nconsole.log(child2.getName()) //Jack\nconsole.log(child2.getAge()) //10\n````\n\n优点：\n1. 融合原型链继承和构造函数的优点。\n\n缺点：\n\n1. 父类中的实例属性和方法既存在于子类的实例中（复制父类实例而来），又存在于子类的原型中（继承父类实例而来）。因此，在使用子类创建实例对象时，会调用两次父构造函数，其原型中会存在两份相同的属性/方法。\n## 原型式继承\n\n原理：直接将某个对象直接赋值给构造函数的原型。\n\nobject()对传入其中的对象执行了一次浅复制，将F的原型直接指向传入的对象\n\n````javascript\nfunction object(obj) {\n  function F() {}\n  F.prototype = obj\n  return new F()\n}\n\n//demo\nvar person = {\n  name: 'Tom',\n  colors: ['red', 'green']\n}\n\nvar person1 = object(person)\nperson1.name = 'Jack'\nperson1.colors.push('blue')\n\nvar person2 = object(person)\nperson2.name = 'Danny'\nperson1.colors.push('yellow')\n\nconsole.log(person1.colors) // [\"red\", \"green\", \"blue\", \"yellow\"]\nconsole.log(person2.colors) // [\"red\", \"green\", \"blue\", \"yellow\"]\nconsole.log(person.colors) // [\"red\", \"green\", \"blue\", \"yellow\"]\n\n````\n\n缺点：\n\n1. 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。\n2. 无法传递参数。\n\n另外，ES5中存在Object.create()的方法，能够代替上面的object方法。\n## 寄生式继承\n\n原理：在原型式继承的基础上，增强对象，返回构造函数。\n\n````javascript\nfunction createObj(o) {\n  var clone = object(o) //通过调用函数创建一个新对象\n  clone.sayHi = function() { //以某种方式增强这个对象\n    return 'Hi'\n  }\n  return clone\n}\n\n//demo\nvar person = {\n  name: 'Tom',\n  colors: ['red', 'green']\n}\n\nvar person1 = createObj(person)\nconsole.log(person1.name) // Tom\nconsole.log(person1.colors) // [\"red\", \"green\"]\nconsole.log(person1.sayHi()) // Hi\n````\n\n缺点：\n\n1. 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能\n2. 无法传递参数\n\n## 组合寄生式继承\n原理：结合借用构造函数传递参数和寄生模式实现继承。\n\n````javascript\nfunction object(o) {\n  function F() {}\n  F.prototype = o\n  return new F()\n}\n\nfunction inherit(child, parent) {\n  var prototype = object(parent.prototype) //创建对象\n  prototype.constructor = child // 增强对象\n  child.prototype = prototype // 指定对象\n}\n\n\n//demo\nfunction Parent(name) {\n  this.name = name\n  this.colors = ['red', 'green']\n}\nParent.prototype.getName = function() {\n  return this.name\n}\n\nfunction Child(name, age) {\n  Parent.call(this, name)\n  this.age = age\n}\n\ninherit(Child, Parent)\n\nChild.prototype.getAge = function() {\n  return this.age\n}\n\nvar child1 = new Child('Tom', 20)\nchild1.colors.push('yellow')\nconsole.log(child1.colors) // [\"red\", \"blue\", \"green\", \"yellow\"]\nconsole.log(child1.getName()) // Tom\nconsole.log(child1.getAge()) //20\n\nvar child2 = new Child('Jack', 10)\nchild2.colors.push('pink')\nconsole.log(child2.colors) // [\"red\", \"blue\", \"green\", \"pink\"]\nconsole.log(child2.getName()) //Jack\nconsole.log(child2.getAge()) //10\n````\n\n优点：\n\n1. 只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。\n2. 原型链能保持不变，能够正常使用 instanceof 和 isPrototypeOf。\n### 参考资料\n* [《javascript高级程序设计》笔记：继承](https://segmentfault.com/a/1190000011917606)\n* [JavaScript深入之继承的多种方式和优缺点](https://github.com/mqyqingfeng/Blog/issues/16)","slug":"JavaScript的继承","published":1,"updated":"2022-04-13T14:14:07.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfef0004g3t8bdvsy7ii","content":"<h2 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h2><p>原理： 将父类的实例作为子类的原型。<br><a id=\"more\"></a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">'Tom'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//demo</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> child1 = <span class=\"keyword\">new</span> Child()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.getName()) <span class=\"comment\">// 'Tom'</span></span><br></pre></td></tr></table></figure>\n<p>缺点：</p>\n<ol>\n<li>原型中引用类型的属性被所有实例共享，改变一个会影响另一个实例的属性，存在篡改的可能。</li>\n<li>在创建 Child 的实例时，不能向Parent传参。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.names = [<span class=\"string\">'Tom'</span>, <span class=\"string\">'Jack'</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//demo</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> child1 = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\"></span><br><span class=\"line\">child1.names.push(<span class=\"string\">'Danny'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.names); <span class=\"comment\">// [\"Tom\", \"Jack\", \"Danny\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> child2 = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.names); <span class=\"comment\">// [\"Tom\", \"Jack\", \"Danny\"]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"借用构造函数继承\"><a href=\"#借用构造函数继承\" class=\"headerlink\" title=\"借用构造函数继承\"></a>借用构造函数继承</h2><p>原理：使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）。</p>\n<p>借用构造函数继承的核心就在于Parent.call(this, name)，“借调”了Parent构造函数，这样，Child的每个实例都会将Parent中的属性复制一份。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.colors = [<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//demo</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">'Jack'</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">child1.colors.push(<span class=\"string\">\"green\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.name) <span class=\"comment\">// Jack</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.age) <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.colors) <span class=\"comment\">// [\"red\", \"blue\", \"green\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.name) <span class=\"comment\">// Tom</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.age) <span class=\"comment\">// 20</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.colors) <span class=\"comment\">// [\"red\", \"blue\"]</span></span><br></pre></td></tr></table></figure>\n<p>优点：</p>\n<ol>\n<li>避免了引用类型的属性被所有实例共享。</li>\n<li>可以在 Child 中向 Parent 传参。</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>只能继承父类的实例属性和方法，不能继承原型属性/方法。</li>\n<li>无法实现复用，方法都在构造函数中定义，每次创建实例都会创建一遍方法，每个子类都有父类实例函数的副本，影响性能。</li>\n</ol>\n<h2 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h2><p>原理：结合原型链继承和构造函数继承通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。</p>\n<p>其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承，这样，既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'blue'</span>, <span class=\"string\">'green'</span>]</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent()</span><br><span class=\"line\">Child.prototype.constructor = Child</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//demo</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>)</span><br><span class=\"line\">child1.colors.push(<span class=\"string\">'yellow'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.colors) <span class=\"comment\">// [\"red\", \"blue\", \"green\", \"yellow\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.getName()) <span class=\"comment\">// Tom</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.getAge()) <span class=\"comment\">//20</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">'Jack'</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">child2.colors.push(<span class=\"string\">'pink'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.colors) <span class=\"comment\">// [\"red\", \"blue\", \"green\", \"pink\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.getName()) <span class=\"comment\">//Jack</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.getAge()) <span class=\"comment\">//10</span></span><br></pre></td></tr></table></figure>\n<p>优点：</p>\n<ol>\n<li>融合原型链继承和构造函数的优点。</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>父类中的实例属性和方法既存在于子类的实例中（复制父类实例而来），又存在于子类的原型中（继承父类实例而来）。因此，在使用子类创建实例对象时，会调用两次父构造函数，其原型中会存在两份相同的属性/方法。<h2 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h2></li>\n</ol>\n<p>原理：直接将某个对象直接赋值给构造函数的原型。</p>\n<p>object()对传入其中的对象执行了一次浅复制，将F的原型直接指向传入的对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = obj</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//demo</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Tom'</span>,</span><br><span class=\"line\">  colors: [<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = object(person)</span><br><span class=\"line\">person1.name = <span class=\"string\">'Jack'</span></span><br><span class=\"line\">person1.colors.push(<span class=\"string\">'blue'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = object(person)</span><br><span class=\"line\">person2.name = <span class=\"string\">'Danny'</span></span><br><span class=\"line\">person1.colors.push(<span class=\"string\">'yellow'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.colors) <span class=\"comment\">// [\"red\", \"green\", \"blue\", \"yellow\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person2.colors) <span class=\"comment\">// [\"red\", \"green\", \"blue\", \"yellow\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.colors) <span class=\"comment\">// [\"red\", \"green\", \"blue\", \"yellow\"]</span></span><br></pre></td></tr></table></figure>\n<p>缺点：</p>\n<ol>\n<li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li>\n<li>无法传递参数。</li>\n</ol>\n<p>另外，ES5中存在Object.create()的方法，能够代替上面的object方法。</p>\n<h2 id=\"寄生式继承\"><a href=\"#寄生式继承\" class=\"headerlink\" title=\"寄生式继承\"></a>寄生式继承</h2><p>原理：在原型式继承的基础上，增强对象，返回构造函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createObj</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> clone = object(o) <span class=\"comment\">//通过调用函数创建一个新对象</span></span><br><span class=\"line\">  clone.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">//以某种方式增强这个对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Hi'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> clone</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//demo</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Tom'</span>,</span><br><span class=\"line\">  colors: [<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = createObj(person)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.name) <span class=\"comment\">// Tom</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.colors) <span class=\"comment\">// [\"red\", \"green\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.sayHi()) <span class=\"comment\">// Hi</span></span><br></pre></td></tr></table></figure>\n<p>缺点：</p>\n<ol>\n<li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能</li>\n<li>无法传递参数</li>\n</ol>\n<h2 id=\"组合寄生式继承\"><a href=\"#组合寄生式继承\" class=\"headerlink\" title=\"组合寄生式继承\"></a>组合寄生式继承</h2><p>原理：结合借用构造函数传递参数和寄生模式实现继承。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = o</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inherit</span>(<span class=\"params\">child, parent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> prototype = object(parent.prototype) <span class=\"comment\">//创建对象</span></span><br><span class=\"line\">  prototype.constructor = child <span class=\"comment\">// 增强对象</span></span><br><span class=\"line\">  child.prototype = prototype <span class=\"comment\">// 指定对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//demo</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inherit(Child, Parent)</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>)</span><br><span class=\"line\">child1.colors.push(<span class=\"string\">'yellow'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.colors) <span class=\"comment\">// [\"red\", \"blue\", \"green\", \"yellow\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.getName()) <span class=\"comment\">// Tom</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.getAge()) <span class=\"comment\">//20</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">'Jack'</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">child2.colors.push(<span class=\"string\">'pink'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.colors) <span class=\"comment\">// [\"red\", \"blue\", \"green\", \"pink\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.getName()) <span class=\"comment\">//Jack</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.getAge()) <span class=\"comment\">//10</span></span><br></pre></td></tr></table></figure>\n<p>优点：</p>\n<ol>\n<li>只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。</li>\n<li>原型链能保持不变，能够正常使用 instanceof 和 isPrototypeOf。<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3></li>\n</ol>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000011917606\" target=\"_blank\" rel=\"noopener\">《javascript高级程序设计》笔记：继承</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/16\" target=\"_blank\" rel=\"noopener\">JavaScript深入之继承的多种方式和优缺点</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h2><p>原理： 将父类的实例作为子类的原型。<br>","more":"</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">'Tom'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//demo</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> child1 = <span class=\"keyword\">new</span> Child()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.getName()) <span class=\"comment\">// 'Tom'</span></span><br></pre></td></tr></table></figure>\n<p>缺点：</p>\n<ol>\n<li>原型中引用类型的属性被所有实例共享，改变一个会影响另一个实例的属性，存在篡改的可能。</li>\n<li>在创建 Child 的实例时，不能向Parent传参。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.names = [<span class=\"string\">'Tom'</span>, <span class=\"string\">'Jack'</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//demo</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> child1 = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\"></span><br><span class=\"line\">child1.names.push(<span class=\"string\">'Danny'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.names); <span class=\"comment\">// [\"Tom\", \"Jack\", \"Danny\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> child2 = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.names); <span class=\"comment\">// [\"Tom\", \"Jack\", \"Danny\"]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"借用构造函数继承\"><a href=\"#借用构造函数继承\" class=\"headerlink\" title=\"借用构造函数继承\"></a>借用构造函数继承</h2><p>原理：使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）。</p>\n<p>借用构造函数继承的核心就在于Parent.call(this, name)，“借调”了Parent构造函数，这样，Child的每个实例都会将Parent中的属性复制一份。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.colors = [<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//demo</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">'Jack'</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">child1.colors.push(<span class=\"string\">\"green\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.name) <span class=\"comment\">// Jack</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.age) <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.colors) <span class=\"comment\">// [\"red\", \"blue\", \"green\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.name) <span class=\"comment\">// Tom</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.age) <span class=\"comment\">// 20</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.colors) <span class=\"comment\">// [\"red\", \"blue\"]</span></span><br></pre></td></tr></table></figure>\n<p>优点：</p>\n<ol>\n<li>避免了引用类型的属性被所有实例共享。</li>\n<li>可以在 Child 中向 Parent 传参。</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>只能继承父类的实例属性和方法，不能继承原型属性/方法。</li>\n<li>无法实现复用，方法都在构造函数中定义，每次创建实例都会创建一遍方法，每个子类都有父类实例函数的副本，影响性能。</li>\n</ol>\n<h2 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h2><p>原理：结合原型链继承和构造函数继承通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。</p>\n<p>其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承，这样，既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'blue'</span>, <span class=\"string\">'green'</span>]</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Parent.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent()</span><br><span class=\"line\">Child.prototype.constructor = Child</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//demo</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>)</span><br><span class=\"line\">child1.colors.push(<span class=\"string\">'yellow'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.colors) <span class=\"comment\">// [\"red\", \"blue\", \"green\", \"yellow\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.getName()) <span class=\"comment\">// Tom</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.getAge()) <span class=\"comment\">//20</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">'Jack'</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">child2.colors.push(<span class=\"string\">'pink'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.colors) <span class=\"comment\">// [\"red\", \"blue\", \"green\", \"pink\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.getName()) <span class=\"comment\">//Jack</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.getAge()) <span class=\"comment\">//10</span></span><br></pre></td></tr></table></figure>\n<p>优点：</p>\n<ol>\n<li>融合原型链继承和构造函数的优点。</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>父类中的实例属性和方法既存在于子类的实例中（复制父类实例而来），又存在于子类的原型中（继承父类实例而来）。因此，在使用子类创建实例对象时，会调用两次父构造函数，其原型中会存在两份相同的属性/方法。<h2 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h2></li>\n</ol>\n<p>原理：直接将某个对象直接赋值给构造函数的原型。</p>\n<p>object()对传入其中的对象执行了一次浅复制，将F的原型直接指向传入的对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = obj</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//demo</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Tom'</span>,</span><br><span class=\"line\">  colors: [<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = object(person)</span><br><span class=\"line\">person1.name = <span class=\"string\">'Jack'</span></span><br><span class=\"line\">person1.colors.push(<span class=\"string\">'blue'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = object(person)</span><br><span class=\"line\">person2.name = <span class=\"string\">'Danny'</span></span><br><span class=\"line\">person1.colors.push(<span class=\"string\">'yellow'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.colors) <span class=\"comment\">// [\"red\", \"green\", \"blue\", \"yellow\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person2.colors) <span class=\"comment\">// [\"red\", \"green\", \"blue\", \"yellow\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.colors) <span class=\"comment\">// [\"red\", \"green\", \"blue\", \"yellow\"]</span></span><br></pre></td></tr></table></figure>\n<p>缺点：</p>\n<ol>\n<li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li>\n<li>无法传递参数。</li>\n</ol>\n<p>另外，ES5中存在Object.create()的方法，能够代替上面的object方法。</p>\n<h2 id=\"寄生式继承\"><a href=\"#寄生式继承\" class=\"headerlink\" title=\"寄生式继承\"></a>寄生式继承</h2><p>原理：在原型式继承的基础上，增强对象，返回构造函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createObj</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> clone = object(o) <span class=\"comment\">//通过调用函数创建一个新对象</span></span><br><span class=\"line\">  clone.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">//以某种方式增强这个对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Hi'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> clone</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//demo</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Tom'</span>,</span><br><span class=\"line\">  colors: [<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = createObj(person)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.name) <span class=\"comment\">// Tom</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.colors) <span class=\"comment\">// [\"red\", \"green\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.sayHi()) <span class=\"comment\">// Hi</span></span><br></pre></td></tr></table></figure>\n<p>缺点：</p>\n<ol>\n<li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能</li>\n<li>无法传递参数</li>\n</ol>\n<h2 id=\"组合寄生式继承\"><a href=\"#组合寄生式继承\" class=\"headerlink\" title=\"组合寄生式继承\"></a>组合寄生式继承</h2><p>原理：结合借用构造函数传递参数和寄生模式实现继承。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = o</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inherit</span>(<span class=\"params\">child, parent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> prototype = object(parent.prototype) <span class=\"comment\">//创建对象</span></span><br><span class=\"line\">  prototype.constructor = child <span class=\"comment\">// 增强对象</span></span><br><span class=\"line\">  child.prototype = prototype <span class=\"comment\">// 指定对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//demo</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inherit(Child, Parent)</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">'Tom'</span>, <span class=\"number\">20</span>)</span><br><span class=\"line\">child1.colors.push(<span class=\"string\">'yellow'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.colors) <span class=\"comment\">// [\"red\", \"blue\", \"green\", \"yellow\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.getName()) <span class=\"comment\">// Tom</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1.getAge()) <span class=\"comment\">//20</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">'Jack'</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">child2.colors.push(<span class=\"string\">'pink'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.colors) <span class=\"comment\">// [\"red\", \"blue\", \"green\", \"pink\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.getName()) <span class=\"comment\">//Jack</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.getAge()) <span class=\"comment\">//10</span></span><br></pre></td></tr></table></figure>\n<p>优点：</p>\n<ol>\n<li>只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。</li>\n<li>原型链能保持不变，能够正常使用 instanceof 和 isPrototypeOf。<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3></li>\n</ol>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000011917606\" target=\"_blank\" rel=\"noopener\">《javascript高级程序设计》笔记：继承</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/16\" target=\"_blank\" rel=\"noopener\">JavaScript深入之继承的多种方式和优缺点</a></li>\n</ul>"},{"title":"Promise的规范和实现","date":"2018-10-05T16:00:00.000Z","_content":"## 什么是Promise ?\nPromise是JS异步编程中的重要概念，异步抽象处理对象，是目前比较流行Javascript异步编程解决方案之一\n<!--more-->\n## Promises/A+ 规范\n为实现者提供一个健全的、可互操作的 JavaScript Promise 的开放标准。\n### 术语\n* 解决 (fulfill) : 指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 fulfill 来表示解决，但在后世的 promise 实现多以 resolve 来指代之。\n* 拒绝（reject) : 指一个 promise 失败时进行的一系列操作。\n* 拒因 (reason) : 也就是拒绝原因，指在 promise 被拒绝时传递给拒绝回调的值。\n* 终值（eventual value） : 所谓终值，指的是 promise 被解决时传递给解决回调的值，由于 promise 有一次性的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。\n* Promise : promise 是一个拥有 then 方法的对象或函数，其行为符合本规范。\n* thenable : 是一个定义了 then 方法的对象或函数，文中译作“拥有 then 方法”。\n* 异常（exception） : 是使用 throw 语句抛出的一个值。\n### 基本要求\n1. Promise 的状态\n\n一个 Promise 的当前状态必须为以下三种状态中的一种：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）\n\n````javascript\nconst PENDING = 'pending';\n\nconst FULFILLED = 'fulfilled';\n\nconst REJECTED = 'rejected';\n````\n\n* 等待状态 (Pending)\n  * 可以迁移至执行态或拒绝态\n  ````javascript\n  if (this.state === PENDING) {\n      this.state = FULFILLED || REJECTED ；\n  }\n  ````\n* 执行状态 (Fulfilled)\n  * 不能迁移至其他任何状态\n  * 必须拥有一个不可变的终值\n  ````javascript\n  this.value = value;\n  ````\n* 拒绝状态 (Rejected)\n  * 不能迁移至其他任何状态\n  * 必须拥有一个不可变的拒因\n  ````javascript\n  this.reason = reason;\n  ````\n\n  ````javascript\n  // 具有终止态的Promise的状态不能被再次改变\n  var promise1 = new Promise((resolve, reject) => {\n    resolve('fulfilled!')\n    reject('rejected!')\n  })\n  console.log(promise1) \n\n  //输出\n  //Promise {<resolved>: \"fulfilled!\"}\n  ````\n2. Then方法\n\n一个 promise 必须提供一个 then 方法以访问其当前值、终值和拒因。\n\npromise 的 then 方法接受两个参数：\n````javascript\npromise.then(onFulfilled, onRejected)\n````\n* 参数可选\n  * onFulfilled 和 onRejected 都是可选参数\n  * 如果 onFulfilled 不是函数，其必须被忽略\n  * 如果 onRejected 不是函数，其必须被忽略\n* onFulfilled 特性\n  * 如果 onFulfilled 是函数：\n  * 当 promise 执行结束后其必须被调用，其第一个参数为 promise 的终值\n  * 在 promise 执行结束前其不可被调用\n  * 其调用次数不可超过一次\n* onRejected 特性\n  * 如果 onRejected 是函数：\n  * 当 promise 被拒绝执行后其必须被调用，其第一个参数为 promise 的拒因\n  * 在 promise 被拒绝执行前其不可被调用\n  * 其调用次数不可超过一次\n* 调用时机\n  * onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用\n* 调用要求\n  * onFulfilled 和 onRejected 必须被作为函数调用（即没有 this 值）\n* 多次调用\n  * then 方法可以被同一个 promise 调用多次\n  * 当 promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调\n  * 当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调\n\n  ````javascript\n  var promise1 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('fulfilled!')\n    }, 1000)\n  })\n  promise1.then(val => {\n    console.log('first ',val)\n  })\n  promise1.then(val => {\n    console.log('second ',val)\n  })\n\n  //输出\n  //first  fulfilled!\n  //second  fulfilled!\n  ````\n## 简易版的实现\n````javascript\n//Promise的三种状态\nconst PENDING = 'pending'\nconst FULFILLED = 'fulfilled'\nconst REJECTED = 'rejected'\n\nclass AjPromise {\n  constructor(fn) {\n    //当前状态\n    this.state = PENDING\n    //终值\n    this.value = null\n    //拒因\n    this.reason = null\n    //成功态回调队列\n    this.onFulfilledCallbackList = []\n    //拒绝态回调队列\n    this.onRejectedCallbackList = []\n\n    //成功态回调\n    const resolve = value => {\n      // 使用macro-task机制(setTimeout),确保onFulfilled异步执行,且在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。\n      setTimeout(() => {\n        if(this.state === PENDING) {\n          this.state = FULFILLED\n          this.value = value\n          this.onFulfilledCallbackList.map(cb => {\n            this.value = cb(this.value)\n          })\n        }\n      }, 0)\n    }\n    //拒绝态回调\n    const reject = reason => {\n      // 使用macro-task机制(setTimeout),确保onFulfilled异步执行,且在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。\n      setTimeout(() => {\n        if (this.state === PENDING) {\n          // pending(等待态)迁移至 fulfilled(拒绝态),保证调用次数不超过一次。\n          this.state = REJECTED\n          //拒因\n          this.reason = reason\n          this.onRejectedCallbackList.map(cb => {\n            this.reason = cb(this.reason)\n          })\n        }\n      }, 0)      \n    }\n\n    //执行promise\n    try {\n      fn(resolve, reject)\n    } catch (error) {\n      reject(e)\n    }\n  }\n\n  then(onFulfilled, onRejected) {\n    typeof onFulfilled === 'function' && this.onFulfilledCallbackList.push(onFulfilled)\n    typeof onRejected === 'function' && this.onRejectedCallbackList.push(onRejected)\n    // 返回this支持then 方法可以被同一个 promise 调用多次\n    return this\n  }\n}\nvar pro = new Promise((resolve, rejecte) => {\n  setTimeout(() => {\n    resolve('yes!')\n  },1000)\n}).then(\n  (value) => {\n  console.log('1',value)\n  return new Promise((resolve, reject) => {\n    reject(value)\n  })\n}, (e) => {\n  console.log('e1',e)\n  return e\n  }).then((value) => {\n  console.log('2',value)\n}, (e) => {\n  console.log('e2',e)\n  })\n````\n## 进一步的规范\n* 返回\n  * 1.then 方法必须返回一个 promise 对象\n\n  ````javascript\n  promise2 = promise1.then(onFulfilled, onRejected);   \n  ````\n  * 2.如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[[Resolve]](promise2, x)\n  * 3.如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e\n  * 4.如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值\n  * 5.如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因\n\n按照以上要求来一步一步完善then方法\n\n1. \n````javascript\n// 1.首先,then方法必须返回一个promise对象\nthen(onFulfilled, onRejected) {\n  let newPromise;\n  return (newPromise = new AjPromise((resolve, reject) => {}));\n}\n````\n2.\n````javascript\nthen(onFulfilled, onRejected) {\n  let newPromise;\n  return (newPromise = new AjPromise((resolve, reject) => {\n    // 2.如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[[Resolve]](promise2, x)\n    this.onFulfilledCallbacks.push(value => {\n      let x = onFulfilled(value);\n      //解决过程 resolvePromise\n      resolvePromise(newPromise, x);\n    });\n    this.onRejectedCallbacks.push(reason => {\n      let x = onRejected(reason);\n      //解决过程 resolvePromise\n      resolvePromise(newPromise, x);\n    });\n  }));\n}\n// 解决过程\nfunction resolvePromise() {\n//...\n}\n````\n3.\n````javascript\nthen(onFulfilled, onRejected) {\n  let newPromise;\n  return (newPromise = new AjPromise((resolve, reject) => {\n    //  3.如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e。\n    this.onFulfilledCallbacks.push(value => {\n      try {\n        let x = onFulfilled(value);\n        resolvePromise(newPromise, x);\n      } catch (e) {\n        reject(e);\n      }\n    });\n    this.onRejectedCallbacks.push(reason => {\n      try {\n        let x = onRejected(reason);\n        resolvePromise(newPromise, x);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }));\n}\n````\n4,5.\n````javascript\nthen(onFulfilled, onRejected) {  \n  let newPromise;\n  // 4.如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值。\n  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\n  // 5.如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因。\n  onRejected =\n    typeof onRejected === 'function'\n      ? onRejected\n      : reason => {\n          throw reason;\n        };\n  return (newPromise = new AjPromise((resolve, reject) => {\n    this.onFulfilledCallbacks.push(value => {\n      try {\n        let x = onFulfilled(value);\n        resolvePromise(newPromise, x);\n      } catch (e) {\n        reject(e);\n      }\n    });\n    this.onRejectedCallbacks.push(reason => {\n      try {\n        let x = onRejected(reason);\n        resolvePromise(newPromise, x);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }));\n}\n````\n6.\n````javascript\nthen(onFulfilled, onRejected) {\n  let newPromise;\n\n  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\n  onRejected =\n    typeof onRejected === 'function'\n      ? onRejected\n      : reason => {\n          throw reason;\n        };\n  // 2.2.6规范 对于一个promise，它的then方法可以调用多次.\n  // 当在其他程序中多次调用同一个promise的then时 由于之前状态已经为FULFILLED / REJECTED状态，则会走以下逻辑,\n  // 所以要确保为FULFILLED / REJECTED状态后 也要异步执行onFulfilled / onRejected ,这里使用setTimeout\n\n  // 6.不论 promise1 被 reject 还是被 resolve 时 promise2 都会被 resolve，只有出现异常时才会被 rejected。\n  // 由于在接下来的解决过程中需要调用resolve,reject进行处理,处理我们在调用处理过程时,传入参数\n  if (this.state == FULFILLED) {  \n    return (newPromise = new AjPromise((resolve, reject) => {\n      setTimeout(() => {\n        try {\n          let x = onFulfilled(this.value);\n          resolvePromise(newPromise, x, resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    }));\n  }\n  if (this.state == REJECTED) {\n    return (newPromise = new AjPromise((resolve, reject) => {\n      setTimeout(() => {\n        try {\n          let x = onRejected(this.reason);\n          resolvePromise(newPromise, x, resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    }));\n  }\n  if (this.state === PENDING) {\n    return (newPromise = new AjPromise((resolve, reject) => {\n      this.onFulfilledCallbacks.push(value => {\n        try {\n          let x = onFulfilled(value);\n          resolvePromise(newPromise, x, resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n      });\n      this.onRejectedCallbacks.push(reason => {\n        try {\n          let x = onRejected(reason);\n          resolvePromise(newPromise, x, resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    }));\n  }\n}\n````\n* Promise 解决过程\n\nPromise 解决过程是一个抽象的操作，其需输入一个 promise 和一个值，我们表示为 [[Resolve]](promise, x)，如果 x 有 then 方法且看上去像一个 Promise ，解决程序即尝试使 promise 接受 x 的状态；否则其用 x 的值来执行 promise 。\n\n这种 thenable 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。\n\n运行 [[Resolve]](promise, x) 需遵循以下步骤：\n\n1. x 与 promise 相等\n* 如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise\n2. x 为 Promise\n* 如果 x 为 Promise ，则使 promise 接受 x 的状态 注4：\n* 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝\n* 如果 x 处于执行态，用相同的值执行 promise\n* 如果 x 处于拒绝态，用相同的据因拒绝 promise\n* x 为对象或函数\n3. 如果 x 为对象或者函数：\n* 把 x.then 赋值给 then\n* 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise\n* 如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise:\n  * 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y)\n  * 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise\n  * 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用\n  * 如果调用 then 方法抛出了异常 e：\n    * 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之\n    * 否则以 e 为据因拒绝 promise\n  * 如果 then 不是函数，以 x 为参数执行 promise\n* 如果 x 不为对象或者函数，以 x 为参数执行 promise\n\n如果一个 promise 被一个循环的 thenable 链中的对象解决，而 [[Resolve]](promise, thenable) 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 TypeError 为据因来拒绝 promise。\n\n加下来一步步处理不同的情况：\n1. x 与 promise 相等\n````javascript\nfunction resolvePromise(promise2, x, resolve, reject) {\n  //x 与 promise 相等 \n  //如果从onFulfilled中返回的x 就是promise2 就会导致循环引用报错\n  \n  //如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise\n  if (x === promise2) {\n    reject(new TypeError('循环引用'));\n  }\n}\n````\n2. x 为 Promise\n````javascript\nfunction resolvePromise(promise2, x, resolve, reject) {\n  if (x === promise2) {\n    reject(new TypeError('循环引用'));\n  }\n  // x 为 Promise\n  else if (x instanceof AjPromise) {\n    // 如果 x 为 Promise ，则使 promise 接受 x 的状态\n    // 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝\n    if (x.state === PENDING) {\n      x.then(\n        y => {\n          resolvePromise(promise2, y, resolve, reject);\n        },\n        reason => {\n          reject(reason);\n        }\n      );\n    } else {\n      // 如果 x 处于执行态，用相同的值执行 promise\n      // 如果 x 处于拒绝态，用相同的据因拒绝 promise\n      x.then(resolve, reject);\n    }\n  }\n}\n````\n3. x 为对象或函数\n````javascript\nfunction resolvePromise(promise2, x, resolve, reject) {\n  if (x === promise2) {\n    reject(new TypeError('循环引用'));\n  }\n  if (x instanceof AjPromise) {\n    if (x.state === PENDING) {\n      x.then(\n        y => {\n          resolvePromise(promise2, y, resolve, reject);\n        },\n        reason => {\n          reject(reason);\n        }\n      );\n    } else {\n      x.then(resolve, reject);\n    }\n  } else if (x && (typeof x === 'function' || typeof x === 'object')) {\n    // 避免多次调用\n    let called = false;\n    try {\n      //把 x.then 赋值给 then\n      let then = x.then;\n      if (typeof then === 'function') {\n        // 如果 then 是函数，将 x 作为函数的作用域 this 调用之。\n        // 传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise\n        // 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用\n        then.call(\n          x,\n          // 如果 resolvePromise 以值 y 为参数被调用，则运行[[Resolve]](promise, y)\n          y => {\n            if (called) return;\n            called = true;\n            resolvePromise(promise2, y, resolve, reject);\n          },\n          // 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise\n          r => {\n            if (called) return;\n            called = true;\n            reject(r);\n          }\n        );\n      }else {\n        // 如果 then 不是函数，以 x 为参数执行 promise\n        resolve(x);\n      }  \n    } catch (e) {\n      // 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise\n      // 如果调用 then 方法抛出了异常 e：\n      // 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之\n      // 否则以 e 为据因拒绝 promise\n      if (called) return;\n      called = true;\n      reject(e);\n    }\n  } else {\n    // 如果 x 不为对象或者函数，以 x 为参数执行 promise\n    resolve(x);\n  }\n}\n````\n\n到此，Promise的解决过程就实现了。\n## Promise其他静态方法\n### Promise.all\n````javascript\n/**\n * Promise.all Promise进行并行处理\n * 参数: promise对象组成的数组作为参数\n * 返回值: 返回一个Promise实例\n * 当这个数组里的所有promise对象全部变为resolve状态的时候，才会resolve。\n */\nPromise.all = function(promises) {\n    return new Promise((resolve, reject) => {\n        let done = gen(promises.length, resolve);\n        promises.forEach((promise, index) => {\n            promise.then((value) => {\n                done(index, value)\n            }, reject)\n        })\n    })\n}\n\nfunction gen(length, resolve) {\n    let count = 0;\n    let values = [];\n    return function(i, value) {\n        values[i] = value;\n        if (++count === length) {\n            console.log(values);\n            resolve(values);\n        }\n    }\n}\n````\n### Poomise.race\n````javascript\n/**\n * Promise.race\n * 参数: 接收 promise对象组成的数组作为参数\n * 返回值: 返回一个Promise实例\n * 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理(取决于哪一个更快)\n */\nPromise.race = function(promises) {\n    return new Promise((resolve, reject) => {\n        promises.forEach((promise, index) => {\n           promise.then(resolve, reject);\n        });\n    });\n}\n````\n## 参考资料\n* [Promises/A+规范](http://www.ituring.com.cn/article/66566)\n* [Promise详解与实现（Promise/A+规范）](https://www.jianshu.com/p/459a856c476f)\n* [实现一个Promise(基于Promise/A+规范)](https://juejin.im/post/5c2b34a15188257abf1d96eb)\n* [你能手写一个Promise吗？Yes I promise](https://juejin.im/post/5c41297cf265da613356d4ec)\n* [Promise不会？？看这里！！！史上最通俗易懂的Promise！！！](https://juejin.im/post/5afe6d3bf265da0b9e654c4b#heading-11)\n* [JavaScript Promise迷你书](https://www.kancloud.cn/kancloud/promises-book )","source":"_posts/Promise的规范和实现.md","raw":"---\ntitle: Promise的规范和实现\ndate: 2018-10-06\ntags: ['promise', 'es6']\ncategories: ['规范']\n---\n## 什么是Promise ?\nPromise是JS异步编程中的重要概念，异步抽象处理对象，是目前比较流行Javascript异步编程解决方案之一\n<!--more-->\n## Promises/A+ 规范\n为实现者提供一个健全的、可互操作的 JavaScript Promise 的开放标准。\n### 术语\n* 解决 (fulfill) : 指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 fulfill 来表示解决，但在后世的 promise 实现多以 resolve 来指代之。\n* 拒绝（reject) : 指一个 promise 失败时进行的一系列操作。\n* 拒因 (reason) : 也就是拒绝原因，指在 promise 被拒绝时传递给拒绝回调的值。\n* 终值（eventual value） : 所谓终值，指的是 promise 被解决时传递给解决回调的值，由于 promise 有一次性的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。\n* Promise : promise 是一个拥有 then 方法的对象或函数，其行为符合本规范。\n* thenable : 是一个定义了 then 方法的对象或函数，文中译作“拥有 then 方法”。\n* 异常（exception） : 是使用 throw 语句抛出的一个值。\n### 基本要求\n1. Promise 的状态\n\n一个 Promise 的当前状态必须为以下三种状态中的一种：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）\n\n````javascript\nconst PENDING = 'pending';\n\nconst FULFILLED = 'fulfilled';\n\nconst REJECTED = 'rejected';\n````\n\n* 等待状态 (Pending)\n  * 可以迁移至执行态或拒绝态\n  ````javascript\n  if (this.state === PENDING) {\n      this.state = FULFILLED || REJECTED ；\n  }\n  ````\n* 执行状态 (Fulfilled)\n  * 不能迁移至其他任何状态\n  * 必须拥有一个不可变的终值\n  ````javascript\n  this.value = value;\n  ````\n* 拒绝状态 (Rejected)\n  * 不能迁移至其他任何状态\n  * 必须拥有一个不可变的拒因\n  ````javascript\n  this.reason = reason;\n  ````\n\n  ````javascript\n  // 具有终止态的Promise的状态不能被再次改变\n  var promise1 = new Promise((resolve, reject) => {\n    resolve('fulfilled!')\n    reject('rejected!')\n  })\n  console.log(promise1) \n\n  //输出\n  //Promise {<resolved>: \"fulfilled!\"}\n  ````\n2. Then方法\n\n一个 promise 必须提供一个 then 方法以访问其当前值、终值和拒因。\n\npromise 的 then 方法接受两个参数：\n````javascript\npromise.then(onFulfilled, onRejected)\n````\n* 参数可选\n  * onFulfilled 和 onRejected 都是可选参数\n  * 如果 onFulfilled 不是函数，其必须被忽略\n  * 如果 onRejected 不是函数，其必须被忽略\n* onFulfilled 特性\n  * 如果 onFulfilled 是函数：\n  * 当 promise 执行结束后其必须被调用，其第一个参数为 promise 的终值\n  * 在 promise 执行结束前其不可被调用\n  * 其调用次数不可超过一次\n* onRejected 特性\n  * 如果 onRejected 是函数：\n  * 当 promise 被拒绝执行后其必须被调用，其第一个参数为 promise 的拒因\n  * 在 promise 被拒绝执行前其不可被调用\n  * 其调用次数不可超过一次\n* 调用时机\n  * onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用\n* 调用要求\n  * onFulfilled 和 onRejected 必须被作为函数调用（即没有 this 值）\n* 多次调用\n  * then 方法可以被同一个 promise 调用多次\n  * 当 promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调\n  * 当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调\n\n  ````javascript\n  var promise1 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('fulfilled!')\n    }, 1000)\n  })\n  promise1.then(val => {\n    console.log('first ',val)\n  })\n  promise1.then(val => {\n    console.log('second ',val)\n  })\n\n  //输出\n  //first  fulfilled!\n  //second  fulfilled!\n  ````\n## 简易版的实现\n````javascript\n//Promise的三种状态\nconst PENDING = 'pending'\nconst FULFILLED = 'fulfilled'\nconst REJECTED = 'rejected'\n\nclass AjPromise {\n  constructor(fn) {\n    //当前状态\n    this.state = PENDING\n    //终值\n    this.value = null\n    //拒因\n    this.reason = null\n    //成功态回调队列\n    this.onFulfilledCallbackList = []\n    //拒绝态回调队列\n    this.onRejectedCallbackList = []\n\n    //成功态回调\n    const resolve = value => {\n      // 使用macro-task机制(setTimeout),确保onFulfilled异步执行,且在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。\n      setTimeout(() => {\n        if(this.state === PENDING) {\n          this.state = FULFILLED\n          this.value = value\n          this.onFulfilledCallbackList.map(cb => {\n            this.value = cb(this.value)\n          })\n        }\n      }, 0)\n    }\n    //拒绝态回调\n    const reject = reason => {\n      // 使用macro-task机制(setTimeout),确保onFulfilled异步执行,且在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。\n      setTimeout(() => {\n        if (this.state === PENDING) {\n          // pending(等待态)迁移至 fulfilled(拒绝态),保证调用次数不超过一次。\n          this.state = REJECTED\n          //拒因\n          this.reason = reason\n          this.onRejectedCallbackList.map(cb => {\n            this.reason = cb(this.reason)\n          })\n        }\n      }, 0)      \n    }\n\n    //执行promise\n    try {\n      fn(resolve, reject)\n    } catch (error) {\n      reject(e)\n    }\n  }\n\n  then(onFulfilled, onRejected) {\n    typeof onFulfilled === 'function' && this.onFulfilledCallbackList.push(onFulfilled)\n    typeof onRejected === 'function' && this.onRejectedCallbackList.push(onRejected)\n    // 返回this支持then 方法可以被同一个 promise 调用多次\n    return this\n  }\n}\nvar pro = new Promise((resolve, rejecte) => {\n  setTimeout(() => {\n    resolve('yes!')\n  },1000)\n}).then(\n  (value) => {\n  console.log('1',value)\n  return new Promise((resolve, reject) => {\n    reject(value)\n  })\n}, (e) => {\n  console.log('e1',e)\n  return e\n  }).then((value) => {\n  console.log('2',value)\n}, (e) => {\n  console.log('e2',e)\n  })\n````\n## 进一步的规范\n* 返回\n  * 1.then 方法必须返回一个 promise 对象\n\n  ````javascript\n  promise2 = promise1.then(onFulfilled, onRejected);   \n  ````\n  * 2.如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[[Resolve]](promise2, x)\n  * 3.如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e\n  * 4.如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值\n  * 5.如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因\n\n按照以上要求来一步一步完善then方法\n\n1. \n````javascript\n// 1.首先,then方法必须返回一个promise对象\nthen(onFulfilled, onRejected) {\n  let newPromise;\n  return (newPromise = new AjPromise((resolve, reject) => {}));\n}\n````\n2.\n````javascript\nthen(onFulfilled, onRejected) {\n  let newPromise;\n  return (newPromise = new AjPromise((resolve, reject) => {\n    // 2.如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[[Resolve]](promise2, x)\n    this.onFulfilledCallbacks.push(value => {\n      let x = onFulfilled(value);\n      //解决过程 resolvePromise\n      resolvePromise(newPromise, x);\n    });\n    this.onRejectedCallbacks.push(reason => {\n      let x = onRejected(reason);\n      //解决过程 resolvePromise\n      resolvePromise(newPromise, x);\n    });\n  }));\n}\n// 解决过程\nfunction resolvePromise() {\n//...\n}\n````\n3.\n````javascript\nthen(onFulfilled, onRejected) {\n  let newPromise;\n  return (newPromise = new AjPromise((resolve, reject) => {\n    //  3.如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e。\n    this.onFulfilledCallbacks.push(value => {\n      try {\n        let x = onFulfilled(value);\n        resolvePromise(newPromise, x);\n      } catch (e) {\n        reject(e);\n      }\n    });\n    this.onRejectedCallbacks.push(reason => {\n      try {\n        let x = onRejected(reason);\n        resolvePromise(newPromise, x);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }));\n}\n````\n4,5.\n````javascript\nthen(onFulfilled, onRejected) {  \n  let newPromise;\n  // 4.如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值。\n  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\n  // 5.如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因。\n  onRejected =\n    typeof onRejected === 'function'\n      ? onRejected\n      : reason => {\n          throw reason;\n        };\n  return (newPromise = new AjPromise((resolve, reject) => {\n    this.onFulfilledCallbacks.push(value => {\n      try {\n        let x = onFulfilled(value);\n        resolvePromise(newPromise, x);\n      } catch (e) {\n        reject(e);\n      }\n    });\n    this.onRejectedCallbacks.push(reason => {\n      try {\n        let x = onRejected(reason);\n        resolvePromise(newPromise, x);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }));\n}\n````\n6.\n````javascript\nthen(onFulfilled, onRejected) {\n  let newPromise;\n\n  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\n  onRejected =\n    typeof onRejected === 'function'\n      ? onRejected\n      : reason => {\n          throw reason;\n        };\n  // 2.2.6规范 对于一个promise，它的then方法可以调用多次.\n  // 当在其他程序中多次调用同一个promise的then时 由于之前状态已经为FULFILLED / REJECTED状态，则会走以下逻辑,\n  // 所以要确保为FULFILLED / REJECTED状态后 也要异步执行onFulfilled / onRejected ,这里使用setTimeout\n\n  // 6.不论 promise1 被 reject 还是被 resolve 时 promise2 都会被 resolve，只有出现异常时才会被 rejected。\n  // 由于在接下来的解决过程中需要调用resolve,reject进行处理,处理我们在调用处理过程时,传入参数\n  if (this.state == FULFILLED) {  \n    return (newPromise = new AjPromise((resolve, reject) => {\n      setTimeout(() => {\n        try {\n          let x = onFulfilled(this.value);\n          resolvePromise(newPromise, x, resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    }));\n  }\n  if (this.state == REJECTED) {\n    return (newPromise = new AjPromise((resolve, reject) => {\n      setTimeout(() => {\n        try {\n          let x = onRejected(this.reason);\n          resolvePromise(newPromise, x, resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    }));\n  }\n  if (this.state === PENDING) {\n    return (newPromise = new AjPromise((resolve, reject) => {\n      this.onFulfilledCallbacks.push(value => {\n        try {\n          let x = onFulfilled(value);\n          resolvePromise(newPromise, x, resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n      });\n      this.onRejectedCallbacks.push(reason => {\n        try {\n          let x = onRejected(reason);\n          resolvePromise(newPromise, x, resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    }));\n  }\n}\n````\n* Promise 解决过程\n\nPromise 解决过程是一个抽象的操作，其需输入一个 promise 和一个值，我们表示为 [[Resolve]](promise, x)，如果 x 有 then 方法且看上去像一个 Promise ，解决程序即尝试使 promise 接受 x 的状态；否则其用 x 的值来执行 promise 。\n\n这种 thenable 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。\n\n运行 [[Resolve]](promise, x) 需遵循以下步骤：\n\n1. x 与 promise 相等\n* 如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise\n2. x 为 Promise\n* 如果 x 为 Promise ，则使 promise 接受 x 的状态 注4：\n* 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝\n* 如果 x 处于执行态，用相同的值执行 promise\n* 如果 x 处于拒绝态，用相同的据因拒绝 promise\n* x 为对象或函数\n3. 如果 x 为对象或者函数：\n* 把 x.then 赋值给 then\n* 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise\n* 如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise:\n  * 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y)\n  * 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise\n  * 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用\n  * 如果调用 then 方法抛出了异常 e：\n    * 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之\n    * 否则以 e 为据因拒绝 promise\n  * 如果 then 不是函数，以 x 为参数执行 promise\n* 如果 x 不为对象或者函数，以 x 为参数执行 promise\n\n如果一个 promise 被一个循环的 thenable 链中的对象解决，而 [[Resolve]](promise, thenable) 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 TypeError 为据因来拒绝 promise。\n\n加下来一步步处理不同的情况：\n1. x 与 promise 相等\n````javascript\nfunction resolvePromise(promise2, x, resolve, reject) {\n  //x 与 promise 相等 \n  //如果从onFulfilled中返回的x 就是promise2 就会导致循环引用报错\n  \n  //如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise\n  if (x === promise2) {\n    reject(new TypeError('循环引用'));\n  }\n}\n````\n2. x 为 Promise\n````javascript\nfunction resolvePromise(promise2, x, resolve, reject) {\n  if (x === promise2) {\n    reject(new TypeError('循环引用'));\n  }\n  // x 为 Promise\n  else if (x instanceof AjPromise) {\n    // 如果 x 为 Promise ，则使 promise 接受 x 的状态\n    // 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝\n    if (x.state === PENDING) {\n      x.then(\n        y => {\n          resolvePromise(promise2, y, resolve, reject);\n        },\n        reason => {\n          reject(reason);\n        }\n      );\n    } else {\n      // 如果 x 处于执行态，用相同的值执行 promise\n      // 如果 x 处于拒绝态，用相同的据因拒绝 promise\n      x.then(resolve, reject);\n    }\n  }\n}\n````\n3. x 为对象或函数\n````javascript\nfunction resolvePromise(promise2, x, resolve, reject) {\n  if (x === promise2) {\n    reject(new TypeError('循环引用'));\n  }\n  if (x instanceof AjPromise) {\n    if (x.state === PENDING) {\n      x.then(\n        y => {\n          resolvePromise(promise2, y, resolve, reject);\n        },\n        reason => {\n          reject(reason);\n        }\n      );\n    } else {\n      x.then(resolve, reject);\n    }\n  } else if (x && (typeof x === 'function' || typeof x === 'object')) {\n    // 避免多次调用\n    let called = false;\n    try {\n      //把 x.then 赋值给 then\n      let then = x.then;\n      if (typeof then === 'function') {\n        // 如果 then 是函数，将 x 作为函数的作用域 this 调用之。\n        // 传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise\n        // 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用\n        then.call(\n          x,\n          // 如果 resolvePromise 以值 y 为参数被调用，则运行[[Resolve]](promise, y)\n          y => {\n            if (called) return;\n            called = true;\n            resolvePromise(promise2, y, resolve, reject);\n          },\n          // 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise\n          r => {\n            if (called) return;\n            called = true;\n            reject(r);\n          }\n        );\n      }else {\n        // 如果 then 不是函数，以 x 为参数执行 promise\n        resolve(x);\n      }  \n    } catch (e) {\n      // 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise\n      // 如果调用 then 方法抛出了异常 e：\n      // 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之\n      // 否则以 e 为据因拒绝 promise\n      if (called) return;\n      called = true;\n      reject(e);\n    }\n  } else {\n    // 如果 x 不为对象或者函数，以 x 为参数执行 promise\n    resolve(x);\n  }\n}\n````\n\n到此，Promise的解决过程就实现了。\n## Promise其他静态方法\n### Promise.all\n````javascript\n/**\n * Promise.all Promise进行并行处理\n * 参数: promise对象组成的数组作为参数\n * 返回值: 返回一个Promise实例\n * 当这个数组里的所有promise对象全部变为resolve状态的时候，才会resolve。\n */\nPromise.all = function(promises) {\n    return new Promise((resolve, reject) => {\n        let done = gen(promises.length, resolve);\n        promises.forEach((promise, index) => {\n            promise.then((value) => {\n                done(index, value)\n            }, reject)\n        })\n    })\n}\n\nfunction gen(length, resolve) {\n    let count = 0;\n    let values = [];\n    return function(i, value) {\n        values[i] = value;\n        if (++count === length) {\n            console.log(values);\n            resolve(values);\n        }\n    }\n}\n````\n### Poomise.race\n````javascript\n/**\n * Promise.race\n * 参数: 接收 promise对象组成的数组作为参数\n * 返回值: 返回一个Promise实例\n * 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理(取决于哪一个更快)\n */\nPromise.race = function(promises) {\n    return new Promise((resolve, reject) => {\n        promises.forEach((promise, index) => {\n           promise.then(resolve, reject);\n        });\n    });\n}\n````\n## 参考资料\n* [Promises/A+规范](http://www.ituring.com.cn/article/66566)\n* [Promise详解与实现（Promise/A+规范）](https://www.jianshu.com/p/459a856c476f)\n* [实现一个Promise(基于Promise/A+规范)](https://juejin.im/post/5c2b34a15188257abf1d96eb)\n* [你能手写一个Promise吗？Yes I promise](https://juejin.im/post/5c41297cf265da613356d4ec)\n* [Promise不会？？看这里！！！史上最通俗易懂的Promise！！！](https://juejin.im/post/5afe6d3bf265da0b9e654c4b#heading-11)\n* [JavaScript Promise迷你书](https://www.kancloud.cn/kancloud/promises-book )","slug":"Promise的规范和实现","published":1,"updated":"2022-04-13T14:14:07.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfeh0005g3t8e1zesr51","content":"<h2 id=\"什么是Promise\"><a href=\"#什么是Promise\" class=\"headerlink\" title=\"什么是Promise ?\"></a>什么是Promise ?</h2><p>Promise是JS异步编程中的重要概念，异步抽象处理对象，是目前比较流行Javascript异步编程解决方案之一<br><a id=\"more\"></a></p>\n<h2 id=\"Promises-A-规范\"><a href=\"#Promises-A-规范\" class=\"headerlink\" title=\"Promises/A+ 规范\"></a>Promises/A+ 规范</h2><p>为实现者提供一个健全的、可互操作的 JavaScript Promise 的开放标准。</p>\n<h3 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h3><ul>\n<li>解决 (fulfill) : 指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 fulfill 来表示解决，但在后世的 promise 实现多以 resolve 来指代之。</li>\n<li>拒绝（reject) : 指一个 promise 失败时进行的一系列操作。</li>\n<li>拒因 (reason) : 也就是拒绝原因，指在 promise 被拒绝时传递给拒绝回调的值。</li>\n<li>终值（eventual value） : 所谓终值，指的是 promise 被解决时传递给解决回调的值，由于 promise 有一次性的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。</li>\n<li>Promise : promise 是一个拥有 then 方法的对象或函数，其行为符合本规范。</li>\n<li>thenable : 是一个定义了 then 方法的对象或函数，文中译作“拥有 then 方法”。</li>\n<li>异常（exception） : 是使用 throw 语句抛出的一个值。<h3 id=\"基本要求\"><a href=\"#基本要求\" class=\"headerlink\" title=\"基本要求\"></a>基本要求</h3></li>\n</ul>\n<ol>\n<li>Promise 的状态</li>\n</ol>\n<p>一个 Promise 的当前状态必须为以下三种状态中的一种：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> FULFILLED = <span class=\"string\">'fulfilled'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">'rejected'</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>等待状态 (Pending)</p>\n<ul>\n<li>可以迁移至执行态或拒绝态<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === PENDING) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = FULFILLED || REJECTED ；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>执行状态 (Fulfilled)</p>\n<ul>\n<li>不能迁移至其他任何状态</li>\n<li>必须拥有一个不可变的终值<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.value = value;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>拒绝状态 (Rejected)</p>\n<ul>\n<li>不能迁移至其他任何状态</li>\n<li>必须拥有一个不可变的拒因<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.reason = reason;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 具有终止态的Promise的状态不能被再次改变</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promise1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  resolve(<span class=\"string\">'fulfilled!'</span>)</span><br><span class=\"line\">  reject(<span class=\"string\">'rejected!'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(promise1) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"comment\">//Promise &#123;&lt;resolved&gt;: \"fulfilled!\"&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"2\">\n<li>Then方法</li>\n</ol>\n<p>一个 promise 必须提供一个 then 方法以访问其当前值、终值和拒因。</p>\n<p>promise 的 then 方法接受两个参数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>参数可选<ul>\n<li>onFulfilled 和 onRejected 都是可选参数</li>\n<li>如果 onFulfilled 不是函数，其必须被忽略</li>\n<li>如果 onRejected 不是函数，其必须被忽略</li>\n</ul>\n</li>\n<li>onFulfilled 特性<ul>\n<li>如果 onFulfilled 是函数：</li>\n<li>当 promise 执行结束后其必须被调用，其第一个参数为 promise 的终值</li>\n<li>在 promise 执行结束前其不可被调用</li>\n<li>其调用次数不可超过一次</li>\n</ul>\n</li>\n<li>onRejected 特性<ul>\n<li>如果 onRejected 是函数：</li>\n<li>当 promise 被拒绝执行后其必须被调用，其第一个参数为 promise 的拒因</li>\n<li>在 promise 被拒绝执行前其不可被调用</li>\n<li>其调用次数不可超过一次</li>\n</ul>\n</li>\n<li>调用时机<ul>\n<li>onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用</li>\n</ul>\n</li>\n<li>调用要求<ul>\n<li>onFulfilled 和 onRejected 必须被作为函数调用（即没有 this 值）</li>\n</ul>\n</li>\n<li><p>多次调用</p>\n<ul>\n<li>then 方法可以被同一个 promise 调用多次</li>\n<li>当 promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调</li>\n<li>当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'fulfilled!'</span>)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise1.then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'first '</span>,val)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise1.then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'second '</span>,val)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"comment\">//first  fulfilled!</span></span><br><span class=\"line\"><span class=\"comment\">//second  fulfilled!</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"简易版的实现\"><a href=\"#简易版的实现\" class=\"headerlink\" title=\"简易版的实现\"></a>简易版的实现</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Promise的三种状态</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">'pending'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> FULFILLED = <span class=\"string\">'fulfilled'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">'rejected'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AjPromise</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(fn) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//当前状态</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = PENDING</span><br><span class=\"line\">    <span class=\"comment\">//终值</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"comment\">//拒因</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.reason = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"comment\">//成功态回调队列</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onFulfilledCallbackList = []</span><br><span class=\"line\">    <span class=\"comment\">//拒绝态回调队列</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onRejectedCallbackList = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//成功态回调</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> resolve = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 使用macro-task机制(setTimeout),确保onFulfilled异步执行,且在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。</span></span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.state === PENDING) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.state = FULFILLED</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.onFulfilledCallbackList.map(<span class=\"function\"><span class=\"params\">cb</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = cb(<span class=\"keyword\">this</span>.value)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//拒绝态回调</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> reject = <span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 使用macro-task机制(setTimeout),确保onFulfilled异步执行,且在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。</span></span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === PENDING) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// pending(等待态)迁移至 fulfilled(拒绝态),保证调用次数不超过一次。</span></span><br><span class=\"line\">          <span class=\"keyword\">this</span>.state = REJECTED</span><br><span class=\"line\">          <span class=\"comment\">//拒因</span></span><br><span class=\"line\">          <span class=\"keyword\">this</span>.reason = reason</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.onRejectedCallbackList.map(<span class=\"function\"><span class=\"params\">cb</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.reason = cb(<span class=\"keyword\">this</span>.reason)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;, <span class=\"number\">0</span>)      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//执行promise</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      fn(resolve, reject)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">      reject(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  then(onFulfilled, onRejected) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> &amp;&amp; <span class=\"keyword\">this</span>.onFulfilledCallbackList.push(onFulfilled)</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">'function'</span> &amp;&amp; <span class=\"keyword\">this</span>.onRejectedCallbackList.push(onRejected)</span><br><span class=\"line\">    <span class=\"comment\">// 返回this支持then 方法可以被同一个 promise 调用多次</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> pro = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, rejecte</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'yes!'</span>)</span><br><span class=\"line\">  &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;).then(</span><br><span class=\"line\">  (value) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'1'</span>,value)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    reject(value)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;, (e) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'e1'</span>,e)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> e</span><br><span class=\"line\">  &#125;).then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'2'</span>,value)</span><br><span class=\"line\">&#125;, (e) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'e2'</span>,e)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"进一步的规范\"><a href=\"#进一步的规范\" class=\"headerlink\" title=\"进一步的规范\"></a>进一步的规范</h2><ul>\n<li><p>返回</p>\n<ul>\n<li>1.then 方法必须返回一个 promise 对象</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>2.如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：<a href=\"promise2, x\">[Resolve]</a></li>\n<li>3.如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e</li>\n<li>4.如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值</li>\n<li>5.如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因</li>\n</ul>\n</li>\n</ul>\n<p>按照以上要求来一步一步完善then方法</p>\n<ol>\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.首先,then方法必须返回一个promise对象</span></span><br><span class=\"line\">then(onFulfilled, onRejected) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newPromise;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">newPromise = <span class=\"keyword\">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;&#125;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>2.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">then(onFulfilled, onRejected) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newPromise;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">newPromise = <span class=\"keyword\">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[[Resolve]](promise2, x)</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onFulfilledCallbacks.push(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> x = onFulfilled(value);</span><br><span class=\"line\">      <span class=\"comment\">//解决过程 resolvePromise</span></span><br><span class=\"line\">      resolvePromise(newPromise, x);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onRejectedCallbacks.push(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> x = onRejected(reason);</span><br><span class=\"line\">      <span class=\"comment\">//解决过程 resolvePromise</span></span><br><span class=\"line\">      resolvePromise(newPromise, x);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 解决过程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolvePromise</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>3.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">then(onFulfilled, onRejected) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newPromise;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">newPromise = <span class=\"keyword\">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  3.如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e。</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onFulfilledCallbacks.push(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> x = onFulfilled(value);</span><br><span class=\"line\">        resolvePromise(newPromise, x);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onRejectedCallbacks.push(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> x = onRejected(reason);</span><br><span class=\"line\">        resolvePromise(newPromise, x);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>4,5.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">then(onFulfilled, onRejected) &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">let</span> newPromise;</span><br><span class=\"line\">  <span class=\"comment\">// 4.如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值。</span></span><br><span class=\"line\">  onFulfilled = <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> ? onFulfilled : <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value;</span><br><span class=\"line\">  <span class=\"comment\">// 5.如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因。</span></span><br><span class=\"line\">  onRejected =</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">'function'</span></span><br><span class=\"line\">      ? onRejected</span><br><span class=\"line\">      : <span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> reason;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">newPromise = <span class=\"keyword\">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onFulfilledCallbacks.push(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> x = onFulfilled(value);</span><br><span class=\"line\">        resolvePromise(newPromise, x);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onRejectedCallbacks.push(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> x = onRejected(reason);</span><br><span class=\"line\">        resolvePromise(newPromise, x);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>6.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">then(onFulfilled, onRejected) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newPromise;</span><br><span class=\"line\"></span><br><span class=\"line\">  onFulfilled = <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> ? onFulfilled : <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value;</span><br><span class=\"line\">  onRejected =</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">'function'</span></span><br><span class=\"line\">      ? onRejected</span><br><span class=\"line\">      : <span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> reason;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 2.2.6规范 对于一个promise，它的then方法可以调用多次.</span></span><br><span class=\"line\">  <span class=\"comment\">// 当在其他程序中多次调用同一个promise的then时 由于之前状态已经为FULFILLED / REJECTED状态，则会走以下逻辑,</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以要确保为FULFILLED / REJECTED状态后 也要异步执行onFulfilled / onRejected ,这里使用setTimeout</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 6.不论 promise1 被 reject 还是被 resolve 时 promise2 都会被 resolve，只有出现异常时才会被 rejected。</span></span><br><span class=\"line\">  <span class=\"comment\">// 由于在接下来的解决过程中需要调用resolve,reject进行处理,处理我们在调用处理过程时,传入参数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state == FULFILLED) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">newPromise = <span class=\"keyword\">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> x = onFulfilled(<span class=\"keyword\">this</span>.value);</span><br><span class=\"line\">          resolvePromise(newPromise, x, resolve, reject);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">          reject(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state == REJECTED) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">newPromise = <span class=\"keyword\">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> x = onRejected(<span class=\"keyword\">this</span>.reason);</span><br><span class=\"line\">          resolvePromise(newPromise, x, resolve, reject);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">          reject(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === PENDING) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">newPromise = <span class=\"keyword\">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.onFulfilledCallbacks.push(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> x = onFulfilled(value);</span><br><span class=\"line\">          resolvePromise(newPromise, x, resolve, reject);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">          reject(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.onRejectedCallbacks.push(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> x = onRejected(reason);</span><br><span class=\"line\">          resolvePromise(newPromise, x, resolve, reject);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">          reject(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>Promise 解决过程</li>\n</ul>\n<p>Promise 解决过程是一个抽象的操作，其需输入一个 promise 和一个值，我们表示为 <a href=\"promise, x\">[Resolve]</a>，如果 x 有 then 方法且看上去像一个 Promise ，解决程序即尝试使 promise 接受 x 的状态；否则其用 x 的值来执行 promise 。</p>\n<p>这种 thenable 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。</p>\n<p>运行 <a href=\"promise, x\">[Resolve]</a> 需遵循以下步骤：</p>\n<ol>\n<li>x 与 promise 相等</li>\n</ol>\n<ul>\n<li>如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise</li>\n</ul>\n<ol start=\"2\">\n<li>x 为 Promise</li>\n</ol>\n<ul>\n<li>如果 x 为 Promise ，则使 promise 接受 x 的状态 注4：</li>\n<li>如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝</li>\n<li>如果 x 处于执行态，用相同的值执行 promise</li>\n<li>如果 x 处于拒绝态，用相同的据因拒绝 promise</li>\n<li>x 为对象或函数</li>\n</ul>\n<ol start=\"3\">\n<li>如果 x 为对象或者函数：</li>\n</ol>\n<ul>\n<li>把 x.then 赋值给 then</li>\n<li>如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise</li>\n<li>如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise:<ul>\n<li>如果 resolvePromise 以值 y 为参数被调用，则运行 <a href=\"promise, y\">[Resolve]</a></li>\n<li>如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise</li>\n<li>如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</li>\n<li>如果调用 then 方法抛出了异常 e：<ul>\n<li>如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之</li>\n<li>否则以 e 为据因拒绝 promise</li>\n</ul>\n</li>\n<li>如果 then 不是函数，以 x 为参数执行 promise</li>\n</ul>\n</li>\n<li>如果 x 不为对象或者函数，以 x 为参数执行 promise</li>\n</ul>\n<p>如果一个 promise 被一个循环的 thenable 链中的对象解决，而 <a href=\"promise, thenable\">[Resolve]</a> 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 TypeError 为据因来拒绝 promise。</p>\n<p>加下来一步步处理不同的情况：</p>\n<ol>\n<li><p>x 与 promise 相等</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolvePromise</span>(<span class=\"params\">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//x 与 promise 相等 </span></span><br><span class=\"line\">  <span class=\"comment\">//如果从onFulfilled中返回的x 就是promise2 就会导致循环引用报错</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === promise2) &#123;</span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'循环引用'</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>x 为 Promise</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolvePromise</span>(<span class=\"params\">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === promise2) &#123;</span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'循环引用'</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// x 为 Promise</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> AjPromise) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 x 为 Promise ，则使 promise 接受 x 的状态</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x.state === PENDING) &#123;</span><br><span class=\"line\">      x.then(</span><br><span class=\"line\">        y =&gt; &#123;</span><br><span class=\"line\">          resolvePromise(promise2, y, resolve, reject);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        reason =&gt; &#123;</span><br><span class=\"line\">          reject(reason);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果 x 处于执行态，用相同的值执行 promise</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果 x 处于拒绝态，用相同的据因拒绝 promise</span></span><br><span class=\"line\">      x.then(resolve, reject);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>x 为对象或函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolvePromise</span>(<span class=\"params\">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === promise2) &#123;</span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'循环引用'</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> AjPromise) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x.state === PENDING) &#123;</span><br><span class=\"line\">      x.then(</span><br><span class=\"line\">        y =&gt; &#123;</span><br><span class=\"line\">          resolvePromise(promise2, y, resolve, reject);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        reason =&gt; &#123;</span><br><span class=\"line\">          reject(reason);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      x.then(resolve, reject);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &amp;&amp; (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'function'</span> || <span class=\"keyword\">typeof</span> x === <span class=\"string\">'object'</span>)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 避免多次调用</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> called = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//把 x.then 赋值给 then</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> then = x.then;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> then === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 then 是函数，将 x 作为函数的作用域 this 调用之。</span></span><br><span class=\"line\">        <span class=\"comment\">// 传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</span></span><br><span class=\"line\">        then.call(</span><br><span class=\"line\">          x,</span><br><span class=\"line\">          <span class=\"comment\">// 如果 resolvePromise 以值 y 为参数被调用，则运行[[Resolve]](promise, y)</span></span><br><span class=\"line\">          y =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            called = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            resolvePromise(promise2, y, resolve, reject);</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          <span class=\"comment\">// 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise</span></span><br><span class=\"line\">          r =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            called = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            reject(r);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 then 不是函数，以 x 为参数执行 promise</span></span><br><span class=\"line\">        resolve(x);</span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果调用 then 方法抛出了异常 e：</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之</span></span><br><span class=\"line\">      <span class=\"comment\">// 否则以 e 为据因拒绝 promise</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      called = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      reject(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 x 不为对象或者函数，以 x 为参数执行 promise</span></span><br><span class=\"line\">    resolve(x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>到此，Promise的解决过程就实现了。</p>\n<h2 id=\"Promise其他静态方法\"><a href=\"#Promise其他静态方法\" class=\"headerlink\" title=\"Promise其他静态方法\"></a>Promise其他静态方法</h2><h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all\"></a>Promise.all</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Promise.all Promise进行并行处理</span></span><br><span class=\"line\"><span class=\"comment\"> * 参数: promise对象组成的数组作为参数</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回一个Promise实例</span></span><br><span class=\"line\"><span class=\"comment\"> * 当这个数组里的所有promise对象全部变为resolve状态的时候，才会resolve。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">promises</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> done = gen(promises.length, resolve);</span><br><span class=\"line\">        promises.forEach(<span class=\"function\">(<span class=\"params\">promise, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            promise.then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                done(index, value)</span><br><span class=\"line\">            &#125;, reject)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">gen</span>(<span class=\"params\">length, resolve</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> values = [];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i, value</span>) </span>&#123;</span><br><span class=\"line\">        values[i] = value;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++count === length) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(values);</span><br><span class=\"line\">            resolve(values);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Poomise-race\"><a href=\"#Poomise-race\" class=\"headerlink\" title=\"Poomise.race\"></a>Poomise.race</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Promise.race</span></span><br><span class=\"line\"><span class=\"comment\"> * 参数: 接收 promise对象组成的数组作为参数</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回一个Promise实例</span></span><br><span class=\"line\"><span class=\"comment\"> * 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理(取决于哪一个更快)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.race = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">promises</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        promises.forEach(<span class=\"function\">(<span class=\"params\">promise, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">           promise.then(resolve, reject);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"http://www.ituring.com.cn/article/66566\" target=\"_blank\" rel=\"noopener\">Promises/A+规范</a></li>\n<li><a href=\"https://www.jianshu.com/p/459a856c476f\" target=\"_blank\" rel=\"noopener\">Promise详解与实现（Promise/A+规范）</a></li>\n<li><a href=\"https://juejin.im/post/5c2b34a15188257abf1d96eb\" target=\"_blank\" rel=\"noopener\">实现一个Promise(基于Promise/A+规范)</a></li>\n<li><a href=\"https://juejin.im/post/5c41297cf265da613356d4ec\" target=\"_blank\" rel=\"noopener\">你能手写一个Promise吗？Yes I promise</a></li>\n<li><a href=\"https://juejin.im/post/5afe6d3bf265da0b9e654c4b#heading-11\" target=\"_blank\" rel=\"noopener\">Promise不会？？看这里！！！史上最通俗易懂的Promise！！！</a></li>\n<li><a href=\"https://www.kancloud.cn/kancloud/promises-book\" target=\"_blank\" rel=\"noopener\">JavaScript Promise迷你书</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是Promise\"><a href=\"#什么是Promise\" class=\"headerlink\" title=\"什么是Promise ?\"></a>什么是Promise ?</h2><p>Promise是JS异步编程中的重要概念，异步抽象处理对象，是目前比较流行Javascript异步编程解决方案之一<br>","more":"</p>\n<h2 id=\"Promises-A-规范\"><a href=\"#Promises-A-规范\" class=\"headerlink\" title=\"Promises/A+ 规范\"></a>Promises/A+ 规范</h2><p>为实现者提供一个健全的、可互操作的 JavaScript Promise 的开放标准。</p>\n<h3 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h3><ul>\n<li>解决 (fulfill) : 指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 fulfill 来表示解决，但在后世的 promise 实现多以 resolve 来指代之。</li>\n<li>拒绝（reject) : 指一个 promise 失败时进行的一系列操作。</li>\n<li>拒因 (reason) : 也就是拒绝原因，指在 promise 被拒绝时传递给拒绝回调的值。</li>\n<li>终值（eventual value） : 所谓终值，指的是 promise 被解决时传递给解决回调的值，由于 promise 有一次性的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。</li>\n<li>Promise : promise 是一个拥有 then 方法的对象或函数，其行为符合本规范。</li>\n<li>thenable : 是一个定义了 then 方法的对象或函数，文中译作“拥有 then 方法”。</li>\n<li>异常（exception） : 是使用 throw 语句抛出的一个值。<h3 id=\"基本要求\"><a href=\"#基本要求\" class=\"headerlink\" title=\"基本要求\"></a>基本要求</h3></li>\n</ul>\n<ol>\n<li>Promise 的状态</li>\n</ol>\n<p>一个 Promise 的当前状态必须为以下三种状态中的一种：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">'pending'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> FULFILLED = <span class=\"string\">'fulfilled'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">'rejected'</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>等待状态 (Pending)</p>\n<ul>\n<li>可以迁移至执行态或拒绝态<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === PENDING) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = FULFILLED || REJECTED ；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>执行状态 (Fulfilled)</p>\n<ul>\n<li>不能迁移至其他任何状态</li>\n<li>必须拥有一个不可变的终值<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.value = value;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>拒绝状态 (Rejected)</p>\n<ul>\n<li>不能迁移至其他任何状态</li>\n<li>必须拥有一个不可变的拒因<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.reason = reason;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 具有终止态的Promise的状态不能被再次改变</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promise1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  resolve(<span class=\"string\">'fulfilled!'</span>)</span><br><span class=\"line\">  reject(<span class=\"string\">'rejected!'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(promise1) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"comment\">//Promise &#123;&lt;resolved&gt;: \"fulfilled!\"&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"2\">\n<li>Then方法</li>\n</ol>\n<p>一个 promise 必须提供一个 then 方法以访问其当前值、终值和拒因。</p>\n<p>promise 的 then 方法接受两个参数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>参数可选<ul>\n<li>onFulfilled 和 onRejected 都是可选参数</li>\n<li>如果 onFulfilled 不是函数，其必须被忽略</li>\n<li>如果 onRejected 不是函数，其必须被忽略</li>\n</ul>\n</li>\n<li>onFulfilled 特性<ul>\n<li>如果 onFulfilled 是函数：</li>\n<li>当 promise 执行结束后其必须被调用，其第一个参数为 promise 的终值</li>\n<li>在 promise 执行结束前其不可被调用</li>\n<li>其调用次数不可超过一次</li>\n</ul>\n</li>\n<li>onRejected 特性<ul>\n<li>如果 onRejected 是函数：</li>\n<li>当 promise 被拒绝执行后其必须被调用，其第一个参数为 promise 的拒因</li>\n<li>在 promise 被拒绝执行前其不可被调用</li>\n<li>其调用次数不可超过一次</li>\n</ul>\n</li>\n<li>调用时机<ul>\n<li>onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用</li>\n</ul>\n</li>\n<li>调用要求<ul>\n<li>onFulfilled 和 onRejected 必须被作为函数调用（即没有 this 值）</li>\n</ul>\n</li>\n<li><p>多次调用</p>\n<ul>\n<li>then 方法可以被同一个 promise 调用多次</li>\n<li>当 promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调</li>\n<li>当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'fulfilled!'</span>)</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise1.then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'first '</span>,val)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise1.then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'second '</span>,val)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"comment\">//first  fulfilled!</span></span><br><span class=\"line\"><span class=\"comment\">//second  fulfilled!</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"简易版的实现\"><a href=\"#简易版的实现\" class=\"headerlink\" title=\"简易版的实现\"></a>简易版的实现</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Promise的三种状态</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">'pending'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> FULFILLED = <span class=\"string\">'fulfilled'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">'rejected'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AjPromise</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(fn) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//当前状态</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = PENDING</span><br><span class=\"line\">    <span class=\"comment\">//终值</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"comment\">//拒因</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.reason = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"comment\">//成功态回调队列</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onFulfilledCallbackList = []</span><br><span class=\"line\">    <span class=\"comment\">//拒绝态回调队列</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onRejectedCallbackList = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//成功态回调</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> resolve = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 使用macro-task机制(setTimeout),确保onFulfilled异步执行,且在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。</span></span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.state === PENDING) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.state = FULFILLED</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.onFulfilledCallbackList.map(<span class=\"function\"><span class=\"params\">cb</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = cb(<span class=\"keyword\">this</span>.value)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//拒绝态回调</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> reject = <span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 使用macro-task机制(setTimeout),确保onFulfilled异步执行,且在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。</span></span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === PENDING) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// pending(等待态)迁移至 fulfilled(拒绝态),保证调用次数不超过一次。</span></span><br><span class=\"line\">          <span class=\"keyword\">this</span>.state = REJECTED</span><br><span class=\"line\">          <span class=\"comment\">//拒因</span></span><br><span class=\"line\">          <span class=\"keyword\">this</span>.reason = reason</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.onRejectedCallbackList.map(<span class=\"function\"><span class=\"params\">cb</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.reason = cb(<span class=\"keyword\">this</span>.reason)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;, <span class=\"number\">0</span>)      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//执行promise</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      fn(resolve, reject)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">      reject(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  then(onFulfilled, onRejected) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> &amp;&amp; <span class=\"keyword\">this</span>.onFulfilledCallbackList.push(onFulfilled)</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">'function'</span> &amp;&amp; <span class=\"keyword\">this</span>.onRejectedCallbackList.push(onRejected)</span><br><span class=\"line\">    <span class=\"comment\">// 返回this支持then 方法可以被同一个 promise 调用多次</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> pro = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, rejecte</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'yes!'</span>)</span><br><span class=\"line\">  &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;).then(</span><br><span class=\"line\">  (value) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'1'</span>,value)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    reject(value)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;, (e) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'e1'</span>,e)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> e</span><br><span class=\"line\">  &#125;).then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'2'</span>,value)</span><br><span class=\"line\">&#125;, (e) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'e2'</span>,e)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"进一步的规范\"><a href=\"#进一步的规范\" class=\"headerlink\" title=\"进一步的规范\"></a>进一步的规范</h2><ul>\n<li><p>返回</p>\n<ul>\n<li>1.then 方法必须返回一个 promise 对象</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>2.如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：<a href=\"promise2, x\">[Resolve]</a></li>\n<li>3.如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e</li>\n<li>4.如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值</li>\n<li>5.如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因</li>\n</ul>\n</li>\n</ul>\n<p>按照以上要求来一步一步完善then方法</p>\n<ol>\n<li><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.首先,then方法必须返回一个promise对象</span></span><br><span class=\"line\">then(onFulfilled, onRejected) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newPromise;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">newPromise = <span class=\"keyword\">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;&#125;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>2.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">then(onFulfilled, onRejected) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newPromise;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">newPromise = <span class=\"keyword\">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[[Resolve]](promise2, x)</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onFulfilledCallbacks.push(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> x = onFulfilled(value);</span><br><span class=\"line\">      <span class=\"comment\">//解决过程 resolvePromise</span></span><br><span class=\"line\">      resolvePromise(newPromise, x);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onRejectedCallbacks.push(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> x = onRejected(reason);</span><br><span class=\"line\">      <span class=\"comment\">//解决过程 resolvePromise</span></span><br><span class=\"line\">      resolvePromise(newPromise, x);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 解决过程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolvePromise</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>3.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">then(onFulfilled, onRejected) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newPromise;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">newPromise = <span class=\"keyword\">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  3.如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e。</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onFulfilledCallbacks.push(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> x = onFulfilled(value);</span><br><span class=\"line\">        resolvePromise(newPromise, x);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onRejectedCallbacks.push(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> x = onRejected(reason);</span><br><span class=\"line\">        resolvePromise(newPromise, x);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>4,5.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">then(onFulfilled, onRejected) &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">let</span> newPromise;</span><br><span class=\"line\">  <span class=\"comment\">// 4.如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值。</span></span><br><span class=\"line\">  onFulfilled = <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> ? onFulfilled : <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value;</span><br><span class=\"line\">  <span class=\"comment\">// 5.如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因。</span></span><br><span class=\"line\">  onRejected =</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">'function'</span></span><br><span class=\"line\">      ? onRejected</span><br><span class=\"line\">      : <span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> reason;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">newPromise = <span class=\"keyword\">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onFulfilledCallbacks.push(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> x = onFulfilled(value);</span><br><span class=\"line\">        resolvePromise(newPromise, x);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onRejectedCallbacks.push(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> x = onRejected(reason);</span><br><span class=\"line\">        resolvePromise(newPromise, x);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>6.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">then(onFulfilled, onRejected) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newPromise;</span><br><span class=\"line\"></span><br><span class=\"line\">  onFulfilled = <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> ? onFulfilled : <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value;</span><br><span class=\"line\">  onRejected =</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">'function'</span></span><br><span class=\"line\">      ? onRejected</span><br><span class=\"line\">      : <span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> reason;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 2.2.6规范 对于一个promise，它的then方法可以调用多次.</span></span><br><span class=\"line\">  <span class=\"comment\">// 当在其他程序中多次调用同一个promise的then时 由于之前状态已经为FULFILLED / REJECTED状态，则会走以下逻辑,</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以要确保为FULFILLED / REJECTED状态后 也要异步执行onFulfilled / onRejected ,这里使用setTimeout</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 6.不论 promise1 被 reject 还是被 resolve 时 promise2 都会被 resolve，只有出现异常时才会被 rejected。</span></span><br><span class=\"line\">  <span class=\"comment\">// 由于在接下来的解决过程中需要调用resolve,reject进行处理,处理我们在调用处理过程时,传入参数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state == FULFILLED) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">newPromise = <span class=\"keyword\">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> x = onFulfilled(<span class=\"keyword\">this</span>.value);</span><br><span class=\"line\">          resolvePromise(newPromise, x, resolve, reject);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">          reject(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state == REJECTED) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">newPromise = <span class=\"keyword\">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> x = onRejected(<span class=\"keyword\">this</span>.reason);</span><br><span class=\"line\">          resolvePromise(newPromise, x, resolve, reject);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">          reject(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === PENDING) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">newPromise = <span class=\"keyword\">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.onFulfilledCallbacks.push(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> x = onFulfilled(value);</span><br><span class=\"line\">          resolvePromise(newPromise, x, resolve, reject);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">          reject(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.onRejectedCallbacks.push(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> x = onRejected(reason);</span><br><span class=\"line\">          resolvePromise(newPromise, x, resolve, reject);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">          reject(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>Promise 解决过程</li>\n</ul>\n<p>Promise 解决过程是一个抽象的操作，其需输入一个 promise 和一个值，我们表示为 <a href=\"promise, x\">[Resolve]</a>，如果 x 有 then 方法且看上去像一个 Promise ，解决程序即尝试使 promise 接受 x 的状态；否则其用 x 的值来执行 promise 。</p>\n<p>这种 thenable 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。</p>\n<p>运行 <a href=\"promise, x\">[Resolve]</a> 需遵循以下步骤：</p>\n<ol>\n<li>x 与 promise 相等</li>\n</ol>\n<ul>\n<li>如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise</li>\n</ul>\n<ol start=\"2\">\n<li>x 为 Promise</li>\n</ol>\n<ul>\n<li>如果 x 为 Promise ，则使 promise 接受 x 的状态 注4：</li>\n<li>如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝</li>\n<li>如果 x 处于执行态，用相同的值执行 promise</li>\n<li>如果 x 处于拒绝态，用相同的据因拒绝 promise</li>\n<li>x 为对象或函数</li>\n</ul>\n<ol start=\"3\">\n<li>如果 x 为对象或者函数：</li>\n</ol>\n<ul>\n<li>把 x.then 赋值给 then</li>\n<li>如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise</li>\n<li>如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise:<ul>\n<li>如果 resolvePromise 以值 y 为参数被调用，则运行 <a href=\"promise, y\">[Resolve]</a></li>\n<li>如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise</li>\n<li>如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</li>\n<li>如果调用 then 方法抛出了异常 e：<ul>\n<li>如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之</li>\n<li>否则以 e 为据因拒绝 promise</li>\n</ul>\n</li>\n<li>如果 then 不是函数，以 x 为参数执行 promise</li>\n</ul>\n</li>\n<li>如果 x 不为对象或者函数，以 x 为参数执行 promise</li>\n</ul>\n<p>如果一个 promise 被一个循环的 thenable 链中的对象解决，而 <a href=\"promise, thenable\">[Resolve]</a> 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 TypeError 为据因来拒绝 promise。</p>\n<p>加下来一步步处理不同的情况：</p>\n<ol>\n<li><p>x 与 promise 相等</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolvePromise</span>(<span class=\"params\">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//x 与 promise 相等 </span></span><br><span class=\"line\">  <span class=\"comment\">//如果从onFulfilled中返回的x 就是promise2 就会导致循环引用报错</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === promise2) &#123;</span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'循环引用'</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>x 为 Promise</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolvePromise</span>(<span class=\"params\">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === promise2) &#123;</span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'循环引用'</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// x 为 Promise</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> AjPromise) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 x 为 Promise ，则使 promise 接受 x 的状态</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x.state === PENDING) &#123;</span><br><span class=\"line\">      x.then(</span><br><span class=\"line\">        y =&gt; &#123;</span><br><span class=\"line\">          resolvePromise(promise2, y, resolve, reject);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        reason =&gt; &#123;</span><br><span class=\"line\">          reject(reason);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果 x 处于执行态，用相同的值执行 promise</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果 x 处于拒绝态，用相同的据因拒绝 promise</span></span><br><span class=\"line\">      x.then(resolve, reject);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>x 为对象或函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolvePromise</span>(<span class=\"params\">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === promise2) &#123;</span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'循环引用'</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> AjPromise) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x.state === PENDING) &#123;</span><br><span class=\"line\">      x.then(</span><br><span class=\"line\">        y =&gt; &#123;</span><br><span class=\"line\">          resolvePromise(promise2, y, resolve, reject);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        reason =&gt; &#123;</span><br><span class=\"line\">          reject(reason);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      x.then(resolve, reject);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x &amp;&amp; (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'function'</span> || <span class=\"keyword\">typeof</span> x === <span class=\"string\">'object'</span>)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 避免多次调用</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> called = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//把 x.then 赋值给 then</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> then = x.then;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> then === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 then 是函数，将 x 作为函数的作用域 this 调用之。</span></span><br><span class=\"line\">        <span class=\"comment\">// 传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</span></span><br><span class=\"line\">        then.call(</span><br><span class=\"line\">          x,</span><br><span class=\"line\">          <span class=\"comment\">// 如果 resolvePromise 以值 y 为参数被调用，则运行[[Resolve]](promise, y)</span></span><br><span class=\"line\">          y =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            called = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            resolvePromise(promise2, y, resolve, reject);</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          <span class=\"comment\">// 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise</span></span><br><span class=\"line\">          r =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            called = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            reject(r);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 then 不是函数，以 x 为参数执行 promise</span></span><br><span class=\"line\">        resolve(x);</span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果调用 then 方法抛出了异常 e：</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之</span></span><br><span class=\"line\">      <span class=\"comment\">// 否则以 e 为据因拒绝 promise</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      called = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      reject(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 x 不为对象或者函数，以 x 为参数执行 promise</span></span><br><span class=\"line\">    resolve(x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>到此，Promise的解决过程就实现了。</p>\n<h2 id=\"Promise其他静态方法\"><a href=\"#Promise其他静态方法\" class=\"headerlink\" title=\"Promise其他静态方法\"></a>Promise其他静态方法</h2><h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all\"></a>Promise.all</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Promise.all Promise进行并行处理</span></span><br><span class=\"line\"><span class=\"comment\"> * 参数: promise对象组成的数组作为参数</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回一个Promise实例</span></span><br><span class=\"line\"><span class=\"comment\"> * 当这个数组里的所有promise对象全部变为resolve状态的时候，才会resolve。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">promises</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> done = gen(promises.length, resolve);</span><br><span class=\"line\">        promises.forEach(<span class=\"function\">(<span class=\"params\">promise, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            promise.then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                done(index, value)</span><br><span class=\"line\">            &#125;, reject)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">gen</span>(<span class=\"params\">length, resolve</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> values = [];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i, value</span>) </span>&#123;</span><br><span class=\"line\">        values[i] = value;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++count === length) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(values);</span><br><span class=\"line\">            resolve(values);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Poomise-race\"><a href=\"#Poomise-race\" class=\"headerlink\" title=\"Poomise.race\"></a>Poomise.race</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Promise.race</span></span><br><span class=\"line\"><span class=\"comment\"> * 参数: 接收 promise对象组成的数组作为参数</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回一个Promise实例</span></span><br><span class=\"line\"><span class=\"comment\"> * 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理(取决于哪一个更快)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.race = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">promises</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        promises.forEach(<span class=\"function\">(<span class=\"params\">promise, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">           promise.then(resolve, reject);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"http://www.ituring.com.cn/article/66566\" target=\"_blank\" rel=\"noopener\">Promises/A+规范</a></li>\n<li><a href=\"https://www.jianshu.com/p/459a856c476f\" target=\"_blank\" rel=\"noopener\">Promise详解与实现（Promise/A+规范）</a></li>\n<li><a href=\"https://juejin.im/post/5c2b34a15188257abf1d96eb\" target=\"_blank\" rel=\"noopener\">实现一个Promise(基于Promise/A+规范)</a></li>\n<li><a href=\"https://juejin.im/post/5c41297cf265da613356d4ec\" target=\"_blank\" rel=\"noopener\">你能手写一个Promise吗？Yes I promise</a></li>\n<li><a href=\"https://juejin.im/post/5afe6d3bf265da0b9e654c4b#heading-11\" target=\"_blank\" rel=\"noopener\">Promise不会？？看这里！！！史上最通俗易懂的Promise！！！</a></li>\n<li><a href=\"https://www.kancloud.cn/kancloud/promises-book\" target=\"_blank\" rel=\"noopener\">JavaScript Promise迷你书</a></li>\n</ul>"},{"title":"TypeScript 中 const enum 和 enum 的区别","date":"2021-11-12T16:00:00.000Z","_content":"\n## const enum 编译时会把实际用到的枚举成员替换成常量值\n\n```ts\n// const-enum.ts\nconst enum Color {\n  Red,\n  Green,\n  Blue,\n}\nconsole.log(Color.Red);\n\n// output.js\nconsole.log(0 /* Red */);\n```\n\n## enum 会编译成运行时的对象\n\n```ts\n// enum.ts\nenum Color {\n  Red,\n  Green,\n  Blue,\n}\nconsole.log(Color.Red);\n\n// output.js\nvar Color;\n(function (Color) {\n  Color[(Color[\"Red\"] = 0)] = \"Red\";\n  Color[(Color[\"Green\"] = 1)] = \"Green\";\n  Color[(Color[\"Blue\"] = 2)] = \"Blue\";\n})(Color || (Color = {}));\nconsole.log(Color.Red);\n```\n\n## 不同场景下的选择\n\n- 尽可能使用 const enum，编译后代码体积较小。\n\n- 在需要动态获取值的场景下，只能使用 enum ，const enum 不能获取到值。\n\n```ts\nconst enum Color {\n  Red,\n  Green,\n  Blue,\n}\n\n// 这样可以\nconsole.log(Color.Blue);\n\n// 这样不行!!\nconst key = \"Blue\";\nconsole.log(Color[key]);\n```\n\n- 编写第三方库的时候，采用 const enum，兼容使用者不同的使用场景。\n","source":"_posts/TypeScript 中 const enum 和 enum 的区别.md","raw":"---\ntitle: TypeScript 中 const enum 和 enum 的区别\ndate: 2021-11-13\ntags: [\"typescript\"]\ncategories: [\"typescript\"]\n---\n\n## const enum 编译时会把实际用到的枚举成员替换成常量值\n\n```ts\n// const-enum.ts\nconst enum Color {\n  Red,\n  Green,\n  Blue,\n}\nconsole.log(Color.Red);\n\n// output.js\nconsole.log(0 /* Red */);\n```\n\n## enum 会编译成运行时的对象\n\n```ts\n// enum.ts\nenum Color {\n  Red,\n  Green,\n  Blue,\n}\nconsole.log(Color.Red);\n\n// output.js\nvar Color;\n(function (Color) {\n  Color[(Color[\"Red\"] = 0)] = \"Red\";\n  Color[(Color[\"Green\"] = 1)] = \"Green\";\n  Color[(Color[\"Blue\"] = 2)] = \"Blue\";\n})(Color || (Color = {}));\nconsole.log(Color.Red);\n```\n\n## 不同场景下的选择\n\n- 尽可能使用 const enum，编译后代码体积较小。\n\n- 在需要动态获取值的场景下，只能使用 enum ，const enum 不能获取到值。\n\n```ts\nconst enum Color {\n  Red,\n  Green,\n  Blue,\n}\n\n// 这样可以\nconsole.log(Color.Blue);\n\n// 这样不行!!\nconst key = \"Blue\";\nconsole.log(Color[key]);\n```\n\n- 编写第三方库的时候，采用 const enum，兼容使用者不同的使用场景。\n","slug":"TypeScript 中 const enum 和 enum 的区别","published":1,"updated":"2022-04-14T02:28:50.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfei0006g3t8ddga11rv","content":"<h2 id=\"const-enum-编译时会把实际用到的枚举成员替换成常量值\"><a href=\"#const-enum-编译时会把实际用到的枚举成员替换成常量值\" class=\"headerlink\" title=\"const enum 编译时会把实际用到的枚举成员替换成常量值\"></a>const enum 编译时会把实际用到的枚举成员替换成常量值</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// const-enum.ts</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> Color &#123;</span><br><span class=\"line\">  Red,</span><br><span class=\"line\">  Green,</span><br><span class=\"line\">  Blue,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Color.Red);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output.js</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">0</span> <span class=\"comment\">/* Red */</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"enum-会编译成运行时的对象\"><a href=\"#enum-会编译成运行时的对象\" class=\"headerlink\" title=\"enum 会编译成运行时的对象\"></a>enum 会编译成运行时的对象</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// enum.ts</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;</span><br><span class=\"line\">  Red,</span><br><span class=\"line\">  Green,</span><br><span class=\"line\">  Blue,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Color.Red);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Color;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Color</span>) </span>&#123;</span><br><span class=\"line\">  Color[(Color[<span class=\"string\">\"Red\"</span>] = <span class=\"number\">0</span>)] = <span class=\"string\">\"Red\"</span>;</span><br><span class=\"line\">  Color[(Color[<span class=\"string\">\"Green\"</span>] = <span class=\"number\">1</span>)] = <span class=\"string\">\"Green\"</span>;</span><br><span class=\"line\">  Color[(Color[<span class=\"string\">\"Blue\"</span>] = <span class=\"number\">2</span>)] = <span class=\"string\">\"Blue\"</span>;</span><br><span class=\"line\">&#125;)(Color || (Color = &#123;&#125;));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Color.Red);</span><br></pre></td></tr></table></figure>\n<h2 id=\"不同场景下的选择\"><a href=\"#不同场景下的选择\" class=\"headerlink\" title=\"不同场景下的选择\"></a>不同场景下的选择</h2><ul>\n<li><p>尽可能使用 const enum，编译后代码体积较小。</p>\n</li>\n<li><p>在需要动态获取值的场景下，只能使用 enum ，const enum 不能获取到值。</p>\n</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> Color &#123;</span><br><span class=\"line\">  Red,</span><br><span class=\"line\">  Green,</span><br><span class=\"line\">  Blue,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这样可以</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Color.Blue);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这样不行!!</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> key = <span class=\"string\">\"Blue\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Color[key]);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>编写第三方库的时候，采用 const enum，兼容使用者不同的使用场景。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"const-enum-编译时会把实际用到的枚举成员替换成常量值\"><a href=\"#const-enum-编译时会把实际用到的枚举成员替换成常量值\" class=\"headerlink\" title=\"const enum 编译时会把实际用到的枚举成员替换成常量值\"></a>const enum 编译时会把实际用到的枚举成员替换成常量值</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// const-enum.ts</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> Color &#123;</span><br><span class=\"line\">  Red,</span><br><span class=\"line\">  Green,</span><br><span class=\"line\">  Blue,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Color.Red);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output.js</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">0</span> <span class=\"comment\">/* Red */</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"enum-会编译成运行时的对象\"><a href=\"#enum-会编译成运行时的对象\" class=\"headerlink\" title=\"enum 会编译成运行时的对象\"></a>enum 会编译成运行时的对象</h2><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// enum.ts</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;</span><br><span class=\"line\">  Red,</span><br><span class=\"line\">  Green,</span><br><span class=\"line\">  Blue,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Color.Red);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Color;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Color</span>) </span>&#123;</span><br><span class=\"line\">  Color[(Color[<span class=\"string\">\"Red\"</span>] = <span class=\"number\">0</span>)] = <span class=\"string\">\"Red\"</span>;</span><br><span class=\"line\">  Color[(Color[<span class=\"string\">\"Green\"</span>] = <span class=\"number\">1</span>)] = <span class=\"string\">\"Green\"</span>;</span><br><span class=\"line\">  Color[(Color[<span class=\"string\">\"Blue\"</span>] = <span class=\"number\">2</span>)] = <span class=\"string\">\"Blue\"</span>;</span><br><span class=\"line\">&#125;)(Color || (Color = &#123;&#125;));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Color.Red);</span><br></pre></td></tr></table></figure>\n<h2 id=\"不同场景下的选择\"><a href=\"#不同场景下的选择\" class=\"headerlink\" title=\"不同场景下的选择\"></a>不同场景下的选择</h2><ul>\n<li><p>尽可能使用 const enum，编译后代码体积较小。</p>\n</li>\n<li><p>在需要动态获取值的场景下，只能使用 enum ，const enum 不能获取到值。</p>\n</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> Color &#123;</span><br><span class=\"line\">  Red,</span><br><span class=\"line\">  Green,</span><br><span class=\"line\">  Blue,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这样可以</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Color.Blue);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这样不行!!</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> key = <span class=\"string\">\"Blue\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Color[key]);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>编写第三方库的时候，采用 const enum，兼容使用者不同的使用场景。</li>\n</ul>\n"},{"title":"ES6 module 中使用 export default 的缺点","date":"2019-05-17T16:00:00.000Z","_content":"\n# 使用 export default 的缺点\n\n# https://blog.neufund.org/why-we-have-banned-default-exports-and-you-should-do-the-same-d51fdc2cf2ad\n\n## 更好的编辑器提示\n\n使用 export default 不导出任何具体的名称。相反的，如果给导出的值指定具体的名称，可以使 IDE 可以自动查找和导入依赖项，这极大地提高了生产率。\n\n## 更利于重构\n\nexport default 使大规模重构变得非常困难，因为每个引用的地方都可以对默认导入进行不同的命名，不利于维护。\n\n## 更利于摇树\n\n导出一个具有很多属性的对象，这是一种反模式，显然不利于摇树。\n\n```javascript\n// do not try this\nexport default {\n  propertyA: \"A\",\n  propertyB: \"B\",\n};\n// do this instead\nexport const propertyA = \"A\";\nexport const propertyB = \"B\";\n```\n\n当引用者不使用所有导出的值时，使用命名的导出可以减小包的大小（在构建库时特别有用）。\n","source":"_posts/banner export default.md","raw":"---\ntitle: ES6 module 中使用 export default 的缺点\ndate: 2019-05-18\ntags: [\"es6\"]\ncategories: [\"javascript\"]\n---\n\n# 使用 export default 的缺点\n\n# https://blog.neufund.org/why-we-have-banned-default-exports-and-you-should-do-the-same-d51fdc2cf2ad\n\n## 更好的编辑器提示\n\n使用 export default 不导出任何具体的名称。相反的，如果给导出的值指定具体的名称，可以使 IDE 可以自动查找和导入依赖项，这极大地提高了生产率。\n\n## 更利于重构\n\nexport default 使大规模重构变得非常困难，因为每个引用的地方都可以对默认导入进行不同的命名，不利于维护。\n\n## 更利于摇树\n\n导出一个具有很多属性的对象，这是一种反模式，显然不利于摇树。\n\n```javascript\n// do not try this\nexport default {\n  propertyA: \"A\",\n  propertyB: \"B\",\n};\n// do this instead\nexport const propertyA = \"A\";\nexport const propertyB = \"B\";\n```\n\n当引用者不使用所有导出的值时，使用命名的导出可以减小包的大小（在构建库时特别有用）。\n","slug":"banner export default","published":1,"updated":"2022-04-14T02:26:28.599Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfek0009g3t8omdj43pr","content":"<h1 id=\"使用-export-default-的缺点\"><a href=\"#使用-export-default-的缺点\" class=\"headerlink\" title=\"使用 export default 的缺点\"></a>使用 export default 的缺点</h1><h1 id=\"https-blog-neufund-org-why-we-have-banned-default-exports-and-you-should-do-the-same-d51fdc2cf2ad\"><a href=\"#https-blog-neufund-org-why-we-have-banned-default-exports-and-you-should-do-the-same-d51fdc2cf2ad\" class=\"headerlink\" title=\"https://blog.neufund.org/why-we-have-banned-default-exports-and-you-should-do-the-same-d51fdc2cf2ad\"></a><a href=\"https://blog.neufund.org/why-we-have-banned-default-exports-and-you-should-do-the-same-d51fdc2cf2ad\" target=\"_blank\" rel=\"noopener\">https://blog.neufund.org/why-we-have-banned-default-exports-and-you-should-do-the-same-d51fdc2cf2ad</a></h1><h2 id=\"更好的编辑器提示\"><a href=\"#更好的编辑器提示\" class=\"headerlink\" title=\"更好的编辑器提示\"></a>更好的编辑器提示</h2><p>使用 export default 不导出任何具体的名称。相反的，如果给导出的值指定具体的名称，可以使 IDE 可以自动查找和导入依赖项，这极大地提高了生产率。</p>\n<h2 id=\"更利于重构\"><a href=\"#更利于重构\" class=\"headerlink\" title=\"更利于重构\"></a>更利于重构</h2><p>export default 使大规模重构变得非常困难，因为每个引用的地方都可以对默认导入进行不同的命名，不利于维护。</p>\n<h2 id=\"更利于摇树\"><a href=\"#更利于摇树\" class=\"headerlink\" title=\"更利于摇树\"></a>更利于摇树</h2><p>导出一个具有很多属性的对象，这是一种反模式，显然不利于摇树。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// do not try this</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  propertyA: <span class=\"string\">\"A\"</span>,</span><br><span class=\"line\">  propertyB: <span class=\"string\">\"B\"</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// do this instead</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> propertyA = <span class=\"string\">\"A\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> propertyB = <span class=\"string\">\"B\"</span>;</span><br></pre></td></tr></table></figure>\n<p>当引用者不使用所有导出的值时，使用命名的导出可以减小包的大小（在构建库时特别有用）。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用-export-default-的缺点\"><a href=\"#使用-export-default-的缺点\" class=\"headerlink\" title=\"使用 export default 的缺点\"></a>使用 export default 的缺点</h1><h1 id=\"https-blog-neufund-org-why-we-have-banned-default-exports-and-you-should-do-the-same-d51fdc2cf2ad\"><a href=\"#https-blog-neufund-org-why-we-have-banned-default-exports-and-you-should-do-the-same-d51fdc2cf2ad\" class=\"headerlink\" title=\"https://blog.neufund.org/why-we-have-banned-default-exports-and-you-should-do-the-same-d51fdc2cf2ad\"></a><a href=\"https://blog.neufund.org/why-we-have-banned-default-exports-and-you-should-do-the-same-d51fdc2cf2ad\" target=\"_blank\" rel=\"noopener\">https://blog.neufund.org/why-we-have-banned-default-exports-and-you-should-do-the-same-d51fdc2cf2ad</a></h1><h2 id=\"更好的编辑器提示\"><a href=\"#更好的编辑器提示\" class=\"headerlink\" title=\"更好的编辑器提示\"></a>更好的编辑器提示</h2><p>使用 export default 不导出任何具体的名称。相反的，如果给导出的值指定具体的名称，可以使 IDE 可以自动查找和导入依赖项，这极大地提高了生产率。</p>\n<h2 id=\"更利于重构\"><a href=\"#更利于重构\" class=\"headerlink\" title=\"更利于重构\"></a>更利于重构</h2><p>export default 使大规模重构变得非常困难，因为每个引用的地方都可以对默认导入进行不同的命名，不利于维护。</p>\n<h2 id=\"更利于摇树\"><a href=\"#更利于摇树\" class=\"headerlink\" title=\"更利于摇树\"></a>更利于摇树</h2><p>导出一个具有很多属性的对象，这是一种反模式，显然不利于摇树。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// do not try this</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  propertyA: <span class=\"string\">\"A\"</span>,</span><br><span class=\"line\">  propertyB: <span class=\"string\">\"B\"</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// do this instead</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> propertyA = <span class=\"string\">\"A\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> propertyB = <span class=\"string\">\"B\"</span>;</span><br></pre></td></tr></table></figure>\n<p>当引用者不使用所有导出的值时，使用命名的导出可以减小包的大小（在构建库时特别有用）。</p>\n"},{"title":"吸顶效果常用实现代码","date":"2020-01-20T16:00:00.000Z","_content":"\n## 吸顶效果常用实现代码\n\n## 原理：通过监听吸顶元素的滚动位置来切换样式。\n\n## 代码\n\n```javascript\nconst el = this.$refs.card;\nconst offsetTop = el && el.getBoundingClientRect().top;\nconst elHeight = el && el.clientHeight;\nif (-offsetTop > elHeight) {\n  this.isTabsStick = true;\n} else {\n  this.isTabsStick = false;\n}\n```\n","source":"_posts/fix top code.md","raw":"---\ntitle: 吸顶效果常用实现代码\ndate: 2020-01-21\ntags: [\"吸顶\"]\ncategories: [\"\"]\n---\n\n## 吸顶效果常用实现代码\n\n## 原理：通过监听吸顶元素的滚动位置来切换样式。\n\n## 代码\n\n```javascript\nconst el = this.$refs.card;\nconst offsetTop = el && el.getBoundingClientRect().top;\nconst elHeight = el && el.clientHeight;\nif (-offsetTop > elHeight) {\n  this.isTabsStick = true;\n} else {\n  this.isTabsStick = false;\n}\n```\n","slug":"fix top code","published":1,"updated":"2022-04-14T02:27:09.592Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfel000ag3t8puqk0v3o","content":"<h2 id=\"吸顶效果常用实现代码\"><a href=\"#吸顶效果常用实现代码\" class=\"headerlink\" title=\"吸顶效果常用实现代码\"></a>吸顶效果常用实现代码</h2><h2 id=\"原理：通过监听吸顶元素的滚动位置来切换样式。\"><a href=\"#原理：通过监听吸顶元素的滚动位置来切换样式。\" class=\"headerlink\" title=\"原理：通过监听吸顶元素的滚动位置来切换样式。\"></a>原理：通过监听吸顶元素的滚动位置来切换样式。</h2><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> el = <span class=\"keyword\">this</span>.$refs.card;</span><br><span class=\"line\"><span class=\"keyword\">const</span> offsetTop = el &amp;&amp; el.getBoundingClientRect().top;</span><br><span class=\"line\"><span class=\"keyword\">const</span> elHeight = el &amp;&amp; el.clientHeight;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (-offsetTop &gt; elHeight) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.isTabsStick = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.isTabsStick = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"吸顶效果常用实现代码\"><a href=\"#吸顶效果常用实现代码\" class=\"headerlink\" title=\"吸顶效果常用实现代码\"></a>吸顶效果常用实现代码</h2><h2 id=\"原理：通过监听吸顶元素的滚动位置来切换样式。\"><a href=\"#原理：通过监听吸顶元素的滚动位置来切换样式。\" class=\"headerlink\" title=\"原理：通过监听吸顶元素的滚动位置来切换样式。\"></a>原理：通过监听吸顶元素的滚动位置来切换样式。</h2><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> el = <span class=\"keyword\">this</span>.$refs.card;</span><br><span class=\"line\"><span class=\"keyword\">const</span> offsetTop = el &amp;&amp; el.getBoundingClientRect().top;</span><br><span class=\"line\"><span class=\"keyword\">const</span> elHeight = el &amp;&amp; el.clientHeight;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (-offsetTop &gt; elHeight) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.isTabsStick = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.isTabsStick = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"FormData笔记","date":"2017-05-05T16:00:00.000Z","_content":"之前项目里需要用到传很多参数的表单提交，原生的表单提交过程可控性差，又不想手动拼接很长的参数，于是决定学习和使用FormData进行替代。\n<!--more-->\n# 概念\nXMLHttpRequest Level 2添加了一个新的接口FormData.利用FormData对象,我们可以通过JavaScript用一些键值对来模拟一系列表单控件,我们还可以使用XMLHttpRequest的send()方法来异步的提交这个\"表单\".比起普通的ajax,使用FormData的最大优点就是我们可以异步上传一个二进制文件。\n#基本使用\n1. 使用new FormData()插件一个FormData对象，调用append()添加字段。\n````javascript\nvar formData = new FormData();\n\nformData.append(\"username\", \"Groucho\");\nformData.append(\"accountnum\", 123456); // 数字 123456 会被立即转换成字符串 \"123456\"\n\n// HTML 文件类型input，由用户选择\nformData.append(\"userfile\", fileInputElement.files[0]);\n\n// JavaScript file-like 对象\nvar content = '<a id=\"a\"><b id=\"b\">hey!</b></a>'; // 新文件的正文...\nvar blob = new Blob([content], { type: \"text/xml\"});\n\nformData.append(\"webmasterfile\", blob);\n\nvar request = new XMLHttpRequest();\nrequest.open(\"POST\", \"http://foo.com/submitform.php\");\nrequest.send(formData);\n````\n2. 构造一个包含Form表单数据的FormData对象，需要在创建FormData对象时传入指定表单的元素\n```javascript\nvar formElement = document.querySelector(\"form\");\nvar formData = new FormData(formElement);\nvar request = new XMLHttpRequest();\nrequest.open(\"POST\", \"submitform.php\");\nformData.append(\"serialnumber\", serialNumber++);\nrequest.send(formData);\n````\n3. 常用api\n* append() 用于添加一个新值到 FormData 对象内的一个已存在的键中，如果键不存在则会添加该键。\n* delete() 用于从 FormData 对象中删除指定 key 和它对应的 value(s)。\n* entries() 用于返回一个 iterator对象 ，此对象可以遍历访问FormData中的键值对。其中键值对的key是一个 USVString 对象；value是一个 USVString , 或者 Blob对象。\n# 配合axios使用\n之前项目是使用axios进行http请求，FormData配合axios使用，请求方法和请求头配置为\n````javascript\naxios.post(url, params, {\n    method: 'post',\n    headers: { 'Content-Type': 'multipart/form-data' }\n})\n````\n# 参考资料\n[https://developer.mozilla.org/zh-CN/docs/Web/API/FormData](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData)\n","source":"_posts/FormData笔记.md","raw":"---\ntitle: FormData笔记\ndate: 2017-05-06\ntags: ['FormData']\ncategories: ['笔记']\n---\n之前项目里需要用到传很多参数的表单提交，原生的表单提交过程可控性差，又不想手动拼接很长的参数，于是决定学习和使用FormData进行替代。\n<!--more-->\n# 概念\nXMLHttpRequest Level 2添加了一个新的接口FormData.利用FormData对象,我们可以通过JavaScript用一些键值对来模拟一系列表单控件,我们还可以使用XMLHttpRequest的send()方法来异步的提交这个\"表单\".比起普通的ajax,使用FormData的最大优点就是我们可以异步上传一个二进制文件。\n#基本使用\n1. 使用new FormData()插件一个FormData对象，调用append()添加字段。\n````javascript\nvar formData = new FormData();\n\nformData.append(\"username\", \"Groucho\");\nformData.append(\"accountnum\", 123456); // 数字 123456 会被立即转换成字符串 \"123456\"\n\n// HTML 文件类型input，由用户选择\nformData.append(\"userfile\", fileInputElement.files[0]);\n\n// JavaScript file-like 对象\nvar content = '<a id=\"a\"><b id=\"b\">hey!</b></a>'; // 新文件的正文...\nvar blob = new Blob([content], { type: \"text/xml\"});\n\nformData.append(\"webmasterfile\", blob);\n\nvar request = new XMLHttpRequest();\nrequest.open(\"POST\", \"http://foo.com/submitform.php\");\nrequest.send(formData);\n````\n2. 构造一个包含Form表单数据的FormData对象，需要在创建FormData对象时传入指定表单的元素\n```javascript\nvar formElement = document.querySelector(\"form\");\nvar formData = new FormData(formElement);\nvar request = new XMLHttpRequest();\nrequest.open(\"POST\", \"submitform.php\");\nformData.append(\"serialnumber\", serialNumber++);\nrequest.send(formData);\n````\n3. 常用api\n* append() 用于添加一个新值到 FormData 对象内的一个已存在的键中，如果键不存在则会添加该键。\n* delete() 用于从 FormData 对象中删除指定 key 和它对应的 value(s)。\n* entries() 用于返回一个 iterator对象 ，此对象可以遍历访问FormData中的键值对。其中键值对的key是一个 USVString 对象；value是一个 USVString , 或者 Blob对象。\n# 配合axios使用\n之前项目是使用axios进行http请求，FormData配合axios使用，请求方法和请求头配置为\n````javascript\naxios.post(url, params, {\n    method: 'post',\n    headers: { 'Content-Type': 'multipart/form-data' }\n})\n````\n# 参考资料\n[https://developer.mozilla.org/zh-CN/docs/Web/API/FormData](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData)\n","slug":"FormData笔记","published":1,"updated":"2022-04-13T14:14:07.639Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfen000eg3t8w0b4ync6","content":"<p>之前项目里需要用到传很多参数的表单提交，原生的表单提交过程可控性差，又不想手动拼接很长的参数，于是决定学习和使用FormData进行替代。<br><a id=\"more\"></a></p>\n<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><p>XMLHttpRequest Level 2添加了一个新的接口FormData.利用FormData对象,我们可以通过JavaScript用一些键值对来模拟一系列表单控件,我们还可以使用XMLHttpRequest的send()方法来异步的提交这个”表单”.比起普通的ajax,使用FormData的最大优点就是我们可以异步上传一个二进制文件。</p>\n<p>#基本使用</p>\n<ol>\n<li><p>使用new FormData()插件一个FormData对象，调用append()添加字段。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> formData = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\"></span><br><span class=\"line\">formData.append(<span class=\"string\">\"username\"</span>, <span class=\"string\">\"Groucho\"</span>);</span><br><span class=\"line\">formData.append(<span class=\"string\">\"accountnum\"</span>, <span class=\"number\">123456</span>); <span class=\"comment\">// 数字 123456 会被立即转换成字符串 \"123456\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// HTML 文件类型input，由用户选择</span></span><br><span class=\"line\">formData.append(<span class=\"string\">\"userfile\"</span>, fileInputElement.files[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// JavaScript file-like 对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> content = <span class=\"string\">'&lt;a id=\"a\"&gt;&lt;b id=\"b\"&gt;hey!&lt;/b&gt;&lt;/a&gt;'</span>; <span class=\"comment\">// 新文件的正文...</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> Blob([content], &#123; <span class=\"attr\">type</span>: <span class=\"string\">\"text/xml\"</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">formData.append(<span class=\"string\">\"webmasterfile\"</span>, blob);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">request.open(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"http://foo.com/submitform.php\"</span>);</span><br><span class=\"line\">request.send(formData);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>构造一个包含Form表单数据的FormData对象，需要在创建FormData对象时传入指定表单的元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> formElement = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"form\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> formData = <span class=\"keyword\">new</span> FormData(formElement);</span><br><span class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">request.open(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"submitform.php\"</span>);</span><br><span class=\"line\">formData.append(<span class=\"string\">\"serialnumber\"</span>, serialNumber++);</span><br><span class=\"line\">request.send(formData);</span><br><span class=\"line\"><span class=\"string\">`</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>常用api</p>\n</li>\n</ol>\n<ul>\n<li>append() 用于添加一个新值到 FormData 对象内的一个已存在的键中，如果键不存在则会添加该键。</li>\n<li>delete() 用于从 FormData 对象中删除指定 key 和它对应的 value(s)。</li>\n<li>entries() 用于返回一个 iterator对象 ，此对象可以遍历访问FormData中的键值对。其中键值对的key是一个 USVString 对象；value是一个 USVString , 或者 Blob对象。<h1 id=\"配合axios使用\"><a href=\"#配合axios使用\" class=\"headerlink\" title=\"配合axios使用\"></a>配合axios使用</h1>之前项目是使用axios进行http请求，FormData配合axios使用，请求方法和请求头配置为<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.post(url, params, &#123;</span><br><span class=\"line\">    method: <span class=\"string\">'post'</span>,</span><br><span class=\"line\">    headers: &#123; <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'multipart/form-data'</span> &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FormData\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/API/FormData</a></p>\n","site":{"data":{}},"excerpt":"<p>之前项目里需要用到传很多参数的表单提交，原生的表单提交过程可控性差，又不想手动拼接很长的参数，于是决定学习和使用FormData进行替代。<br>","more":"</p>\n<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><p>XMLHttpRequest Level 2添加了一个新的接口FormData.利用FormData对象,我们可以通过JavaScript用一些键值对来模拟一系列表单控件,我们还可以使用XMLHttpRequest的send()方法来异步的提交这个”表单”.比起普通的ajax,使用FormData的最大优点就是我们可以异步上传一个二进制文件。</p>\n<p>#基本使用</p>\n<ol>\n<li><p>使用new FormData()插件一个FormData对象，调用append()添加字段。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> formData = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\"></span><br><span class=\"line\">formData.append(<span class=\"string\">\"username\"</span>, <span class=\"string\">\"Groucho\"</span>);</span><br><span class=\"line\">formData.append(<span class=\"string\">\"accountnum\"</span>, <span class=\"number\">123456</span>); <span class=\"comment\">// 数字 123456 会被立即转换成字符串 \"123456\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// HTML 文件类型input，由用户选择</span></span><br><span class=\"line\">formData.append(<span class=\"string\">\"userfile\"</span>, fileInputElement.files[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// JavaScript file-like 对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> content = <span class=\"string\">'&lt;a id=\"a\"&gt;&lt;b id=\"b\"&gt;hey!&lt;/b&gt;&lt;/a&gt;'</span>; <span class=\"comment\">// 新文件的正文...</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> Blob([content], &#123; <span class=\"attr\">type</span>: <span class=\"string\">\"text/xml\"</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">formData.append(<span class=\"string\">\"webmasterfile\"</span>, blob);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">request.open(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"http://foo.com/submitform.php\"</span>);</span><br><span class=\"line\">request.send(formData);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>构造一个包含Form表单数据的FormData对象，需要在创建FormData对象时传入指定表单的元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> formElement = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"form\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> formData = <span class=\"keyword\">new</span> FormData(formElement);</span><br><span class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">request.open(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"submitform.php\"</span>);</span><br><span class=\"line\">formData.append(<span class=\"string\">\"serialnumber\"</span>, serialNumber++);</span><br><span class=\"line\">request.send(formData);</span><br><span class=\"line\"><span class=\"string\">`</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>常用api</p>\n</li>\n</ol>\n<ul>\n<li>append() 用于添加一个新值到 FormData 对象内的一个已存在的键中，如果键不存在则会添加该键。</li>\n<li>delete() 用于从 FormData 对象中删除指定 key 和它对应的 value(s)。</li>\n<li>entries() 用于返回一个 iterator对象 ，此对象可以遍历访问FormData中的键值对。其中键值对的key是一个 USVString 对象；value是一个 USVString , 或者 Blob对象。<h1 id=\"配合axios使用\"><a href=\"#配合axios使用\" class=\"headerlink\" title=\"配合axios使用\"></a>配合axios使用</h1>之前项目是使用axios进行http请求，FormData配合axios使用，请求方法和请求头配置为<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.post(url, params, &#123;</span><br><span class=\"line\">    method: <span class=\"string\">'post'</span>,</span><br><span class=\"line\">    headers: &#123; <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'multipart/form-data'</span> &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FormData\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/API/FormData</a></p>"},{"title":"babel常用配置记录","date":"2017-08-26T16:00:00.000Z","_content":"## 简介\nbabel是一个javascript语法的编译器，借助babel，我们可以使用新的javascript语法和api，编译成低版本的javascript语法，能被低版本的浏览器识别，解决浏览器的兼容性问题。\n<!--more-->\n## 使用\n使用babel主要是学会babel的配置,并安装相应插件,告诉babel我们需要编译成哪个版本的javascript。\n\nbabel的配置就是对presets和plugins进行配置，这样babel才能按照我们预想的进行工作。\n### presets\n预设，是预先设定好一系列转换标准的配置，可以当做是一系列插件（plugins）的集合。\n#### 官方preset\n1. env \n\nbabel-preset-env是根据你所支持的环境，依据[compat-table](https://github.com/kangax/compat-table)自动确定您需要的Babel插件。\n\n默认设置是会编译所有的ES2015+的新特性，行为和babel-preset-latest一样。\n\n常用设置项：\n* targets: { [string]: number }，默认{} \n\n设置需要支持的环境版本，例如chrome, opera, edge, firefox, safari, ie, ios, android, node, electron。\n\n推荐写上特定的版本号，如node: \"6.10\"。\n\n* targets.node: number | string | \"current\" | true\n\n设置node环境的版本\n\n* targets.browsers: Array<string> | string\n\n设置支持符合相应条件的浏览器集合，使用[browserslist](https://github.com/ai/browserslist),如\n````javascript\n{\n  \"browserslist\": [\n    \"> 1%\",\n    \"last 2 versions\"\n  ]\n}\n````\n其余配置项参考[babel-preset-env](https://babeljs.io/docs/plugins/preset-env/)\n\n2. es2015\n\n将es2015编译成es5。这个preset主要是包含了一系列转换es2015方法的插件\n> check-es2015-constants\n>\n> transform-es2015-arrow-functions\n>\n> transform-es2015-block-scoped-functions\n>\n> transform-es2015-block-scoping\n>\n> transform-es2015-classes\n>\n> transform-es2015-computed-properties\n>\n> transform-es2015-destructuring\n>\n> transform-es2015-duplicate-keys\n>\n> transform-es2015-for-of\n>\n> transform-es2015-function-name\n>\n> transform-es2015-literals\n>\n> transform-es2015-modules-commonjs\n>\n> transform-es2015-object-super\n>\n> transform-es2015-parameters\n>\n> transform-es2015-shorthand-properties\n>\n> transform-es2015-spread\n>\n> transform-es2015-sticky-regex\n>\n> transform-es2015-template-literals\n>\n> transform-es2015-typeof-symbol\n>\n> transform-es2015-unicode-regex\n>\n> transform-regenerator\n\n常用设置项：\n* modules: \"amd\" | \"umd\" | \"systemjs\" | \"commonjs\" | false, defaults to \"commonjs\".\n3. es2016\n\n将es2016编译成es5\n4. es2017\n\n将es2017编译成es5\n5. Latest preset\n\n包含最新的preset，包括了es2015，es2016，es2017的预设。\n\n已经被移除，使用preset-env代替。\n6. react\n专门对react推出的预设，包含：\n\npreset-flow\n\nsyntax-jsx\n\ntransform-react-jsx\n\ntransform-react-display-name\n7. Flow preset\n包含transform-flow-strip-types插件，用来转换javascript静态类型检查(flow语法)。\n####　Stage-X (试验性预设)\nStage-X预设是用来转换那些未被批准，未发布Javascript的语言特性。\n\nStage-X是按照javascript的语法提案阶段区分的。\n\nTC39（Technical Committee 39）是一个推动JavaScript发展的委员会。每一项新特性，要最终纳入ECMAScript规范中，TC39拟定了一个处理过程，称为TC39 process。\n\n其中共包含5个阶段，Stage 0 ~ Stage 4。\n* Stage 0: strawman\n\n一种推进ECMAScript发展的自由形式，任何TC39成员，或者注册为TC39贡献者的会员，都可以提交。\n\n* Stage 1: proposal\n\n该阶段产生一个正式的提案。\n\n* Stage 2: draft\n\n草案是规范的第一个版本，与最终标准中包含的特性不会有太大差别。\n\n* Stage 3: candidate\n\n候选阶段，获得具体实现和用户的反馈。\n\n* Stage 4: finished\n\n已经准备就绪，该特性会出现在年度发布的规范之中。\n\n可以看到Stage-0包含的范围是最广的，一般使用选择babel-preset-stage-2。\n### plugins\n插件，专门针对某一个语法或某个单一功能的转换。\n[插件列表](https://babeljs.io/docs/plugins/#transform-plugins)\n#### 常用插件\n* babel-plugin-transform-es2015-classes\n\n用于转换ES2015的类到ES5。\n\n* babel-plugin-transform-es2015-spread\n\n转换ES2015的扩展运算符。\n\n* babel-plugin-transform-react-jsx\n\n转换jsx语法\n\n* babel-plugin-transform-runtime\n\ntransform-runtime提供包含编译模块的工具函数。\n\nbabel在转换 ES2015 语法为 ES 5 的语法时，babel需要一些辅助函数，例如 _extend。babel默认会将这些辅助函数直接插入到每一个 js 文件里，这样文件多的时候，重复的辅助函数多，项目重复代码就很多。\n\n所以 babel 提供了 transform-runtime 来将这些辅助函数都引入到一个单独的模块 babel-runtime 中，避免重复的代码。\n\nBabel 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。如果想使用这些新的对象和方法，必须使用 babel-polyfill，为当前环境提供一个垫片。\n\n像 Promise 这样的全局对象会污染全局命名空间，这就要求库的使用者自己提供 polyfill。这些 polyfill 一般在库和工具的使用说明中会提到，比如很多库都会有要求提供 es5 的 polyfill。在使用 babel-runtime 后，库和工具只要在 package.json 中增加依赖 babel-runtime，交给 babel-runtime 去引入 polyfill 就行了，所以使用transform-runtime另一个作用是为你的代码提供一个沙盒环境。\n\n常用设置项：\n\nhelpers：boolean, defaults to true.\n\n是否引入Babel的helpers函数。\n\npolyfill：boolean, defaults to true.\n\n是否使用不会污染全局的polyfill。\n\n非实例方法的polyfill，如Object.assign，但是实例方法不支持，如\"foobar\".includes(\"foo\")，这时候需要单独引入babel-polyfill\n## 执行顺序\n* 插件在预设之前执行。\n* 插件的执行顺序是从前往后。\n* 预设的执行顺序是从后往前。\n## 参考资料\n[transform-runtime](https://babeljs.io/docs/plugins/transform-runtime)\n[https://segmentfault.com/q/1010000005596587](https://segmentfault.com/q/1010000005596587)\n[https://www.vanadis.cn/2017/04/28/difference-between-babel-polyfill-and-babel-runtime/](https://www.vanadis.cn/2017/04/28/difference-between-babel-polyfill-and-babel-runtime/)\n","source":"_posts/babel常用配置记录.md","raw":"---\ntitle: babel常用配置记录\ndate: 2017-08-27\ntags: ['babel']\ncategories: ['笔记']\n---\n## 简介\nbabel是一个javascript语法的编译器，借助babel，我们可以使用新的javascript语法和api，编译成低版本的javascript语法，能被低版本的浏览器识别，解决浏览器的兼容性问题。\n<!--more-->\n## 使用\n使用babel主要是学会babel的配置,并安装相应插件,告诉babel我们需要编译成哪个版本的javascript。\n\nbabel的配置就是对presets和plugins进行配置，这样babel才能按照我们预想的进行工作。\n### presets\n预设，是预先设定好一系列转换标准的配置，可以当做是一系列插件（plugins）的集合。\n#### 官方preset\n1. env \n\nbabel-preset-env是根据你所支持的环境，依据[compat-table](https://github.com/kangax/compat-table)自动确定您需要的Babel插件。\n\n默认设置是会编译所有的ES2015+的新特性，行为和babel-preset-latest一样。\n\n常用设置项：\n* targets: { [string]: number }，默认{} \n\n设置需要支持的环境版本，例如chrome, opera, edge, firefox, safari, ie, ios, android, node, electron。\n\n推荐写上特定的版本号，如node: \"6.10\"。\n\n* targets.node: number | string | \"current\" | true\n\n设置node环境的版本\n\n* targets.browsers: Array<string> | string\n\n设置支持符合相应条件的浏览器集合，使用[browserslist](https://github.com/ai/browserslist),如\n````javascript\n{\n  \"browserslist\": [\n    \"> 1%\",\n    \"last 2 versions\"\n  ]\n}\n````\n其余配置项参考[babel-preset-env](https://babeljs.io/docs/plugins/preset-env/)\n\n2. es2015\n\n将es2015编译成es5。这个preset主要是包含了一系列转换es2015方法的插件\n> check-es2015-constants\n>\n> transform-es2015-arrow-functions\n>\n> transform-es2015-block-scoped-functions\n>\n> transform-es2015-block-scoping\n>\n> transform-es2015-classes\n>\n> transform-es2015-computed-properties\n>\n> transform-es2015-destructuring\n>\n> transform-es2015-duplicate-keys\n>\n> transform-es2015-for-of\n>\n> transform-es2015-function-name\n>\n> transform-es2015-literals\n>\n> transform-es2015-modules-commonjs\n>\n> transform-es2015-object-super\n>\n> transform-es2015-parameters\n>\n> transform-es2015-shorthand-properties\n>\n> transform-es2015-spread\n>\n> transform-es2015-sticky-regex\n>\n> transform-es2015-template-literals\n>\n> transform-es2015-typeof-symbol\n>\n> transform-es2015-unicode-regex\n>\n> transform-regenerator\n\n常用设置项：\n* modules: \"amd\" | \"umd\" | \"systemjs\" | \"commonjs\" | false, defaults to \"commonjs\".\n3. es2016\n\n将es2016编译成es5\n4. es2017\n\n将es2017编译成es5\n5. Latest preset\n\n包含最新的preset，包括了es2015，es2016，es2017的预设。\n\n已经被移除，使用preset-env代替。\n6. react\n专门对react推出的预设，包含：\n\npreset-flow\n\nsyntax-jsx\n\ntransform-react-jsx\n\ntransform-react-display-name\n7. Flow preset\n包含transform-flow-strip-types插件，用来转换javascript静态类型检查(flow语法)。\n####　Stage-X (试验性预设)\nStage-X预设是用来转换那些未被批准，未发布Javascript的语言特性。\n\nStage-X是按照javascript的语法提案阶段区分的。\n\nTC39（Technical Committee 39）是一个推动JavaScript发展的委员会。每一项新特性，要最终纳入ECMAScript规范中，TC39拟定了一个处理过程，称为TC39 process。\n\n其中共包含5个阶段，Stage 0 ~ Stage 4。\n* Stage 0: strawman\n\n一种推进ECMAScript发展的自由形式，任何TC39成员，或者注册为TC39贡献者的会员，都可以提交。\n\n* Stage 1: proposal\n\n该阶段产生一个正式的提案。\n\n* Stage 2: draft\n\n草案是规范的第一个版本，与最终标准中包含的特性不会有太大差别。\n\n* Stage 3: candidate\n\n候选阶段，获得具体实现和用户的反馈。\n\n* Stage 4: finished\n\n已经准备就绪，该特性会出现在年度发布的规范之中。\n\n可以看到Stage-0包含的范围是最广的，一般使用选择babel-preset-stage-2。\n### plugins\n插件，专门针对某一个语法或某个单一功能的转换。\n[插件列表](https://babeljs.io/docs/plugins/#transform-plugins)\n#### 常用插件\n* babel-plugin-transform-es2015-classes\n\n用于转换ES2015的类到ES5。\n\n* babel-plugin-transform-es2015-spread\n\n转换ES2015的扩展运算符。\n\n* babel-plugin-transform-react-jsx\n\n转换jsx语法\n\n* babel-plugin-transform-runtime\n\ntransform-runtime提供包含编译模块的工具函数。\n\nbabel在转换 ES2015 语法为 ES 5 的语法时，babel需要一些辅助函数，例如 _extend。babel默认会将这些辅助函数直接插入到每一个 js 文件里，这样文件多的时候，重复的辅助函数多，项目重复代码就很多。\n\n所以 babel 提供了 transform-runtime 来将这些辅助函数都引入到一个单独的模块 babel-runtime 中，避免重复的代码。\n\nBabel 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。如果想使用这些新的对象和方法，必须使用 babel-polyfill，为当前环境提供一个垫片。\n\n像 Promise 这样的全局对象会污染全局命名空间，这就要求库的使用者自己提供 polyfill。这些 polyfill 一般在库和工具的使用说明中会提到，比如很多库都会有要求提供 es5 的 polyfill。在使用 babel-runtime 后，库和工具只要在 package.json 中增加依赖 babel-runtime，交给 babel-runtime 去引入 polyfill 就行了，所以使用transform-runtime另一个作用是为你的代码提供一个沙盒环境。\n\n常用设置项：\n\nhelpers：boolean, defaults to true.\n\n是否引入Babel的helpers函数。\n\npolyfill：boolean, defaults to true.\n\n是否使用不会污染全局的polyfill。\n\n非实例方法的polyfill，如Object.assign，但是实例方法不支持，如\"foobar\".includes(\"foo\")，这时候需要单独引入babel-polyfill\n## 执行顺序\n* 插件在预设之前执行。\n* 插件的执行顺序是从前往后。\n* 预设的执行顺序是从后往前。\n## 参考资料\n[transform-runtime](https://babeljs.io/docs/plugins/transform-runtime)\n[https://segmentfault.com/q/1010000005596587](https://segmentfault.com/q/1010000005596587)\n[https://www.vanadis.cn/2017/04/28/difference-between-babel-polyfill-and-babel-runtime/](https://www.vanadis.cn/2017/04/28/difference-between-babel-polyfill-and-babel-runtime/)\n","slug":"babel常用配置记录","published":1,"updated":"2022-04-13T14:14:07.764Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvff40014g3t8o88y6nzt","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>babel是一个javascript语法的编译器，借助babel，我们可以使用新的javascript语法和api，编译成低版本的javascript语法，能被低版本的浏览器识别，解决浏览器的兼容性问题。<br><a id=\"more\"></a></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>使用babel主要是学会babel的配置,并安装相应插件,告诉babel我们需要编译成哪个版本的javascript。</p>\n<p>babel的配置就是对presets和plugins进行配置，这样babel才能按照我们预想的进行工作。</p>\n<h3 id=\"presets\"><a href=\"#presets\" class=\"headerlink\" title=\"presets\"></a>presets</h3><p>预设，是预先设定好一系列转换标准的配置，可以当做是一系列插件（plugins）的集合。</p>\n<h4 id=\"官方preset\"><a href=\"#官方preset\" class=\"headerlink\" title=\"官方preset\"></a>官方preset</h4><ol>\n<li>env </li>\n</ol>\n<p>babel-preset-env是根据你所支持的环境，依据<a href=\"https://github.com/kangax/compat-table\" target=\"_blank\" rel=\"noopener\">compat-table</a>自动确定您需要的Babel插件。</p>\n<p>默认设置是会编译所有的ES2015+的新特性，行为和babel-preset-latest一样。</p>\n<p>常用设置项：</p>\n<ul>\n<li>targets: { [string]: number }，默认{} </li>\n</ul>\n<p>设置需要支持的环境版本，例如chrome, opera, edge, firefox, safari, ie, ios, android, node, electron。</p>\n<p>推荐写上特定的版本号，如node: “6.10”。</p>\n<ul>\n<li>targets.node: number | string | “current” | true</li>\n</ul>\n<p>设置node环境的版本</p>\n<ul>\n<li>targets.browsers: Array<string> | string</string></li>\n</ul>\n<p>设置支持符合相应条件的浏览器集合，使用<a href=\"https://github.com/ai/browserslist\" target=\"_blank\" rel=\"noopener\">browserslist</a>,如<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"browserslist\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"&gt; 1%\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"last 2 versions\"</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其余配置项参考<a href=\"https://babeljs.io/docs/plugins/preset-env/\" target=\"_blank\" rel=\"noopener\">babel-preset-env</a></p>\n<ol start=\"2\">\n<li>es2015</li>\n</ol>\n<p>将es2015编译成es5。这个preset主要是包含了一系列转换es2015方法的插件</p>\n<blockquote>\n<p>check-es2015-constants</p>\n<p>transform-es2015-arrow-functions</p>\n<p>transform-es2015-block-scoped-functions</p>\n<p>transform-es2015-block-scoping</p>\n<p>transform-es2015-classes</p>\n<p>transform-es2015-computed-properties</p>\n<p>transform-es2015-destructuring</p>\n<p>transform-es2015-duplicate-keys</p>\n<p>transform-es2015-for-of</p>\n<p>transform-es2015-function-name</p>\n<p>transform-es2015-literals</p>\n<p>transform-es2015-modules-commonjs</p>\n<p>transform-es2015-object-super</p>\n<p>transform-es2015-parameters</p>\n<p>transform-es2015-shorthand-properties</p>\n<p>transform-es2015-spread</p>\n<p>transform-es2015-sticky-regex</p>\n<p>transform-es2015-template-literals</p>\n<p>transform-es2015-typeof-symbol</p>\n<p>transform-es2015-unicode-regex</p>\n<p>transform-regenerator</p>\n</blockquote>\n<p>常用设置项：</p>\n<ul>\n<li>modules: “amd” | “umd” | “systemjs” | “commonjs” | false, defaults to “commonjs”.</li>\n</ul>\n<ol start=\"3\">\n<li>es2016</li>\n</ol>\n<p>将es2016编译成es5</p>\n<ol start=\"4\">\n<li>es2017</li>\n</ol>\n<p>将es2017编译成es5</p>\n<ol start=\"5\">\n<li>Latest preset</li>\n</ol>\n<p>包含最新的preset，包括了es2015，es2016，es2017的预设。</p>\n<p>已经被移除，使用preset-env代替。</p>\n<ol start=\"6\">\n<li>react<br>专门对react推出的预设，包含：</li>\n</ol>\n<p>preset-flow</p>\n<p>syntax-jsx</p>\n<p>transform-react-jsx</p>\n<p>transform-react-display-name</p>\n<ol start=\"7\">\n<li>Flow preset<br>包含transform-flow-strip-types插件，用来转换javascript静态类型检查(flow语法)。<br>####　Stage-X (试验性预设)<br>Stage-X预设是用来转换那些未被批准，未发布Javascript的语言特性。</li>\n</ol>\n<p>Stage-X是按照javascript的语法提案阶段区分的。</p>\n<p>TC39（Technical Committee 39）是一个推动JavaScript发展的委员会。每一项新特性，要最终纳入ECMAScript规范中，TC39拟定了一个处理过程，称为TC39 process。</p>\n<p>其中共包含5个阶段，Stage 0 ~ Stage 4。</p>\n<ul>\n<li>Stage 0: strawman</li>\n</ul>\n<p>一种推进ECMAScript发展的自由形式，任何TC39成员，或者注册为TC39贡献者的会员，都可以提交。</p>\n<ul>\n<li>Stage 1: proposal</li>\n</ul>\n<p>该阶段产生一个正式的提案。</p>\n<ul>\n<li>Stage 2: draft</li>\n</ul>\n<p>草案是规范的第一个版本，与最终标准中包含的特性不会有太大差别。</p>\n<ul>\n<li>Stage 3: candidate</li>\n</ul>\n<p>候选阶段，获得具体实现和用户的反馈。</p>\n<ul>\n<li>Stage 4: finished</li>\n</ul>\n<p>已经准备就绪，该特性会出现在年度发布的规范之中。</p>\n<p>可以看到Stage-0包含的范围是最广的，一般使用选择babel-preset-stage-2。</p>\n<h3 id=\"plugins\"><a href=\"#plugins\" class=\"headerlink\" title=\"plugins\"></a>plugins</h3><p>插件，专门针对某一个语法或某个单一功能的转换。<br><a href=\"https://babeljs.io/docs/plugins/#transform-plugins\" target=\"_blank\" rel=\"noopener\">插件列表</a></p>\n<h4 id=\"常用插件\"><a href=\"#常用插件\" class=\"headerlink\" title=\"常用插件\"></a>常用插件</h4><ul>\n<li>babel-plugin-transform-es2015-classes</li>\n</ul>\n<p>用于转换ES2015的类到ES5。</p>\n<ul>\n<li>babel-plugin-transform-es2015-spread</li>\n</ul>\n<p>转换ES2015的扩展运算符。</p>\n<ul>\n<li>babel-plugin-transform-react-jsx</li>\n</ul>\n<p>转换jsx语法</p>\n<ul>\n<li>babel-plugin-transform-runtime</li>\n</ul>\n<p>transform-runtime提供包含编译模块的工具函数。</p>\n<p>babel在转换 ES2015 语法为 ES 5 的语法时，babel需要一些辅助函数，例如 _extend。babel默认会将这些辅助函数直接插入到每一个 js 文件里，这样文件多的时候，重复的辅助函数多，项目重复代码就很多。</p>\n<p>所以 babel 提供了 transform-runtime 来将这些辅助函数都引入到一个单独的模块 babel-runtime 中，避免重复的代码。</p>\n<p>Babel 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。如果想使用这些新的对象和方法，必须使用 babel-polyfill，为当前环境提供一个垫片。</p>\n<p>像 Promise 这样的全局对象会污染全局命名空间，这就要求库的使用者自己提供 polyfill。这些 polyfill 一般在库和工具的使用说明中会提到，比如很多库都会有要求提供 es5 的 polyfill。在使用 babel-runtime 后，库和工具只要在 package.json 中增加依赖 babel-runtime，交给 babel-runtime 去引入 polyfill 就行了，所以使用transform-runtime另一个作用是为你的代码提供一个沙盒环境。</p>\n<p>常用设置项：</p>\n<p>helpers：boolean, defaults to true.</p>\n<p>是否引入Babel的helpers函数。</p>\n<p>polyfill：boolean, defaults to true.</p>\n<p>是否使用不会污染全局的polyfill。</p>\n<p>非实例方法的polyfill，如Object.assign，但是实例方法不支持，如”foobar”.includes(“foo”)，这时候需要单独引入babel-polyfill</p>\n<h2 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h2><ul>\n<li>插件在预设之前执行。</li>\n<li>插件的执行顺序是从前往后。</li>\n<li>预设的执行顺序是从后往前。<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><a href=\"https://babeljs.io/docs/plugins/transform-runtime\" target=\"_blank\" rel=\"noopener\">transform-runtime</a><br><a href=\"https://segmentfault.com/q/1010000005596587\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/q/1010000005596587</a><br><a href=\"https://www.vanadis.cn/2017/04/28/difference-between-babel-polyfill-and-babel-runtime/\" target=\"_blank\" rel=\"noopener\">https://www.vanadis.cn/2017/04/28/difference-between-babel-polyfill-and-babel-runtime/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>babel是一个javascript语法的编译器，借助babel，我们可以使用新的javascript语法和api，编译成低版本的javascript语法，能被低版本的浏览器识别，解决浏览器的兼容性问题。<br>","more":"</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>使用babel主要是学会babel的配置,并安装相应插件,告诉babel我们需要编译成哪个版本的javascript。</p>\n<p>babel的配置就是对presets和plugins进行配置，这样babel才能按照我们预想的进行工作。</p>\n<h3 id=\"presets\"><a href=\"#presets\" class=\"headerlink\" title=\"presets\"></a>presets</h3><p>预设，是预先设定好一系列转换标准的配置，可以当做是一系列插件（plugins）的集合。</p>\n<h4 id=\"官方preset\"><a href=\"#官方preset\" class=\"headerlink\" title=\"官方preset\"></a>官方preset</h4><ol>\n<li>env </li>\n</ol>\n<p>babel-preset-env是根据你所支持的环境，依据<a href=\"https://github.com/kangax/compat-table\" target=\"_blank\" rel=\"noopener\">compat-table</a>自动确定您需要的Babel插件。</p>\n<p>默认设置是会编译所有的ES2015+的新特性，行为和babel-preset-latest一样。</p>\n<p>常用设置项：</p>\n<ul>\n<li>targets: { [string]: number }，默认{} </li>\n</ul>\n<p>设置需要支持的环境版本，例如chrome, opera, edge, firefox, safari, ie, ios, android, node, electron。</p>\n<p>推荐写上特定的版本号，如node: “6.10”。</p>\n<ul>\n<li>targets.node: number | string | “current” | true</li>\n</ul>\n<p>设置node环境的版本</p>\n<ul>\n<li>targets.browsers: Array<string> | string</string></li>\n</ul>\n<p>设置支持符合相应条件的浏览器集合，使用<a href=\"https://github.com/ai/browserslist\" target=\"_blank\" rel=\"noopener\">browserslist</a>,如<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"browserslist\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"&gt; 1%\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"last 2 versions\"</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其余配置项参考<a href=\"https://babeljs.io/docs/plugins/preset-env/\" target=\"_blank\" rel=\"noopener\">babel-preset-env</a></p>\n<ol start=\"2\">\n<li>es2015</li>\n</ol>\n<p>将es2015编译成es5。这个preset主要是包含了一系列转换es2015方法的插件</p>\n<blockquote>\n<p>check-es2015-constants</p>\n<p>transform-es2015-arrow-functions</p>\n<p>transform-es2015-block-scoped-functions</p>\n<p>transform-es2015-block-scoping</p>\n<p>transform-es2015-classes</p>\n<p>transform-es2015-computed-properties</p>\n<p>transform-es2015-destructuring</p>\n<p>transform-es2015-duplicate-keys</p>\n<p>transform-es2015-for-of</p>\n<p>transform-es2015-function-name</p>\n<p>transform-es2015-literals</p>\n<p>transform-es2015-modules-commonjs</p>\n<p>transform-es2015-object-super</p>\n<p>transform-es2015-parameters</p>\n<p>transform-es2015-shorthand-properties</p>\n<p>transform-es2015-spread</p>\n<p>transform-es2015-sticky-regex</p>\n<p>transform-es2015-template-literals</p>\n<p>transform-es2015-typeof-symbol</p>\n<p>transform-es2015-unicode-regex</p>\n<p>transform-regenerator</p>\n</blockquote>\n<p>常用设置项：</p>\n<ul>\n<li>modules: “amd” | “umd” | “systemjs” | “commonjs” | false, defaults to “commonjs”.</li>\n</ul>\n<ol start=\"3\">\n<li>es2016</li>\n</ol>\n<p>将es2016编译成es5</p>\n<ol start=\"4\">\n<li>es2017</li>\n</ol>\n<p>将es2017编译成es5</p>\n<ol start=\"5\">\n<li>Latest preset</li>\n</ol>\n<p>包含最新的preset，包括了es2015，es2016，es2017的预设。</p>\n<p>已经被移除，使用preset-env代替。</p>\n<ol start=\"6\">\n<li>react<br>专门对react推出的预设，包含：</li>\n</ol>\n<p>preset-flow</p>\n<p>syntax-jsx</p>\n<p>transform-react-jsx</p>\n<p>transform-react-display-name</p>\n<ol start=\"7\">\n<li>Flow preset<br>包含transform-flow-strip-types插件，用来转换javascript静态类型检查(flow语法)。<br>####　Stage-X (试验性预设)<br>Stage-X预设是用来转换那些未被批准，未发布Javascript的语言特性。</li>\n</ol>\n<p>Stage-X是按照javascript的语法提案阶段区分的。</p>\n<p>TC39（Technical Committee 39）是一个推动JavaScript发展的委员会。每一项新特性，要最终纳入ECMAScript规范中，TC39拟定了一个处理过程，称为TC39 process。</p>\n<p>其中共包含5个阶段，Stage 0 ~ Stage 4。</p>\n<ul>\n<li>Stage 0: strawman</li>\n</ul>\n<p>一种推进ECMAScript发展的自由形式，任何TC39成员，或者注册为TC39贡献者的会员，都可以提交。</p>\n<ul>\n<li>Stage 1: proposal</li>\n</ul>\n<p>该阶段产生一个正式的提案。</p>\n<ul>\n<li>Stage 2: draft</li>\n</ul>\n<p>草案是规范的第一个版本，与最终标准中包含的特性不会有太大差别。</p>\n<ul>\n<li>Stage 3: candidate</li>\n</ul>\n<p>候选阶段，获得具体实现和用户的反馈。</p>\n<ul>\n<li>Stage 4: finished</li>\n</ul>\n<p>已经准备就绪，该特性会出现在年度发布的规范之中。</p>\n<p>可以看到Stage-0包含的范围是最广的，一般使用选择babel-preset-stage-2。</p>\n<h3 id=\"plugins\"><a href=\"#plugins\" class=\"headerlink\" title=\"plugins\"></a>plugins</h3><p>插件，专门针对某一个语法或某个单一功能的转换。<br><a href=\"https://babeljs.io/docs/plugins/#transform-plugins\" target=\"_blank\" rel=\"noopener\">插件列表</a></p>\n<h4 id=\"常用插件\"><a href=\"#常用插件\" class=\"headerlink\" title=\"常用插件\"></a>常用插件</h4><ul>\n<li>babel-plugin-transform-es2015-classes</li>\n</ul>\n<p>用于转换ES2015的类到ES5。</p>\n<ul>\n<li>babel-plugin-transform-es2015-spread</li>\n</ul>\n<p>转换ES2015的扩展运算符。</p>\n<ul>\n<li>babel-plugin-transform-react-jsx</li>\n</ul>\n<p>转换jsx语法</p>\n<ul>\n<li>babel-plugin-transform-runtime</li>\n</ul>\n<p>transform-runtime提供包含编译模块的工具函数。</p>\n<p>babel在转换 ES2015 语法为 ES 5 的语法时，babel需要一些辅助函数，例如 _extend。babel默认会将这些辅助函数直接插入到每一个 js 文件里，这样文件多的时候，重复的辅助函数多，项目重复代码就很多。</p>\n<p>所以 babel 提供了 transform-runtime 来将这些辅助函数都引入到一个单独的模块 babel-runtime 中，避免重复的代码。</p>\n<p>Babel 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。如果想使用这些新的对象和方法，必须使用 babel-polyfill，为当前环境提供一个垫片。</p>\n<p>像 Promise 这样的全局对象会污染全局命名空间，这就要求库的使用者自己提供 polyfill。这些 polyfill 一般在库和工具的使用说明中会提到，比如很多库都会有要求提供 es5 的 polyfill。在使用 babel-runtime 后，库和工具只要在 package.json 中增加依赖 babel-runtime，交给 babel-runtime 去引入 polyfill 就行了，所以使用transform-runtime另一个作用是为你的代码提供一个沙盒环境。</p>\n<p>常用设置项：</p>\n<p>helpers：boolean, defaults to true.</p>\n<p>是否引入Babel的helpers函数。</p>\n<p>polyfill：boolean, defaults to true.</p>\n<p>是否使用不会污染全局的polyfill。</p>\n<p>非实例方法的polyfill，如Object.assign，但是实例方法不支持，如”foobar”.includes(“foo”)，这时候需要单独引入babel-polyfill</p>\n<h2 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h2><ul>\n<li>插件在预设之前执行。</li>\n<li>插件的执行顺序是从前往后。</li>\n<li>预设的执行顺序是从后往前。<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><a href=\"https://babeljs.io/docs/plugins/transform-runtime\" target=\"_blank\" rel=\"noopener\">transform-runtime</a><br><a href=\"https://segmentfault.com/q/1010000005596587\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/q/1010000005596587</a><br><a href=\"https://www.vanadis.cn/2017/04/28/difference-between-babel-polyfill-and-babel-runtime/\" target=\"_blank\" rel=\"noopener\">https://www.vanadis.cn/2017/04/28/difference-between-babel-polyfill-and-babel-runtime/</a></li>\n</ul>"},{"title":"Git Proxy","date":"2017-07-15T16:00:00.000Z","_content":"## git设置代理\n### http代理\n````bash\ngit config --global https.proxy http://127.0.0.1:1080\n\ngit config --global https.proxy https://127.0.0.1:1080\n\n#取消代理\ngit config --global --unset http.proxy\n\ngit config --global --unset https.proxy\n````\n<!--more-->\n#### 针对github的代理\n````bash\n#只对github.com进行代理\ngit config --global http.https://github.com.proxy socks5://127.0.0.1:1080\n\n#取消代理\ngit config --global --unset http.https://github.com.proxy\n````\n### ssh代理\n对于使用git@协议的，可以配置socks5代理\n在~/.ssh/config 文件后面添加几行，没有可以新建一个\n````bash\nHost github.com\nProxyCommand nc -X 5 -x 127.0.0.1:1080 %h %p\n````\n* windows下\n\n因为这个bash是不带netcat的，也就找到不到nc命令。\n在win10上，有的msysgit版本集成了connect工具，所以在windows上，可以把ssh的config文件设置为：\n````bash\nHost github.com\nProxyCommand connect -S 127.0.0.1:1080 %h %p\n````\n### 参考资料\n[git 设置和取消代理](https://gist.github.com/laispace/666dd7b27e9116faece6)\n\n[Tutorial: how to use git through a proxy](http://cms-sw.github.io/tutorial-proxy.html)\n\n[GitConfigHttpProxy](https://gist.github.com/evantoli/f8c23a37eb3558ab8765)\n\n","source":"_posts/git proxy.md","raw":"---\ntitle: Git Proxy\ndate: 2017-07-16\ntags: ['git', 'proxy']\ncategories: ['git']\n---\n## git设置代理\n### http代理\n````bash\ngit config --global https.proxy http://127.0.0.1:1080\n\ngit config --global https.proxy https://127.0.0.1:1080\n\n#取消代理\ngit config --global --unset http.proxy\n\ngit config --global --unset https.proxy\n````\n<!--more-->\n#### 针对github的代理\n````bash\n#只对github.com进行代理\ngit config --global http.https://github.com.proxy socks5://127.0.0.1:1080\n\n#取消代理\ngit config --global --unset http.https://github.com.proxy\n````\n### ssh代理\n对于使用git@协议的，可以配置socks5代理\n在~/.ssh/config 文件后面添加几行，没有可以新建一个\n````bash\nHost github.com\nProxyCommand nc -X 5 -x 127.0.0.1:1080 %h %p\n````\n* windows下\n\n因为这个bash是不带netcat的，也就找到不到nc命令。\n在win10上，有的msysgit版本集成了connect工具，所以在windows上，可以把ssh的config文件设置为：\n````bash\nHost github.com\nProxyCommand connect -S 127.0.0.1:1080 %h %p\n````\n### 参考资料\n[git 设置和取消代理](https://gist.github.com/laispace/666dd7b27e9116faece6)\n\n[Tutorial: how to use git through a proxy](http://cms-sw.github.io/tutorial-proxy.html)\n\n[GitConfigHttpProxy](https://gist.github.com/evantoli/f8c23a37eb3558ab8765)\n\n","slug":"git proxy","published":1,"updated":"2022-04-13T14:14:07.769Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvff50016g3t8hqrtefkr","content":"<h2 id=\"git设置代理\"><a href=\"#git设置代理\" class=\"headerlink\" title=\"git设置代理\"></a>git设置代理</h2><h3 id=\"http代理\"><a href=\"#http代理\" class=\"headerlink\" title=\"http代理\"></a>http代理</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global https.proxy http://127.0.0.1:1080</span><br><span class=\"line\"></span><br><span class=\"line\">git config --global https.proxy https://127.0.0.1:1080</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#取消代理</span></span><br><span class=\"line\">git config --global --<span class=\"built_in\">unset</span> http.proxy</span><br><span class=\"line\"></span><br><span class=\"line\">git config --global --<span class=\"built_in\">unset</span> https.proxy</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h4 id=\"针对github的代理\"><a href=\"#针对github的代理\" class=\"headerlink\" title=\"针对github的代理\"></a>针对github的代理</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#只对github.com进行代理</span></span><br><span class=\"line\">git config --global http.https://github.com.proxy socks5://127.0.0.1:1080</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#取消代理</span></span><br><span class=\"line\">git config --global --<span class=\"built_in\">unset</span> http.https://github.com.proxy</span><br></pre></td></tr></table></figure>\n<h3 id=\"ssh代理\"><a href=\"#ssh代理\" class=\"headerlink\" title=\"ssh代理\"></a>ssh代理</h3><p>对于使用git@协议的，可以配置socks5代理<br>在~/.ssh/config 文件后面添加几行，没有可以新建一个<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host github.com</span><br><span class=\"line\">ProxyCommand nc -X 5 -x 127.0.0.1:1080 %h %p</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>windows下</li>\n</ul>\n<p>因为这个bash是不带netcat的，也就找到不到nc命令。<br>在win10上，有的msysgit版本集成了connect工具，所以在windows上，可以把ssh的config文件设置为：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host github.com</span><br><span class=\"line\">ProxyCommand connect -S 127.0.0.1:1080 %h %p</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://gist.github.com/laispace/666dd7b27e9116faece6\" target=\"_blank\" rel=\"noopener\">git 设置和取消代理</a></p>\n<p><a href=\"http://cms-sw.github.io/tutorial-proxy.html\" target=\"_blank\" rel=\"noopener\">Tutorial: how to use git through a proxy</a></p>\n<p><a href=\"https://gist.github.com/evantoli/f8c23a37eb3558ab8765\" target=\"_blank\" rel=\"noopener\">GitConfigHttpProxy</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"git设置代理\"><a href=\"#git设置代理\" class=\"headerlink\" title=\"git设置代理\"></a>git设置代理</h2><h3 id=\"http代理\"><a href=\"#http代理\" class=\"headerlink\" title=\"http代理\"></a>http代理</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global https.proxy http://127.0.0.1:1080</span><br><span class=\"line\"></span><br><span class=\"line\">git config --global https.proxy https://127.0.0.1:1080</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#取消代理</span></span><br><span class=\"line\">git config --global --<span class=\"built_in\">unset</span> http.proxy</span><br><span class=\"line\"></span><br><span class=\"line\">git config --global --<span class=\"built_in\">unset</span> https.proxy</span><br></pre></td></tr></table></figure>","more":"<h4 id=\"针对github的代理\"><a href=\"#针对github的代理\" class=\"headerlink\" title=\"针对github的代理\"></a>针对github的代理</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#只对github.com进行代理</span></span><br><span class=\"line\">git config --global http.https://github.com.proxy socks5://127.0.0.1:1080</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#取消代理</span></span><br><span class=\"line\">git config --global --<span class=\"built_in\">unset</span> http.https://github.com.proxy</span><br></pre></td></tr></table></figure>\n<h3 id=\"ssh代理\"><a href=\"#ssh代理\" class=\"headerlink\" title=\"ssh代理\"></a>ssh代理</h3><p>对于使用git@协议的，可以配置socks5代理<br>在~/.ssh/config 文件后面添加几行，没有可以新建一个<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host github.com</span><br><span class=\"line\">ProxyCommand nc -X 5 -x 127.0.0.1:1080 %h %p</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>windows下</li>\n</ul>\n<p>因为这个bash是不带netcat的，也就找到不到nc命令。<br>在win10上，有的msysgit版本集成了connect工具，所以在windows上，可以把ssh的config文件设置为：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host github.com</span><br><span class=\"line\">ProxyCommand connect -S 127.0.0.1:1080 %h %p</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://gist.github.com/laispace/666dd7b27e9116faece6\" target=\"_blank\" rel=\"noopener\">git 设置和取消代理</a></p>\n<p><a href=\"http://cms-sw.github.io/tutorial-proxy.html\" target=\"_blank\" rel=\"noopener\">Tutorial: how to use git through a proxy</a></p>\n<p><a href=\"https://gist.github.com/evantoli/f8c23a37eb3558ab8765\" target=\"_blank\" rel=\"noopener\">GitConfigHttpProxy</a></p>"},{"title":"React高阶组件的原理与应用","date":"2018-09-21T16:00:00.000Z","_content":"## 什么是高阶组件\n* 高阶函数\n\n如果一个函数 接受一个或多个函数作为参数或者返回一个函数 就可称之为 高阶函数。\n<!--more-->\n* 高阶组件\n\n如果一个函数 接受一个或多个组件作为参数并且返回一个组件 就可称之为 高阶组件。\n\n当高阶组件中返回的组件是 无状态组件（Stateless Component） 时，该高阶组件其实就是一个 高阶函数，因为 无状态组件 本身就是一个纯函数。\n## 高阶组件的实现\n**React 中的高阶组件主要有两种形式：属性代理 和 反向继承。**\n### 属性代理（Props Proxy）\n一个函数接受一个 WrappedComponent 组件作为参数传入，并返回一个继承了 React.Component 组件的类，且在该类的 render() 方法中返回被传入的 WrappedComponent 组件。\n\n此时，能对 render() 方法里的 WrappedComponent 组件进行一些处理：\n* 操作 props\n````javascript\nfunction HigherOrderComponent(WrappedComponent) {\n  return class extends React.Component {\n    render() {\n      const newProps = {\n        value: 'defalut'\n      };\n      return <WrappedComponent {...this.props} {...newProps} />;\n    }\n  };\n}\n````\n* 抽离 state\n利用 props 和回调函数把 state 抽离出来：\n\n````javascript\nfunction withOnChange(WrappedComponent) {\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        value: '',\n      };\n    }\n    onChange = (value) => {\n      this.setState({\n        value\n      });\n    }\n    render() {\n      const newProps = {\n        value: this.state.value,\n        onChange: this.onChange,\n      };\n      return <WrappedComponent {...this.props} {...newProps} />;\n    }\n  };\n}\n````\n* 通过 ref 访问到组件实例\n\n在需要访问 DOM element （使用第三方 DOM 操作库）的时候就会用到组件的 ref 属性。它只能声明在 Class 类型的组件上，而无法声明在函数（无状态）类型的组件上。\n\n不能在无状态组件（函数类型组件）上使用 ref 属性，因为无状态组件没有实例。\nref 的值可以是字符串（不推荐使用）也可以是一个回调函数，如果是回调函数的话，它的执行时机是：\n\n* 组件被挂载后（componentDidMount），回调函数立即执行，回调函数的参数为该组件的实例。\n* 组件被卸载（componentDidUnmount）或者原有的 ref 属性本身发生变化的时候，此时回调函数也会立即执行，且回调函数的参数为 null。\n\n````javascript\nfunction HigherOrderComponent(WrappedComponent) {\n  return class extends React.Component {\n    executeInstanceMethod = (wrappedComponentInstance) => {\n      wrappedComponentInstance.someMethod();\n    }\n    render() {\n      return <WrappedComponent {...this.props} ref={this.executeInstanceMethod} />;\n    }\n  };\n}\n````\n* 用其他元素包裹传入的组件 WrappedComponent\n\n给 WrappedComponent 组件包一层背景色为 #fafafa 的 div 元素：\n\n````javascript\nfunction withBackgroundColor(WrappedComponent) {\n  return class extends React.Component {\n    render() {\n      return (\n        <div style={{ backgroundColor: '#fafafa' }}>\n            <WrappedComponent {...this.props} />\n        </div>\n      );\n    }\n  };\n}\n````\n### 反向继承（Inheritance Inversion）\n一个函数接受一个 WrappedComponent 组件作为参数传入，并返回一个继承了该传入 WrappedComponent 组件的类，且在该类的 render() 方法中返回 super.render() 方法。\n\n作用：\n* 操作 state\n\n高阶组件中可以读取、编辑和删除 WrappedComponent 组件实例中的 state。甚至可以增加更多的 state 项，但是 非常不建议这么做 因为这可能会导致 state 难以维护及管理。\n\n````javascript\nfunction withLogging(WrappedComponent) {\n  return class extends WrappedComponent {\n    render() {\n      return (\n        <div>\n          <h2>Debugger Component Logging...</h2>\n          <p>state:</p>\n          <pre>{JSON.stringify(this.state, null, 4)}</pre>\n          <p>props:</p>\n          <pre>{JSON.stringify(this.props, null, 4)}</pre>\n          {super.render()}\n        </div>\n      );\n    }\n  };\n}\n````\n* 渲染劫持（Render Highjacking）\n\n渲染劫持 是因为高阶组件控制着 WrappedComponent 组件的渲染输出，通过渲染劫持我们可以：\n\n* 有条件地展示元素树（element tree）\n* 操作由 render() 输出的 React 元素树\n* 在任何由 render() 输出的 React 元素中操作 props\n* 用其他元素包裹传入的组件 WrappedComponent （同 属性代理）\n\n````javascript\nfunction withLoading(WrappedComponent) {\n    return class extends WrappedComponent {\n        render() {\n            if(this.props.isLoading) {\n                return <Loading />;\n            } else {\n                return super.render();\n            }\n        }\n    };\n}\n````\n\n````javascript\nfunction HigherOrderComponent(WrappedComponent) {\n    return class extends WrappedComponent {\n        render() {\n            const tree = super.render();\n            const newProps = {};\n            if (tree && tree.type === 'input') {\n                newProps.value = 'something here';\n            }\n            const props = {\n                ...tree.props,\n                ...newProps,\n            };\n            const newTree = React.cloneElement(tree, props, tree.props.children);\n            return newTree;\n        }\n    };\n}\n````\n## 高阶组件存在的问题\n* 静态方法丢失\n因为原始组件被包裹于一个容器组件内，也就意味着新组件会没有原始组件的任何静态方法。\n\n须将静态方法做拷贝：\n````javascript\nfunction HigherOrderComponent(WrappedComponent) {\n  class Enhance extends React.Component {}\n  // 必须得知道要拷贝的方法\n  Enhance.staticMethod = WrappedComponent.staticMethod;\n  return Enhance;\n}\n````\n借助库 hoist-non-react-statics 来自动处理，它会 自动拷贝所有非 React 的静态方法。\n````javascript\nimport hoistNonReactStatic from 'hoist-non-react-statics';\n\nfunction HigherOrderComponent(WrappedComponent) {\n  class Enhance extends React.Component {}\n  hoistNonReactStatic(Enhance, WrappedComponent);\n  return Enhance;\n}\n````\n* refs 属性不能透传\n高阶组件可以传递所有的 props 给包裹的组件 WrappedComponent，但是有一种属性不能传递，它就是 ref。与其他属性不同的地方在于 React 对其进行了特殊的处理。\n\n如果你向一个由高阶组件创建的组件的元素添加 ref 引用，那么 ref 指向的是最外层容器组件实例的，而不是被包裹的 WrappedComponent 组件。\n\nReact 为我们提供了一个名为 React.forwardRef 的 API 来解决这一问题（在 React 16.3 版本中被添加）：\n````javascript\nfunction withLogging(WrappedComponent) {\n  class Enhance extends WrappedComponent {\n    componentWillReceiveProps() {\n      console.log('Current props', this.props);\n      console.log('Next props', nextProps);\n    }\n    render() {\n      const {forwardedRef, ...rest} = this.props;\n      // 把 forwardedRef 赋值给 ref\n      return <WrappedComponent {...rest} ref={forwardedRef} />;\n    }\n  };\n\n  // React.forwardRef 方法会传入 props 和 ref 两个参数给其回调函数\n  // 所以这边的 ref 是由 React.forwardRef 提供的\n  function forwardRef(props, ref) {\n    return <Enhance {...props} forwardRef={ref} />\n  }\n\n  return React.forwardRef(forwardRef);\n}\nconst EnhancedComponent = withLogging(SomeComponent);\n````\n* 反向继承不能保证完整的子组件树被解析\n如果渲染 elements tree 中包含了 function 类型的组件的话，这时候就不能操作组件的子组件了。\n## 遵循的约定\n* props 保持一致\n保持原有组件的 props 不受影响。\n* 不要以任何方式改变原始组件 WrappedComponent\n对原有组件产生了副作用，失去了组件复用的意义，所以请通过 纯函数（相同的输入总有相同的输出） 返回新的组件。\n* 透传不相关 props 属性给被包裹的组件 WrappedComponent\n* 不要再 render() 方法中使用高阶组件\n调用高阶函数的时候每次都会返回一个新的组件，每次 render 的时候，都会使子对象树完全被卸载和重新渲染，重新加载一个组件会引起原有组件的状态和它的所有子组件丢失。\n* 使用 compose 组合高阶组件\n可以显著提高代码的可读性和逻辑的清晰度。\n````javascript\n// 不要这么使用\nconst EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))；\n// 可以使用一个 compose 函数组合这些高阶组件\n// lodash, redux, ramda 等第三方库都提供了类似 `compose` 功能的函数\nconst enhance = compose(withRouter, connect(commentSelector))；\nconst EnhancedComponent = enhance(WrappedComponent)；\n````\n* 包装显示名字以便于调试\n高阶组件创建的容器组件在 React Developer Tools 中的表现和其它的普通组件是一样的。为了便于调试，可以选择一个显示名字，传达它是一个高阶组件的结果。\n````javascript\nconst getDisplayName = WrappedComponent => WrappedComponent.displayName || WrappedComponent.name || 'Component';\nfunction HigherOrderComponent(WrappedComponent) {\n  class HigherOrderComponent extends React.Component {/* ... */}\n  HigherOrderComponent.displayName = `HigherOrderComponent(${getDisplayName(WrappedComponent)})`;\n  return HigherOrderComponent;\n}\n````\n## 常见应用场景\n* 权限控制\n利用高阶组件的 条件渲染 特性可以对页面进行权限控制，权限控制一般分为两个维度：页面级别 和 页面元素级别。\n* 组件渲染性能追踪\n根据react父子组件的渲染顺序和父组件子组件生命周期规则捕获子组件的生命周期，可以方便的对某个组件的渲染时间进行记录：\n````javascript\nclass Home extends React.Component {\n    render() {\n        return (<h1>Hello World.</h1>);\n    }\n}\nfunction withTiming(WrappedComponent) {\n  return class extends WrappedComponent {\n    constructor(props) {\n      super(props);\n      this.start = 0;\n      this.end = 0;\n    }\n    componentWillMount() {\n      super.componentWillMount && super.componentWillMount();\n      this.start = Date.now();\n    }\n    componentDidMount() {\n      super.componentDidMount && super.componentDidMount();\n      this.end = Date.now();\n      console.log(`${WrappedComponent.name} 组件渲染时间为 ${this.end - this.start} ms`);\n    }\n    render() {\n      return super.render();\n    }\n  };\n}\n\nexport default withTiming(Home);\n````\n* 页面复用\n将多个页面不同的部分抽离到外部传入，从而实现页面的复用。\n## Function as Child Components\n另一种类似高阶组件的方式叫做 Function as Child Components。它的思路是将函数（执行结果是返回新的组件）作为子组件传入，在父组件的render方法中执行此函数，可以传入特定的参数作为子组件的props。\n````javascript\nclass StudentWithAge extends React.Component {\n  componentWillMount() {\n    this.setState({\n      name: '小红',\n      age: 25,\n    });\n  }\n  render() {\n    return (\n      <div>\n        {this.props.children(this.state.name, this.state.age)}\n      </div>\n    );\n  }\n}\n````\n使用：\n````javascript\n<StudentWithAge>\n  {\n    (name, age) => {\n      let studentName = name;\n      if (age > 22) {\n          studentName = `大学毕业的${studentName}`;\n      }\n      return <Student name={studentName} />;\n    }\n  }\n</StudentWithAge>\n````\n\n相比高阶组件的优点：\n1. 代码结构上少掉了一层（返回高阶组件的）函数封装。\n2.调试时组件结构更加清晰\n3.从组件复用角度来看，父组件和子组件之间通过children连接，两个组件其实又完全可以单独使用，内部耦合较小。当然单独使用意义并不大，而且高阶组件也可以通过组合两个组件来做到。\n缺点：\n1. （返回子组件）函数占用了父组件原本的props.children；\n2. （返回子组件）函数只能进行调用，无法劫持劫持原组件生命周期方法或取到static方法；\n3. （返回子组件）函数作为子组件包裹在父组件中的方式看起来虽灵活但不够优雅；\n4. 由于子组件的渲染控制完全通过在父组件render方法中调用（返回子组件）函数，无法通过shouldComponentUpdate来做性能优化。\n\n所以这两种方式各有优劣，可根据具体场景选择。\n## 参考资料\n* [Higher-Order Components - React](https://reactjs.org/docs/higher-order-components.html)\n* [React 中的高阶组件及其应用场景](https://juejin.im/post/5c72b97de51d4545c66f75d5)\n* [React高阶组件实践](https://juejin.im/post/59b36b416fb9a00a636a207e)","source":"_posts/React高阶组件原理与应用.md","raw":"---\ntitle: React高阶组件的原理与应用\ndate: 2018-09-22\ntags: ['react', 'hoc']\ncategories: ['react']\n---\n## 什么是高阶组件\n* 高阶函数\n\n如果一个函数 接受一个或多个函数作为参数或者返回一个函数 就可称之为 高阶函数。\n<!--more-->\n* 高阶组件\n\n如果一个函数 接受一个或多个组件作为参数并且返回一个组件 就可称之为 高阶组件。\n\n当高阶组件中返回的组件是 无状态组件（Stateless Component） 时，该高阶组件其实就是一个 高阶函数，因为 无状态组件 本身就是一个纯函数。\n## 高阶组件的实现\n**React 中的高阶组件主要有两种形式：属性代理 和 反向继承。**\n### 属性代理（Props Proxy）\n一个函数接受一个 WrappedComponent 组件作为参数传入，并返回一个继承了 React.Component 组件的类，且在该类的 render() 方法中返回被传入的 WrappedComponent 组件。\n\n此时，能对 render() 方法里的 WrappedComponent 组件进行一些处理：\n* 操作 props\n````javascript\nfunction HigherOrderComponent(WrappedComponent) {\n  return class extends React.Component {\n    render() {\n      const newProps = {\n        value: 'defalut'\n      };\n      return <WrappedComponent {...this.props} {...newProps} />;\n    }\n  };\n}\n````\n* 抽离 state\n利用 props 和回调函数把 state 抽离出来：\n\n````javascript\nfunction withOnChange(WrappedComponent) {\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        value: '',\n      };\n    }\n    onChange = (value) => {\n      this.setState({\n        value\n      });\n    }\n    render() {\n      const newProps = {\n        value: this.state.value,\n        onChange: this.onChange,\n      };\n      return <WrappedComponent {...this.props} {...newProps} />;\n    }\n  };\n}\n````\n* 通过 ref 访问到组件实例\n\n在需要访问 DOM element （使用第三方 DOM 操作库）的时候就会用到组件的 ref 属性。它只能声明在 Class 类型的组件上，而无法声明在函数（无状态）类型的组件上。\n\n不能在无状态组件（函数类型组件）上使用 ref 属性，因为无状态组件没有实例。\nref 的值可以是字符串（不推荐使用）也可以是一个回调函数，如果是回调函数的话，它的执行时机是：\n\n* 组件被挂载后（componentDidMount），回调函数立即执行，回调函数的参数为该组件的实例。\n* 组件被卸载（componentDidUnmount）或者原有的 ref 属性本身发生变化的时候，此时回调函数也会立即执行，且回调函数的参数为 null。\n\n````javascript\nfunction HigherOrderComponent(WrappedComponent) {\n  return class extends React.Component {\n    executeInstanceMethod = (wrappedComponentInstance) => {\n      wrappedComponentInstance.someMethod();\n    }\n    render() {\n      return <WrappedComponent {...this.props} ref={this.executeInstanceMethod} />;\n    }\n  };\n}\n````\n* 用其他元素包裹传入的组件 WrappedComponent\n\n给 WrappedComponent 组件包一层背景色为 #fafafa 的 div 元素：\n\n````javascript\nfunction withBackgroundColor(WrappedComponent) {\n  return class extends React.Component {\n    render() {\n      return (\n        <div style={{ backgroundColor: '#fafafa' }}>\n            <WrappedComponent {...this.props} />\n        </div>\n      );\n    }\n  };\n}\n````\n### 反向继承（Inheritance Inversion）\n一个函数接受一个 WrappedComponent 组件作为参数传入，并返回一个继承了该传入 WrappedComponent 组件的类，且在该类的 render() 方法中返回 super.render() 方法。\n\n作用：\n* 操作 state\n\n高阶组件中可以读取、编辑和删除 WrappedComponent 组件实例中的 state。甚至可以增加更多的 state 项，但是 非常不建议这么做 因为这可能会导致 state 难以维护及管理。\n\n````javascript\nfunction withLogging(WrappedComponent) {\n  return class extends WrappedComponent {\n    render() {\n      return (\n        <div>\n          <h2>Debugger Component Logging...</h2>\n          <p>state:</p>\n          <pre>{JSON.stringify(this.state, null, 4)}</pre>\n          <p>props:</p>\n          <pre>{JSON.stringify(this.props, null, 4)}</pre>\n          {super.render()}\n        </div>\n      );\n    }\n  };\n}\n````\n* 渲染劫持（Render Highjacking）\n\n渲染劫持 是因为高阶组件控制着 WrappedComponent 组件的渲染输出，通过渲染劫持我们可以：\n\n* 有条件地展示元素树（element tree）\n* 操作由 render() 输出的 React 元素树\n* 在任何由 render() 输出的 React 元素中操作 props\n* 用其他元素包裹传入的组件 WrappedComponent （同 属性代理）\n\n````javascript\nfunction withLoading(WrappedComponent) {\n    return class extends WrappedComponent {\n        render() {\n            if(this.props.isLoading) {\n                return <Loading />;\n            } else {\n                return super.render();\n            }\n        }\n    };\n}\n````\n\n````javascript\nfunction HigherOrderComponent(WrappedComponent) {\n    return class extends WrappedComponent {\n        render() {\n            const tree = super.render();\n            const newProps = {};\n            if (tree && tree.type === 'input') {\n                newProps.value = 'something here';\n            }\n            const props = {\n                ...tree.props,\n                ...newProps,\n            };\n            const newTree = React.cloneElement(tree, props, tree.props.children);\n            return newTree;\n        }\n    };\n}\n````\n## 高阶组件存在的问题\n* 静态方法丢失\n因为原始组件被包裹于一个容器组件内，也就意味着新组件会没有原始组件的任何静态方法。\n\n须将静态方法做拷贝：\n````javascript\nfunction HigherOrderComponent(WrappedComponent) {\n  class Enhance extends React.Component {}\n  // 必须得知道要拷贝的方法\n  Enhance.staticMethod = WrappedComponent.staticMethod;\n  return Enhance;\n}\n````\n借助库 hoist-non-react-statics 来自动处理，它会 自动拷贝所有非 React 的静态方法。\n````javascript\nimport hoistNonReactStatic from 'hoist-non-react-statics';\n\nfunction HigherOrderComponent(WrappedComponent) {\n  class Enhance extends React.Component {}\n  hoistNonReactStatic(Enhance, WrappedComponent);\n  return Enhance;\n}\n````\n* refs 属性不能透传\n高阶组件可以传递所有的 props 给包裹的组件 WrappedComponent，但是有一种属性不能传递，它就是 ref。与其他属性不同的地方在于 React 对其进行了特殊的处理。\n\n如果你向一个由高阶组件创建的组件的元素添加 ref 引用，那么 ref 指向的是最外层容器组件实例的，而不是被包裹的 WrappedComponent 组件。\n\nReact 为我们提供了一个名为 React.forwardRef 的 API 来解决这一问题（在 React 16.3 版本中被添加）：\n````javascript\nfunction withLogging(WrappedComponent) {\n  class Enhance extends WrappedComponent {\n    componentWillReceiveProps() {\n      console.log('Current props', this.props);\n      console.log('Next props', nextProps);\n    }\n    render() {\n      const {forwardedRef, ...rest} = this.props;\n      // 把 forwardedRef 赋值给 ref\n      return <WrappedComponent {...rest} ref={forwardedRef} />;\n    }\n  };\n\n  // React.forwardRef 方法会传入 props 和 ref 两个参数给其回调函数\n  // 所以这边的 ref 是由 React.forwardRef 提供的\n  function forwardRef(props, ref) {\n    return <Enhance {...props} forwardRef={ref} />\n  }\n\n  return React.forwardRef(forwardRef);\n}\nconst EnhancedComponent = withLogging(SomeComponent);\n````\n* 反向继承不能保证完整的子组件树被解析\n如果渲染 elements tree 中包含了 function 类型的组件的话，这时候就不能操作组件的子组件了。\n## 遵循的约定\n* props 保持一致\n保持原有组件的 props 不受影响。\n* 不要以任何方式改变原始组件 WrappedComponent\n对原有组件产生了副作用，失去了组件复用的意义，所以请通过 纯函数（相同的输入总有相同的输出） 返回新的组件。\n* 透传不相关 props 属性给被包裹的组件 WrappedComponent\n* 不要再 render() 方法中使用高阶组件\n调用高阶函数的时候每次都会返回一个新的组件，每次 render 的时候，都会使子对象树完全被卸载和重新渲染，重新加载一个组件会引起原有组件的状态和它的所有子组件丢失。\n* 使用 compose 组合高阶组件\n可以显著提高代码的可读性和逻辑的清晰度。\n````javascript\n// 不要这么使用\nconst EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))；\n// 可以使用一个 compose 函数组合这些高阶组件\n// lodash, redux, ramda 等第三方库都提供了类似 `compose` 功能的函数\nconst enhance = compose(withRouter, connect(commentSelector))；\nconst EnhancedComponent = enhance(WrappedComponent)；\n````\n* 包装显示名字以便于调试\n高阶组件创建的容器组件在 React Developer Tools 中的表现和其它的普通组件是一样的。为了便于调试，可以选择一个显示名字，传达它是一个高阶组件的结果。\n````javascript\nconst getDisplayName = WrappedComponent => WrappedComponent.displayName || WrappedComponent.name || 'Component';\nfunction HigherOrderComponent(WrappedComponent) {\n  class HigherOrderComponent extends React.Component {/* ... */}\n  HigherOrderComponent.displayName = `HigherOrderComponent(${getDisplayName(WrappedComponent)})`;\n  return HigherOrderComponent;\n}\n````\n## 常见应用场景\n* 权限控制\n利用高阶组件的 条件渲染 特性可以对页面进行权限控制，权限控制一般分为两个维度：页面级别 和 页面元素级别。\n* 组件渲染性能追踪\n根据react父子组件的渲染顺序和父组件子组件生命周期规则捕获子组件的生命周期，可以方便的对某个组件的渲染时间进行记录：\n````javascript\nclass Home extends React.Component {\n    render() {\n        return (<h1>Hello World.</h1>);\n    }\n}\nfunction withTiming(WrappedComponent) {\n  return class extends WrappedComponent {\n    constructor(props) {\n      super(props);\n      this.start = 0;\n      this.end = 0;\n    }\n    componentWillMount() {\n      super.componentWillMount && super.componentWillMount();\n      this.start = Date.now();\n    }\n    componentDidMount() {\n      super.componentDidMount && super.componentDidMount();\n      this.end = Date.now();\n      console.log(`${WrappedComponent.name} 组件渲染时间为 ${this.end - this.start} ms`);\n    }\n    render() {\n      return super.render();\n    }\n  };\n}\n\nexport default withTiming(Home);\n````\n* 页面复用\n将多个页面不同的部分抽离到外部传入，从而实现页面的复用。\n## Function as Child Components\n另一种类似高阶组件的方式叫做 Function as Child Components。它的思路是将函数（执行结果是返回新的组件）作为子组件传入，在父组件的render方法中执行此函数，可以传入特定的参数作为子组件的props。\n````javascript\nclass StudentWithAge extends React.Component {\n  componentWillMount() {\n    this.setState({\n      name: '小红',\n      age: 25,\n    });\n  }\n  render() {\n    return (\n      <div>\n        {this.props.children(this.state.name, this.state.age)}\n      </div>\n    );\n  }\n}\n````\n使用：\n````javascript\n<StudentWithAge>\n  {\n    (name, age) => {\n      let studentName = name;\n      if (age > 22) {\n          studentName = `大学毕业的${studentName}`;\n      }\n      return <Student name={studentName} />;\n    }\n  }\n</StudentWithAge>\n````\n\n相比高阶组件的优点：\n1. 代码结构上少掉了一层（返回高阶组件的）函数封装。\n2.调试时组件结构更加清晰\n3.从组件复用角度来看，父组件和子组件之间通过children连接，两个组件其实又完全可以单独使用，内部耦合较小。当然单独使用意义并不大，而且高阶组件也可以通过组合两个组件来做到。\n缺点：\n1. （返回子组件）函数占用了父组件原本的props.children；\n2. （返回子组件）函数只能进行调用，无法劫持劫持原组件生命周期方法或取到static方法；\n3. （返回子组件）函数作为子组件包裹在父组件中的方式看起来虽灵活但不够优雅；\n4. 由于子组件的渲染控制完全通过在父组件render方法中调用（返回子组件）函数，无法通过shouldComponentUpdate来做性能优化。\n\n所以这两种方式各有优劣，可根据具体场景选择。\n## 参考资料\n* [Higher-Order Components - React](https://reactjs.org/docs/higher-order-components.html)\n* [React 中的高阶组件及其应用场景](https://juejin.im/post/5c72b97de51d4545c66f75d5)\n* [React高阶组件实践](https://juejin.im/post/59b36b416fb9a00a636a207e)","slug":"React高阶组件原理与应用","published":1,"updated":"2022-04-13T14:14:07.751Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvff60018g3t8h1mokknt","content":"<h2 id=\"什么是高阶组件\"><a href=\"#什么是高阶组件\" class=\"headerlink\" title=\"什么是高阶组件\"></a>什么是高阶组件</h2><ul>\n<li>高阶函数</li>\n</ul>\n<p>如果一个函数 接受一个或多个函数作为参数或者返回一个函数 就可称之为 高阶函数。<br><a id=\"more\"></a></p>\n<ul>\n<li>高阶组件</li>\n</ul>\n<p>如果一个函数 接受一个或多个组件作为参数并且返回一个组件 就可称之为 高阶组件。</p>\n<p>当高阶组件中返回的组件是 无状态组件（Stateless Component） 时，该高阶组件其实就是一个 高阶函数，因为 无状态组件 本身就是一个纯函数。</p>\n<h2 id=\"高阶组件的实现\"><a href=\"#高阶组件的实现\" class=\"headerlink\" title=\"高阶组件的实现\"></a>高阶组件的实现</h2><p><strong>React 中的高阶组件主要有两种形式：属性代理 和 反向继承。</strong></p>\n<h3 id=\"属性代理（Props-Proxy）\"><a href=\"#属性代理（Props-Proxy）\" class=\"headerlink\" title=\"属性代理（Props Proxy）\"></a>属性代理（Props Proxy）</h3><p>一个函数接受一个 WrappedComponent 组件作为参数传入，并返回一个继承了 React.Component 组件的类，且在该类的 render() 方法中返回被传入的 WrappedComponent 组件。</p>\n<p>此时，能对 render() 方法里的 WrappedComponent 组件进行一些处理：</p>\n<ul>\n<li><p>操作 props</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HigherOrderComponent</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> newProps = &#123;</span><br><span class=\"line\">        value: <span class=\"string\">'defalut'</span></span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...this.props</span>&#125; &#123;<span class=\"attr\">...newProps</span>&#125; /&gt;</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>抽离 state<br>利用 props 和回调函数把 state 抽离出来：</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withOnChange</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">        value: <span class=\"string\">''</span>,</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    onChange = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        value</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> newProps = &#123;</span><br><span class=\"line\">        value: <span class=\"keyword\">this</span>.state.value,</span><br><span class=\"line\">        onChange: <span class=\"keyword\">this</span>.onChange,</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...this.props</span>&#125; &#123;<span class=\"attr\">...newProps</span>&#125; /&gt;</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过 ref 访问到组件实例</li>\n</ul>\n<p>在需要访问 DOM element （使用第三方 DOM 操作库）的时候就会用到组件的 ref 属性。它只能声明在 Class 类型的组件上，而无法声明在函数（无状态）类型的组件上。</p>\n<p>不能在无状态组件（函数类型组件）上使用 ref 属性，因为无状态组件没有实例。<br>ref 的值可以是字符串（不推荐使用）也可以是一个回调函数，如果是回调函数的话，它的执行时机是：</p>\n<ul>\n<li>组件被挂载后（componentDidMount），回调函数立即执行，回调函数的参数为该组件的实例。</li>\n<li>组件被卸载（componentDidUnmount）或者原有的 ref 属性本身发生变化的时候，此时回调函数也会立即执行，且回调函数的参数为 null。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HigherOrderComponent</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    executeInstanceMethod = <span class=\"function\">(<span class=\"params\">wrappedComponentInstance</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      wrappedComponentInstance.someMethod();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...this.props</span>&#125; <span class=\"attr\">ref</span>=<span class=\"string\">&#123;this.executeInstanceMethod&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>用其他元素包裹传入的组件 WrappedComponent</li>\n</ul>\n<p>给 WrappedComponent 组件包一层背景色为 #fafafa 的 div 元素：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withBackgroundColor</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div style=&#123;&#123; <span class=\"attr\">backgroundColor</span>: <span class=\"string\">'#fafafa'</span> &#125;&#125;&gt;</span><br><span class=\"line\">            &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"反向继承（Inheritance-Inversion）\"><a href=\"#反向继承（Inheritance-Inversion）\" class=\"headerlink\" title=\"反向继承（Inheritance Inversion）\"></a>反向继承（Inheritance Inversion）</h3><p>一个函数接受一个 WrappedComponent 组件作为参数传入，并返回一个继承了该传入 WrappedComponent 组件的类，且在该类的 render() 方法中返回 super.render() 方法。</p>\n<p>作用：</p>\n<ul>\n<li>操作 state</li>\n</ul>\n<p>高阶组件中可以读取、编辑和删除 WrappedComponent 组件实例中的 state。甚至可以增加更多的 state 项，但是 非常不建议这么做 因为这可能会导致 state 难以维护及管理。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withLogging</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &lt;h2&gt;Debugger Component Logging...&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;p&gt;state:&lt;/</span>p&gt;</span><br><span class=\"line\">          &lt;pre&gt;&#123;<span class=\"built_in\">JSON</span>.stringify(<span class=\"keyword\">this</span>.state, <span class=\"literal\">null</span>, <span class=\"number\">4</span>)&#125;&lt;<span class=\"regexp\">/pre&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;p&gt;props:&lt;/</span>p&gt;</span><br><span class=\"line\">          &lt;pre&gt;&#123;<span class=\"built_in\">JSON</span>.stringify(<span class=\"keyword\">this</span>.props, <span class=\"literal\">null</span>, <span class=\"number\">4</span>)&#125;&lt;<span class=\"regexp\">/pre&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &#123;super.render()&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>渲染劫持（Render Highjacking）</li>\n</ul>\n<p>渲染劫持 是因为高阶组件控制着 WrappedComponent 组件的渲染输出，通过渲染劫持我们可以：</p>\n<ul>\n<li>有条件地展示元素树（element tree）</li>\n<li>操作由 render() 输出的 React 元素树</li>\n<li>在任何由 render() 输出的 React 元素中操作 props</li>\n<li>用其他元素包裹传入的组件 WrappedComponent （同 属性代理）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withLoading</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.props.isLoading) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Loading</span> /&gt;</span></span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.render();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HigherOrderComponent</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> tree = <span class=\"keyword\">super</span>.render();</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newProps = &#123;&#125;;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tree &amp;&amp; tree.type === <span class=\"string\">'input'</span>) &#123;</span><br><span class=\"line\">                newProps.value = <span class=\"string\">'something here'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> props = &#123;</span><br><span class=\"line\">                ...tree.props,</span><br><span class=\"line\">                ...newProps,</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newTree = React.cloneElement(tree, props, tree.props.children);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> newTree;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"高阶组件存在的问题\"><a href=\"#高阶组件存在的问题\" class=\"headerlink\" title=\"高阶组件存在的问题\"></a>高阶组件存在的问题</h2><ul>\n<li>静态方法丢失<br>因为原始组件被包裹于一个容器组件内，也就意味着新组件会没有原始组件的任何静态方法。</li>\n</ul>\n<p>须将静态方法做拷贝：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HigherOrderComponent</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enhance</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 必须得知道要拷贝的方法</span></span><br><span class=\"line\">  Enhance.staticMethod = WrappedComponent.staticMethod;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Enhance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>借助库 hoist-non-react-statics 来自动处理，它会 自动拷贝所有非 React 的静态方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hoistNonReactStatic <span class=\"keyword\">from</span> <span class=\"string\">'hoist-non-react-statics'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HigherOrderComponent</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enhance</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;&#125;</span><br><span class=\"line\">  hoistNonReactStatic(Enhance, WrappedComponent);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Enhance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>refs 属性不能透传<br>高阶组件可以传递所有的 props 给包裹的组件 WrappedComponent，但是有一种属性不能传递，它就是 ref。与其他属性不同的地方在于 React 对其进行了特殊的处理。</li>\n</ul>\n<p>如果你向一个由高阶组件创建的组件的元素添加 ref 引用，那么 ref 指向的是最外层容器组件实例的，而不是被包裹的 WrappedComponent 组件。</p>\n<p>React 为我们提供了一个名为 React.forwardRef 的 API 来解决这一问题（在 React 16.3 版本中被添加）：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withLogging</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enhance</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">    componentWillReceiveProps() &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Current props'</span>, <span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Next props'</span>, nextProps);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123;forwardedRef, ...rest&#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\">      <span class=\"comment\">// 把 forwardedRef 赋值给 ref</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...rest</span>&#125; <span class=\"attr\">ref</span>=<span class=\"string\">&#123;forwardedRef&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// React.forwardRef 方法会传入 props 和 ref 两个参数给其回调函数</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以这边的 ref 是由 React.forwardRef 提供的</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">forwardRef</span>(<span class=\"params\">props, ref</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Enhance</span> &#123;<span class=\"attr\">...props</span>&#125; <span class=\"attr\">forwardRef</span>=<span class=\"string\">&#123;ref&#125;</span> /&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> React.forwardRef(forwardRef);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> EnhancedComponent = withLogging(SomeComponent);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>反向继承不能保证完整的子组件树被解析<br>如果渲染 elements tree 中包含了 function 类型的组件的话，这时候就不能操作组件的子组件了。<h2 id=\"遵循的约定\"><a href=\"#遵循的约定\" class=\"headerlink\" title=\"遵循的约定\"></a>遵循的约定</h2></li>\n<li>props 保持一致<br>保持原有组件的 props 不受影响。</li>\n<li>不要以任何方式改变原始组件 WrappedComponent<br>对原有组件产生了副作用，失去了组件复用的意义，所以请通过 纯函数（相同的输入总有相同的输出） 返回新的组件。</li>\n<li>透传不相关 props 属性给被包裹的组件 WrappedComponent</li>\n<li>不要再 render() 方法中使用高阶组件<br>调用高阶函数的时候每次都会返回一个新的组件，每次 render 的时候，都会使子对象树完全被卸载和重新渲染，重新加载一个组件会引起原有组件的状态和它的所有子组件丢失。</li>\n<li><p>使用 compose 组合高阶组件<br>可以显著提高代码的可读性和逻辑的清晰度。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不要这么使用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))；</span><br><span class=\"line\"><span class=\"comment\">// 可以使用一个 compose 函数组合这些高阶组件</span></span><br><span class=\"line\"><span class=\"comment\">// lodash, redux, ramda 等第三方库都提供了类似 `compose` 功能的函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> enhance = compose(withRouter, connect(commentSelector))；</span><br><span class=\"line\"><span class=\"keyword\">const</span> EnhancedComponent = enhance(WrappedComponent)；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>包装显示名字以便于调试<br>高阶组件创建的容器组件在 React Developer Tools 中的表现和其它的普通组件是一样的。为了便于调试，可以选择一个显示名字，传达它是一个高阶组件的结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getDisplayName = <span class=\"function\"><span class=\"params\">WrappedComponent</span> =&gt;</span> WrappedComponent.displayName || WrappedComponent.name || <span class=\"string\">'Component'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HigherOrderComponent</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HigherOrderComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;<span class=\"comment\">/* ... */</span>&#125;</span><br><span class=\"line\">  HigherOrderComponent.displayName = <span class=\"string\">`HigherOrderComponent(<span class=\"subst\">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> HigherOrderComponent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"常见应用场景\"><a href=\"#常见应用场景\" class=\"headerlink\" title=\"常见应用场景\"></a>常见应用场景</h2><ul>\n<li>权限控制<br>利用高阶组件的 条件渲染 特性可以对页面进行权限控制，权限控制一般分为两个维度：页面级别 和 页面元素级别。</li>\n<li><p>组件渲染性能追踪<br>根据react父子组件的渲染顺序和父组件子组件生命周期规则捕获子组件的生命周期，可以方便的对某个组件的渲染时间进行记录：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Home</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello World.<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withTiming</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.start = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.end = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentWillMount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>.componentWillMount &amp;&amp; <span class=\"keyword\">super</span>.componentWillMount();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.start = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>.componentDidMount &amp;&amp; <span class=\"keyword\">super</span>.componentDidMount();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.end = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;WrappedComponent.name&#125;</span> 组件渲染时间为 <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.end - <span class=\"keyword\">this</span>.start&#125;</span> ms`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.render();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> withTiming(Home);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>页面复用<br>将多个页面不同的部分抽离到外部传入，从而实现页面的复用。</p>\n<h2 id=\"Function-as-Child-Components\"><a href=\"#Function-as-Child-Components\" class=\"headerlink\" title=\"Function as Child Components\"></a>Function as Child Components</h2><p>另一种类似高阶组件的方式叫做 Function as Child Components。它的思路是将函数（执行结果是返回新的组件）作为子组件传入，在父组件的render方法中执行此函数，可以传入特定的参数作为子组件的props。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StudentWithAge</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  componentWillMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      name: <span class=\"string\">'小红'</span>,</span><br><span class=\"line\">      age: <span class=\"number\">25</span>,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &#123;<span class=\"keyword\">this</span>.props.children(<span class=\"keyword\">this</span>.state.name, <span class=\"keyword\">this</span>.state.age)&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>使用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;StudentWithAge&gt;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    (name, age) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> studentName = name;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (age &gt; <span class=\"number\">22</span>) &#123;</span><br><span class=\"line\">          studentName = <span class=\"string\">`大学毕业的<span class=\"subst\">$&#123;studentName&#125;</span>`</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Student</span> <span class=\"attr\">name</span>=<span class=\"string\">&#123;studentName&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/StudentWithAge&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>相比高阶组件的优点：</p>\n<ol>\n<li>代码结构上少掉了一层（返回高阶组件的）函数封装。<br>2.调试时组件结构更加清晰<br>3.从组件复用角度来看，父组件和子组件之间通过children连接，两个组件其实又完全可以单独使用，内部耦合较小。当然单独使用意义并不大，而且高阶组件也可以通过组合两个组件来做到。<br>缺点：</li>\n<li>（返回子组件）函数占用了父组件原本的props.children；</li>\n<li>（返回子组件）函数只能进行调用，无法劫持劫持原组件生命周期方法或取到static方法；</li>\n<li>（返回子组件）函数作为子组件包裹在父组件中的方式看起来虽灵活但不够优雅；</li>\n<li>由于子组件的渲染控制完全通过在父组件render方法中调用（返回子组件）函数，无法通过shouldComponentUpdate来做性能优化。</li>\n</ol>\n<p>所以这两种方式各有优劣，可根据具体场景选择。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://reactjs.org/docs/higher-order-components.html\" target=\"_blank\" rel=\"noopener\">Higher-Order Components - React</a></li>\n<li><a href=\"https://juejin.im/post/5c72b97de51d4545c66f75d5\" target=\"_blank\" rel=\"noopener\">React 中的高阶组件及其应用场景</a></li>\n<li><a href=\"https://juejin.im/post/59b36b416fb9a00a636a207e\" target=\"_blank\" rel=\"noopener\">React高阶组件实践</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是高阶组件\"><a href=\"#什么是高阶组件\" class=\"headerlink\" title=\"什么是高阶组件\"></a>什么是高阶组件</h2><ul>\n<li>高阶函数</li>\n</ul>\n<p>如果一个函数 接受一个或多个函数作为参数或者返回一个函数 就可称之为 高阶函数。<br>","more":"</p>\n<ul>\n<li>高阶组件</li>\n</ul>\n<p>如果一个函数 接受一个或多个组件作为参数并且返回一个组件 就可称之为 高阶组件。</p>\n<p>当高阶组件中返回的组件是 无状态组件（Stateless Component） 时，该高阶组件其实就是一个 高阶函数，因为 无状态组件 本身就是一个纯函数。</p>\n<h2 id=\"高阶组件的实现\"><a href=\"#高阶组件的实现\" class=\"headerlink\" title=\"高阶组件的实现\"></a>高阶组件的实现</h2><p><strong>React 中的高阶组件主要有两种形式：属性代理 和 反向继承。</strong></p>\n<h3 id=\"属性代理（Props-Proxy）\"><a href=\"#属性代理（Props-Proxy）\" class=\"headerlink\" title=\"属性代理（Props Proxy）\"></a>属性代理（Props Proxy）</h3><p>一个函数接受一个 WrappedComponent 组件作为参数传入，并返回一个继承了 React.Component 组件的类，且在该类的 render() 方法中返回被传入的 WrappedComponent 组件。</p>\n<p>此时，能对 render() 方法里的 WrappedComponent 组件进行一些处理：</p>\n<ul>\n<li><p>操作 props</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HigherOrderComponent</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> newProps = &#123;</span><br><span class=\"line\">        value: <span class=\"string\">'defalut'</span></span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...this.props</span>&#125; &#123;<span class=\"attr\">...newProps</span>&#125; /&gt;</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>抽离 state<br>利用 props 和回调函数把 state 抽离出来：</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withOnChange</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">        value: <span class=\"string\">''</span>,</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    onChange = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        value</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> newProps = &#123;</span><br><span class=\"line\">        value: <span class=\"keyword\">this</span>.state.value,</span><br><span class=\"line\">        onChange: <span class=\"keyword\">this</span>.onChange,</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...this.props</span>&#125; &#123;<span class=\"attr\">...newProps</span>&#125; /&gt;</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过 ref 访问到组件实例</li>\n</ul>\n<p>在需要访问 DOM element （使用第三方 DOM 操作库）的时候就会用到组件的 ref 属性。它只能声明在 Class 类型的组件上，而无法声明在函数（无状态）类型的组件上。</p>\n<p>不能在无状态组件（函数类型组件）上使用 ref 属性，因为无状态组件没有实例。<br>ref 的值可以是字符串（不推荐使用）也可以是一个回调函数，如果是回调函数的话，它的执行时机是：</p>\n<ul>\n<li>组件被挂载后（componentDidMount），回调函数立即执行，回调函数的参数为该组件的实例。</li>\n<li>组件被卸载（componentDidUnmount）或者原有的 ref 属性本身发生变化的时候，此时回调函数也会立即执行，且回调函数的参数为 null。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HigherOrderComponent</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    executeInstanceMethod = <span class=\"function\">(<span class=\"params\">wrappedComponentInstance</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      wrappedComponentInstance.someMethod();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...this.props</span>&#125; <span class=\"attr\">ref</span>=<span class=\"string\">&#123;this.executeInstanceMethod&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>用其他元素包裹传入的组件 WrappedComponent</li>\n</ul>\n<p>给 WrappedComponent 组件包一层背景色为 #fafafa 的 div 元素：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withBackgroundColor</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div style=&#123;&#123; <span class=\"attr\">backgroundColor</span>: <span class=\"string\">'#fafafa'</span> &#125;&#125;&gt;</span><br><span class=\"line\">            &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"反向继承（Inheritance-Inversion）\"><a href=\"#反向继承（Inheritance-Inversion）\" class=\"headerlink\" title=\"反向继承（Inheritance Inversion）\"></a>反向继承（Inheritance Inversion）</h3><p>一个函数接受一个 WrappedComponent 组件作为参数传入，并返回一个继承了该传入 WrappedComponent 组件的类，且在该类的 render() 方法中返回 super.render() 方法。</p>\n<p>作用：</p>\n<ul>\n<li>操作 state</li>\n</ul>\n<p>高阶组件中可以读取、编辑和删除 WrappedComponent 组件实例中的 state。甚至可以增加更多的 state 项，但是 非常不建议这么做 因为这可能会导致 state 难以维护及管理。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withLogging</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &lt;h2&gt;Debugger Component Logging...&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;p&gt;state:&lt;/</span>p&gt;</span><br><span class=\"line\">          &lt;pre&gt;&#123;<span class=\"built_in\">JSON</span>.stringify(<span class=\"keyword\">this</span>.state, <span class=\"literal\">null</span>, <span class=\"number\">4</span>)&#125;&lt;<span class=\"regexp\">/pre&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;p&gt;props:&lt;/</span>p&gt;</span><br><span class=\"line\">          &lt;pre&gt;&#123;<span class=\"built_in\">JSON</span>.stringify(<span class=\"keyword\">this</span>.props, <span class=\"literal\">null</span>, <span class=\"number\">4</span>)&#125;&lt;<span class=\"regexp\">/pre&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &#123;super.render()&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>渲染劫持（Render Highjacking）</li>\n</ul>\n<p>渲染劫持 是因为高阶组件控制着 WrappedComponent 组件的渲染输出，通过渲染劫持我们可以：</p>\n<ul>\n<li>有条件地展示元素树（element tree）</li>\n<li>操作由 render() 输出的 React 元素树</li>\n<li>在任何由 render() 输出的 React 元素中操作 props</li>\n<li>用其他元素包裹传入的组件 WrappedComponent （同 属性代理）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withLoading</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.props.isLoading) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Loading</span> /&gt;</span></span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.render();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HigherOrderComponent</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> tree = <span class=\"keyword\">super</span>.render();</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newProps = &#123;&#125;;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tree &amp;&amp; tree.type === <span class=\"string\">'input'</span>) &#123;</span><br><span class=\"line\">                newProps.value = <span class=\"string\">'something here'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> props = &#123;</span><br><span class=\"line\">                ...tree.props,</span><br><span class=\"line\">                ...newProps,</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newTree = React.cloneElement(tree, props, tree.props.children);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> newTree;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"高阶组件存在的问题\"><a href=\"#高阶组件存在的问题\" class=\"headerlink\" title=\"高阶组件存在的问题\"></a>高阶组件存在的问题</h2><ul>\n<li>静态方法丢失<br>因为原始组件被包裹于一个容器组件内，也就意味着新组件会没有原始组件的任何静态方法。</li>\n</ul>\n<p>须将静态方法做拷贝：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HigherOrderComponent</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enhance</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 必须得知道要拷贝的方法</span></span><br><span class=\"line\">  Enhance.staticMethod = WrappedComponent.staticMethod;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Enhance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>借助库 hoist-non-react-statics 来自动处理，它会 自动拷贝所有非 React 的静态方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hoistNonReactStatic <span class=\"keyword\">from</span> <span class=\"string\">'hoist-non-react-statics'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HigherOrderComponent</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enhance</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;&#125;</span><br><span class=\"line\">  hoistNonReactStatic(Enhance, WrappedComponent);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Enhance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>refs 属性不能透传<br>高阶组件可以传递所有的 props 给包裹的组件 WrappedComponent，但是有一种属性不能传递，它就是 ref。与其他属性不同的地方在于 React 对其进行了特殊的处理。</li>\n</ul>\n<p>如果你向一个由高阶组件创建的组件的元素添加 ref 引用，那么 ref 指向的是最外层容器组件实例的，而不是被包裹的 WrappedComponent 组件。</p>\n<p>React 为我们提供了一个名为 React.forwardRef 的 API 来解决这一问题（在 React 16.3 版本中被添加）：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withLogging</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enhance</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">    componentWillReceiveProps() &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Current props'</span>, <span class=\"keyword\">this</span>.props);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Next props'</span>, nextProps);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123;forwardedRef, ...rest&#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\">      <span class=\"comment\">// 把 forwardedRef 赋值给 ref</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...rest</span>&#125; <span class=\"attr\">ref</span>=<span class=\"string\">&#123;forwardedRef&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// React.forwardRef 方法会传入 props 和 ref 两个参数给其回调函数</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以这边的 ref 是由 React.forwardRef 提供的</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">forwardRef</span>(<span class=\"params\">props, ref</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Enhance</span> &#123;<span class=\"attr\">...props</span>&#125; <span class=\"attr\">forwardRef</span>=<span class=\"string\">&#123;ref&#125;</span> /&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> React.forwardRef(forwardRef);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> EnhancedComponent = withLogging(SomeComponent);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>反向继承不能保证完整的子组件树被解析<br>如果渲染 elements tree 中包含了 function 类型的组件的话，这时候就不能操作组件的子组件了。<h2 id=\"遵循的约定\"><a href=\"#遵循的约定\" class=\"headerlink\" title=\"遵循的约定\"></a>遵循的约定</h2></li>\n<li>props 保持一致<br>保持原有组件的 props 不受影响。</li>\n<li>不要以任何方式改变原始组件 WrappedComponent<br>对原有组件产生了副作用，失去了组件复用的意义，所以请通过 纯函数（相同的输入总有相同的输出） 返回新的组件。</li>\n<li>透传不相关 props 属性给被包裹的组件 WrappedComponent</li>\n<li>不要再 render() 方法中使用高阶组件<br>调用高阶函数的时候每次都会返回一个新的组件，每次 render 的时候，都会使子对象树完全被卸载和重新渲染，重新加载一个组件会引起原有组件的状态和它的所有子组件丢失。</li>\n<li><p>使用 compose 组合高阶组件<br>可以显著提高代码的可读性和逻辑的清晰度。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不要这么使用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))；</span><br><span class=\"line\"><span class=\"comment\">// 可以使用一个 compose 函数组合这些高阶组件</span></span><br><span class=\"line\"><span class=\"comment\">// lodash, redux, ramda 等第三方库都提供了类似 `compose` 功能的函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> enhance = compose(withRouter, connect(commentSelector))；</span><br><span class=\"line\"><span class=\"keyword\">const</span> EnhancedComponent = enhance(WrappedComponent)；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>包装显示名字以便于调试<br>高阶组件创建的容器组件在 React Developer Tools 中的表现和其它的普通组件是一样的。为了便于调试，可以选择一个显示名字，传达它是一个高阶组件的结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getDisplayName = <span class=\"function\"><span class=\"params\">WrappedComponent</span> =&gt;</span> WrappedComponent.displayName || WrappedComponent.name || <span class=\"string\">'Component'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HigherOrderComponent</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HigherOrderComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;<span class=\"comment\">/* ... */</span>&#125;</span><br><span class=\"line\">  HigherOrderComponent.displayName = <span class=\"string\">`HigherOrderComponent(<span class=\"subst\">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> HigherOrderComponent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"常见应用场景\"><a href=\"#常见应用场景\" class=\"headerlink\" title=\"常见应用场景\"></a>常见应用场景</h2><ul>\n<li>权限控制<br>利用高阶组件的 条件渲染 特性可以对页面进行权限控制，权限控制一般分为两个维度：页面级别 和 页面元素级别。</li>\n<li><p>组件渲染性能追踪<br>根据react父子组件的渲染顺序和父组件子组件生命周期规则捕获子组件的生命周期，可以方便的对某个组件的渲染时间进行记录：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Home</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello World.<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withTiming</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.start = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.end = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentWillMount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>.componentWillMount &amp;&amp; <span class=\"keyword\">super</span>.componentWillMount();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.start = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>.componentDidMount &amp;&amp; <span class=\"keyword\">super</span>.componentDidMount();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.end = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;WrappedComponent.name&#125;</span> 组件渲染时间为 <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.end - <span class=\"keyword\">this</span>.start&#125;</span> ms`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.render();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> withTiming(Home);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>页面复用<br>将多个页面不同的部分抽离到外部传入，从而实现页面的复用。</p>\n<h2 id=\"Function-as-Child-Components\"><a href=\"#Function-as-Child-Components\" class=\"headerlink\" title=\"Function as Child Components\"></a>Function as Child Components</h2><p>另一种类似高阶组件的方式叫做 Function as Child Components。它的思路是将函数（执行结果是返回新的组件）作为子组件传入，在父组件的render方法中执行此函数，可以传入特定的参数作为子组件的props。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StudentWithAge</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  componentWillMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      name: <span class=\"string\">'小红'</span>,</span><br><span class=\"line\">      age: <span class=\"number\">25</span>,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &#123;<span class=\"keyword\">this</span>.props.children(<span class=\"keyword\">this</span>.state.name, <span class=\"keyword\">this</span>.state.age)&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>使用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;StudentWithAge&gt;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    (name, age) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> studentName = name;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (age &gt; <span class=\"number\">22</span>) &#123;</span><br><span class=\"line\">          studentName = <span class=\"string\">`大学毕业的<span class=\"subst\">$&#123;studentName&#125;</span>`</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Student</span> <span class=\"attr\">name</span>=<span class=\"string\">&#123;studentName&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/StudentWithAge&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>相比高阶组件的优点：</p>\n<ol>\n<li>代码结构上少掉了一层（返回高阶组件的）函数封装。<br>2.调试时组件结构更加清晰<br>3.从组件复用角度来看，父组件和子组件之间通过children连接，两个组件其实又完全可以单独使用，内部耦合较小。当然单独使用意义并不大，而且高阶组件也可以通过组合两个组件来做到。<br>缺点：</li>\n<li>（返回子组件）函数占用了父组件原本的props.children；</li>\n<li>（返回子组件）函数只能进行调用，无法劫持劫持原组件生命周期方法或取到static方法；</li>\n<li>（返回子组件）函数作为子组件包裹在父组件中的方式看起来虽灵活但不够优雅；</li>\n<li>由于子组件的渲染控制完全通过在父组件render方法中调用（返回子组件）函数，无法通过shouldComponentUpdate来做性能优化。</li>\n</ol>\n<p>所以这两种方式各有优劣，可根据具体场景选择。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://reactjs.org/docs/higher-order-components.html\" target=\"_blank\" rel=\"noopener\">Higher-Order Components - React</a></li>\n<li><a href=\"https://juejin.im/post/5c72b97de51d4545c66f75d5\" target=\"_blank\" rel=\"noopener\">React 中的高阶组件及其应用场景</a></li>\n<li><a href=\"https://juejin.im/post/59b36b416fb9a00a636a207e\" target=\"_blank\" rel=\"noopener\">React高阶组件实践</a></li>\n</ul>"},{"title":"react服务端渲染的实现","date":"2018-08-10T16:00:00.000Z","_content":"## 什么时候需要服务端渲染（Server Side Render）\n1. 现代前端应用的页面内容由ajax请求数据之后，再在客户端进行页面的动态渲染，而一般搜索引擎或网页爬虫只对ajax渲染前的HTML文件进行爬取，这种形式不利于网站的SEO。\n2. 单页应用通过请求js和ajax请求数据之后，再进行页面结构和数据的渲染，降低了首屏的展示速度。\n<!--more-->\n因此，通过服务端渲染的方式，将渲染结果以HTML结构的形式返回给客户端，可以优化以上两个主要的问题。\n\n## react中和SSR相关的API\n* renderToString()\n\n将 React 元素渲染为初始 HTML。React 将返回一个 HTML 字符串。你可以使用此方法在服务端生成 HTML。\n* renderToStaticMarkup()\n\n此方法与 renderToString 相似，但此方法不会在 React 内部创建的额外 DOM 属性，例如 data-reactroot。如果你希望把 React 当作静态页面生成器来使用，此方法会非常有用，因为去除额外的属性可以节省一些字节。\n\n如果你计划在前端使用 React 以使得标记可交互，请不要使用此方法。你可以在服务端上使用 renderToString 或在前端上使用 ReactDOM.hydrate() 来代替此方法。\n\n**以上两个API可以被使用在服务端和浏览器环境。**\n\n**下述附加方法依赖一个只能在服务端使用的 package（stream）。它们在浏览器中不起作用。**\n* renderToNodeStream()\n\n将一个 React 元素渲染成其初始 HTML。返回一个可输出 HTML 字符串的可读流。通过可读流输出的 HTML 完全等同于 ReactDOMServer.renderToString 返回的 HTML。\n* renderToStaticNodeStream()\n\n此方法与 renderToNodeStream 相似，但此方法不会在 React 内部创建的额外 DOM 属性，例如 data-reactroot。如果你希望把 React 当作静态页面生成器来使用，此方法会非常有用，因为去除额外的属性可以节省一些字节。\n## 实现\n\n下面借助 renderToString() 方法实现一个简单的服务端渲染例子。\n### 引入服务端框架\n这里我们采用 express 框架。\n新建一个 React 组件.\n\n**App.js**\n````javascript\nimport React, { Component } from 'react'\n\nclass App extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      count: 0\n    }\n  }\n  \n  render() {\n    return (\n      <div>\n        首页\n        <div>\n          <button onClick={() => {this.setState({count: this.state.count + 1})}}>+</button>\n          <div>{this.state.count}</div>\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default App\n````\n**server.js**\n\n````javascript\nimport express from 'express'\nimport fs from 'fs'\nimport path from 'path'\nimport { renderToString } from 'react-dom/server'\nimport React from 'react'\nimport App from './src/App'\n\nvar app = express()\n\napp.get('/*', (req, res) => {\n  const renderedString = renderToString(\n        <App/>\n    )\n\n  fs.readFile(path.resolve('index.html'), 'utf8', (error, data) => {\n    if(error) {\n      console.log(error)\n      res.send('<p>Error!</p>')\n      return false\n    }\n    console\n    res.send(`${data.replace('<div id=\"app\"></div>', `<div id=\"app\">${renderedString}</div>`)}`)\n  })\n})\n\napp.listen(8000)\n````\n然后运行 node server.js。这个时候会发现，启动报错。原因在于我们在 node 里面使用了 ES6 Module 和 React JSX，node并不支持。\n\n引入 babel-node 来解决这个问题。\n\n安装完成 babel-node 以及 babel-core，babel-cli，babel-preset-react 等相关工具之后，执行\n````javascript\n\"scripts\": {\n  \"start\": \"babel-node ./server.js --presets es2015,stage-0,react\"\n},\n````\n访问 localhost:8000,就可以看到页面效果了。\n\n![服务端渲染](https://i.loli.net/2019/03/22/5c944d96a9ea0.png)\n### 客户端React组件的实例化\n上面的App组件中，点击 + 按钮，并不会生效，这个页面只是一个静态的HTML页面，没有在客户端渲染React组件并初始化React实例。只有在初始化React实例后，才能更新组件的state和props，初始化React的事件系统，执行虚拟DOM的重新渲染机制。\n\n那么这里可能会有疑问，服务器端已经渲染了一次React组件，如果在客户端中再渲染一次 React 组件，会不会渲染两次 React 组件。答案当然是不会的。\n\n在 React16 版本以前，如果使用renderToString渲染组件，会在组件的第一个DOM带有data-react-checksum属性，当客户端渲染React组件时，首先计算出组件的checksum值，然后检索HTML DOM看看是否存在数值相同的data-react-checksum属性，如果存在，则组件只会渲染一次，如果不存在，则会抛出一个warning异常。\n\n也就是说，当服务器端和客户端渲染具有相同的props和相同DOM结构的组件时，该React组件只会渲染一次。\n\n在服务器端使用renderToStaticMarkup渲染的组件不会带有data-react-checksum属性，此时客户端会重新渲染组件，覆盖掉服务器端的组件。因此，当页面不是渲染一个静态的页面时，最好还是使用renderToString方法。\n\n接着根据 data-reactid 属性，找到需要绑定的事件元素，进行事件绑定的处理。\n\n> React v16 版本里，ReactDOMServer 渲染的内容不再有 data-react 的属性，而是尽可能复用 SSR 的 HTML 结构。这就带来了一个问题，ReactDOM.render 不再能够简单地用 data-react-checksum 的存在性来判断是否应该尝试复用，如果每次 ReactDOM.render 都要尽可能尝试复用，性能和语义都会出现问题。所以， ReactDOM 提供了一个新的 API， ReactDOM.hydrate() 。\n> 在 React v17 版本里，ReactDOM.render 则直接不再具有复用 SSR 内容的功能。\n\n实践发现，v16 版本里面，render() 方法会将整个 DOM 结构重新渲染， 而使用 hydrate 则不会。\n\n加上在客户端渲染的代码\n**index.js**\n\n````javascript\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport { BrowserRouter } from 'react-router-dom'\nimport App from './App'\n\nReactDOM.render(\n  <App />\n, document.getElementById('app'))\n````\n这个时候，我们需要引入 webpack，将要在客户端执行的代码用 webpack 打包到 dist 文件夹。\n\n````javascript\n\"scripts\": {\n  \"start\": \"npm run build && babel-node ./server.js --presets es2015,stage-0,react\",\n  \"build\": \"webpack\"\n},\n````\n在 html 模板里手动引入js，\n````html\n<body>\n  <div id=\"app\"></div>\n</body>\n<script src=\"dist/app.js\"></script>\n````\n再次启动项目，这个时候会发现，请求回来的 app.js 的内容变成了 html.index 文件。\n\n![服务端渲染](https://i.loli.net/2019/03/22/5c944e3cb98ad.png)\n原因在于请求 /dist/app.js 被当成了普通的路由了，没有被当成一个静态资源来返回有效的 JavaScript 代码，解决方案就是在 express 中添加一个静态资源服务。\n````javascript\nvar app = express()\napp.use(express.static('dist'));\n````\n同时将 html 的 script 路径修改下，\n````html\n<body>\n  <div id=\"app\"></div>\n</body>\n<script src=\"/app.js\"></script>\n````\n这样就可以客户端就可以正确地获取到 app.js 的内容了，然后在客户端进行 React 组件的实例化，这个时候点击 + 按钮也有效果了。\n### 路由\n接下来添加路由功能\n\n服务端匹配路由的时候，不能用 BrowserRouter，要使用无状态的 StaticRouter，并结合 location 和 context 两个属性。\n\n给App组件添加路由。\n\n**App.js**\n````javascript\nimport { Switch, Route, Link } from 'react-router-dom' \nimport PageA from './component/PageA'\nimport PageB from './component/PageB'\n//...\n  render() {\n    return (\n      <div>\n        首页\n        <div>\n          <button onClick={() => {this.setState({count: this.state.count + 1})}}>+</button>\n          <div>{this.state.count}</div>\n        </div>\n        <Link to='/'>跳转到pageA</Link>\n        <br/>\n        <Link to='/pageb'>跳转到pageB</Link>\n        <Switch>\n          <Route exact path=\"/\" component={ PageA } />\n          <Route exact path=\"/pageb\" component={ PageB } />\n        </Switch>\n      </div>\n    )\n  }\n//...\n````\n服务端加入路由匹配。这里默认浏览器 url 和 配置的路由地址一样，也可以把路由抽成单独的配置文件，借助 react-router-dom 路由模块的 matchPath 方法来匹配路由。\n\n**server.js**\n````javascript\nimport { StaticRouter } from 'react-router-dom'\n\napp.get('/*', (req, res) => {\n  const renderedString = renderToString(\n    <StaticRouter location={ req.url }>\n      <App />\n    </StaticRouter>\n  )\n  //...\n})\n````\n可以看到，已经实现了路由功能。\n\n![服务端渲染](https://i.loli.net/2019/03/22/5c9455e9e0e31.png)\n![服务端渲染](https://i.loli.net/2019/03/22/5c9455e9df280.png)\n\n### 服务端异步获取数据\n当服务端渲染的html文件数据需要通过请求另外的接口获取时，这个时候就需要服务端去请求数据，再将渲染完的 html 页面返回给客户端。\n\n模拟接口返回数据。\n\n**fetchData.js**\n````javascript\nexport function getInitCount() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(10)\n    }, 3000)\n  })\n}\n````\n服务端请求完数据之后，需要将给数据 React 组件使用。可以采用两种方式：\n\n1. 通过 React 组件的 props 传入。\n2. 通过 Router 的 context 传入，React 组件中再通过 props.staticContext 获取到。\n\n**server.js**\n````javascript\nimport { getInitCount } from './src/utils/fetchData'\n//...\napp.get('/*', (req, res) => {\n  const renderedString = renderToString(\n    <StaticRouter location={ req.url }>\n      <App initCount={resData} />\n    </StaticRouter>\n  )\n  //...\n})\n````\n**App.js**\n````javascript\nclass App extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      count: props.initCount || 0\n    }\n  }\n  //...\n}\n````\n这样可以看到服务器返回的 html 文件内容，已经将 count 的初始值 10 渲染进去了。\n\n![服务端渲染](https://i.loli.net/2019/03/22/5c948522154ca.jpg)\n\n但是此时页面显示的count值还是0，原因在于虽然使用了 hydrate() 方法，并不会将 html 结构重新渲染，但是 React 组件还是会走一遍生命周期流程，App 组件的 props.initCount 依旧是 0。\n\n为了让客户端和服务端的props保持一致，需要将一个服务器生成的首屏 props 赋给客户端的全局变量。\n\n修改下server.js 和 index.js\n````javascript\napp.get('/*', (req, res) => {\n  getInitCount().then(resData => {\n    const renderedString = renderToString(\n        <StaticRouter location={req.url}>\n          <App initCount={resData} />\n        </StaticRouter>\n      )\n  \n    fs.readFile(path.resolve('index.html'), 'utf8', (error, data) => {\n      //...\n\n      res.send(`${data\n        .replace('<div id=\"app\"></div>', `<div id=\"app\">${renderedString}</div>`)\n        .replace('</body>', `</body><script>window.__initCount__ = ${JSON.stringify(resData)}</script>`)}`)\n    })\n  })\n})\n````\n````javascript\nReactDOM.hydrate(\n    <BrowserRouter>\n        <App initCount={window.__initCount__} />\n    </BrowserRouter>\n    , document.getElementById('app'))\n````\n注意 window.__initCount__ 需要在 app.js 前面加载。\n\n![服务端渲染](https://i.loli.net/2019/03/22/5c9487b39b46b.png)\n\n### 服务端无法支持图片、css等资源文件\n如果代码中我们 import 了图片, svg, css 等非 js 资源，在客户端 webpack 的各种 loader 帮我们处理了这些资源，而 node 环境下只能识别 js。由于之前的例子没有引入额外的静态资源，所以没有出现这样的问题。\n\n试着在 pageB 组件中引入图片。\n````javascript\nrender() {\n  return (\n    <div>\n      <div>B页面</div>\n      <img src={require('../assets/img/hat.jpg')} alt=\"\"/>\n    </div>\n  )\n}\n````\n\n运行便报错了。\n\n引入 webpack-isomorphic-tools 工具来解决这个问题。\n\nwebpack-isomorphic-tools 完成了两件事：\n\n1. 以webpack插件的形式，预编译less（不局限于less，还支持图片文件、字体文件等），将其转换为一个 assets.json 文件保存到项目目录下。\n2. require hook，所有less文件的引入，代理到生成的 JSON 文件中，匹配文件路径，返回一个预先编译好的 JSON 对象。\n\n实现步骤：\n1. 修改webpack.config.js\n\n````javascript\nvar WebpackIsomorphicToolsPlugin = require('webpack-isomorphic-tools/plugin')\n\nvar webpackIsomorphicToolsPlugin = \n  // webpack-isomorphic-tools settings reside in a separate .js file \n  // (because they will be used in the web server code too).\n  new WebpackIsomorphicToolsPlugin(require('./webpack-isomorphic-tools-configuration'))\n  // also enter development mode since it's a development webpack configuration\n  // (see below for explanation)\n  .development()\n\n// usual Webpack configuration\nmodule.exports =\n{\n  context: '(required) your project path here',\n  module:\n  {\n    loaders:\n    [\n      //...,\n      {\n        test: webpackIsomorphicToolsPlugin.regularExpression('images'),\n        loader: 'url-loader?limit=1024', // any image below or equal to 10K will be converted to inline base64 instead\n      }\n    ]\n  },\n\n  plugins:\n  [\n    //...,\n    webpackIsomorphicToolsPlugin\n  ]\n  //...\n}\n````\n2. 添加 webpack-isomorphic-tools 配置文件 webpack-isomorphic-config.js\n\n````javascript\nmodule.exports = \n{\n  assets:\n  {\n    images:\n    {\n      extensions: ['png', 'jpg', 'gif', 'ico', 'svg']\n    }\n  }\n}\n````\n\nwebpack-isomorphic-tools 启动时，会先等待指定目录下 assets.json 文件生成，只有该文件就绪后，require hook 才会进行，进而触发 server 回调，只有在此回调中执行的代码，才能保证进行了require hook。所以 server.js 文件变成了回调，需要新增额外的入口文件。\n\n3. 增加mian.js\n\n````javascript\nvar WebpackIsomorphicTools = require('webpack-isomorphic-tools');\n\nglobal.webpackIsomorphicTools = new WebpackIsomorphicTools(require('./webpack-isomorphic-config'))\n    .server('./', function () {\n        //回调\n        require('./server.js') //启动 server\n  })\n````\n同时修改启动脚本\n````javascript\n\"scripts\": {\n  \"start\": \"npm run build && babel-node ./main.js --presets es2015,stage-0,react\",\n  \"build\": \"webpack\"\n},\n````\n启动，会先生成 webpack-assets.json 文件, 通过映射关系可以正确处理非 js 文件。\n````javascript\n{\n  \"javascript\": {\n    \"app\": \"app.js\"\n  },\n  \"styles\": {},\n  \"assets\": {\n    \"./src/assets/img/hat.jpg\": \"a80196c0daaadce1c8ef8446cc8212d5.jpg\"\n  },\n  \"webpack\": {\n    \"version\": \"4.29.6\"\n  }\n}\n````\n这样子页面也能正确加载图片了。\n\n![服务端渲染](https://i.loli.net/2019/03/22/5c9495e4cd31b.png)\n\n带来的问题: webpack-isomorphic-tools 这种 hook 方式，将整个Express Server置于自身的回调中，仿佛劫持了整个server，总不是显得那么的优雅。\n## 源码地址\n\n* [react-ssr](https://github.com/60kmlh/react-ssr)\n\n## 参考资料\n\n* [如何用 React 做服务端渲染](https://juejin.im/post/5c18c34ef265da615114ae78)\n* [React16.x中的服务端渲染（SSR）](https://juejin.im/post/5b399412e51d4558dc4ae82d)\n* [ReactDOMServer](https://zh-hans.reactjs.org/docs/react-dom-server.html)\n* [react中出现的\"hydrate\"这个单词到底是什么意思?](https://www.zhihu.com/question/66068748)\n* [webpack-isomorphic-tools](https://github.com/catamphetamine/webpack-isomorphic-tools)\n","source":"_posts/React服务端渲染的实现.md","raw":"---\ntitle: react服务端渲染的实现\ndate: 2018-08-11\ntags: ['react', 'js', 'ssr']\ncategories: ['react']\n---\n## 什么时候需要服务端渲染（Server Side Render）\n1. 现代前端应用的页面内容由ajax请求数据之后，再在客户端进行页面的动态渲染，而一般搜索引擎或网页爬虫只对ajax渲染前的HTML文件进行爬取，这种形式不利于网站的SEO。\n2. 单页应用通过请求js和ajax请求数据之后，再进行页面结构和数据的渲染，降低了首屏的展示速度。\n<!--more-->\n因此，通过服务端渲染的方式，将渲染结果以HTML结构的形式返回给客户端，可以优化以上两个主要的问题。\n\n## react中和SSR相关的API\n* renderToString()\n\n将 React 元素渲染为初始 HTML。React 将返回一个 HTML 字符串。你可以使用此方法在服务端生成 HTML。\n* renderToStaticMarkup()\n\n此方法与 renderToString 相似，但此方法不会在 React 内部创建的额外 DOM 属性，例如 data-reactroot。如果你希望把 React 当作静态页面生成器来使用，此方法会非常有用，因为去除额外的属性可以节省一些字节。\n\n如果你计划在前端使用 React 以使得标记可交互，请不要使用此方法。你可以在服务端上使用 renderToString 或在前端上使用 ReactDOM.hydrate() 来代替此方法。\n\n**以上两个API可以被使用在服务端和浏览器环境。**\n\n**下述附加方法依赖一个只能在服务端使用的 package（stream）。它们在浏览器中不起作用。**\n* renderToNodeStream()\n\n将一个 React 元素渲染成其初始 HTML。返回一个可输出 HTML 字符串的可读流。通过可读流输出的 HTML 完全等同于 ReactDOMServer.renderToString 返回的 HTML。\n* renderToStaticNodeStream()\n\n此方法与 renderToNodeStream 相似，但此方法不会在 React 内部创建的额外 DOM 属性，例如 data-reactroot。如果你希望把 React 当作静态页面生成器来使用，此方法会非常有用，因为去除额外的属性可以节省一些字节。\n## 实现\n\n下面借助 renderToString() 方法实现一个简单的服务端渲染例子。\n### 引入服务端框架\n这里我们采用 express 框架。\n新建一个 React 组件.\n\n**App.js**\n````javascript\nimport React, { Component } from 'react'\n\nclass App extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      count: 0\n    }\n  }\n  \n  render() {\n    return (\n      <div>\n        首页\n        <div>\n          <button onClick={() => {this.setState({count: this.state.count + 1})}}>+</button>\n          <div>{this.state.count}</div>\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default App\n````\n**server.js**\n\n````javascript\nimport express from 'express'\nimport fs from 'fs'\nimport path from 'path'\nimport { renderToString } from 'react-dom/server'\nimport React from 'react'\nimport App from './src/App'\n\nvar app = express()\n\napp.get('/*', (req, res) => {\n  const renderedString = renderToString(\n        <App/>\n    )\n\n  fs.readFile(path.resolve('index.html'), 'utf8', (error, data) => {\n    if(error) {\n      console.log(error)\n      res.send('<p>Error!</p>')\n      return false\n    }\n    console\n    res.send(`${data.replace('<div id=\"app\"></div>', `<div id=\"app\">${renderedString}</div>`)}`)\n  })\n})\n\napp.listen(8000)\n````\n然后运行 node server.js。这个时候会发现，启动报错。原因在于我们在 node 里面使用了 ES6 Module 和 React JSX，node并不支持。\n\n引入 babel-node 来解决这个问题。\n\n安装完成 babel-node 以及 babel-core，babel-cli，babel-preset-react 等相关工具之后，执行\n````javascript\n\"scripts\": {\n  \"start\": \"babel-node ./server.js --presets es2015,stage-0,react\"\n},\n````\n访问 localhost:8000,就可以看到页面效果了。\n\n![服务端渲染](https://i.loli.net/2019/03/22/5c944d96a9ea0.png)\n### 客户端React组件的实例化\n上面的App组件中，点击 + 按钮，并不会生效，这个页面只是一个静态的HTML页面，没有在客户端渲染React组件并初始化React实例。只有在初始化React实例后，才能更新组件的state和props，初始化React的事件系统，执行虚拟DOM的重新渲染机制。\n\n那么这里可能会有疑问，服务器端已经渲染了一次React组件，如果在客户端中再渲染一次 React 组件，会不会渲染两次 React 组件。答案当然是不会的。\n\n在 React16 版本以前，如果使用renderToString渲染组件，会在组件的第一个DOM带有data-react-checksum属性，当客户端渲染React组件时，首先计算出组件的checksum值，然后检索HTML DOM看看是否存在数值相同的data-react-checksum属性，如果存在，则组件只会渲染一次，如果不存在，则会抛出一个warning异常。\n\n也就是说，当服务器端和客户端渲染具有相同的props和相同DOM结构的组件时，该React组件只会渲染一次。\n\n在服务器端使用renderToStaticMarkup渲染的组件不会带有data-react-checksum属性，此时客户端会重新渲染组件，覆盖掉服务器端的组件。因此，当页面不是渲染一个静态的页面时，最好还是使用renderToString方法。\n\n接着根据 data-reactid 属性，找到需要绑定的事件元素，进行事件绑定的处理。\n\n> React v16 版本里，ReactDOMServer 渲染的内容不再有 data-react 的属性，而是尽可能复用 SSR 的 HTML 结构。这就带来了一个问题，ReactDOM.render 不再能够简单地用 data-react-checksum 的存在性来判断是否应该尝试复用，如果每次 ReactDOM.render 都要尽可能尝试复用，性能和语义都会出现问题。所以， ReactDOM 提供了一个新的 API， ReactDOM.hydrate() 。\n> 在 React v17 版本里，ReactDOM.render 则直接不再具有复用 SSR 内容的功能。\n\n实践发现，v16 版本里面，render() 方法会将整个 DOM 结构重新渲染， 而使用 hydrate 则不会。\n\n加上在客户端渲染的代码\n**index.js**\n\n````javascript\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport { BrowserRouter } from 'react-router-dom'\nimport App from './App'\n\nReactDOM.render(\n  <App />\n, document.getElementById('app'))\n````\n这个时候，我们需要引入 webpack，将要在客户端执行的代码用 webpack 打包到 dist 文件夹。\n\n````javascript\n\"scripts\": {\n  \"start\": \"npm run build && babel-node ./server.js --presets es2015,stage-0,react\",\n  \"build\": \"webpack\"\n},\n````\n在 html 模板里手动引入js，\n````html\n<body>\n  <div id=\"app\"></div>\n</body>\n<script src=\"dist/app.js\"></script>\n````\n再次启动项目，这个时候会发现，请求回来的 app.js 的内容变成了 html.index 文件。\n\n![服务端渲染](https://i.loli.net/2019/03/22/5c944e3cb98ad.png)\n原因在于请求 /dist/app.js 被当成了普通的路由了，没有被当成一个静态资源来返回有效的 JavaScript 代码，解决方案就是在 express 中添加一个静态资源服务。\n````javascript\nvar app = express()\napp.use(express.static('dist'));\n````\n同时将 html 的 script 路径修改下，\n````html\n<body>\n  <div id=\"app\"></div>\n</body>\n<script src=\"/app.js\"></script>\n````\n这样就可以客户端就可以正确地获取到 app.js 的内容了，然后在客户端进行 React 组件的实例化，这个时候点击 + 按钮也有效果了。\n### 路由\n接下来添加路由功能\n\n服务端匹配路由的时候，不能用 BrowserRouter，要使用无状态的 StaticRouter，并结合 location 和 context 两个属性。\n\n给App组件添加路由。\n\n**App.js**\n````javascript\nimport { Switch, Route, Link } from 'react-router-dom' \nimport PageA from './component/PageA'\nimport PageB from './component/PageB'\n//...\n  render() {\n    return (\n      <div>\n        首页\n        <div>\n          <button onClick={() => {this.setState({count: this.state.count + 1})}}>+</button>\n          <div>{this.state.count}</div>\n        </div>\n        <Link to='/'>跳转到pageA</Link>\n        <br/>\n        <Link to='/pageb'>跳转到pageB</Link>\n        <Switch>\n          <Route exact path=\"/\" component={ PageA } />\n          <Route exact path=\"/pageb\" component={ PageB } />\n        </Switch>\n      </div>\n    )\n  }\n//...\n````\n服务端加入路由匹配。这里默认浏览器 url 和 配置的路由地址一样，也可以把路由抽成单独的配置文件，借助 react-router-dom 路由模块的 matchPath 方法来匹配路由。\n\n**server.js**\n````javascript\nimport { StaticRouter } from 'react-router-dom'\n\napp.get('/*', (req, res) => {\n  const renderedString = renderToString(\n    <StaticRouter location={ req.url }>\n      <App />\n    </StaticRouter>\n  )\n  //...\n})\n````\n可以看到，已经实现了路由功能。\n\n![服务端渲染](https://i.loli.net/2019/03/22/5c9455e9e0e31.png)\n![服务端渲染](https://i.loli.net/2019/03/22/5c9455e9df280.png)\n\n### 服务端异步获取数据\n当服务端渲染的html文件数据需要通过请求另外的接口获取时，这个时候就需要服务端去请求数据，再将渲染完的 html 页面返回给客户端。\n\n模拟接口返回数据。\n\n**fetchData.js**\n````javascript\nexport function getInitCount() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(10)\n    }, 3000)\n  })\n}\n````\n服务端请求完数据之后，需要将给数据 React 组件使用。可以采用两种方式：\n\n1. 通过 React 组件的 props 传入。\n2. 通过 Router 的 context 传入，React 组件中再通过 props.staticContext 获取到。\n\n**server.js**\n````javascript\nimport { getInitCount } from './src/utils/fetchData'\n//...\napp.get('/*', (req, res) => {\n  const renderedString = renderToString(\n    <StaticRouter location={ req.url }>\n      <App initCount={resData} />\n    </StaticRouter>\n  )\n  //...\n})\n````\n**App.js**\n````javascript\nclass App extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      count: props.initCount || 0\n    }\n  }\n  //...\n}\n````\n这样可以看到服务器返回的 html 文件内容，已经将 count 的初始值 10 渲染进去了。\n\n![服务端渲染](https://i.loli.net/2019/03/22/5c948522154ca.jpg)\n\n但是此时页面显示的count值还是0，原因在于虽然使用了 hydrate() 方法，并不会将 html 结构重新渲染，但是 React 组件还是会走一遍生命周期流程，App 组件的 props.initCount 依旧是 0。\n\n为了让客户端和服务端的props保持一致，需要将一个服务器生成的首屏 props 赋给客户端的全局变量。\n\n修改下server.js 和 index.js\n````javascript\napp.get('/*', (req, res) => {\n  getInitCount().then(resData => {\n    const renderedString = renderToString(\n        <StaticRouter location={req.url}>\n          <App initCount={resData} />\n        </StaticRouter>\n      )\n  \n    fs.readFile(path.resolve('index.html'), 'utf8', (error, data) => {\n      //...\n\n      res.send(`${data\n        .replace('<div id=\"app\"></div>', `<div id=\"app\">${renderedString}</div>`)\n        .replace('</body>', `</body><script>window.__initCount__ = ${JSON.stringify(resData)}</script>`)}`)\n    })\n  })\n})\n````\n````javascript\nReactDOM.hydrate(\n    <BrowserRouter>\n        <App initCount={window.__initCount__} />\n    </BrowserRouter>\n    , document.getElementById('app'))\n````\n注意 window.__initCount__ 需要在 app.js 前面加载。\n\n![服务端渲染](https://i.loli.net/2019/03/22/5c9487b39b46b.png)\n\n### 服务端无法支持图片、css等资源文件\n如果代码中我们 import 了图片, svg, css 等非 js 资源，在客户端 webpack 的各种 loader 帮我们处理了这些资源，而 node 环境下只能识别 js。由于之前的例子没有引入额外的静态资源，所以没有出现这样的问题。\n\n试着在 pageB 组件中引入图片。\n````javascript\nrender() {\n  return (\n    <div>\n      <div>B页面</div>\n      <img src={require('../assets/img/hat.jpg')} alt=\"\"/>\n    </div>\n  )\n}\n````\n\n运行便报错了。\n\n引入 webpack-isomorphic-tools 工具来解决这个问题。\n\nwebpack-isomorphic-tools 完成了两件事：\n\n1. 以webpack插件的形式，预编译less（不局限于less，还支持图片文件、字体文件等），将其转换为一个 assets.json 文件保存到项目目录下。\n2. require hook，所有less文件的引入，代理到生成的 JSON 文件中，匹配文件路径，返回一个预先编译好的 JSON 对象。\n\n实现步骤：\n1. 修改webpack.config.js\n\n````javascript\nvar WebpackIsomorphicToolsPlugin = require('webpack-isomorphic-tools/plugin')\n\nvar webpackIsomorphicToolsPlugin = \n  // webpack-isomorphic-tools settings reside in a separate .js file \n  // (because they will be used in the web server code too).\n  new WebpackIsomorphicToolsPlugin(require('./webpack-isomorphic-tools-configuration'))\n  // also enter development mode since it's a development webpack configuration\n  // (see below for explanation)\n  .development()\n\n// usual Webpack configuration\nmodule.exports =\n{\n  context: '(required) your project path here',\n  module:\n  {\n    loaders:\n    [\n      //...,\n      {\n        test: webpackIsomorphicToolsPlugin.regularExpression('images'),\n        loader: 'url-loader?limit=1024', // any image below or equal to 10K will be converted to inline base64 instead\n      }\n    ]\n  },\n\n  plugins:\n  [\n    //...,\n    webpackIsomorphicToolsPlugin\n  ]\n  //...\n}\n````\n2. 添加 webpack-isomorphic-tools 配置文件 webpack-isomorphic-config.js\n\n````javascript\nmodule.exports = \n{\n  assets:\n  {\n    images:\n    {\n      extensions: ['png', 'jpg', 'gif', 'ico', 'svg']\n    }\n  }\n}\n````\n\nwebpack-isomorphic-tools 启动时，会先等待指定目录下 assets.json 文件生成，只有该文件就绪后，require hook 才会进行，进而触发 server 回调，只有在此回调中执行的代码，才能保证进行了require hook。所以 server.js 文件变成了回调，需要新增额外的入口文件。\n\n3. 增加mian.js\n\n````javascript\nvar WebpackIsomorphicTools = require('webpack-isomorphic-tools');\n\nglobal.webpackIsomorphicTools = new WebpackIsomorphicTools(require('./webpack-isomorphic-config'))\n    .server('./', function () {\n        //回调\n        require('./server.js') //启动 server\n  })\n````\n同时修改启动脚本\n````javascript\n\"scripts\": {\n  \"start\": \"npm run build && babel-node ./main.js --presets es2015,stage-0,react\",\n  \"build\": \"webpack\"\n},\n````\n启动，会先生成 webpack-assets.json 文件, 通过映射关系可以正确处理非 js 文件。\n````javascript\n{\n  \"javascript\": {\n    \"app\": \"app.js\"\n  },\n  \"styles\": {},\n  \"assets\": {\n    \"./src/assets/img/hat.jpg\": \"a80196c0daaadce1c8ef8446cc8212d5.jpg\"\n  },\n  \"webpack\": {\n    \"version\": \"4.29.6\"\n  }\n}\n````\n这样子页面也能正确加载图片了。\n\n![服务端渲染](https://i.loli.net/2019/03/22/5c9495e4cd31b.png)\n\n带来的问题: webpack-isomorphic-tools 这种 hook 方式，将整个Express Server置于自身的回调中，仿佛劫持了整个server，总不是显得那么的优雅。\n## 源码地址\n\n* [react-ssr](https://github.com/60kmlh/react-ssr)\n\n## 参考资料\n\n* [如何用 React 做服务端渲染](https://juejin.im/post/5c18c34ef265da615114ae78)\n* [React16.x中的服务端渲染（SSR）](https://juejin.im/post/5b399412e51d4558dc4ae82d)\n* [ReactDOMServer](https://zh-hans.reactjs.org/docs/react-dom-server.html)\n* [react中出现的\"hydrate\"这个单词到底是什么意思?](https://www.zhihu.com/question/66068748)\n* [webpack-isomorphic-tools](https://github.com/catamphetamine/webpack-isomorphic-tools)\n","slug":"React服务端渲染的实现","published":1,"updated":"2022-04-13T14:14:07.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvff7001ag3t859em7e60","content":"<h2 id=\"什么时候需要服务端渲染（Server-Side-Render）\"><a href=\"#什么时候需要服务端渲染（Server-Side-Render）\" class=\"headerlink\" title=\"什么时候需要服务端渲染（Server Side Render）\"></a>什么时候需要服务端渲染（Server Side Render）</h2><ol>\n<li>现代前端应用的页面内容由ajax请求数据之后，再在客户端进行页面的动态渲染，而一般搜索引擎或网页爬虫只对ajax渲染前的HTML文件进行爬取，这种形式不利于网站的SEO。</li>\n<li>单页应用通过请求js和ajax请求数据之后，再进行页面结构和数据的渲染，降低了首屏的展示速度。<a id=\"more\"></a>\n因此，通过服务端渲染的方式，将渲染结果以HTML结构的形式返回给客户端，可以优化以上两个主要的问题。</li>\n</ol>\n<h2 id=\"react中和SSR相关的API\"><a href=\"#react中和SSR相关的API\" class=\"headerlink\" title=\"react中和SSR相关的API\"></a>react中和SSR相关的API</h2><ul>\n<li>renderToString()</li>\n</ul>\n<p>将 React 元素渲染为初始 HTML。React 将返回一个 HTML 字符串。你可以使用此方法在服务端生成 HTML。</p>\n<ul>\n<li>renderToStaticMarkup()</li>\n</ul>\n<p>此方法与 renderToString 相似，但此方法不会在 React 内部创建的额外 DOM 属性，例如 data-reactroot。如果你希望把 React 当作静态页面生成器来使用，此方法会非常有用，因为去除额外的属性可以节省一些字节。</p>\n<p>如果你计划在前端使用 React 以使得标记可交互，请不要使用此方法。你可以在服务端上使用 renderToString 或在前端上使用 ReactDOM.hydrate() 来代替此方法。</p>\n<p><strong>以上两个API可以被使用在服务端和浏览器环境。</strong></p>\n<p><strong>下述附加方法依赖一个只能在服务端使用的 package（stream）。它们在浏览器中不起作用。</strong></p>\n<ul>\n<li>renderToNodeStream()</li>\n</ul>\n<p>将一个 React 元素渲染成其初始 HTML。返回一个可输出 HTML 字符串的可读流。通过可读流输出的 HTML 完全等同于 ReactDOMServer.renderToString 返回的 HTML。</p>\n<ul>\n<li>renderToStaticNodeStream()</li>\n</ul>\n<p>此方法与 renderToNodeStream 相似，但此方法不会在 React 内部创建的额外 DOM 属性，例如 data-reactroot。如果你希望把 React 当作静态页面生成器来使用，此方法会非常有用，因为去除额外的属性可以节省一些字节。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>下面借助 renderToString() 方法实现一个简单的服务端渲染例子。</p>\n<h3 id=\"引入服务端框架\"><a href=\"#引入服务端框架\" class=\"headerlink\" title=\"引入服务端框架\"></a>引入服务端框架</h3><p>这里我们采用 express 框架。<br>新建一个 React 组件.</p>\n<p><strong>App.js</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      count: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        首页</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &lt;button onClick=&#123;() =&gt; &#123;<span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">count</span>: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span>&#125;)&#125;&#125;&gt;+&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;div&gt;&#123;this.state.count&#125;&lt;/</span>div&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App</span><br></pre></td></tr></table></figure></p>\n<p><strong>server.js</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> express <span class=\"keyword\">from</span> <span class=\"string\">'express'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> fs <span class=\"keyword\">from</span> <span class=\"string\">'fs'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> path <span class=\"keyword\">from</span> <span class=\"string\">'path'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; renderToString &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-dom/server'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./src/App'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express()</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/*'</span>, (req, res) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> renderedString = renderToString(</span><br><span class=\"line\">        &lt;App/&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">  fs.readFile(path.resolve(<span class=\"string\">'index.html'</span>), <span class=\"string\">'utf8'</span>, (error, data) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(error) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(error)</span><br><span class=\"line\">      res.send(<span class=\"string\">'&lt;p&gt;Error!&lt;/p&gt;'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span></span><br><span class=\"line\">    res.send(<span class=\"string\">`<span class=\"subst\">$&#123;data.replace(<span class=\"string\">'&lt;div id=\"app\"&gt;&lt;/div&gt;'</span>, <span class=\"string\">`&lt;div id=\"app\"&gt;<span class=\"subst\">$&#123;renderedString&#125;</span>&lt;/div&gt;`</span>)&#125;</span>`</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">8000</span>)</span><br></pre></td></tr></table></figure>\n<p>然后运行 node server.js。这个时候会发现，启动报错。原因在于我们在 node 里面使用了 ES6 Module 和 React JSX，node并不支持。</p>\n<p>引入 babel-node 来解决这个问题。</p>\n<p>安装完成 babel-node 以及 babel-core，babel-cli，babel-preset-react 等相关工具之后，执行<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"start\"</span>: <span class=\"string\">\"babel-node ./server.js --presets es2015,stage-0,react\"</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>访问 localhost:8000,就可以看到页面效果了。</p>\n<p><img src=\"https://i.loli.net/2019/03/22/5c944d96a9ea0.png\" alt=\"服务端渲染\"></p>\n<h3 id=\"客户端React组件的实例化\"><a href=\"#客户端React组件的实例化\" class=\"headerlink\" title=\"客户端React组件的实例化\"></a>客户端React组件的实例化</h3><p>上面的App组件中，点击 + 按钮，并不会生效，这个页面只是一个静态的HTML页面，没有在客户端渲染React组件并初始化React实例。只有在初始化React实例后，才能更新组件的state和props，初始化React的事件系统，执行虚拟DOM的重新渲染机制。</p>\n<p>那么这里可能会有疑问，服务器端已经渲染了一次React组件，如果在客户端中再渲染一次 React 组件，会不会渲染两次 React 组件。答案当然是不会的。</p>\n<p>在 React16 版本以前，如果使用renderToString渲染组件，会在组件的第一个DOM带有data-react-checksum属性，当客户端渲染React组件时，首先计算出组件的checksum值，然后检索HTML DOM看看是否存在数值相同的data-react-checksum属性，如果存在，则组件只会渲染一次，如果不存在，则会抛出一个warning异常。</p>\n<p>也就是说，当服务器端和客户端渲染具有相同的props和相同DOM结构的组件时，该React组件只会渲染一次。</p>\n<p>在服务器端使用renderToStaticMarkup渲染的组件不会带有data-react-checksum属性，此时客户端会重新渲染组件，覆盖掉服务器端的组件。因此，当页面不是渲染一个静态的页面时，最好还是使用renderToString方法。</p>\n<p>接着根据 data-reactid 属性，找到需要绑定的事件元素，进行事件绑定的处理。</p>\n<blockquote>\n<p>React v16 版本里，ReactDOMServer 渲染的内容不再有 data-react 的属性，而是尽可能复用 SSR 的 HTML 结构。这就带来了一个问题，ReactDOM.render 不再能够简单地用 data-react-checksum 的存在性来判断是否应该尝试复用，如果每次 ReactDOM.render 都要尽可能尝试复用，性能和语义都会出现问题。所以， ReactDOM 提供了一个新的 API， ReactDOM.hydrate() 。<br>在 React v17 版本里，ReactDOM.render 则直接不再具有复用 SSR 内容的功能。</p>\n</blockquote>\n<p>实践发现，v16 版本里面，render() 方法会将整个 DOM 结构重新渲染， 而使用 hydrate 则不会。</p>\n<p>加上在客户端渲染的代码<br><strong>index.js</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; BrowserRouter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router-dom'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span></span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;App /&gt;</span><br><span class=\"line\">, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>))</span><br></pre></td></tr></table></figure>\n<p>这个时候，我们需要引入 webpack，将要在客户端执行的代码用 webpack 打包到 dist 文件夹。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"start\"</span>: <span class=\"string\">\"npm run build &amp;&amp; babel-node ./server.js --presets es2015,stage-0,react\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"build\"</span>: <span class=\"string\">\"webpack\"</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>在 html 模板里手动引入js，<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"dist/app.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>再次启动项目，这个时候会发现，请求回来的 app.js 的内容变成了 html.index 文件。</p>\n<p><img src=\"https://i.loli.net/2019/03/22/5c944e3cb98ad.png\" alt=\"服务端渲染\"><br>原因在于请求 /dist/app.js 被当成了普通的路由了，没有被当成一个静态资源来返回有效的 JavaScript 代码，解决方案就是在 express 中添加一个静态资源服务。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = express()</span><br><span class=\"line\">app.use(express.static(<span class=\"string\">'dist'</span>));</span><br></pre></td></tr></table></figure></p>\n<p>同时将 html 的 script 路径修改下，<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/app.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这样就可以客户端就可以正确地获取到 app.js 的内容了，然后在客户端进行 React 组件的实例化，这个时候点击 + 按钮也有效果了。</p>\n<h3 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h3><p>接下来添加路由功能</p>\n<p>服务端匹配路由的时候，不能用 BrowserRouter，要使用无状态的 StaticRouter，并结合 location 和 context 两个属性。</p>\n<p>给App组件添加路由。</p>\n<p><strong>App.js</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Switch, Route, Link &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router-dom'</span> </span><br><span class=\"line\"><span class=\"keyword\">import</span> PageA <span class=\"keyword\">from</span> <span class=\"string\">'./component/PageA'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> PageB <span class=\"keyword\">from</span> <span class=\"string\">'./component/PageB'</span></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        首页</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &lt;button onClick=&#123;() =&gt; &#123;<span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">count</span>: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span>&#125;)&#125;&#125;&gt;+&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;div&gt;&#123;this.state.count&#125;&lt;/</span>div&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;Link to='/</span><span class=\"string\">'&gt;跳转到pageA&lt;/Link&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;Link to='</span>/pageb<span class=\"string\">'&gt;跳转到pageB&lt;/Link&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;Switch&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;Route exact path=\"/\" component=&#123; PageA &#125; /&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;Route exact path=\"/pageb\" component=&#123; PageB &#125; /&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/Switch&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    )</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">//...</span></span><br></pre></td></tr></table></figure></p>\n<p>服务端加入路由匹配。这里默认浏览器 url 和 配置的路由地址一样，也可以把路由抽成单独的配置文件，借助 react-router-dom 路由模块的 matchPath 方法来匹配路由。</p>\n<p><strong>server.js</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; StaticRouter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router-dom'</span></span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/*'</span>, (req, res) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> renderedString = renderToString(</span><br><span class=\"line\">    &lt;StaticRouter location=&#123; req.url &#125;&gt;</span><br><span class=\"line\">      &lt;App /&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/StaticRouter&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/...</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;)</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到，已经实现了路由功能。</p>\n<p><img src=\"https://i.loli.net/2019/03/22/5c9455e9e0e31.png\" alt=\"服务端渲染\"><br><img src=\"https://i.loli.net/2019/03/22/5c9455e9df280.png\" alt=\"服务端渲染\"></p>\n<h3 id=\"服务端异步获取数据\"><a href=\"#服务端异步获取数据\" class=\"headerlink\" title=\"服务端异步获取数据\"></a>服务端异步获取数据</h3><p>当服务端渲染的html文件数据需要通过请求另外的接口获取时，这个时候就需要服务端去请求数据，再将渲染完的 html 页面返回给客户端。</p>\n<p>模拟接口返回数据。</p>\n<p><strong>fetchData.js</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getInitCount</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      resolve(<span class=\"number\">10</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>服务端请求完数据之后，需要将给数据 React 组件使用。可以采用两种方式：</p>\n<ol>\n<li>通过 React 组件的 props 传入。</li>\n<li>通过 Router 的 context 传入，React 组件中再通过 props.staticContext 获取到。</li>\n</ol>\n<p><strong>server.js</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; getInitCount &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./src/utils/fetchData'</span></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">app.get(<span class=\"string\">'/*'</span>, (req, res) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> renderedString = renderToString(</span><br><span class=\"line\">    &lt;StaticRouter location=&#123; req.url &#125;&gt;</span><br><span class=\"line\">      &lt;App initCount=&#123;resData&#125; /&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/StaticRouter&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/...</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;)</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>App.js</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      count: props.initCount || <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样可以看到服务器返回的 html 文件内容，已经将 count 的初始值 10 渲染进去了。</p>\n<p><img src=\"https://i.loli.net/2019/03/22/5c948522154ca.jpg\" alt=\"服务端渲染\"></p>\n<p>但是此时页面显示的count值还是0，原因在于虽然使用了 hydrate() 方法，并不会将 html 结构重新渲染，但是 React 组件还是会走一遍生命周期流程，App 组件的 props.initCount 依旧是 0。</p>\n<p>为了让客户端和服务端的props保持一致，需要将一个服务器生成的首屏 props 赋给客户端的全局变量。</p>\n<p>修改下server.js 和 index.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.get(<span class=\"string\">'/*'</span>, (req, res) =&gt; &#123;</span><br><span class=\"line\">  getInitCount().then(<span class=\"function\"><span class=\"params\">resData</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> renderedString = renderToString(</span><br><span class=\"line\">        &lt;StaticRouter location=&#123;req.url&#125;&gt;</span><br><span class=\"line\">          &lt;App initCount=&#123;resData&#125; /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/StaticRouter&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      )</span></span><br><span class=\"line\"><span class=\"regexp\">  </span></span><br><span class=\"line\"><span class=\"regexp\">    fs.readFile(path.resolve('index.html'), 'utf8', (error, data) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      /</span><span class=\"regexp\">/...</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">      res.send(`$&#123;data</span></span><br><span class=\"line\"><span class=\"regexp\">        .replace('&lt;div id=\"app\"&gt;&lt;/</span>div&gt;<span class=\"string\">', `&lt;div id=\"app\"&gt;$&#123;renderedString&#125;&lt;/div&gt;`)</span></span><br><span class=\"line\"><span class=\"string\">        .replace('</span>&lt;<span class=\"regexp\">/body&gt;', `&lt;/</span>body&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"built_in\">window</span>.__initCount__ = $&#123;<span class=\"built_in\">JSON</span>.stringify(resData)&#125;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><span class=\"string\">`)&#125;`</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReactDOM.hydrate(</span><br><span class=\"line\">    &lt;BrowserRouter&gt;</span><br><span class=\"line\">        &lt;App initCount=&#123;<span class=\"built_in\">window</span>.__initCount__&#125; /&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/BrowserRouter&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    , document.getElementById('app'))</span></span><br></pre></td></tr></table></figure>\n<p>注意 window.<strong>initCount</strong> 需要在 app.js 前面加载。</p>\n<p><img src=\"https://i.loli.net/2019/03/22/5c9487b39b46b.png\" alt=\"服务端渲染\"></p>\n<h3 id=\"服务端无法支持图片、css等资源文件\"><a href=\"#服务端无法支持图片、css等资源文件\" class=\"headerlink\" title=\"服务端无法支持图片、css等资源文件\"></a>服务端无法支持图片、css等资源文件</h3><p>如果代码中我们 import 了图片, svg, css 等非 js 资源，在客户端 webpack 的各种 loader 帮我们处理了这些资源，而 node 环境下只能识别 js。由于之前的例子没有引入额外的静态资源，所以没有出现这样的问题。</p>\n<p>试着在 pageB 组件中引入图片。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;div&gt;B页面&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;img src=&#123;require('../</span>assets/img/hat.jpg<span class=\"string\">')&#125; alt=\"\"/&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  )</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>运行便报错了。</p>\n<p>引入 webpack-isomorphic-tools 工具来解决这个问题。</p>\n<p>webpack-isomorphic-tools 完成了两件事：</p>\n<ol>\n<li>以webpack插件的形式，预编译less（不局限于less，还支持图片文件、字体文件等），将其转换为一个 assets.json 文件保存到项目目录下。</li>\n<li>require hook，所有less文件的引入，代理到生成的 JSON 文件中，匹配文件路径，返回一个预先编译好的 JSON 对象。</li>\n</ol>\n<p>实现步骤：</p>\n<ol>\n<li>修改webpack.config.js</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> WebpackIsomorphicToolsPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-isomorphic-tools/plugin'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> webpackIsomorphicToolsPlugin = </span><br><span class=\"line\">  <span class=\"comment\">// webpack-isomorphic-tools settings reside in a separate .js file </span></span><br><span class=\"line\">  <span class=\"comment\">// (because they will be used in the web server code too).</span></span><br><span class=\"line\">  <span class=\"keyword\">new</span> WebpackIsomorphicToolsPlugin(<span class=\"built_in\">require</span>(<span class=\"string\">'./webpack-isomorphic-tools-configuration'</span>))</span><br><span class=\"line\">  <span class=\"comment\">// also enter development mode since it's a development webpack configuration</span></span><br><span class=\"line\">  <span class=\"comment\">// (see below for explanation)</span></span><br><span class=\"line\">  .development()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// usual Webpack configuration</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports =</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  context: <span class=\"string\">'(required) your project path here'</span>,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>:</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    loaders:</span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"comment\">//...,</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: webpackIsomorphicToolsPlugin.regularExpression(<span class=\"string\">'images'</span>),</span><br><span class=\"line\">        loader: <span class=\"string\">'url-loader?limit=1024'</span>, <span class=\"comment\">// any image below or equal to 10K will be converted to inline base64 instead</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  plugins:</span><br><span class=\"line\">  [</span><br><span class=\"line\">    <span class=\"comment\">//...,</span></span><br><span class=\"line\">    webpackIsomorphicToolsPlugin</span><br><span class=\"line\">  ]</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>添加 webpack-isomorphic-tools 配置文件 webpack-isomorphic-config.js</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  assets:</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    images:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      extensions: [<span class=\"string\">'png'</span>, <span class=\"string\">'jpg'</span>, <span class=\"string\">'gif'</span>, <span class=\"string\">'ico'</span>, <span class=\"string\">'svg'</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>webpack-isomorphic-tools 启动时，会先等待指定目录下 assets.json 文件生成，只有该文件就绪后，require hook 才会进行，进而触发 server 回调，只有在此回调中执行的代码，才能保证进行了require hook。所以 server.js 文件变成了回调，需要新增额外的入口文件。</p>\n<ol start=\"3\">\n<li>增加mian.js</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> WebpackIsomorphicTools = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-isomorphic-tools'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">global.webpackIsomorphicTools = <span class=\"keyword\">new</span> WebpackIsomorphicTools(<span class=\"built_in\">require</span>(<span class=\"string\">'./webpack-isomorphic-config'</span>))</span><br><span class=\"line\">    .server(<span class=\"string\">'./'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//回调</span></span><br><span class=\"line\">        <span class=\"built_in\">require</span>(<span class=\"string\">'./server.js'</span>) <span class=\"comment\">//启动 server</span></span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>同时修改启动脚本<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"start\"</span>: <span class=\"string\">\"npm run build &amp;&amp; babel-node ./main.js --presets es2015,stage-0,react\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"build\"</span>: <span class=\"string\">\"webpack\"</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>启动，会先生成 webpack-assets.json 文件, 通过映射关系可以正确处理非 js 文件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"javascript\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"app\"</span>: <span class=\"string\">\"app.js\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"styles\"</span>: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"string\">\"assets\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"./src/assets/img/hat.jpg\"</span>: <span class=\"string\">\"a80196c0daaadce1c8ef8446cc8212d5.jpg\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"webpack\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"version\"</span>: <span class=\"string\">\"4.29.6\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样子页面也能正确加载图片了。</p>\n<p><img src=\"https://i.loli.net/2019/03/22/5c9495e4cd31b.png\" alt=\"服务端渲染\"></p>\n<p>带来的问题: webpack-isomorphic-tools 这种 hook 方式，将整个Express Server置于自身的回调中，仿佛劫持了整个server，总不是显得那么的优雅。</p>\n<h2 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a>源码地址</h2><ul>\n<li><a href=\"https://github.com/60kmlh/react-ssr\" target=\"_blank\" rel=\"noopener\">react-ssr</a></li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://juejin.im/post/5c18c34ef265da615114ae78\" target=\"_blank\" rel=\"noopener\">如何用 React 做服务端渲染</a></li>\n<li><a href=\"https://juejin.im/post/5b399412e51d4558dc4ae82d\" target=\"_blank\" rel=\"noopener\">React16.x中的服务端渲染（SSR）</a></li>\n<li><a href=\"https://zh-hans.reactjs.org/docs/react-dom-server.html\" target=\"_blank\" rel=\"noopener\">ReactDOMServer</a></li>\n<li><a href=\"https://www.zhihu.com/question/66068748\" target=\"_blank\" rel=\"noopener\">react中出现的”hydrate”这个单词到底是什么意思?</a></li>\n<li><a href=\"https://github.com/catamphetamine/webpack-isomorphic-tools\" target=\"_blank\" rel=\"noopener\">webpack-isomorphic-tools</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么时候需要服务端渲染（Server-Side-Render）\"><a href=\"#什么时候需要服务端渲染（Server-Side-Render）\" class=\"headerlink\" title=\"什么时候需要服务端渲染（Server Side Render）\"></a>什么时候需要服务端渲染（Server Side Render）</h2><ol>\n<li>现代前端应用的页面内容由ajax请求数据之后，再在客户端进行页面的动态渲染，而一般搜索引擎或网页爬虫只对ajax渲染前的HTML文件进行爬取，这种形式不利于网站的SEO。</li>\n<li>单页应用通过请求js和ajax请求数据之后，再进行页面结构和数据的渲染，降低了首屏的展示速度。","more":"因此，通过服务端渲染的方式，将渲染结果以HTML结构的形式返回给客户端，可以优化以上两个主要的问题。</li>\n</ol>\n<h2 id=\"react中和SSR相关的API\"><a href=\"#react中和SSR相关的API\" class=\"headerlink\" title=\"react中和SSR相关的API\"></a>react中和SSR相关的API</h2><ul>\n<li>renderToString()</li>\n</ul>\n<p>将 React 元素渲染为初始 HTML。React 将返回一个 HTML 字符串。你可以使用此方法在服务端生成 HTML。</p>\n<ul>\n<li>renderToStaticMarkup()</li>\n</ul>\n<p>此方法与 renderToString 相似，但此方法不会在 React 内部创建的额外 DOM 属性，例如 data-reactroot。如果你希望把 React 当作静态页面生成器来使用，此方法会非常有用，因为去除额外的属性可以节省一些字节。</p>\n<p>如果你计划在前端使用 React 以使得标记可交互，请不要使用此方法。你可以在服务端上使用 renderToString 或在前端上使用 ReactDOM.hydrate() 来代替此方法。</p>\n<p><strong>以上两个API可以被使用在服务端和浏览器环境。</strong></p>\n<p><strong>下述附加方法依赖一个只能在服务端使用的 package（stream）。它们在浏览器中不起作用。</strong></p>\n<ul>\n<li>renderToNodeStream()</li>\n</ul>\n<p>将一个 React 元素渲染成其初始 HTML。返回一个可输出 HTML 字符串的可读流。通过可读流输出的 HTML 完全等同于 ReactDOMServer.renderToString 返回的 HTML。</p>\n<ul>\n<li>renderToStaticNodeStream()</li>\n</ul>\n<p>此方法与 renderToNodeStream 相似，但此方法不会在 React 内部创建的额外 DOM 属性，例如 data-reactroot。如果你希望把 React 当作静态页面生成器来使用，此方法会非常有用，因为去除额外的属性可以节省一些字节。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>下面借助 renderToString() 方法实现一个简单的服务端渲染例子。</p>\n<h3 id=\"引入服务端框架\"><a href=\"#引入服务端框架\" class=\"headerlink\" title=\"引入服务端框架\"></a>引入服务端框架</h3><p>这里我们采用 express 框架。<br>新建一个 React 组件.</p>\n<p><strong>App.js</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      count: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        首页</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &lt;button onClick=&#123;() =&gt; &#123;<span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">count</span>: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span>&#125;)&#125;&#125;&gt;+&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;div&gt;&#123;this.state.count&#125;&lt;/</span>div&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App</span><br></pre></td></tr></table></figure></p>\n<p><strong>server.js</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> express <span class=\"keyword\">from</span> <span class=\"string\">'express'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> fs <span class=\"keyword\">from</span> <span class=\"string\">'fs'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> path <span class=\"keyword\">from</span> <span class=\"string\">'path'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; renderToString &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-dom/server'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./src/App'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express()</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/*'</span>, (req, res) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> renderedString = renderToString(</span><br><span class=\"line\">        &lt;App/&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">  fs.readFile(path.resolve(<span class=\"string\">'index.html'</span>), <span class=\"string\">'utf8'</span>, (error, data) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(error) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(error)</span><br><span class=\"line\">      res.send(<span class=\"string\">'&lt;p&gt;Error!&lt;/p&gt;'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span></span><br><span class=\"line\">    res.send(<span class=\"string\">`<span class=\"subst\">$&#123;data.replace(<span class=\"string\">'&lt;div id=\"app\"&gt;&lt;/div&gt;'</span>, <span class=\"string\">`&lt;div id=\"app\"&gt;<span class=\"subst\">$&#123;renderedString&#125;</span>&lt;/div&gt;`</span>)&#125;</span>`</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">8000</span>)</span><br></pre></td></tr></table></figure>\n<p>然后运行 node server.js。这个时候会发现，启动报错。原因在于我们在 node 里面使用了 ES6 Module 和 React JSX，node并不支持。</p>\n<p>引入 babel-node 来解决这个问题。</p>\n<p>安装完成 babel-node 以及 babel-core，babel-cli，babel-preset-react 等相关工具之后，执行<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"start\"</span>: <span class=\"string\">\"babel-node ./server.js --presets es2015,stage-0,react\"</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>访问 localhost:8000,就可以看到页面效果了。</p>\n<p><img src=\"https://i.loli.net/2019/03/22/5c944d96a9ea0.png\" alt=\"服务端渲染\"></p>\n<h3 id=\"客户端React组件的实例化\"><a href=\"#客户端React组件的实例化\" class=\"headerlink\" title=\"客户端React组件的实例化\"></a>客户端React组件的实例化</h3><p>上面的App组件中，点击 + 按钮，并不会生效，这个页面只是一个静态的HTML页面，没有在客户端渲染React组件并初始化React实例。只有在初始化React实例后，才能更新组件的state和props，初始化React的事件系统，执行虚拟DOM的重新渲染机制。</p>\n<p>那么这里可能会有疑问，服务器端已经渲染了一次React组件，如果在客户端中再渲染一次 React 组件，会不会渲染两次 React 组件。答案当然是不会的。</p>\n<p>在 React16 版本以前，如果使用renderToString渲染组件，会在组件的第一个DOM带有data-react-checksum属性，当客户端渲染React组件时，首先计算出组件的checksum值，然后检索HTML DOM看看是否存在数值相同的data-react-checksum属性，如果存在，则组件只会渲染一次，如果不存在，则会抛出一个warning异常。</p>\n<p>也就是说，当服务器端和客户端渲染具有相同的props和相同DOM结构的组件时，该React组件只会渲染一次。</p>\n<p>在服务器端使用renderToStaticMarkup渲染的组件不会带有data-react-checksum属性，此时客户端会重新渲染组件，覆盖掉服务器端的组件。因此，当页面不是渲染一个静态的页面时，最好还是使用renderToString方法。</p>\n<p>接着根据 data-reactid 属性，找到需要绑定的事件元素，进行事件绑定的处理。</p>\n<blockquote>\n<p>React v16 版本里，ReactDOMServer 渲染的内容不再有 data-react 的属性，而是尽可能复用 SSR 的 HTML 结构。这就带来了一个问题，ReactDOM.render 不再能够简单地用 data-react-checksum 的存在性来判断是否应该尝试复用，如果每次 ReactDOM.render 都要尽可能尝试复用，性能和语义都会出现问题。所以， ReactDOM 提供了一个新的 API， ReactDOM.hydrate() 。<br>在 React v17 版本里，ReactDOM.render 则直接不再具有复用 SSR 内容的功能。</p>\n</blockquote>\n<p>实践发现，v16 版本里面，render() 方法会将整个 DOM 结构重新渲染， 而使用 hydrate 则不会。</p>\n<p>加上在客户端渲染的代码<br><strong>index.js</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; BrowserRouter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router-dom'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span></span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;App /&gt;</span><br><span class=\"line\">, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>))</span><br></pre></td></tr></table></figure>\n<p>这个时候，我们需要引入 webpack，将要在客户端执行的代码用 webpack 打包到 dist 文件夹。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"start\"</span>: <span class=\"string\">\"npm run build &amp;&amp; babel-node ./server.js --presets es2015,stage-0,react\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"build\"</span>: <span class=\"string\">\"webpack\"</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>在 html 模板里手动引入js，<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"dist/app.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>再次启动项目，这个时候会发现，请求回来的 app.js 的内容变成了 html.index 文件。</p>\n<p><img src=\"https://i.loli.net/2019/03/22/5c944e3cb98ad.png\" alt=\"服务端渲染\"><br>原因在于请求 /dist/app.js 被当成了普通的路由了，没有被当成一个静态资源来返回有效的 JavaScript 代码，解决方案就是在 express 中添加一个静态资源服务。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = express()</span><br><span class=\"line\">app.use(express.static(<span class=\"string\">'dist'</span>));</span><br></pre></td></tr></table></figure></p>\n<p>同时将 html 的 script 路径修改下，<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/app.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>这样就可以客户端就可以正确地获取到 app.js 的内容了，然后在客户端进行 React 组件的实例化，这个时候点击 + 按钮也有效果了。</p>\n<h3 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h3><p>接下来添加路由功能</p>\n<p>服务端匹配路由的时候，不能用 BrowserRouter，要使用无状态的 StaticRouter，并结合 location 和 context 两个属性。</p>\n<p>给App组件添加路由。</p>\n<p><strong>App.js</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Switch, Route, Link &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router-dom'</span> </span><br><span class=\"line\"><span class=\"keyword\">import</span> PageA <span class=\"keyword\">from</span> <span class=\"string\">'./component/PageA'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> PageB <span class=\"keyword\">from</span> <span class=\"string\">'./component/PageB'</span></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        首页</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &lt;button onClick=&#123;() =&gt; &#123;<span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">count</span>: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span>&#125;)&#125;&#125;&gt;+&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;div&gt;&#123;this.state.count&#125;&lt;/</span>div&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;Link to='/</span><span class=\"string\">'&gt;跳转到pageA&lt;/Link&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;Link to='</span>/pageb<span class=\"string\">'&gt;跳转到pageB&lt;/Link&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;Switch&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;Route exact path=\"/\" component=&#123; PageA &#125; /&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;Route exact path=\"/pageb\" component=&#123; PageB &#125; /&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/Switch&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    )</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">//...</span></span><br></pre></td></tr></table></figure></p>\n<p>服务端加入路由匹配。这里默认浏览器 url 和 配置的路由地址一样，也可以把路由抽成单独的配置文件，借助 react-router-dom 路由模块的 matchPath 方法来匹配路由。</p>\n<p><strong>server.js</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; StaticRouter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-router-dom'</span></span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/*'</span>, (req, res) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> renderedString = renderToString(</span><br><span class=\"line\">    &lt;StaticRouter location=&#123; req.url &#125;&gt;</span><br><span class=\"line\">      &lt;App /&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/StaticRouter&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/...</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;)</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到，已经实现了路由功能。</p>\n<p><img src=\"https://i.loli.net/2019/03/22/5c9455e9e0e31.png\" alt=\"服务端渲染\"><br><img src=\"https://i.loli.net/2019/03/22/5c9455e9df280.png\" alt=\"服务端渲染\"></p>\n<h3 id=\"服务端异步获取数据\"><a href=\"#服务端异步获取数据\" class=\"headerlink\" title=\"服务端异步获取数据\"></a>服务端异步获取数据</h3><p>当服务端渲染的html文件数据需要通过请求另外的接口获取时，这个时候就需要服务端去请求数据，再将渲染完的 html 页面返回给客户端。</p>\n<p>模拟接口返回数据。</p>\n<p><strong>fetchData.js</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getInitCount</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      resolve(<span class=\"number\">10</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>服务端请求完数据之后，需要将给数据 React 组件使用。可以采用两种方式：</p>\n<ol>\n<li>通过 React 组件的 props 传入。</li>\n<li>通过 Router 的 context 传入，React 组件中再通过 props.staticContext 获取到。</li>\n</ol>\n<p><strong>server.js</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; getInitCount &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./src/utils/fetchData'</span></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">app.get(<span class=\"string\">'/*'</span>, (req, res) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> renderedString = renderToString(</span><br><span class=\"line\">    &lt;StaticRouter location=&#123; req.url &#125;&gt;</span><br><span class=\"line\">      &lt;App initCount=&#123;resData&#125; /&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/StaticRouter&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\">  /</span><span class=\"regexp\">/...</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;)</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>App.js</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      count: props.initCount || <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样可以看到服务器返回的 html 文件内容，已经将 count 的初始值 10 渲染进去了。</p>\n<p><img src=\"https://i.loli.net/2019/03/22/5c948522154ca.jpg\" alt=\"服务端渲染\"></p>\n<p>但是此时页面显示的count值还是0，原因在于虽然使用了 hydrate() 方法，并不会将 html 结构重新渲染，但是 React 组件还是会走一遍生命周期流程，App 组件的 props.initCount 依旧是 0。</p>\n<p>为了让客户端和服务端的props保持一致，需要将一个服务器生成的首屏 props 赋给客户端的全局变量。</p>\n<p>修改下server.js 和 index.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.get(<span class=\"string\">'/*'</span>, (req, res) =&gt; &#123;</span><br><span class=\"line\">  getInitCount().then(<span class=\"function\"><span class=\"params\">resData</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> renderedString = renderToString(</span><br><span class=\"line\">        &lt;StaticRouter location=&#123;req.url&#125;&gt;</span><br><span class=\"line\">          &lt;App initCount=&#123;resData&#125; /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/StaticRouter&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      )</span></span><br><span class=\"line\"><span class=\"regexp\">  </span></span><br><span class=\"line\"><span class=\"regexp\">    fs.readFile(path.resolve('index.html'), 'utf8', (error, data) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      /</span><span class=\"regexp\">/...</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">      res.send(`$&#123;data</span></span><br><span class=\"line\"><span class=\"regexp\">        .replace('&lt;div id=\"app\"&gt;&lt;/</span>div&gt;<span class=\"string\">', `&lt;div id=\"app\"&gt;$&#123;renderedString&#125;&lt;/div&gt;`)</span></span><br><span class=\"line\"><span class=\"string\">        .replace('</span>&lt;<span class=\"regexp\">/body&gt;', `&lt;/</span>body&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"built_in\">window</span>.__initCount__ = $&#123;<span class=\"built_in\">JSON</span>.stringify(resData)&#125;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><span class=\"string\">`)&#125;`</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReactDOM.hydrate(</span><br><span class=\"line\">    &lt;BrowserRouter&gt;</span><br><span class=\"line\">        &lt;App initCount=&#123;<span class=\"built_in\">window</span>.__initCount__&#125; /&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/BrowserRouter&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    , document.getElementById('app'))</span></span><br></pre></td></tr></table></figure>\n<p>注意 window.<strong>initCount</strong> 需要在 app.js 前面加载。</p>\n<p><img src=\"https://i.loli.net/2019/03/22/5c9487b39b46b.png\" alt=\"服务端渲染\"></p>\n<h3 id=\"服务端无法支持图片、css等资源文件\"><a href=\"#服务端无法支持图片、css等资源文件\" class=\"headerlink\" title=\"服务端无法支持图片、css等资源文件\"></a>服务端无法支持图片、css等资源文件</h3><p>如果代码中我们 import 了图片, svg, css 等非 js 资源，在客户端 webpack 的各种 loader 帮我们处理了这些资源，而 node 环境下只能识别 js。由于之前的例子没有引入额外的静态资源，所以没有出现这样的问题。</p>\n<p>试着在 pageB 组件中引入图片。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;div&gt;B页面&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;img src=&#123;require('../</span>assets/img/hat.jpg<span class=\"string\">')&#125; alt=\"\"/&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  )</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>运行便报错了。</p>\n<p>引入 webpack-isomorphic-tools 工具来解决这个问题。</p>\n<p>webpack-isomorphic-tools 完成了两件事：</p>\n<ol>\n<li>以webpack插件的形式，预编译less（不局限于less，还支持图片文件、字体文件等），将其转换为一个 assets.json 文件保存到项目目录下。</li>\n<li>require hook，所有less文件的引入，代理到生成的 JSON 文件中，匹配文件路径，返回一个预先编译好的 JSON 对象。</li>\n</ol>\n<p>实现步骤：</p>\n<ol>\n<li>修改webpack.config.js</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> WebpackIsomorphicToolsPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-isomorphic-tools/plugin'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> webpackIsomorphicToolsPlugin = </span><br><span class=\"line\">  <span class=\"comment\">// webpack-isomorphic-tools settings reside in a separate .js file </span></span><br><span class=\"line\">  <span class=\"comment\">// (because they will be used in the web server code too).</span></span><br><span class=\"line\">  <span class=\"keyword\">new</span> WebpackIsomorphicToolsPlugin(<span class=\"built_in\">require</span>(<span class=\"string\">'./webpack-isomorphic-tools-configuration'</span>))</span><br><span class=\"line\">  <span class=\"comment\">// also enter development mode since it's a development webpack configuration</span></span><br><span class=\"line\">  <span class=\"comment\">// (see below for explanation)</span></span><br><span class=\"line\">  .development()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// usual Webpack configuration</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports =</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  context: <span class=\"string\">'(required) your project path here'</span>,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>:</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    loaders:</span><br><span class=\"line\">    [</span><br><span class=\"line\">      <span class=\"comment\">//...,</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: webpackIsomorphicToolsPlugin.regularExpression(<span class=\"string\">'images'</span>),</span><br><span class=\"line\">        loader: <span class=\"string\">'url-loader?limit=1024'</span>, <span class=\"comment\">// any image below or equal to 10K will be converted to inline base64 instead</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  plugins:</span><br><span class=\"line\">  [</span><br><span class=\"line\">    <span class=\"comment\">//...,</span></span><br><span class=\"line\">    webpackIsomorphicToolsPlugin</span><br><span class=\"line\">  ]</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>添加 webpack-isomorphic-tools 配置文件 webpack-isomorphic-config.js</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  assets:</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    images:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      extensions: [<span class=\"string\">'png'</span>, <span class=\"string\">'jpg'</span>, <span class=\"string\">'gif'</span>, <span class=\"string\">'ico'</span>, <span class=\"string\">'svg'</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>webpack-isomorphic-tools 启动时，会先等待指定目录下 assets.json 文件生成，只有该文件就绪后，require hook 才会进行，进而触发 server 回调，只有在此回调中执行的代码，才能保证进行了require hook。所以 server.js 文件变成了回调，需要新增额外的入口文件。</p>\n<ol start=\"3\">\n<li>增加mian.js</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> WebpackIsomorphicTools = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-isomorphic-tools'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">global.webpackIsomorphicTools = <span class=\"keyword\">new</span> WebpackIsomorphicTools(<span class=\"built_in\">require</span>(<span class=\"string\">'./webpack-isomorphic-config'</span>))</span><br><span class=\"line\">    .server(<span class=\"string\">'./'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//回调</span></span><br><span class=\"line\">        <span class=\"built_in\">require</span>(<span class=\"string\">'./server.js'</span>) <span class=\"comment\">//启动 server</span></span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>同时修改启动脚本<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"start\"</span>: <span class=\"string\">\"npm run build &amp;&amp; babel-node ./main.js --presets es2015,stage-0,react\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"build\"</span>: <span class=\"string\">\"webpack\"</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>启动，会先生成 webpack-assets.json 文件, 通过映射关系可以正确处理非 js 文件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"javascript\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"app\"</span>: <span class=\"string\">\"app.js\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"styles\"</span>: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"string\">\"assets\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"./src/assets/img/hat.jpg\"</span>: <span class=\"string\">\"a80196c0daaadce1c8ef8446cc8212d5.jpg\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"webpack\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"version\"</span>: <span class=\"string\">\"4.29.6\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样子页面也能正确加载图片了。</p>\n<p><img src=\"https://i.loli.net/2019/03/22/5c9495e4cd31b.png\" alt=\"服务端渲染\"></p>\n<p>带来的问题: webpack-isomorphic-tools 这种 hook 方式，将整个Express Server置于自身的回调中，仿佛劫持了整个server，总不是显得那么的优雅。</p>\n<h2 id=\"源码地址\"><a href=\"#源码地址\" class=\"headerlink\" title=\"源码地址\"></a>源码地址</h2><ul>\n<li><a href=\"https://github.com/60kmlh/react-ssr\" target=\"_blank\" rel=\"noopener\">react-ssr</a></li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://juejin.im/post/5c18c34ef265da615114ae78\" target=\"_blank\" rel=\"noopener\">如何用 React 做服务端渲染</a></li>\n<li><a href=\"https://juejin.im/post/5b399412e51d4558dc4ae82d\" target=\"_blank\" rel=\"noopener\">React16.x中的服务端渲染（SSR）</a></li>\n<li><a href=\"https://zh-hans.reactjs.org/docs/react-dom-server.html\" target=\"_blank\" rel=\"noopener\">ReactDOMServer</a></li>\n<li><a href=\"https://www.zhihu.com/question/66068748\" target=\"_blank\" rel=\"noopener\">react中出现的”hydrate”这个单词到底是什么意思?</a></li>\n<li><a href=\"https://github.com/catamphetamine/webpack-isomorphic-tools\" target=\"_blank\" rel=\"noopener\">webpack-isomorphic-tools</a></li>\n</ul>"},{"title":"html标签语意化的区别","date":"2017-10-19T16:00:00.000Z","_content":"## title 和 H1 \n* title\n\nHTML \\<title\\> 元素 定义文档的标题，显示在浏览器的标题栏或标签页上。它只可以包含文本，若是包含有标签，则包含的任何标签都不会被解释。\n<!--more-->\n* H1\n标题(Heading)元素拥有六个不同的级别，\\<h1\\> 是最高级的，而 \\<h6\\> 则是最低的级别。 一个标题元素能简要描述该节的主题。\n## b 和 strong\n* b\n\nHTML \\<b\\>元素表表示相对于普通文本字体上的区别，但不表示任何特殊的强调或者关联，通常以粗体显示。\n\n* strong\n\nStrong 元素 (\\<strong\\>)表示文本十分重要，一般用粗体显示。\n\n## i 和 em\n* i\n\nHTML元素 \\<i\\> 用于表现因某些原因需要区分普通文本的一系列文本。例如技术术语、外文短语或是小说中人物的思想活动等，它的内容通常以斜体显示。\n* em\n\nHTML 着重元素 (\\<em\\>) 标记出需要用户着重阅读的内容， \\<em\\> 元素是可以嵌套的，嵌套层次越深，则其包含的内容被认定为越需要着重阅读。\n## 补充\n> 在HTML4.01中： \n> < b >  < i > 是视觉要素（presentationl elements），分别表示无意义的加粗，无意义的斜体，表现样式为 { font-weight: bolder }，仅仅表示「这里应该用粗体显示」或者「这里应该用斜体显示」，此两个标签在HTML4.01中并不被推荐使用；\n> \n> < em >  和  < strong >  是表达要素(phrase elements)。 < em > （emphasized text）表示一般的强调文本，而 < strong > （strong emphasized text）表示比 < em > 语义更强的的强调文本。\n> \n> 而在新的 HTML5 工作草案 中：\n> \n> < em >  和  < strong >  仍旧是表达要素(phrase elements)。但这时的 < strong > 表示html页面上的强调（emphasized text）， < em > 表示句子中的强调（即强调语义）\n>\n> 从规范中可以注意到：b 和 i 元素将被赋予真正的语义。更应有预见性注意 b 、i 与 strong 、em 的不同使用 。\n\n## 参考资料\n* [https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element)\n* [https://www.zhihu.com/question/19551271/answer/12521687](https://www.zhihu.com/question/19551271/answer/12521687)\n","source":"_posts/html标签语义化的区别.md","raw":"---\ntitle: html标签语意化的区别\ndate: 2017-10-20\ntags: ['html','语意化']\ncategories: ['笔记']\n---\n## title 和 H1 \n* title\n\nHTML \\<title\\> 元素 定义文档的标题，显示在浏览器的标题栏或标签页上。它只可以包含文本，若是包含有标签，则包含的任何标签都不会被解释。\n<!--more-->\n* H1\n标题(Heading)元素拥有六个不同的级别，\\<h1\\> 是最高级的，而 \\<h6\\> 则是最低的级别。 一个标题元素能简要描述该节的主题。\n## b 和 strong\n* b\n\nHTML \\<b\\>元素表表示相对于普通文本字体上的区别，但不表示任何特殊的强调或者关联，通常以粗体显示。\n\n* strong\n\nStrong 元素 (\\<strong\\>)表示文本十分重要，一般用粗体显示。\n\n## i 和 em\n* i\n\nHTML元素 \\<i\\> 用于表现因某些原因需要区分普通文本的一系列文本。例如技术术语、外文短语或是小说中人物的思想活动等，它的内容通常以斜体显示。\n* em\n\nHTML 着重元素 (\\<em\\>) 标记出需要用户着重阅读的内容， \\<em\\> 元素是可以嵌套的，嵌套层次越深，则其包含的内容被认定为越需要着重阅读。\n## 补充\n> 在HTML4.01中： \n> < b >  < i > 是视觉要素（presentationl elements），分别表示无意义的加粗，无意义的斜体，表现样式为 { font-weight: bolder }，仅仅表示「这里应该用粗体显示」或者「这里应该用斜体显示」，此两个标签在HTML4.01中并不被推荐使用；\n> \n> < em >  和  < strong >  是表达要素(phrase elements)。 < em > （emphasized text）表示一般的强调文本，而 < strong > （strong emphasized text）表示比 < em > 语义更强的的强调文本。\n> \n> 而在新的 HTML5 工作草案 中：\n> \n> < em >  和  < strong >  仍旧是表达要素(phrase elements)。但这时的 < strong > 表示html页面上的强调（emphasized text）， < em > 表示句子中的强调（即强调语义）\n>\n> 从规范中可以注意到：b 和 i 元素将被赋予真正的语义。更应有预见性注意 b 、i 与 strong 、em 的不同使用 。\n\n## 参考资料\n* [https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element)\n* [https://www.zhihu.com/question/19551271/answer/12521687](https://www.zhihu.com/question/19551271/answer/12521687)\n","slug":"html标签语义化的区别","published":1,"updated":"2022-04-13T14:14:07.773Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvff9001cg3t80cx4jw2l","content":"<h2 id=\"title-和-H1\"><a href=\"#title-和-H1\" class=\"headerlink\" title=\"title 和 H1\"></a>title 和 H1</h2><ul>\n<li>title</li>\n</ul>\n<p>HTML \\&lt;title> 元素 定义文档的标题，显示在浏览器的标题栏或标签页上。它只可以包含文本，若是包含有标签，则包含的任何标签都不会被解释。<br><a id=\"more\"></a></p>\n<ul>\n<li>H1<br>标题(Heading)元素拥有六个不同的级别，\\&lt;h1> 是最高级的，而 \\&lt;h6> 则是最低的级别。 一个标题元素能简要描述该节的主题。<h2 id=\"b-和-strong\"><a href=\"#b-和-strong\" class=\"headerlink\" title=\"b 和 strong\"></a>b 和 strong</h2></li>\n<li>b</li>\n</ul>\n<p>HTML \\&lt;b>元素表表示相对于普通文本字体上的区别，但不表示任何特殊的强调或者关联，通常以粗体显示。</p>\n<ul>\n<li>strong</li>\n</ul>\n<p>Strong 元素 (\\&lt;strong>)表示文本十分重要，一般用粗体显示。</p>\n<h2 id=\"i-和-em\"><a href=\"#i-和-em\" class=\"headerlink\" title=\"i 和 em\"></a>i 和 em</h2><ul>\n<li>i</li>\n</ul>\n<p>HTML元素 \\&lt;i> 用于表现因某些原因需要区分普通文本的一系列文本。例如技术术语、外文短语或是小说中人物的思想活动等，它的内容通常以斜体显示。</p>\n<ul>\n<li>em</li>\n</ul>\n<p>HTML 着重元素 (\\&lt;em>) 标记出需要用户着重阅读的内容， \\&lt;em> 元素是可以嵌套的，嵌套层次越深，则其包含的内容被认定为越需要着重阅读。</p>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><blockquote>\n<p>在HTML4.01中：<br>&lt; b &gt;  &lt; i &gt; 是视觉要素（presentationl elements），分别表示无意义的加粗，无意义的斜体，表现样式为 { font-weight: bolder }，仅仅表示「这里应该用粗体显示」或者「这里应该用斜体显示」，此两个标签在HTML4.01中并不被推荐使用；</p>\n<p>&lt; em &gt;  和  &lt; strong &gt;  是表达要素(phrase elements)。 &lt; em &gt; （emphasized text）表示一般的强调文本，而 &lt; strong &gt; （strong emphasized text）表示比 &lt; em &gt; 语义更强的的强调文本。</p>\n<p>而在新的 HTML5 工作草案 中：</p>\n<p>&lt; em &gt;  和  &lt; strong &gt;  仍旧是表达要素(phrase elements)。但这时的 &lt; strong &gt; 表示html页面上的强调（emphasized text）， &lt; em &gt; 表示句子中的强调（即强调语义）</p>\n<p>从规范中可以注意到：b 和 i 元素将被赋予真正的语义。更应有预见性注意 b 、i 与 strong 、em 的不同使用 。</p>\n</blockquote>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element</a></li>\n<li><a href=\"https://www.zhihu.com/question/19551271/answer/12521687\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/19551271/answer/12521687</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"title-和-H1\"><a href=\"#title-和-H1\" class=\"headerlink\" title=\"title 和 H1\"></a>title 和 H1</h2><ul>\n<li>title</li>\n</ul>\n<p>HTML \\&lt;title> 元素 定义文档的标题，显示在浏览器的标题栏或标签页上。它只可以包含文本，若是包含有标签，则包含的任何标签都不会被解释。<br>","more":"</p>\n<ul>\n<li>H1<br>标题(Heading)元素拥有六个不同的级别，\\&lt;h1> 是最高级的，而 \\&lt;h6> 则是最低的级别。 一个标题元素能简要描述该节的主题。<h2 id=\"b-和-strong\"><a href=\"#b-和-strong\" class=\"headerlink\" title=\"b 和 strong\"></a>b 和 strong</h2></li>\n<li>b</li>\n</ul>\n<p>HTML \\&lt;b>元素表表示相对于普通文本字体上的区别，但不表示任何特殊的强调或者关联，通常以粗体显示。</p>\n<ul>\n<li>strong</li>\n</ul>\n<p>Strong 元素 (\\&lt;strong>)表示文本十分重要，一般用粗体显示。</p>\n<h2 id=\"i-和-em\"><a href=\"#i-和-em\" class=\"headerlink\" title=\"i 和 em\"></a>i 和 em</h2><ul>\n<li>i</li>\n</ul>\n<p>HTML元素 \\&lt;i> 用于表现因某些原因需要区分普通文本的一系列文本。例如技术术语、外文短语或是小说中人物的思想活动等，它的内容通常以斜体显示。</p>\n<ul>\n<li>em</li>\n</ul>\n<p>HTML 着重元素 (\\&lt;em>) 标记出需要用户着重阅读的内容， \\&lt;em> 元素是可以嵌套的，嵌套层次越深，则其包含的内容被认定为越需要着重阅读。</p>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><blockquote>\n<p>在HTML4.01中：<br>&lt; b &gt;  &lt; i &gt; 是视觉要素（presentationl elements），分别表示无意义的加粗，无意义的斜体，表现样式为 { font-weight: bolder }，仅仅表示「这里应该用粗体显示」或者「这里应该用斜体显示」，此两个标签在HTML4.01中并不被推荐使用；</p>\n<p>&lt; em &gt;  和  &lt; strong &gt;  是表达要素(phrase elements)。 &lt; em &gt; （emphasized text）表示一般的强调文本，而 &lt; strong &gt; （strong emphasized text）表示比 &lt; em &gt; 语义更强的的强调文本。</p>\n<p>而在新的 HTML5 工作草案 中：</p>\n<p>&lt; em &gt;  和  &lt; strong &gt;  仍旧是表达要素(phrase elements)。但这时的 &lt; strong &gt; 表示html页面上的强调（emphasized text）， &lt; em &gt; 表示句子中的强调（即强调语义）</p>\n<p>从规范中可以注意到：b 和 i 元素将被赋予真正的语义。更应有预见性注意 b 、i 与 strong 、em 的不同使用 。</p>\n</blockquote>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element</a></li>\n<li><a href=\"https://www.zhihu.com/question/19551271/answer/12521687\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/19551271/answer/12521687</a></li>\n</ul>"},{"title":"TypeScript 中对象通过中括号读取属性值报错的问题","date":"2021-07-14T16:00:00.000Z","_content":"\n## 报错代码\n\n```javascript\nconst obj = {\n  key1: \"xxx\",\n};\nfunction getKeyValue(arg: string) {\n  return obj[arg];\n}\n```\n\n该代码在 typescript 中会报错：Element implicitly has an 'any' type because expression of type 'string' can't be used to index。\n\n## 原因\n\nkey 只声明为 string 的话，typescript 为了防止运行时传入了未知的 key 进行取值，返回了 undefined 报错，于是对这种写法进行警告。\n\n## 解决办法\n\n1. 在 tsconfig 中关闭针对该错误的检查，suppressImplicitAnyIndexErrors 设置为 true。\n\n2. 将 key 声明为 obj 的属性\n\n```javascript\n    const obj = {\n  key1: \"xxx\",\n};\nfunction getKeyValue(arg: keyof typeof obj) {\n  return obj[arg];\n}\n\n```\n\n3. 更加通用的写法，使用泛型\n\n```javascript\nconst obj = {\n  key1: \"xxx\",\n};\nfunction getKeyValue<O>(object:O, arg: keyof O) {\n  return object[arg];\n}\n\n```\n\n## 参考资料\n\n[https://dev.to/mapleleaf/indexing-objects-in-typescript-1cgi](https://dev.to/mapleleaf/indexing-objects-in-typescript-1cgi)\n[https://stackoverflow.com/questions/57086672/element-implicitly-has-an-any-type-because-expression-of-type-string-cant-b](https://stackoverflow.com/questions/57086672/element-implicitly-has-an-any-type-because-expression-of-type-string-cant-b)\n","source":"_posts/ts-index.md","raw":"---\ntitle: TypeScript 中对象通过中括号读取属性值报错的问题\ndate: 2021-07-15\ntags: [\"typescript\"]\ncategories: [\"\"]\n---\n\n## 报错代码\n\n```javascript\nconst obj = {\n  key1: \"xxx\",\n};\nfunction getKeyValue(arg: string) {\n  return obj[arg];\n}\n```\n\n该代码在 typescript 中会报错：Element implicitly has an 'any' type because expression of type 'string' can't be used to index。\n\n## 原因\n\nkey 只声明为 string 的话，typescript 为了防止运行时传入了未知的 key 进行取值，返回了 undefined 报错，于是对这种写法进行警告。\n\n## 解决办法\n\n1. 在 tsconfig 中关闭针对该错误的检查，suppressImplicitAnyIndexErrors 设置为 true。\n\n2. 将 key 声明为 obj 的属性\n\n```javascript\n    const obj = {\n  key1: \"xxx\",\n};\nfunction getKeyValue(arg: keyof typeof obj) {\n  return obj[arg];\n}\n\n```\n\n3. 更加通用的写法，使用泛型\n\n```javascript\nconst obj = {\n  key1: \"xxx\",\n};\nfunction getKeyValue<O>(object:O, arg: keyof O) {\n  return object[arg];\n}\n\n```\n\n## 参考资料\n\n[https://dev.to/mapleleaf/indexing-objects-in-typescript-1cgi](https://dev.to/mapleleaf/indexing-objects-in-typescript-1cgi)\n[https://stackoverflow.com/questions/57086672/element-implicitly-has-an-any-type-because-expression-of-type-string-cant-b](https://stackoverflow.com/questions/57086672/element-implicitly-has-an-any-type-because-expression-of-type-string-cant-b)\n","slug":"ts-index","published":1,"updated":"2022-04-14T02:28:36.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffa001fg3t8mgyshaoe","content":"<h2 id=\"报错代码\"><a href=\"#报错代码\" class=\"headerlink\" title=\"报错代码\"></a>报错代码</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  key1: <span class=\"string\">\"xxx\"</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getKeyValue</span>(<span class=\"params\">arg: string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj[arg];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该代码在 typescript 中会报错：Element implicitly has an ‘any’ type because expression of type ‘string’ can’t be used to index。</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>key 只声明为 string 的话，typescript 为了防止运行时传入了未知的 key 进行取值，返回了 undefined 报错，于是对这种写法进行警告。</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><ol>\n<li><p>在 tsconfig 中关闭针对该错误的检查，suppressImplicitAnyIndexErrors 设置为 true。</p>\n</li>\n<li><p>将 key 声明为 obj 的属性</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  key1: <span class=\"string\">\"xxx\"</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getKeyValue</span>(<span class=\"params\">arg: keyof typeof obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj[arg];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>更加通用的写法，使用泛型</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  key1: <span class=\"string\">\"xxx\"</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getKeyValue</span>&lt;<span class=\"title\">O</span>&gt;(<span class=\"params\">object:O, arg: keyof O</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> object[arg];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://dev.to/mapleleaf/indexing-objects-in-typescript-1cgi\" target=\"_blank\" rel=\"noopener\">https://dev.to/mapleleaf/indexing-objects-in-typescript-1cgi</a><br><a href=\"https://stackoverflow.com/questions/57086672/element-implicitly-has-an-any-type-because-expression-of-type-string-cant-b\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/57086672/element-implicitly-has-an-any-type-because-expression-of-type-string-cant-b</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"报错代码\"><a href=\"#报错代码\" class=\"headerlink\" title=\"报错代码\"></a>报错代码</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  key1: <span class=\"string\">\"xxx\"</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getKeyValue</span>(<span class=\"params\">arg: string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj[arg];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该代码在 typescript 中会报错：Element implicitly has an ‘any’ type because expression of type ‘string’ can’t be used to index。</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>key 只声明为 string 的话，typescript 为了防止运行时传入了未知的 key 进行取值，返回了 undefined 报错，于是对这种写法进行警告。</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><ol>\n<li><p>在 tsconfig 中关闭针对该错误的检查，suppressImplicitAnyIndexErrors 设置为 true。</p>\n</li>\n<li><p>将 key 声明为 obj 的属性</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  key1: <span class=\"string\">\"xxx\"</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getKeyValue</span>(<span class=\"params\">arg: keyof typeof obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj[arg];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>更加通用的写法，使用泛型</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  key1: <span class=\"string\">\"xxx\"</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getKeyValue</span>&lt;<span class=\"title\">O</span>&gt;(<span class=\"params\">object:O, arg: keyof O</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> object[arg];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://dev.to/mapleleaf/indexing-objects-in-typescript-1cgi\" target=\"_blank\" rel=\"noopener\">https://dev.to/mapleleaf/indexing-objects-in-typescript-1cgi</a><br><a href=\"https://stackoverflow.com/questions/57086672/element-implicitly-has-an-any-type-because-expression-of-type-string-cant-b\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/57086672/element-implicitly-has-an-any-type-because-expression-of-type-string-cant-b</a></p>\n"},{"title":"inline-block元素间距问题","date":"2017-11-04T16:00:00.000Z","_content":"## 背景\n有时候，我们需要将&lt;li&gt;横向排列，而又为了能设置其宽度和高度，为其设置display:inline-block，相邻&lt;li&gt;之间会出现8px的空白间隔，不是margin也不是padding。\n<!--more-->\n## 产生原因\n浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个&lt;li&gt;放在一行，这导致&lt;li&gt;换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。\n> 此乃历史问题。不难理解，空白字符压缩（white space collapse）是西文排版的必然结果。\n\n## 解决方式\n1. 改变代码书写方式。\n\n元素间留白间距出现的原因就是标签段之间的空格，因此，去掉HTML中的空格，自然间距就消失了。\n````html\n<ul><li>1</li><li>2</li><li>3</li></ul>\n````\n或者\n````html\n<ul>\n  <li>1</li\n  ><li>2</li\n  ><li>3</li>\n</ul>\n````\n2. 修改font-size\n\n将&lt;ul&gt;内的字符尺寸直接设为0，即font-size: 0。不足：&lt;ul&gt;中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。\n\n3. 使用margin负值\n\nmargin负值的大小与上下文的字体和文字大小相关，Arial字体的margin负值为-3像素，Tahoma和Verdana就是-4像素，而Geneva为-6像素。由于外部环境的不确定性，以及最后一个元素多出的父margin值等问题，这个方法不适合大规模使用。\n\n4. 使用word-spacing或letter-spacing\n\nletter-spacing子元素要设置letter-spacing为0，不然会继承父元素的值；使用word-spacing时，只需设置父元素word-spacing为合适值即可。\n\n## 参考资料\n* [有哪些好方法能处理 display: inline-block 元素之间出现的空格？\n](https://www.zhihu.com/question/21468450)\n* [inline-block间距产生的原因，去除inline-block间距的方法？](https://www.jianshu.com/p/b6fb427308ad)\n","source":"_posts/inline-block元素间距问题.md","raw":"---\ntitle: inline-block元素间距问题\ndate: 2017-11-05\ntags: ['css']\ncategories: ['css']\n---\n## 背景\n有时候，我们需要将&lt;li&gt;横向排列，而又为了能设置其宽度和高度，为其设置display:inline-block，相邻&lt;li&gt;之间会出现8px的空白间隔，不是margin也不是padding。\n<!--more-->\n## 产生原因\n浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个&lt;li&gt;放在一行，这导致&lt;li&gt;换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。\n> 此乃历史问题。不难理解，空白字符压缩（white space collapse）是西文排版的必然结果。\n\n## 解决方式\n1. 改变代码书写方式。\n\n元素间留白间距出现的原因就是标签段之间的空格，因此，去掉HTML中的空格，自然间距就消失了。\n````html\n<ul><li>1</li><li>2</li><li>3</li></ul>\n````\n或者\n````html\n<ul>\n  <li>1</li\n  ><li>2</li\n  ><li>3</li>\n</ul>\n````\n2. 修改font-size\n\n将&lt;ul&gt;内的字符尺寸直接设为0，即font-size: 0。不足：&lt;ul&gt;中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。\n\n3. 使用margin负值\n\nmargin负值的大小与上下文的字体和文字大小相关，Arial字体的margin负值为-3像素，Tahoma和Verdana就是-4像素，而Geneva为-6像素。由于外部环境的不确定性，以及最后一个元素多出的父margin值等问题，这个方法不适合大规模使用。\n\n4. 使用word-spacing或letter-spacing\n\nletter-spacing子元素要设置letter-spacing为0，不然会继承父元素的值；使用word-spacing时，只需设置父元素word-spacing为合适值即可。\n\n## 参考资料\n* [有哪些好方法能处理 display: inline-block 元素之间出现的空格？\n](https://www.zhihu.com/question/21468450)\n* [inline-block间距产生的原因，去除inline-block间距的方法？](https://www.jianshu.com/p/b6fb427308ad)\n","slug":"inline-block元素间距问题","published":1,"updated":"2022-04-13T14:14:07.784Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffc001hg3t8i7wcjyds","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>有时候，我们需要将&lt;li&gt;横向排列，而又为了能设置其宽度和高度，为其设置display:inline-block，相邻&lt;li&gt;之间会出现8px的空白间隔，不是margin也不是padding。<br><a id=\"more\"></a></p>\n<h2 id=\"产生原因\"><a href=\"#产生原因\" class=\"headerlink\" title=\"产生原因\"></a>产生原因</h2><p>浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个&lt;li&gt;放在一行，这导致&lt;li&gt;换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</p>\n<blockquote>\n<p>此乃历史问题。不难理解，空白字符压缩（white space collapse）是西文排版的必然结果。</p>\n</blockquote>\n<h2 id=\"解决方式\"><a href=\"#解决方式\" class=\"headerlink\" title=\"解决方式\"></a>解决方式</h2><ol>\n<li>改变代码书写方式。</li>\n</ol>\n<p>元素间留白间距出现的原因就是标签段之间的空格，因此，去掉HTML中的空格，自然间距就消失了。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>或者<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">li</span></span></span><br><span class=\"line\"><span class=\"tag\">  &gt;</span><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">li</span></span></span><br><span class=\"line\"><span class=\"tag\">  &gt;</span><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>修改font-size</li>\n</ol>\n<p>将&lt;ul&gt;内的字符尺寸直接设为0，即font-size: 0。不足：&lt;ul&gt;中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。</p>\n<ol start=\"3\">\n<li>使用margin负值</li>\n</ol>\n<p>margin负值的大小与上下文的字体和文字大小相关，Arial字体的margin负值为-3像素，Tahoma和Verdana就是-4像素，而Geneva为-6像素。由于外部环境的不确定性，以及最后一个元素多出的父margin值等问题，这个方法不适合大规模使用。</p>\n<ol start=\"4\">\n<li>使用word-spacing或letter-spacing</li>\n</ol>\n<p>letter-spacing子元素要设置letter-spacing为0，不然会继承父元素的值；使用word-spacing时，只需设置父元素word-spacing为合适值即可。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://www.zhihu.com/question/21468450\" target=\"_blank\" rel=\"noopener\">有哪些好方法能处理 display: inline-block 元素之间出现的空格？\n</a></li>\n<li><a href=\"https://www.jianshu.com/p/b6fb427308ad\" target=\"_blank\" rel=\"noopener\">inline-block间距产生的原因，去除inline-block间距的方法？</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>有时候，我们需要将&lt;li&gt;横向排列，而又为了能设置其宽度和高度，为其设置display:inline-block，相邻&lt;li&gt;之间会出现8px的空白间隔，不是margin也不是padding。<br>","more":"</p>\n<h2 id=\"产生原因\"><a href=\"#产生原因\" class=\"headerlink\" title=\"产生原因\"></a>产生原因</h2><p>浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个&lt;li&gt;放在一行，这导致&lt;li&gt;换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</p>\n<blockquote>\n<p>此乃历史问题。不难理解，空白字符压缩（white space collapse）是西文排版的必然结果。</p>\n</blockquote>\n<h2 id=\"解决方式\"><a href=\"#解决方式\" class=\"headerlink\" title=\"解决方式\"></a>解决方式</h2><ol>\n<li>改变代码书写方式。</li>\n</ol>\n<p>元素间留白间距出现的原因就是标签段之间的空格，因此，去掉HTML中的空格，自然间距就消失了。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>或者<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">li</span></span></span><br><span class=\"line\"><span class=\"tag\">  &gt;</span><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">li</span></span></span><br><span class=\"line\"><span class=\"tag\">  &gt;</span><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>修改font-size</li>\n</ol>\n<p>将&lt;ul&gt;内的字符尺寸直接设为0，即font-size: 0。不足：&lt;ul&gt;中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。</p>\n<ol start=\"3\">\n<li>使用margin负值</li>\n</ol>\n<p>margin负值的大小与上下文的字体和文字大小相关，Arial字体的margin负值为-3像素，Tahoma和Verdana就是-4像素，而Geneva为-6像素。由于外部环境的不确定性，以及最后一个元素多出的父margin值等问题，这个方法不适合大规模使用。</p>\n<ol start=\"4\">\n<li>使用word-spacing或letter-spacing</li>\n</ol>\n<p>letter-spacing子元素要设置letter-spacing为0，不然会继承父元素的值；使用word-spacing时，只需设置父元素word-spacing为合适值即可。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://www.zhihu.com/question/21468450\" target=\"_blank\" rel=\"noopener\">有哪些好方法能处理 display: inline-block 元素之间出现的空格？\n</a></li>\n<li><a href=\"https://www.jianshu.com/p/b6fb427308ad\" target=\"_blank\" rel=\"noopener\">inline-block间距产生的原因，去除inline-block间距的方法？</a></li>\n</ul>"},{"title":"vue的Runtime Compiler vs Runtime-only","date":"2017-10-11T16:00:00.000Z","_content":"在vue的官方文档中可以得知，vue有两种不同的构建方式，运行时+编译器（Runtime+Compiler）和只包含运行时（Runtime-only）。\n<!--more-->\n两者的区别是：\n\n运行时+编译器是完整版的构建，即vue.common.js,支持创建vue实例时，传入template选项。编译器会将模板编译成渲染函数。\n\n运行时构建的vue版本删除了模板编译的功能，因此无法支持带template属性的Vue实例选项。使用该构建方式的vue需要借助vue-loader或者vueify事先将.vue文件内部的模板会在构建时预编译成渲染函数，供vue实例使用。\n\n> 因为运行时构建相比完整版缩减了30%的体积，你应该尽可能使用这个版本。\n\nVue的npm包也将package.json中的main指向了运行时构建dist/vue.runtime.common.js。\n\n当你使用了运行时构建的版本，而由没有将模板预先编译成渲染函数，vue就会报如下的警告：\n> [Vue warn]: Failed to mount component: template or render function not defined. (found in root instance).\n## 参考资料\n* [https://cn.vuejs.org/v2/guide/installation.html#运行时-编译器-vs-只包含运行时](https://cn.vuejs.org/v2/guide/installation.html#运行时-编译器-vs-只包含运行时)\n* [https://zhuanlan.zhihu.com/p/25486761](https://zhuanlan.zhihu.com/p/25486761)\n","source":"_posts/vue的Runtime   Compiler vs. Runtime-only.md","raw":"---\ntitle: vue的Runtime Compiler vs Runtime-only\ndate: 2017-10-12\ntags: ['vue']\ncategories: ['笔记']\n---\n在vue的官方文档中可以得知，vue有两种不同的构建方式，运行时+编译器（Runtime+Compiler）和只包含运行时（Runtime-only）。\n<!--more-->\n两者的区别是：\n\n运行时+编译器是完整版的构建，即vue.common.js,支持创建vue实例时，传入template选项。编译器会将模板编译成渲染函数。\n\n运行时构建的vue版本删除了模板编译的功能，因此无法支持带template属性的Vue实例选项。使用该构建方式的vue需要借助vue-loader或者vueify事先将.vue文件内部的模板会在构建时预编译成渲染函数，供vue实例使用。\n\n> 因为运行时构建相比完整版缩减了30%的体积，你应该尽可能使用这个版本。\n\nVue的npm包也将package.json中的main指向了运行时构建dist/vue.runtime.common.js。\n\n当你使用了运行时构建的版本，而由没有将模板预先编译成渲染函数，vue就会报如下的警告：\n> [Vue warn]: Failed to mount component: template or render function not defined. (found in root instance).\n## 参考资料\n* [https://cn.vuejs.org/v2/guide/installation.html#运行时-编译器-vs-只包含运行时](https://cn.vuejs.org/v2/guide/installation.html#运行时-编译器-vs-只包含运行时)\n* [https://zhuanlan.zhihu.com/p/25486761](https://zhuanlan.zhihu.com/p/25486761)\n","slug":"vue的Runtime   Compiler vs. Runtime-only","published":1,"updated":"2022-04-13T14:14:07.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffd001kg3t8yg4v907c","content":"<p>在vue的官方文档中可以得知，vue有两种不同的构建方式，运行时+编译器（Runtime+Compiler）和只包含运行时（Runtime-only）。<br><a id=\"more\"></a><br>两者的区别是：</p>\n<p>运行时+编译器是完整版的构建，即vue.common.js,支持创建vue实例时，传入template选项。编译器会将模板编译成渲染函数。</p>\n<p>运行时构建的vue版本删除了模板编译的功能，因此无法支持带template属性的Vue实例选项。使用该构建方式的vue需要借助vue-loader或者vueify事先将.vue文件内部的模板会在构建时预编译成渲染函数，供vue实例使用。</p>\n<blockquote>\n<p>因为运行时构建相比完整版缩减了30%的体积，你应该尽可能使用这个版本。</p>\n</blockquote>\n<p>Vue的npm包也将package.json中的main指向了运行时构建dist/vue.runtime.common.js。</p>\n<p>当你使用了运行时构建的版本，而由没有将模板预先编译成渲染函数，vue就会报如下的警告：</p>\n<blockquote>\n<p>[Vue warn]: Failed to mount component: template or render function not defined. (found in root instance).</p>\n</blockquote>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://cn.vuejs.org/v2/guide/installation.html#运行时-编译器-vs-只包含运行时\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/v2/guide/installation.html#运行时-编译器-vs-只包含运行时</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25486761\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/25486761</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在vue的官方文档中可以得知，vue有两种不同的构建方式，运行时+编译器（Runtime+Compiler）和只包含运行时（Runtime-only）。<br>","more":"<br>两者的区别是：</p>\n<p>运行时+编译器是完整版的构建，即vue.common.js,支持创建vue实例时，传入template选项。编译器会将模板编译成渲染函数。</p>\n<p>运行时构建的vue版本删除了模板编译的功能，因此无法支持带template属性的Vue实例选项。使用该构建方式的vue需要借助vue-loader或者vueify事先将.vue文件内部的模板会在构建时预编译成渲染函数，供vue实例使用。</p>\n<blockquote>\n<p>因为运行时构建相比完整版缩减了30%的体积，你应该尽可能使用这个版本。</p>\n</blockquote>\n<p>Vue的npm包也将package.json中的main指向了运行时构建dist/vue.runtime.common.js。</p>\n<p>当你使用了运行时构建的版本，而由没有将模板预先编译成渲染函数，vue就会报如下的警告：</p>\n<blockquote>\n<p>[Vue warn]: Failed to mount component: template or render function not defined. (found in root instance).</p>\n</blockquote>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://cn.vuejs.org/v2/guide/installation.html#运行时-编译器-vs-只包含运行时\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/v2/guide/installation.html#运行时-编译器-vs-只包含运行时</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25486761\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/25486761</a></li>\n</ul>"},{"title":"vue项目总结","date":"2017-06-09T16:00:00.000Z","_content":"1. 项目结构: 使用vue官方手脚架生成初始结构，src目录结构修改为\n````javascript\n│  App.vue\n│  main.js\n│\n├─assets\n│  ├─css\n│  │      style.css \n│  │\n│  └─images\n│          product.jpg\n│\n├─components\n│      Head.vue\n│      Loading.vue\n│\n├─lib\n│      api.js\n│      mobileUtil.js\n│\n├─router\n│      router.js\n│\n├─views\n│  ├─pageA\n│  │      childA.vue\n│  │      childB.vue\n│  │      Main.vue\n│  │\n│  ├─pageB\n│  │      childA.vue\n│  │      childB.vue\n│  │      Main.vue\n│  │\n│  └─pageC\n│         childA.vue\n│         childB.vue\n│         Main.vue\n│  \n│\n└─vuex\n    │  store.js\n    │\n    └─modules\n        ├─pageA\n        │      actions.js\n        │      getters.js\n        │      index.js\n        │      mutation-type.js\n        │      mutations.js\n        │\n        ├─pageB\n        │      actions.js\n        │      getters.js\n        │      index.js\n        │      mutation-type.js\n        │      mutations.js\n        │\n        └─pageC\n               actions.js\n               getters.js\n               index.js\n               mutation-type.js\n               mutations.js\n````\n<!--more-->\nassets文件夹存放img，css等静态资源。\n\ncomponents文件夹存放公共组件。\n\nlib文件夹存放工具类，api配置等。\n\nrouter文件夹存放路由配置。\n\nviews文件夹存放页面级的组件，统一Main.vue为每个页面主入口，同一页面的其他组件为子路由组件。\n\nvuex文件夹存放vuex全局数据，store.js为主入口，里面的子文件夹按页面划分模块。\n\n2. vuex的action间需要进行异步回调时，使用Promise。\n3. <img>标签里可以通过require引入静态资源。\n4. <keep-alive>配合activated钩子。\n5. [动态路由](http://60kmlh.github.io/2017/07/08/基于vue-router的管理系统权限控制的实现/)\n6. 利用process.env.NODE_ENV管理生产环境的api和开发环境的api前缀。\n7. 利用v-if强制更新一个组件，$forceUpdate不生效。\n8. 表单校验使用v-validate插件。\n","source":"_posts/vue项目总结.md","raw":"---\ntitle: vue项目总结\ndate: 2017-06-10\ntags: ['vue']\ncategories: ['工作总结']\n---\n1. 项目结构: 使用vue官方手脚架生成初始结构，src目录结构修改为\n````javascript\n│  App.vue\n│  main.js\n│\n├─assets\n│  ├─css\n│  │      style.css \n│  │\n│  └─images\n│          product.jpg\n│\n├─components\n│      Head.vue\n│      Loading.vue\n│\n├─lib\n│      api.js\n│      mobileUtil.js\n│\n├─router\n│      router.js\n│\n├─views\n│  ├─pageA\n│  │      childA.vue\n│  │      childB.vue\n│  │      Main.vue\n│  │\n│  ├─pageB\n│  │      childA.vue\n│  │      childB.vue\n│  │      Main.vue\n│  │\n│  └─pageC\n│         childA.vue\n│         childB.vue\n│         Main.vue\n│  \n│\n└─vuex\n    │  store.js\n    │\n    └─modules\n        ├─pageA\n        │      actions.js\n        │      getters.js\n        │      index.js\n        │      mutation-type.js\n        │      mutations.js\n        │\n        ├─pageB\n        │      actions.js\n        │      getters.js\n        │      index.js\n        │      mutation-type.js\n        │      mutations.js\n        │\n        └─pageC\n               actions.js\n               getters.js\n               index.js\n               mutation-type.js\n               mutations.js\n````\n<!--more-->\nassets文件夹存放img，css等静态资源。\n\ncomponents文件夹存放公共组件。\n\nlib文件夹存放工具类，api配置等。\n\nrouter文件夹存放路由配置。\n\nviews文件夹存放页面级的组件，统一Main.vue为每个页面主入口，同一页面的其他组件为子路由组件。\n\nvuex文件夹存放vuex全局数据，store.js为主入口，里面的子文件夹按页面划分模块。\n\n2. vuex的action间需要进行异步回调时，使用Promise。\n3. <img>标签里可以通过require引入静态资源。\n4. <keep-alive>配合activated钩子。\n5. [动态路由](http://60kmlh.github.io/2017/07/08/基于vue-router的管理系统权限控制的实现/)\n6. 利用process.env.NODE_ENV管理生产环境的api和开发环境的api前缀。\n7. 利用v-if强制更新一个组件，$forceUpdate不生效。\n8. 表单校验使用v-validate插件。\n","slug":"vue项目总结","published":1,"updated":"2022-04-13T14:14:07.835Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffe001ng3t8zu4q4yol","content":"<ol>\n<li>项目结构: 使用vue官方手脚架生成初始结构，src目录结构修改为<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">│  App.vue</span><br><span class=\"line\">│  main.js</span><br><span class=\"line\">│</span><br><span class=\"line\">├─assets</span><br><span class=\"line\">│  ├─css</span><br><span class=\"line\">│  │      style.css </span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  └─images</span><br><span class=\"line\">│          product.jpg</span><br><span class=\"line\">│</span><br><span class=\"line\">├─components</span><br><span class=\"line\">│      Head.vue</span><br><span class=\"line\">│      Loading.vue</span><br><span class=\"line\">│</span><br><span class=\"line\">├─lib</span><br><span class=\"line\">│      api.js</span><br><span class=\"line\">│      mobileUtil.js</span><br><span class=\"line\">│</span><br><span class=\"line\">├─router</span><br><span class=\"line\">│      router.js</span><br><span class=\"line\">│</span><br><span class=\"line\">├─views</span><br><span class=\"line\">│  ├─pageA</span><br><span class=\"line\">│  │      childA.vue</span><br><span class=\"line\">│  │      childB.vue</span><br><span class=\"line\">│  │      Main.vue</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  ├─pageB</span><br><span class=\"line\">│  │      childA.vue</span><br><span class=\"line\">│  │      childB.vue</span><br><span class=\"line\">│  │      Main.vue</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  └─pageC</span><br><span class=\"line\">│         childA.vue</span><br><span class=\"line\">│         childB.vue</span><br><span class=\"line\">│         Main.vue</span><br><span class=\"line\">│  </span><br><span class=\"line\">│</span><br><span class=\"line\">└─vuex</span><br><span class=\"line\">    │  store.js</span><br><span class=\"line\">    │</span><br><span class=\"line\">    └─modules</span><br><span class=\"line\">        ├─pageA</span><br><span class=\"line\">        │      actions.js</span><br><span class=\"line\">        │      getters.js</span><br><span class=\"line\">        │      index.js</span><br><span class=\"line\">        │      mutation-type.js</span><br><span class=\"line\">        │      mutations.js</span><br><span class=\"line\">        │</span><br><span class=\"line\">        ├─pageB</span><br><span class=\"line\">        │      actions.js</span><br><span class=\"line\">        │      getters.js</span><br><span class=\"line\">        │      index.js</span><br><span class=\"line\">        │      mutation-type.js</span><br><span class=\"line\">        │      mutations.js</span><br><span class=\"line\">        │</span><br><span class=\"line\">        └─pageC</span><br><span class=\"line\">               actions.js</span><br><span class=\"line\">               getters.js</span><br><span class=\"line\">               index.js</span><br><span class=\"line\">               mutation-type.js</span><br><span class=\"line\">               mutations.js</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<a id=\"more\"></a>\n<p>assets文件夹存放img，css等静态资源。</p>\n<p>components文件夹存放公共组件。</p>\n<p>lib文件夹存放工具类，api配置等。</p>\n<p>router文件夹存放路由配置。</p>\n<p>views文件夹存放页面级的组件，统一Main.vue为每个页面主入口，同一页面的其他组件为子路由组件。</p>\n<p>vuex文件夹存放vuex全局数据，store.js为主入口，里面的子文件夹按页面划分模块。</p>\n<ol start=\"2\">\n<li>vuex的action间需要进行异步回调时，使用Promise。</li>\n<li><img>标签里可以通过require引入静态资源。</li>\n<li><keep-alive>配合activated钩子。</keep-alive></li>\n<li><a href=\"http://60kmlh.github.io/2017/07/08/基于vue-router的管理系统权限控制的实现/\">动态路由</a></li>\n<li>利用process.env.NODE_ENV管理生产环境的api和开发环境的api前缀。</li>\n<li>利用v-if强制更新一个组件，$forceUpdate不生效。</li>\n<li>表单校验使用v-validate插件。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<ol>\n<li>项目结构: 使用vue官方手脚架生成初始结构，src目录结构修改为<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">│  App.vue</span><br><span class=\"line\">│  main.js</span><br><span class=\"line\">│</span><br><span class=\"line\">├─assets</span><br><span class=\"line\">│  ├─css</span><br><span class=\"line\">│  │      style.css </span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  └─images</span><br><span class=\"line\">│          product.jpg</span><br><span class=\"line\">│</span><br><span class=\"line\">├─components</span><br><span class=\"line\">│      Head.vue</span><br><span class=\"line\">│      Loading.vue</span><br><span class=\"line\">│</span><br><span class=\"line\">├─lib</span><br><span class=\"line\">│      api.js</span><br><span class=\"line\">│      mobileUtil.js</span><br><span class=\"line\">│</span><br><span class=\"line\">├─router</span><br><span class=\"line\">│      router.js</span><br><span class=\"line\">│</span><br><span class=\"line\">├─views</span><br><span class=\"line\">│  ├─pageA</span><br><span class=\"line\">│  │      childA.vue</span><br><span class=\"line\">│  │      childB.vue</span><br><span class=\"line\">│  │      Main.vue</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  ├─pageB</span><br><span class=\"line\">│  │      childA.vue</span><br><span class=\"line\">│  │      childB.vue</span><br><span class=\"line\">│  │      Main.vue</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  └─pageC</span><br><span class=\"line\">│         childA.vue</span><br><span class=\"line\">│         childB.vue</span><br><span class=\"line\">│         Main.vue</span><br><span class=\"line\">│  </span><br><span class=\"line\">│</span><br><span class=\"line\">└─vuex</span><br><span class=\"line\">    │  store.js</span><br><span class=\"line\">    │</span><br><span class=\"line\">    └─modules</span><br><span class=\"line\">        ├─pageA</span><br><span class=\"line\">        │      actions.js</span><br><span class=\"line\">        │      getters.js</span><br><span class=\"line\">        │      index.js</span><br><span class=\"line\">        │      mutation-type.js</span><br><span class=\"line\">        │      mutations.js</span><br><span class=\"line\">        │</span><br><span class=\"line\">        ├─pageB</span><br><span class=\"line\">        │      actions.js</span><br><span class=\"line\">        │      getters.js</span><br><span class=\"line\">        │      index.js</span><br><span class=\"line\">        │      mutation-type.js</span><br><span class=\"line\">        │      mutations.js</span><br><span class=\"line\">        │</span><br><span class=\"line\">        └─pageC</span><br><span class=\"line\">               actions.js</span><br><span class=\"line\">               getters.js</span><br><span class=\"line\">               index.js</span><br><span class=\"line\">               mutation-type.js</span><br><span class=\"line\">               mutations.js</span><br></pre></td></tr></table></figure>\n</li>\n</ol>","more":"<p>assets文件夹存放img，css等静态资源。</p>\n<p>components文件夹存放公共组件。</p>\n<p>lib文件夹存放工具类，api配置等。</p>\n<p>router文件夹存放路由配置。</p>\n<p>views文件夹存放页面级的组件，统一Main.vue为每个页面主入口，同一页面的其他组件为子路由组件。</p>\n<p>vuex文件夹存放vuex全局数据，store.js为主入口，里面的子文件夹按页面划分模块。</p>\n<ol start=\"2\">\n<li>vuex的action间需要进行异步回调时，使用Promise。</li>\n<li><img>标签里可以通过require引入静态资源。</li>\n<li><keep-alive>配合activated钩子。</keep-alive></li>\n<li><a href=\"http://60kmlh.github.io/2017/07/08/基于vue-router的管理系统权限控制的实现/\">动态路由</a></li>\n<li>利用process.env.NODE_ENV管理生产环境的api和开发环境的api前缀。</li>\n<li>利用v-if强制更新一个组件，$forceUpdate不生效。</li>\n<li>表单校验使用v-validate插件。</li>\n</ol>"},{"title":"switch 语句内的块级作用域","date":"2021-03-03T16:00:00.000Z","_content":"\n## 现象\n\n在 switch/case 中使用 let 进行声明，ESLint 会报错：SyntaxError: Identifier 'msg' has already been declared\n\n```javascript\nswitch (key) {\n  case value1:\n    let a = 1;\n    break;\n  case valu2:\n    let a = 2;\n    break;\n  default:\n    break;\n}\n```\n\n这是因为第一个 let a = 1; 与第二个 la = 2; 语句产生了冲突，虽然他们处于各自分隔的 case 语句中，即 case value1: 和 case value2:。导致这一问题的根本原因在于两个 let 语句处于同一个块级作用域，所以它们被认为是同一个变量名的重复声明\n\n## 解决办法\n\n把 case 语句加上花框{ }, 明確的告訴 ESLint 不同 case 的作用域也不同，则可以解决这个问题。\n\n```javascript\nswitch (key) {\n  case value1: {\n    let a = 1;\n    break;\n  }\n  case valu2: {\n    let a = 2;\n    break;\n  }\n  default:\n    break;\n}\n```\n\n## 参考资料\n\n[禁止在 case 或 default 子句中出现词法声明 (no-case-declarations)\n](https://cn.eslint.org/docs/rules/no-case-declarations)\n","source":"_posts/switch case中使用let进行声明.md","raw":"---\ntitle: switch 语句内的块级作用域\ndate: 2021-03-04\ntags: [\"switch/case\"]\ncategories: [\"javascript\"]\n---\n\n## 现象\n\n在 switch/case 中使用 let 进行声明，ESLint 会报错：SyntaxError: Identifier 'msg' has already been declared\n\n```javascript\nswitch (key) {\n  case value1:\n    let a = 1;\n    break;\n  case valu2:\n    let a = 2;\n    break;\n  default:\n    break;\n}\n```\n\n这是因为第一个 let a = 1; 与第二个 la = 2; 语句产生了冲突，虽然他们处于各自分隔的 case 语句中，即 case value1: 和 case value2:。导致这一问题的根本原因在于两个 let 语句处于同一个块级作用域，所以它们被认为是同一个变量名的重复声明\n\n## 解决办法\n\n把 case 语句加上花框{ }, 明確的告訴 ESLint 不同 case 的作用域也不同，则可以解决这个问题。\n\n```javascript\nswitch (key) {\n  case value1: {\n    let a = 1;\n    break;\n  }\n  case valu2: {\n    let a = 2;\n    break;\n  }\n  default:\n    break;\n}\n```\n\n## 参考资料\n\n[禁止在 case 或 default 子句中出现词法声明 (no-case-declarations)\n](https://cn.eslint.org/docs/rules/no-case-declarations)\n","slug":"switch case中使用let进行声明","published":1,"updated":"2022-04-14T02:28:10.690Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfff001qg3t8mst5lp9x","content":"<h2 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h2><p>在 switch/case 中使用 let 进行声明，ESLint 会报错：SyntaxError: Identifier ‘msg’ has already been declared</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (key) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> value1:</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> valu2:</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是因为第一个 let a = 1; 与第二个 la = 2; 语句产生了冲突，虽然他们处于各自分隔的 case 语句中，即 case value1: 和 case value2:。导致这一问题的根本原因在于两个 let 语句处于同一个块级作用域，所以它们被认为是同一个变量名的重复声明</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>把 case 语句加上花框{ }, 明確的告訴 ESLint 不同 case 的作用域也不同，则可以解决这个问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (key) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> value1: &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> valu2: &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://cn.eslint.org/docs/rules/no-case-declarations\" target=\"_blank\" rel=\"noopener\">禁止在 case 或 default 子句中出现词法声明 (no-case-declarations)\n</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h2><p>在 switch/case 中使用 let 进行声明，ESLint 会报错：SyntaxError: Identifier ‘msg’ has already been declared</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (key) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> value1:</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> valu2:</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是因为第一个 let a = 1; 与第二个 la = 2; 语句产生了冲突，虽然他们处于各自分隔的 case 语句中，即 case value1: 和 case value2:。导致这一问题的根本原因在于两个 let 语句处于同一个块级作用域，所以它们被认为是同一个变量名的重复声明</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>把 case 语句加上花框{ }, 明確的告訴 ESLint 不同 case 的作用域也不同，则可以解决这个问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (key) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> value1: &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> valu2: &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://cn.eslint.org/docs/rules/no-case-declarations\" target=\"_blank\" rel=\"noopener\">禁止在 case 或 default 子句中出现词法声明 (no-case-declarations)\n</a></p>\n"},{"title":"《图解http》第一章笔记","date":"2017-09-14T16:00:00.000Z","_content":"## TCP/IP协议族\n### 简介\n计算机与网络设备要相互通信，双方必须基于相同的方法。如，如何探测到目标，使用哪种语言进行通信等，所有的这一切都需要一种规则，这种规则称为协议。\n\n协议中存在各式各样的内容，如从电缆规格到IP地址的选取方法寻找异地用户的方法等。与互联网相关联的协议集合，称为TCP/IP。\n<!--more-->\n### TCP/IP的分层管理\n为了方便管理和改动，TCP/IP协议族按层次分为以下四层：\n* 应用层\n\n  决定了向用户提供应用服务时的通信活动。\n  \n  FTP(File Transfer Protocol,文件传输协议)，DNS(Domain Name System,域名系统)，HTTP(Hyper Transfer Potocol, 超文本传输协议)均处于改层。\n* 传输层\n\n  提供处于网络连接中两台计算机之间的数据传输。\n\n  TCP(Transmission Control Protocol,传输控制协议)，UDP(User Data Protocol,用户数据报协议)处于该层。\n* 网络层\n\n  应用层用来处理网络上流动的数据包。数据包是网络传输的最小单位。\n\n  该层规定了提供怎样的路径到达对方计算机，并把数据包传给对方。\n  IP(Internal Protocol,网际协议)位于该层。\n* 数据链路层\n\n  用来处理连接网络的硬件部分。包括控制操作系统，硬件的设备驱动，网卡，光纤的可见部分。\n### TCP/IP通信传输流\n利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。\n\n用 HTTP 举例来说明，首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。\n\n\n接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。\n\n在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。\n\n接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。\n\n当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。\n\n发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息，反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种做法称为封装（encapsulate）。\n### IP协议\nIP协议的作用是把各种数据包传送给对方，其中重要的条件是IP地址和MAC地址。\n\nIP地址指明节点被分配到的地址，MAC地址指网卡所属的固定地址。IP地址和MAC地址可以进行配对。\n\nIP间的通信依赖MAC地址，通信双经常是经过多台计算机和网络设备中转才能连接到对方。而中转采用ARP协议。\n\nARP协议是一种用来解析地址的协议，根据通信方的IP地址反查出MAC地址。\n### TCP协议\nTCP协议提供可靠的字节流服务。TCP协议为了容易传输大数据将数据分割，而且能够准确的确认数据最终是否送达到对方。\n\nTCP采用三次握手（three-way-handshaking）策略。握手过程使用TCP的标志（flag）———SYN（synchronize）和ACK（acknowledgement）。\n\n发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表握手结束。\n### DNS协议\nDNS服务提供域名到IP地址之间的解析服务。DNS协议提供通过域名查找IP地址，或逆向从IP地址查找域名的服务。\n### URI和URL\nURI统一资源标示符，表示由某个协议方案表示的资源的定位标示符。而URL表示资源的地址。\n\nURL格式：\n  ![URL格式](http://oq8q06ybp.bkt.clouddn.com/image/URL.PNG)\n### 各种协议和HTTP协议的关系\n当客户端向某一个网址发起请求时，会向DNS查询这个域名的IP地址。\n\n接着HTTP协议生成针对WEB目标服务器的HTTP请求报文。\n\n为了方便通讯，TCP协议按序号将HTTP请求报文分割成报文段，采用三次握手把每个报文段可靠地传给对方。\n\n路由器根据IP协议，搜索对方的地址，一遍中转一遍传送。\n\n当对方接受到数据包时，根据TCP协议，将从对方那里接受到的报文段，按序号以原来的顺序重组报文。\n\n接着HTTP协议再对WEB服务器请求的内容进行处理，在发送给服务器，服务器处理完的结果也同样利用TCP/IP通讯协议向客户端回传。\n","source":"_posts/《图解http》第一章笔记.md","raw":"---\ntitle: 《图解http》第一章笔记\ndate: 2017-09-15\ntags: ['http']\ncategories: ['笔记']\n---\n## TCP/IP协议族\n### 简介\n计算机与网络设备要相互通信，双方必须基于相同的方法。如，如何探测到目标，使用哪种语言进行通信等，所有的这一切都需要一种规则，这种规则称为协议。\n\n协议中存在各式各样的内容，如从电缆规格到IP地址的选取方法寻找异地用户的方法等。与互联网相关联的协议集合，称为TCP/IP。\n<!--more-->\n### TCP/IP的分层管理\n为了方便管理和改动，TCP/IP协议族按层次分为以下四层：\n* 应用层\n\n  决定了向用户提供应用服务时的通信活动。\n  \n  FTP(File Transfer Protocol,文件传输协议)，DNS(Domain Name System,域名系统)，HTTP(Hyper Transfer Potocol, 超文本传输协议)均处于改层。\n* 传输层\n\n  提供处于网络连接中两台计算机之间的数据传输。\n\n  TCP(Transmission Control Protocol,传输控制协议)，UDP(User Data Protocol,用户数据报协议)处于该层。\n* 网络层\n\n  应用层用来处理网络上流动的数据包。数据包是网络传输的最小单位。\n\n  该层规定了提供怎样的路径到达对方计算机，并把数据包传给对方。\n  IP(Internal Protocol,网际协议)位于该层。\n* 数据链路层\n\n  用来处理连接网络的硬件部分。包括控制操作系统，硬件的设备驱动，网卡，光纤的可见部分。\n### TCP/IP通信传输流\n利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。\n\n用 HTTP 举例来说明，首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。\n\n\n接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。\n\n在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。\n\n接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。\n\n当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。\n\n发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息，反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种做法称为封装（encapsulate）。\n### IP协议\nIP协议的作用是把各种数据包传送给对方，其中重要的条件是IP地址和MAC地址。\n\nIP地址指明节点被分配到的地址，MAC地址指网卡所属的固定地址。IP地址和MAC地址可以进行配对。\n\nIP间的通信依赖MAC地址，通信双经常是经过多台计算机和网络设备中转才能连接到对方。而中转采用ARP协议。\n\nARP协议是一种用来解析地址的协议，根据通信方的IP地址反查出MAC地址。\n### TCP协议\nTCP协议提供可靠的字节流服务。TCP协议为了容易传输大数据将数据分割，而且能够准确的确认数据最终是否送达到对方。\n\nTCP采用三次握手（three-way-handshaking）策略。握手过程使用TCP的标志（flag）———SYN（synchronize）和ACK（acknowledgement）。\n\n发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表握手结束。\n### DNS协议\nDNS服务提供域名到IP地址之间的解析服务。DNS协议提供通过域名查找IP地址，或逆向从IP地址查找域名的服务。\n### URI和URL\nURI统一资源标示符，表示由某个协议方案表示的资源的定位标示符。而URL表示资源的地址。\n\nURL格式：\n  ![URL格式](http://oq8q06ybp.bkt.clouddn.com/image/URL.PNG)\n### 各种协议和HTTP协议的关系\n当客户端向某一个网址发起请求时，会向DNS查询这个域名的IP地址。\n\n接着HTTP协议生成针对WEB目标服务器的HTTP请求报文。\n\n为了方便通讯，TCP协议按序号将HTTP请求报文分割成报文段，采用三次握手把每个报文段可靠地传给对方。\n\n路由器根据IP协议，搜索对方的地址，一遍中转一遍传送。\n\n当对方接受到数据包时，根据TCP协议，将从对方那里接受到的报文段，按序号以原来的顺序重组报文。\n\n接着HTTP协议再对WEB服务器请求的内容进行处理，在发送给服务器，服务器处理完的结果也同样利用TCP/IP通讯协议向客户端回传。\n","slug":"《图解http》第一章笔记","published":1,"updated":"2022-04-13T14:14:07.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffg001ug3t8gw5uk4ds","content":"<h2 id=\"TCP-IP协议族\"><a href=\"#TCP-IP协议族\" class=\"headerlink\" title=\"TCP/IP协议族\"></a>TCP/IP协议族</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>计算机与网络设备要相互通信，双方必须基于相同的方法。如，如何探测到目标，使用哪种语言进行通信等，所有的这一切都需要一种规则，这种规则称为协议。</p>\n<p>协议中存在各式各样的内容，如从电缆规格到IP地址的选取方法寻找异地用户的方法等。与互联网相关联的协议集合，称为TCP/IP。<br><a id=\"more\"></a></p>\n<h3 id=\"TCP-IP的分层管理\"><a href=\"#TCP-IP的分层管理\" class=\"headerlink\" title=\"TCP/IP的分层管理\"></a>TCP/IP的分层管理</h3><p>为了方便管理和改动，TCP/IP协议族按层次分为以下四层：</p>\n<ul>\n<li><p>应用层</p>\n<p>决定了向用户提供应用服务时的通信活动。</p>\n<p>FTP(File Transfer Protocol,文件传输协议)，DNS(Domain Name System,域名系统)，HTTP(Hyper Transfer Potocol, 超文本传输协议)均处于改层。</p>\n</li>\n<li><p>传输层</p>\n<p>提供处于网络连接中两台计算机之间的数据传输。</p>\n<p>TCP(Transmission Control Protocol,传输控制协议)，UDP(User Data Protocol,用户数据报协议)处于该层。</p>\n</li>\n<li><p>网络层</p>\n<p>应用层用来处理网络上流动的数据包。数据包是网络传输的最小单位。</p>\n<p>该层规定了提供怎样的路径到达对方计算机，并把数据包传给对方。<br>IP(Internal Protocol,网际协议)位于该层。</p>\n</li>\n<li><p>数据链路层</p>\n<p>用来处理连接网络的硬件部分。包括控制操作系统，硬件的设备驱动，网卡，光纤的可见部分。</p>\n<h3 id=\"TCP-IP通信传输流\"><a href=\"#TCP-IP通信传输流\" class=\"headerlink\" title=\"TCP/IP通信传输流\"></a>TCP/IP通信传输流</h3><p>利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。</p>\n</li>\n</ul>\n<p>用 HTTP 举例来说明，首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。</p>\n<p>接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</p>\n<p>在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。</p>\n<p>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。</p>\n<p>当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。</p>\n<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息，反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种做法称为封装（encapsulate）。</p>\n<h3 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h3><p>IP协议的作用是把各种数据包传送给对方，其中重要的条件是IP地址和MAC地址。</p>\n<p>IP地址指明节点被分配到的地址，MAC地址指网卡所属的固定地址。IP地址和MAC地址可以进行配对。</p>\n<p>IP间的通信依赖MAC地址，通信双经常是经过多台计算机和网络设备中转才能连接到对方。而中转采用ARP协议。</p>\n<p>ARP协议是一种用来解析地址的协议，根据通信方的IP地址反查出MAC地址。</p>\n<h3 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h3><p>TCP协议提供可靠的字节流服务。TCP协议为了容易传输大数据将数据分割，而且能够准确的确认数据最终是否送达到对方。</p>\n<p>TCP采用三次握手（three-way-handshaking）策略。握手过程使用TCP的标志（flag）———SYN（synchronize）和ACK（acknowledgement）。</p>\n<p>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表握手结束。</p>\n<h3 id=\"DNS协议\"><a href=\"#DNS协议\" class=\"headerlink\" title=\"DNS协议\"></a>DNS协议</h3><p>DNS服务提供域名到IP地址之间的解析服务。DNS协议提供通过域名查找IP地址，或逆向从IP地址查找域名的服务。</p>\n<h3 id=\"URI和URL\"><a href=\"#URI和URL\" class=\"headerlink\" title=\"URI和URL\"></a>URI和URL</h3><p>URI统一资源标示符，表示由某个协议方案表示的资源的定位标示符。而URL表示资源的地址。</p>\n<p>URL格式：<br>  <img src=\"http://oq8q06ybp.bkt.clouddn.com/image/URL.PNG\" alt=\"URL格式\"></p>\n<h3 id=\"各种协议和HTTP协议的关系\"><a href=\"#各种协议和HTTP协议的关系\" class=\"headerlink\" title=\"各种协议和HTTP协议的关系\"></a>各种协议和HTTP协议的关系</h3><p>当客户端向某一个网址发起请求时，会向DNS查询这个域名的IP地址。</p>\n<p>接着HTTP协议生成针对WEB目标服务器的HTTP请求报文。</p>\n<p>为了方便通讯，TCP协议按序号将HTTP请求报文分割成报文段，采用三次握手把每个报文段可靠地传给对方。</p>\n<p>路由器根据IP协议，搜索对方的地址，一遍中转一遍传送。</p>\n<p>当对方接受到数据包时，根据TCP协议，将从对方那里接受到的报文段，按序号以原来的顺序重组报文。</p>\n<p>接着HTTP协议再对WEB服务器请求的内容进行处理，在发送给服务器，服务器处理完的结果也同样利用TCP/IP通讯协议向客户端回传。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"TCP-IP协议族\"><a href=\"#TCP-IP协议族\" class=\"headerlink\" title=\"TCP/IP协议族\"></a>TCP/IP协议族</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>计算机与网络设备要相互通信，双方必须基于相同的方法。如，如何探测到目标，使用哪种语言进行通信等，所有的这一切都需要一种规则，这种规则称为协议。</p>\n<p>协议中存在各式各样的内容，如从电缆规格到IP地址的选取方法寻找异地用户的方法等。与互联网相关联的协议集合，称为TCP/IP。<br>","more":"</p>\n<h3 id=\"TCP-IP的分层管理\"><a href=\"#TCP-IP的分层管理\" class=\"headerlink\" title=\"TCP/IP的分层管理\"></a>TCP/IP的分层管理</h3><p>为了方便管理和改动，TCP/IP协议族按层次分为以下四层：</p>\n<ul>\n<li><p>应用层</p>\n<p>决定了向用户提供应用服务时的通信活动。</p>\n<p>FTP(File Transfer Protocol,文件传输协议)，DNS(Domain Name System,域名系统)，HTTP(Hyper Transfer Potocol, 超文本传输协议)均处于改层。</p>\n</li>\n<li><p>传输层</p>\n<p>提供处于网络连接中两台计算机之间的数据传输。</p>\n<p>TCP(Transmission Control Protocol,传输控制协议)，UDP(User Data Protocol,用户数据报协议)处于该层。</p>\n</li>\n<li><p>网络层</p>\n<p>应用层用来处理网络上流动的数据包。数据包是网络传输的最小单位。</p>\n<p>该层规定了提供怎样的路径到达对方计算机，并把数据包传给对方。<br>IP(Internal Protocol,网际协议)位于该层。</p>\n</li>\n<li><p>数据链路层</p>\n<p>用来处理连接网络的硬件部分。包括控制操作系统，硬件的设备驱动，网卡，光纤的可见部分。</p>\n<h3 id=\"TCP-IP通信传输流\"><a href=\"#TCP-IP通信传输流\" class=\"headerlink\" title=\"TCP/IP通信传输流\"></a>TCP/IP通信传输流</h3><p>利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。</p>\n</li>\n</ul>\n<p>用 HTTP 举例来说明，首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。</p>\n<p>接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</p>\n<p>在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。</p>\n<p>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。</p>\n<p>当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。</p>\n<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息，反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种做法称为封装（encapsulate）。</p>\n<h3 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h3><p>IP协议的作用是把各种数据包传送给对方，其中重要的条件是IP地址和MAC地址。</p>\n<p>IP地址指明节点被分配到的地址，MAC地址指网卡所属的固定地址。IP地址和MAC地址可以进行配对。</p>\n<p>IP间的通信依赖MAC地址，通信双经常是经过多台计算机和网络设备中转才能连接到对方。而中转采用ARP协议。</p>\n<p>ARP协议是一种用来解析地址的协议，根据通信方的IP地址反查出MAC地址。</p>\n<h3 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h3><p>TCP协议提供可靠的字节流服务。TCP协议为了容易传输大数据将数据分割，而且能够准确的确认数据最终是否送达到对方。</p>\n<p>TCP采用三次握手（three-way-handshaking）策略。握手过程使用TCP的标志（flag）———SYN（synchronize）和ACK（acknowledgement）。</p>\n<p>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表握手结束。</p>\n<h3 id=\"DNS协议\"><a href=\"#DNS协议\" class=\"headerlink\" title=\"DNS协议\"></a>DNS协议</h3><p>DNS服务提供域名到IP地址之间的解析服务。DNS协议提供通过域名查找IP地址，或逆向从IP地址查找域名的服务。</p>\n<h3 id=\"URI和URL\"><a href=\"#URI和URL\" class=\"headerlink\" title=\"URI和URL\"></a>URI和URL</h3><p>URI统一资源标示符，表示由某个协议方案表示的资源的定位标示符。而URL表示资源的地址。</p>\n<p>URL格式：<br>  <img src=\"http://oq8q06ybp.bkt.clouddn.com/image/URL.PNG\" alt=\"URL格式\"></p>\n<h3 id=\"各种协议和HTTP协议的关系\"><a href=\"#各种协议和HTTP协议的关系\" class=\"headerlink\" title=\"各种协议和HTTP协议的关系\"></a>各种协议和HTTP协议的关系</h3><p>当客户端向某一个网址发起请求时，会向DNS查询这个域名的IP地址。</p>\n<p>接着HTTP协议生成针对WEB目标服务器的HTTP请求报文。</p>\n<p>为了方便通讯，TCP协议按序号将HTTP请求报文分割成报文段，采用三次握手把每个报文段可靠地传给对方。</p>\n<p>路由器根据IP协议，搜索对方的地址，一遍中转一遍传送。</p>\n<p>当对方接受到数据包时，根据TCP协议，将从对方那里接受到的报文段，按序号以原来的顺序重组报文。</p>\n<p>接着HTTP协议再对WEB服务器请求的内容进行处理，在发送给服务器，服务器处理完的结果也同样利用TCP/IP通讯协议向客户端回传。</p>"},{"title":"《javascript权威指南》第六章读书笔记","date":"2017-03-10T16:00:00.000Z","_content":"## 6.1 创建对象\n\n### 创建对象三种的方式\n\n1. 使用对象直接量\n\n创建对象最简单的方式就是在JavaScript代码中使用对象直接量(key / value)。\n\n在ECMAScript 5中，对象直接量中的最后一个属性后的逗号将忽略，且在ECMAScript 3的大部分实行中也可以忽略这个逗号，但在IE中则报错。\n<!--more-->\n所有通过对象直接量创建的对象具有同一个原型对象，即Object.prototype。Object.prototype没有原型。\n\n2. 使用new运算符\n\n关键字new后跟随一个构造函数使用，创建的对象的原型是构造函数的prototype属性的值。\n\n所有通过对象直接量创建的对象具有同一个原型对象，即Object.prototype。Object.prototype没有原型。\n\n3. 使用Object.create() \n\nECMAScript 5中使用Object.create(obj)传入原型对象，创建的对象会继承该原型的属性。传入Null则创建一个没有原型的对象,不继承任何属性。\n\n在ECMASCript 3中模拟原型继承\n````javascript\nfunction inherit(p) {\n    if (p == null) throw TypeError();\n    if (Object.create) return Object.create(p);\n    var t = typeof p;\n    if (t != 'function' && t != 'object') throw TypeError();\n    function f() { };\n    f.prototype = p;\n    return new f()\n````\n## 6.2 属性的查询和设置\n可以通过点(.)或者方括号([])运算符获取属性的值。\n\nJavascript对象具有'自有属性'，也有原型属性是从原型对象继承而来的。\n\n查询对象o的属性x，如果在o中找不到x，则在o的原型对象中查找属性x。如果该原型对象也没有属性x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到x属性或者一个原型是null的对象为止。即对象的原型属性构成一个'链'。\n````javascript\nvar o = {}\no.x = 1;\nvar p = inherit(o)\np.y = 2;\nvar q = inherit(p)\nq.z = 3;\nvar s = q.toString()\nconsole.log(s)//[object Object]\nconsole.log(q.x+q.y)//3\n````\n如果允许属性赋值操作，那么它总是在原始对象上进行属性创建或者对已有属性进行赋值，而不会去修改原型链。\n\n查询属性才和继承有关，设置属性则无关，改特性可以选择性得覆盖继承的属性。\n\n查询一个不存在的属性不会报错，返回undefined。如果对象不存在，查找这个不存在的对象的属性就会报错。\n````javascript\nvar len = book&&book.substitle&&book.substitle.length;\n````\n## 6.3删除属性\n使用delete刪除屬性。delete只是断开属性与宿主之间的联系，而不会去操作属性中的属性。\n````javascript\nvar a = {p:{x:1}};\nvar b = a.p;\ndelete a.p;\nconsole.log(a.p);//undefined\nconsole.log(b);//{x:1}\n````\ndelete不行删除可configurable为false的属性。\n## 6.4检测属性\n检测某个属性是否存在于某个对象中。\n\n1. in运算符\n\n如果对象的自有属性或继承属性包含这个属性，则返回true。\n```javascript\nvar a = {x:1};\nconsole.log('x' in a);//true\nconsole.log('toString' in a);//true\n````\n\n2. hasOwnProperty()\n\n该方法用来检测给定的名字是否是对象的自有属性。\n````javascript\nvar a = {x:1};\nconsole.log(a.hasOwnProperty('x'));//true\nconsole.log(a.hasOwnProperty('toString'));//false\n````\n\n3. propertyIsEnumerable()\n\n检测到是自有属性且这个属性的enumerable特性为true是，返回true。\n````javascript\nvar o = inherit({x:1});\no.y = 2;\nconsole.log(o.propertyIsEnumerable('x'))//true\nconsole.log(o.propertyIsEnumerable('y'))//false\nconsole.log(o.propertyIsEnumerable('toString'))//false\n````\n## 6.5枚举属性\n使用for/in便利对象所有可枚举的属性。\n````javascript\nvar o = {x:1 ,y:2, z:3};\nconsole.log(o.propertyIsEnumerable('toString'))//fasle\nfor(prop in o){\n    console.log(prop)\n}//x y z\n````\nECMAScript 5中使用Object.keys(obj)返回一个数组，数组由对象中的可枚举的自有属性组成。\n````javascript\nvar o = {x:1,y:2};\nObject.defineProperty(o,'y',{enumerable:false})\nconsole.log(Object.keys(o));//['x']\n````\nECMAScript 5中使用Object.getOwnPropertyNames(obj)返回对象所有的自有属性。\n````javascript\nvar o = {x:1,y:2};\nObject.defineProperty(o,'y',{enumerable:false})\nconsole.log(Object.getOwnPropertyNames(o));//['x','y']\n````\n## 6.6属性的getter和setter\n在ECMAScript 5中 ，对象的属性可以有一个或两个函数代替，即getter和getter。由getter和setter定义的属性叫做'存取器属性'(accessor property)，不同于'数据属性'(data property)。\n\n存取器属性定义为一个或两个和属性同名的函数，不使用function关键字，而是使用get和set。\n\n存取器属性不具有可写性(writable attribute)。\n````javascript\nvar serialNum={\n    $n:0,\n    get next(){\n        return this.$n++\n    },\n    set next(n){\n        if(n>this.$n) this.$n=n*3;\n        else throw '序列号的值不能比当前值小'\n    }\n}\nconsole.log(serialNum.next)//0\nconsole.log(serialNum.next)//1\nserialNum.next=10;\nconsole.log(serialNum.next)//30\nconsole.log(serialNum.next)//31\n````\n## 6.7属性的特性\n数据属性的4个特性是：value writable enumerable configurable。\n\n存取器属性不具有value和writable特性，其可写性有setter方法是否存在决定。\n\n存取器属性的4个特性是：get set enumerable configurable。\n\n通过调用Object.getOwnPropertyDescriptor(obj,propName)获得某个对象特定属性的属性描述符。\n````javascript\nconsole.log(Object.getOwnPropertyDescriptor({x:1},'x'))//{ value: 1, writable: true, enumerable: true, configurable: true }\n````\n设置属性的特性则是使用Object.defineProperty(obj,propName,desc)和Object.defineProperties(obj,desc)\n\n赋值属性的特性\n````javascript\nObject.defineProperty(Object.prototype,'extend',{\n    writable:true,\n    enumerable:false,\n    configurable:true,\n    value:function(o){\n        var names=Object.getOwnPropertyNames(o);\n        for( let i=0;i<names.length;i++){\n            if(names[i] in this) continue;\n            var desc = Object.getOwnPropertyDescriptor(o,names[i]);\n            Object.defineProperty(this,names[i],desc)\n        }\n    }\n})\n````\n## 6.8对象的3个属性\n\n1. 原型(prototype)\n\nECMAScript 5中使用Object.getProprttyOf(obj)查询对象的原型。\n\nECMAScript 3中使用o.constructor.prototype检查对象的原型(不可靠)。\n\n使用isPrototypeOf检测一个对象是否是另一个对象的原型。\n\n2. 类属性(class attribute)\n\n查询方法\n````javascript\nfunction classOf(o){\n    if(o===null) return 'Null';\n    if(o===undefined) return 'Undefined';\n    return Object.prototype.toString.call(o).slice(8,-1)\n}\n````\n3. 可扩展性(extensible attribute)\n\n对象的可扩展性表示是否可以给对象添加新属性。\n\n所以内置对象和自定义对象都是显式可扩展的。\n\n可以通过Object.esExtensible(obj)来检测对象是否是可扩展的\n\n通过Object.preventExtensions(obj)、Object.seal(obj)、Object.freeze(obj)来将对象设置为不可扩展的\n\n## 6.9序列化对象\n对象序列化(serialization)是指对象的状态和字符串的互相转换。\n\nECMAScript 5内置函数JSON.stringify()和JSON.parse()来序列化和还原对象。\n````javascript\nvar o = {x:1,y:{a:1}};\nvar s = JSON.stringify(o);\nconsole.log(s);//{\"x\":1,\"y\":{\"a\":1}}\nconsole.log(JSON.parse(s));//Object {x: 1, y: Object}\n````\n## 6.10对象方法\nObject.prototype里常见的方法，例如toString(),valueOf()等，但有些特定的类会重写这些方法。\n","source":"_posts/javascripts权威指南笔记-6.md","raw":"---\ntitle: 《javascript权威指南》第六章读书笔记\ndate: 2017-03-11\ntags: ['object']\ncategories: ['笔记']\n---\n## 6.1 创建对象\n\n### 创建对象三种的方式\n\n1. 使用对象直接量\n\n创建对象最简单的方式就是在JavaScript代码中使用对象直接量(key / value)。\n\n在ECMAScript 5中，对象直接量中的最后一个属性后的逗号将忽略，且在ECMAScript 3的大部分实行中也可以忽略这个逗号，但在IE中则报错。\n<!--more-->\n所有通过对象直接量创建的对象具有同一个原型对象，即Object.prototype。Object.prototype没有原型。\n\n2. 使用new运算符\n\n关键字new后跟随一个构造函数使用，创建的对象的原型是构造函数的prototype属性的值。\n\n所有通过对象直接量创建的对象具有同一个原型对象，即Object.prototype。Object.prototype没有原型。\n\n3. 使用Object.create() \n\nECMAScript 5中使用Object.create(obj)传入原型对象，创建的对象会继承该原型的属性。传入Null则创建一个没有原型的对象,不继承任何属性。\n\n在ECMASCript 3中模拟原型继承\n````javascript\nfunction inherit(p) {\n    if (p == null) throw TypeError();\n    if (Object.create) return Object.create(p);\n    var t = typeof p;\n    if (t != 'function' && t != 'object') throw TypeError();\n    function f() { };\n    f.prototype = p;\n    return new f()\n````\n## 6.2 属性的查询和设置\n可以通过点(.)或者方括号([])运算符获取属性的值。\n\nJavascript对象具有'自有属性'，也有原型属性是从原型对象继承而来的。\n\n查询对象o的属性x，如果在o中找不到x，则在o的原型对象中查找属性x。如果该原型对象也没有属性x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到x属性或者一个原型是null的对象为止。即对象的原型属性构成一个'链'。\n````javascript\nvar o = {}\no.x = 1;\nvar p = inherit(o)\np.y = 2;\nvar q = inherit(p)\nq.z = 3;\nvar s = q.toString()\nconsole.log(s)//[object Object]\nconsole.log(q.x+q.y)//3\n````\n如果允许属性赋值操作，那么它总是在原始对象上进行属性创建或者对已有属性进行赋值，而不会去修改原型链。\n\n查询属性才和继承有关，设置属性则无关，改特性可以选择性得覆盖继承的属性。\n\n查询一个不存在的属性不会报错，返回undefined。如果对象不存在，查找这个不存在的对象的属性就会报错。\n````javascript\nvar len = book&&book.substitle&&book.substitle.length;\n````\n## 6.3删除属性\n使用delete刪除屬性。delete只是断开属性与宿主之间的联系，而不会去操作属性中的属性。\n````javascript\nvar a = {p:{x:1}};\nvar b = a.p;\ndelete a.p;\nconsole.log(a.p);//undefined\nconsole.log(b);//{x:1}\n````\ndelete不行删除可configurable为false的属性。\n## 6.4检测属性\n检测某个属性是否存在于某个对象中。\n\n1. in运算符\n\n如果对象的自有属性或继承属性包含这个属性，则返回true。\n```javascript\nvar a = {x:1};\nconsole.log('x' in a);//true\nconsole.log('toString' in a);//true\n````\n\n2. hasOwnProperty()\n\n该方法用来检测给定的名字是否是对象的自有属性。\n````javascript\nvar a = {x:1};\nconsole.log(a.hasOwnProperty('x'));//true\nconsole.log(a.hasOwnProperty('toString'));//false\n````\n\n3. propertyIsEnumerable()\n\n检测到是自有属性且这个属性的enumerable特性为true是，返回true。\n````javascript\nvar o = inherit({x:1});\no.y = 2;\nconsole.log(o.propertyIsEnumerable('x'))//true\nconsole.log(o.propertyIsEnumerable('y'))//false\nconsole.log(o.propertyIsEnumerable('toString'))//false\n````\n## 6.5枚举属性\n使用for/in便利对象所有可枚举的属性。\n````javascript\nvar o = {x:1 ,y:2, z:3};\nconsole.log(o.propertyIsEnumerable('toString'))//fasle\nfor(prop in o){\n    console.log(prop)\n}//x y z\n````\nECMAScript 5中使用Object.keys(obj)返回一个数组，数组由对象中的可枚举的自有属性组成。\n````javascript\nvar o = {x:1,y:2};\nObject.defineProperty(o,'y',{enumerable:false})\nconsole.log(Object.keys(o));//['x']\n````\nECMAScript 5中使用Object.getOwnPropertyNames(obj)返回对象所有的自有属性。\n````javascript\nvar o = {x:1,y:2};\nObject.defineProperty(o,'y',{enumerable:false})\nconsole.log(Object.getOwnPropertyNames(o));//['x','y']\n````\n## 6.6属性的getter和setter\n在ECMAScript 5中 ，对象的属性可以有一个或两个函数代替，即getter和getter。由getter和setter定义的属性叫做'存取器属性'(accessor property)，不同于'数据属性'(data property)。\n\n存取器属性定义为一个或两个和属性同名的函数，不使用function关键字，而是使用get和set。\n\n存取器属性不具有可写性(writable attribute)。\n````javascript\nvar serialNum={\n    $n:0,\n    get next(){\n        return this.$n++\n    },\n    set next(n){\n        if(n>this.$n) this.$n=n*3;\n        else throw '序列号的值不能比当前值小'\n    }\n}\nconsole.log(serialNum.next)//0\nconsole.log(serialNum.next)//1\nserialNum.next=10;\nconsole.log(serialNum.next)//30\nconsole.log(serialNum.next)//31\n````\n## 6.7属性的特性\n数据属性的4个特性是：value writable enumerable configurable。\n\n存取器属性不具有value和writable特性，其可写性有setter方法是否存在决定。\n\n存取器属性的4个特性是：get set enumerable configurable。\n\n通过调用Object.getOwnPropertyDescriptor(obj,propName)获得某个对象特定属性的属性描述符。\n````javascript\nconsole.log(Object.getOwnPropertyDescriptor({x:1},'x'))//{ value: 1, writable: true, enumerable: true, configurable: true }\n````\n设置属性的特性则是使用Object.defineProperty(obj,propName,desc)和Object.defineProperties(obj,desc)\n\n赋值属性的特性\n````javascript\nObject.defineProperty(Object.prototype,'extend',{\n    writable:true,\n    enumerable:false,\n    configurable:true,\n    value:function(o){\n        var names=Object.getOwnPropertyNames(o);\n        for( let i=0;i<names.length;i++){\n            if(names[i] in this) continue;\n            var desc = Object.getOwnPropertyDescriptor(o,names[i]);\n            Object.defineProperty(this,names[i],desc)\n        }\n    }\n})\n````\n## 6.8对象的3个属性\n\n1. 原型(prototype)\n\nECMAScript 5中使用Object.getProprttyOf(obj)查询对象的原型。\n\nECMAScript 3中使用o.constructor.prototype检查对象的原型(不可靠)。\n\n使用isPrototypeOf检测一个对象是否是另一个对象的原型。\n\n2. 类属性(class attribute)\n\n查询方法\n````javascript\nfunction classOf(o){\n    if(o===null) return 'Null';\n    if(o===undefined) return 'Undefined';\n    return Object.prototype.toString.call(o).slice(8,-1)\n}\n````\n3. 可扩展性(extensible attribute)\n\n对象的可扩展性表示是否可以给对象添加新属性。\n\n所以内置对象和自定义对象都是显式可扩展的。\n\n可以通过Object.esExtensible(obj)来检测对象是否是可扩展的\n\n通过Object.preventExtensions(obj)、Object.seal(obj)、Object.freeze(obj)来将对象设置为不可扩展的\n\n## 6.9序列化对象\n对象序列化(serialization)是指对象的状态和字符串的互相转换。\n\nECMAScript 5内置函数JSON.stringify()和JSON.parse()来序列化和还原对象。\n````javascript\nvar o = {x:1,y:{a:1}};\nvar s = JSON.stringify(o);\nconsole.log(s);//{\"x\":1,\"y\":{\"a\":1}}\nconsole.log(JSON.parse(s));//Object {x: 1, y: Object}\n````\n## 6.10对象方法\nObject.prototype里常见的方法，例如toString(),valueOf()等，但有些特定的类会重写这些方法。\n","slug":"javascripts权威指南笔记-6","published":1,"updated":"2022-04-13T14:14:07.788Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffh001yg3t8ymav3mcx","content":"<h2 id=\"6-1-创建对象\"><a href=\"#6-1-创建对象\" class=\"headerlink\" title=\"6.1 创建对象\"></a>6.1 创建对象</h2><h3 id=\"创建对象三种的方式\"><a href=\"#创建对象三种的方式\" class=\"headerlink\" title=\"创建对象三种的方式\"></a>创建对象三种的方式</h3><ol>\n<li>使用对象直接量</li>\n</ol>\n<p>创建对象最简单的方式就是在JavaScript代码中使用对象直接量(key / value)。</p>\n<p>在ECMAScript 5中，对象直接量中的最后一个属性后的逗号将忽略，且在ECMAScript 3的大部分实行中也可以忽略这个逗号，但在IE中则报错。<br><a id=\"more\"></a><br>所有通过对象直接量创建的对象具有同一个原型对象，即Object.prototype。Object.prototype没有原型。</p>\n<ol start=\"2\">\n<li>使用new运算符</li>\n</ol>\n<p>关键字new后跟随一个构造函数使用，创建的对象的原型是构造函数的prototype属性的值。</p>\n<p>所有通过对象直接量创建的对象具有同一个原型对象，即Object.prototype。Object.prototype没有原型。</p>\n<ol start=\"3\">\n<li>使用Object.create() </li>\n</ol>\n<p>ECMAScript 5中使用Object.create(obj)传入原型对象，创建的对象会继承该原型的属性。传入Null则创建一个没有原型的对象,不继承任何属性。</p>\n<p>在ECMASCript 3中模拟原型继承<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inherit</span>(<span class=\"params\">p</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">null</span>) <span class=\"keyword\">throw</span> <span class=\"built_in\">TypeError</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.create) <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.create(p);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> t = <span class=\"keyword\">typeof</span> p;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t != <span class=\"string\">'function'</span> &amp;&amp; t != <span class=\"string\">'object'</span>) <span class=\"keyword\">throw</span> <span class=\"built_in\">TypeError</span>();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; &#125;;</span><br><span class=\"line\">    f.prototype = p;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> f()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-2-属性的查询和设置\"><a href=\"#6-2-属性的查询和设置\" class=\"headerlink\" title=\"6.2 属性的查询和设置\"></a>6.2 属性的查询和设置</h2><p>可以通过点(.)或者方括号([])运算符获取属性的值。</p>\n<p>Javascript对象具有’自有属性’，也有原型属性是从原型对象继承而来的。</p>\n<p>查询对象o的属性x，如果在o中找不到x，则在o的原型对象中查找属性x。如果该原型对象也没有属性x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到x属性或者一个原型是null的对象为止。即对象的原型属性构成一个’链’。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;&#125;</span><br><span class=\"line\">o.x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = inherit(o)</span><br><span class=\"line\">p.y = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> q = inherit(p)</span><br><span class=\"line\">q.z = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s = q.toString()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s)<span class=\"comment\">//[object Object]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(q.x+q.y)<span class=\"comment\">//3</span></span><br></pre></td></tr></table></figure></p>\n<p>如果允许属性赋值操作，那么它总是在原始对象上进行属性创建或者对已有属性进行赋值，而不会去修改原型链。</p>\n<p>查询属性才和继承有关，设置属性则无关，改特性可以选择性得覆盖继承的属性。</p>\n<p>查询一个不存在的属性不会报错，返回undefined。如果对象不存在，查找这个不存在的对象的属性就会报错。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> len = book&amp;&amp;book.substitle&amp;&amp;book.substitle.length;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-3删除属性\"><a href=\"#6-3删除属性\" class=\"headerlink\" title=\"6.3删除属性\"></a>6.3删除属性</h2><p>使用delete刪除屬性。delete只是断开属性与宿主之间的联系，而不会去操作属性中的属性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">p</span>:&#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a.p;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> a.p;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.p);<span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);<span class=\"comment\">//&#123;x:1&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>delete不行删除可configurable为false的属性。</p>\n<h2 id=\"6-4检测属性\"><a href=\"#6-4检测属性\" class=\"headerlink\" title=\"6.4检测属性\"></a>6.4检测属性</h2><p>检测某个属性是否存在于某个对象中。</p>\n<ol>\n<li>in运算符</li>\n</ol>\n<p>如果对象的自有属性或继承属性包含这个属性，则返回true。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'x'</span> <span class=\"keyword\">in</span> a);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'toString'</span> <span class=\"keyword\">in</span> a);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"string\">`</span></span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>hasOwnProperty()</li>\n</ol>\n<p>该方法用来检测给定的名字是否是对象的自有属性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.hasOwnProperty(<span class=\"string\">'x'</span>));<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.hasOwnProperty(<span class=\"string\">'toString'</span>));<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\">\n<li>propertyIsEnumerable()</li>\n</ol>\n<p>检测到是自有属性且这个属性的enumerable特性为true是，返回true。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = inherit(&#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">o.y = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o.propertyIsEnumerable(<span class=\"string\">'x'</span>))<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o.propertyIsEnumerable(<span class=\"string\">'y'</span>))<span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o.propertyIsEnumerable(<span class=\"string\">'toString'</span>))<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-5枚举属性\"><a href=\"#6-5枚举属性\" class=\"headerlink\" title=\"6.5枚举属性\"></a>6.5枚举属性</h2><p>使用for/in便利对象所有可枚举的属性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span> ,<span class=\"attr\">y</span>:<span class=\"number\">2</span>, <span class=\"attr\">z</span>:<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o.propertyIsEnumerable(<span class=\"string\">'toString'</span>))<span class=\"comment\">//fasle</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(prop <span class=\"keyword\">in</span> o)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(prop)</span><br><span class=\"line\">&#125;<span class=\"comment\">//x y z</span></span><br></pre></td></tr></table></figure></p>\n<p>ECMAScript 5中使用Object.keys(obj)返回一个数组，数组由对象中的可枚举的自有属性组成。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>,<span class=\"attr\">y</span>:<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(o,<span class=\"string\">'y'</span>,&#123;<span class=\"attr\">enumerable</span>:<span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(o));<span class=\"comment\">//['x']</span></span><br></pre></td></tr></table></figure></p>\n<p>ECMAScript 5中使用Object.getOwnPropertyNames(obj)返回对象所有的自有属性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>,<span class=\"attr\">y</span>:<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(o,<span class=\"string\">'y'</span>,&#123;<span class=\"attr\">enumerable</span>:<span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyNames(o));<span class=\"comment\">//['x','y']</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-6属性的getter和setter\"><a href=\"#6-6属性的getter和setter\" class=\"headerlink\" title=\"6.6属性的getter和setter\"></a>6.6属性的getter和setter</h2><p>在ECMAScript 5中 ，对象的属性可以有一个或两个函数代替，即getter和getter。由getter和setter定义的属性叫做’存取器属性’(accessor property)，不同于’数据属性’(data property)。</p>\n<p>存取器属性定义为一个或两个和属性同名的函数，不使用function关键字，而是使用get和set。</p>\n<p>存取器属性不具有可写性(writable attribute)。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> serialNum=&#123;</span><br><span class=\"line\">    $n:<span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"keyword\">get</span> next()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$n++</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">set</span> next(n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n&gt;<span class=\"keyword\">this</span>.$n) <span class=\"keyword\">this</span>.$n=n*<span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">throw</span> <span class=\"string\">'序列号的值不能比当前值小'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(serialNum.next)<span class=\"comment\">//0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(serialNum.next)<span class=\"comment\">//1</span></span><br><span class=\"line\">serialNum.next=<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(serialNum.next)<span class=\"comment\">//30</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(serialNum.next)<span class=\"comment\">//31</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-7属性的特性\"><a href=\"#6-7属性的特性\" class=\"headerlink\" title=\"6.7属性的特性\"></a>6.7属性的特性</h2><p>数据属性的4个特性是：value writable enumerable configurable。</p>\n<p>存取器属性不具有value和writable特性，其可写性有setter方法是否存在决定。</p>\n<p>存取器属性的4个特性是：get set enumerable configurable。</p>\n<p>通过调用Object.getOwnPropertyDescriptor(obj,propName)获得某个对象特定属性的属性描述符。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(&#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;,<span class=\"string\">'x'</span>))<span class=\"comment\">//&#123; value: 1, writable: true, enumerable: true, configurable: true &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>设置属性的特性则是使用Object.defineProperty(obj,propName,desc)和Object.defineProperties(obj,desc)</p>\n<p>赋值属性的特性<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">Object</span>.prototype,<span class=\"string\">'extend'</span>,&#123;</span><br><span class=\"line\">    writable:<span class=\"literal\">true</span>,</span><br><span class=\"line\">    enumerable:<span class=\"literal\">false</span>,</span><br><span class=\"line\">    configurable:<span class=\"literal\">true</span>,</span><br><span class=\"line\">    value:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> names=<span class=\"built_in\">Object</span>.getOwnPropertyNames(o);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>( <span class=\"keyword\">let</span> i=<span class=\"number\">0</span>;i&lt;names.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(names[i] <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> desc = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(o,names[i]);</span><br><span class=\"line\">            <span class=\"built_in\">Object</span>.defineProperty(<span class=\"keyword\">this</span>,names[i],desc)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-8对象的3个属性\"><a href=\"#6-8对象的3个属性\" class=\"headerlink\" title=\"6.8对象的3个属性\"></a>6.8对象的3个属性</h2><ol>\n<li>原型(prototype)</li>\n</ol>\n<p>ECMAScript 5中使用Object.getProprttyOf(obj)查询对象的原型。</p>\n<p>ECMAScript 3中使用o.constructor.prototype检查对象的原型(不可靠)。</p>\n<p>使用isPrototypeOf检测一个对象是否是另一个对象的原型。</p>\n<ol start=\"2\">\n<li>类属性(class attribute)</li>\n</ol>\n<p>查询方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">classOf</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(o===<span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"string\">'Null'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(o===<span class=\"literal\">undefined</span>) <span class=\"keyword\">return</span> <span class=\"string\">'Undefined'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>,<span class=\"number\">-1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\">\n<li>可扩展性(extensible attribute)</li>\n</ol>\n<p>对象的可扩展性表示是否可以给对象添加新属性。</p>\n<p>所以内置对象和自定义对象都是显式可扩展的。</p>\n<p>可以通过Object.esExtensible(obj)来检测对象是否是可扩展的</p>\n<p>通过Object.preventExtensions(obj)、Object.seal(obj)、Object.freeze(obj)来将对象设置为不可扩展的</p>\n<h2 id=\"6-9序列化对象\"><a href=\"#6-9序列化对象\" class=\"headerlink\" title=\"6.9序列化对象\"></a>6.9序列化对象</h2><p>对象序列化(serialization)是指对象的状态和字符串的互相转换。</p>\n<p>ECMAScript 5内置函数JSON.stringify()和JSON.parse()来序列化和还原对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>,<span class=\"attr\">y</span>:&#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"built_in\">JSON</span>.stringify(o);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s);<span class=\"comment\">//&#123;\"x\":1,\"y\":&#123;\"a\":1&#125;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.parse(s));<span class=\"comment\">//Object &#123;x: 1, y: Object&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-10对象方法\"><a href=\"#6-10对象方法\" class=\"headerlink\" title=\"6.10对象方法\"></a>6.10对象方法</h2><p>Object.prototype里常见的方法，例如toString(),valueOf()等，但有些特定的类会重写这些方法。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"6-1-创建对象\"><a href=\"#6-1-创建对象\" class=\"headerlink\" title=\"6.1 创建对象\"></a>6.1 创建对象</h2><h3 id=\"创建对象三种的方式\"><a href=\"#创建对象三种的方式\" class=\"headerlink\" title=\"创建对象三种的方式\"></a>创建对象三种的方式</h3><ol>\n<li>使用对象直接量</li>\n</ol>\n<p>创建对象最简单的方式就是在JavaScript代码中使用对象直接量(key / value)。</p>\n<p>在ECMAScript 5中，对象直接量中的最后一个属性后的逗号将忽略，且在ECMAScript 3的大部分实行中也可以忽略这个逗号，但在IE中则报错。<br>","more":"<br>所有通过对象直接量创建的对象具有同一个原型对象，即Object.prototype。Object.prototype没有原型。</p>\n<ol start=\"2\">\n<li>使用new运算符</li>\n</ol>\n<p>关键字new后跟随一个构造函数使用，创建的对象的原型是构造函数的prototype属性的值。</p>\n<p>所有通过对象直接量创建的对象具有同一个原型对象，即Object.prototype。Object.prototype没有原型。</p>\n<ol start=\"3\">\n<li>使用Object.create() </li>\n</ol>\n<p>ECMAScript 5中使用Object.create(obj)传入原型对象，创建的对象会继承该原型的属性。传入Null则创建一个没有原型的对象,不继承任何属性。</p>\n<p>在ECMASCript 3中模拟原型继承<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inherit</span>(<span class=\"params\">p</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">null</span>) <span class=\"keyword\">throw</span> <span class=\"built_in\">TypeError</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.create) <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.create(p);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> t = <span class=\"keyword\">typeof</span> p;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t != <span class=\"string\">'function'</span> &amp;&amp; t != <span class=\"string\">'object'</span>) <span class=\"keyword\">throw</span> <span class=\"built_in\">TypeError</span>();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; &#125;;</span><br><span class=\"line\">    f.prototype = p;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> f()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-2-属性的查询和设置\"><a href=\"#6-2-属性的查询和设置\" class=\"headerlink\" title=\"6.2 属性的查询和设置\"></a>6.2 属性的查询和设置</h2><p>可以通过点(.)或者方括号([])运算符获取属性的值。</p>\n<p>Javascript对象具有’自有属性’，也有原型属性是从原型对象继承而来的。</p>\n<p>查询对象o的属性x，如果在o中找不到x，则在o的原型对象中查找属性x。如果该原型对象也没有属性x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到x属性或者一个原型是null的对象为止。即对象的原型属性构成一个’链’。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;&#125;</span><br><span class=\"line\">o.x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = inherit(o)</span><br><span class=\"line\">p.y = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> q = inherit(p)</span><br><span class=\"line\">q.z = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s = q.toString()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s)<span class=\"comment\">//[object Object]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(q.x+q.y)<span class=\"comment\">//3</span></span><br></pre></td></tr></table></figure></p>\n<p>如果允许属性赋值操作，那么它总是在原始对象上进行属性创建或者对已有属性进行赋值，而不会去修改原型链。</p>\n<p>查询属性才和继承有关，设置属性则无关，改特性可以选择性得覆盖继承的属性。</p>\n<p>查询一个不存在的属性不会报错，返回undefined。如果对象不存在，查找这个不存在的对象的属性就会报错。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> len = book&amp;&amp;book.substitle&amp;&amp;book.substitle.length;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-3删除属性\"><a href=\"#6-3删除属性\" class=\"headerlink\" title=\"6.3删除属性\"></a>6.3删除属性</h2><p>使用delete刪除屬性。delete只是断开属性与宿主之间的联系，而不会去操作属性中的属性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">p</span>:&#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a.p;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> a.p;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.p);<span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);<span class=\"comment\">//&#123;x:1&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>delete不行删除可configurable为false的属性。</p>\n<h2 id=\"6-4检测属性\"><a href=\"#6-4检测属性\" class=\"headerlink\" title=\"6.4检测属性\"></a>6.4检测属性</h2><p>检测某个属性是否存在于某个对象中。</p>\n<ol>\n<li>in运算符</li>\n</ol>\n<p>如果对象的自有属性或继承属性包含这个属性，则返回true。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'x'</span> <span class=\"keyword\">in</span> a);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'toString'</span> <span class=\"keyword\">in</span> a);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"string\">`</span></span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>hasOwnProperty()</li>\n</ol>\n<p>该方法用来检测给定的名字是否是对象的自有属性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.hasOwnProperty(<span class=\"string\">'x'</span>));<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.hasOwnProperty(<span class=\"string\">'toString'</span>));<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\">\n<li>propertyIsEnumerable()</li>\n</ol>\n<p>检测到是自有属性且这个属性的enumerable特性为true是，返回true。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = inherit(&#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">o.y = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o.propertyIsEnumerable(<span class=\"string\">'x'</span>))<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o.propertyIsEnumerable(<span class=\"string\">'y'</span>))<span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o.propertyIsEnumerable(<span class=\"string\">'toString'</span>))<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-5枚举属性\"><a href=\"#6-5枚举属性\" class=\"headerlink\" title=\"6.5枚举属性\"></a>6.5枚举属性</h2><p>使用for/in便利对象所有可枚举的属性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span> ,<span class=\"attr\">y</span>:<span class=\"number\">2</span>, <span class=\"attr\">z</span>:<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o.propertyIsEnumerable(<span class=\"string\">'toString'</span>))<span class=\"comment\">//fasle</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(prop <span class=\"keyword\">in</span> o)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(prop)</span><br><span class=\"line\">&#125;<span class=\"comment\">//x y z</span></span><br></pre></td></tr></table></figure></p>\n<p>ECMAScript 5中使用Object.keys(obj)返回一个数组，数组由对象中的可枚举的自有属性组成。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>,<span class=\"attr\">y</span>:<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(o,<span class=\"string\">'y'</span>,&#123;<span class=\"attr\">enumerable</span>:<span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(o));<span class=\"comment\">//['x']</span></span><br></pre></td></tr></table></figure></p>\n<p>ECMAScript 5中使用Object.getOwnPropertyNames(obj)返回对象所有的自有属性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>,<span class=\"attr\">y</span>:<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(o,<span class=\"string\">'y'</span>,&#123;<span class=\"attr\">enumerable</span>:<span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyNames(o));<span class=\"comment\">//['x','y']</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-6属性的getter和setter\"><a href=\"#6-6属性的getter和setter\" class=\"headerlink\" title=\"6.6属性的getter和setter\"></a>6.6属性的getter和setter</h2><p>在ECMAScript 5中 ，对象的属性可以有一个或两个函数代替，即getter和getter。由getter和setter定义的属性叫做’存取器属性’(accessor property)，不同于’数据属性’(data property)。</p>\n<p>存取器属性定义为一个或两个和属性同名的函数，不使用function关键字，而是使用get和set。</p>\n<p>存取器属性不具有可写性(writable attribute)。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> serialNum=&#123;</span><br><span class=\"line\">    $n:<span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"keyword\">get</span> next()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$n++</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">set</span> next(n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n&gt;<span class=\"keyword\">this</span>.$n) <span class=\"keyword\">this</span>.$n=n*<span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">throw</span> <span class=\"string\">'序列号的值不能比当前值小'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(serialNum.next)<span class=\"comment\">//0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(serialNum.next)<span class=\"comment\">//1</span></span><br><span class=\"line\">serialNum.next=<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(serialNum.next)<span class=\"comment\">//30</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(serialNum.next)<span class=\"comment\">//31</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-7属性的特性\"><a href=\"#6-7属性的特性\" class=\"headerlink\" title=\"6.7属性的特性\"></a>6.7属性的特性</h2><p>数据属性的4个特性是：value writable enumerable configurable。</p>\n<p>存取器属性不具有value和writable特性，其可写性有setter方法是否存在决定。</p>\n<p>存取器属性的4个特性是：get set enumerable configurable。</p>\n<p>通过调用Object.getOwnPropertyDescriptor(obj,propName)获得某个对象特定属性的属性描述符。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(&#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;,<span class=\"string\">'x'</span>))<span class=\"comment\">//&#123; value: 1, writable: true, enumerable: true, configurable: true &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>设置属性的特性则是使用Object.defineProperty(obj,propName,desc)和Object.defineProperties(obj,desc)</p>\n<p>赋值属性的特性<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">Object</span>.prototype,<span class=\"string\">'extend'</span>,&#123;</span><br><span class=\"line\">    writable:<span class=\"literal\">true</span>,</span><br><span class=\"line\">    enumerable:<span class=\"literal\">false</span>,</span><br><span class=\"line\">    configurable:<span class=\"literal\">true</span>,</span><br><span class=\"line\">    value:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> names=<span class=\"built_in\">Object</span>.getOwnPropertyNames(o);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>( <span class=\"keyword\">let</span> i=<span class=\"number\">0</span>;i&lt;names.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(names[i] <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> desc = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(o,names[i]);</span><br><span class=\"line\">            <span class=\"built_in\">Object</span>.defineProperty(<span class=\"keyword\">this</span>,names[i],desc)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-8对象的3个属性\"><a href=\"#6-8对象的3个属性\" class=\"headerlink\" title=\"6.8对象的3个属性\"></a>6.8对象的3个属性</h2><ol>\n<li>原型(prototype)</li>\n</ol>\n<p>ECMAScript 5中使用Object.getProprttyOf(obj)查询对象的原型。</p>\n<p>ECMAScript 3中使用o.constructor.prototype检查对象的原型(不可靠)。</p>\n<p>使用isPrototypeOf检测一个对象是否是另一个对象的原型。</p>\n<ol start=\"2\">\n<li>类属性(class attribute)</li>\n</ol>\n<p>查询方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">classOf</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(o===<span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"string\">'Null'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(o===<span class=\"literal\">undefined</span>) <span class=\"keyword\">return</span> <span class=\"string\">'Undefined'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>,<span class=\"number\">-1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\">\n<li>可扩展性(extensible attribute)</li>\n</ol>\n<p>对象的可扩展性表示是否可以给对象添加新属性。</p>\n<p>所以内置对象和自定义对象都是显式可扩展的。</p>\n<p>可以通过Object.esExtensible(obj)来检测对象是否是可扩展的</p>\n<p>通过Object.preventExtensions(obj)、Object.seal(obj)、Object.freeze(obj)来将对象设置为不可扩展的</p>\n<h2 id=\"6-9序列化对象\"><a href=\"#6-9序列化对象\" class=\"headerlink\" title=\"6.9序列化对象\"></a>6.9序列化对象</h2><p>对象序列化(serialization)是指对象的状态和字符串的互相转换。</p>\n<p>ECMAScript 5内置函数JSON.stringify()和JSON.parse()来序列化和还原对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>,<span class=\"attr\">y</span>:&#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"built_in\">JSON</span>.stringify(o);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s);<span class=\"comment\">//&#123;\"x\":1,\"y\":&#123;\"a\":1&#125;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.parse(s));<span class=\"comment\">//Object &#123;x: 1, y: Object&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-10对象方法\"><a href=\"#6-10对象方法\" class=\"headerlink\" title=\"6.10对象方法\"></a>6.10对象方法</h2><p>Object.prototype里常见的方法，例如toString(),valueOf()等，但有些特定的类会重写这些方法。</p>"},{"title":"《图解http》第三章笔记","date":"2017-09-15T16:00:00.000Z","_content":"## HTTP报文内的HTTP信息\n### HTTP报文\n用于HTTP协议交互的信息被称为HTTP报文。HTTP报文本身是由多行（使用CRLF作换行符）数据构成的字符串文本。\n\nHTTP报文大体可分为报文首部和报文实体。两者有最初出现的空行（CRLF）来划分。\n<!--more-->\n### 请求报文及响应报文的结构\n请求报文和响应报文的内容由以下数据组成：\n* 请求行\n    包含用于请求的方法，请求URI和HTTP版本。\n* 状态行\n    包含表明响应状态的状态码，原因短语和HTTP版本。\n* 首部字段\n    包含表示请求和响应的各种条件和属性的各类首部。一般有4种首部：通用首部，请求首部，响应首部，实体首部。\n* 其他\n    可能包含HTTP的RFC里未定义的首部。\n### 编码提升传输速率\n报文主体和实体主体的差异：\n* 报文（message）\n    是HTTP通信中的基本单位，由8位组字节流（octet sequence，其中octet为8个比特）组成，通过HTTP通信传输。\n* 实体（entity）\n    作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成。\n\nHTTP报文的主体用于传输请求或响应的实体主体。\n\n通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。\n\n内容编码应指明应用在实体内容上的编码格式，并保持实体信息的原样压缩。编码后的实体由客户端负责接收和解码。\n\n常用的内容编码有以下几种：\n* gzip（GNU zip）\n* compress（UNIX系统的标准压缩）\n* deflate（zlib）\n* identity不进行编码）\n在传输大数据容量时，通过把数据分割成多块，能够让浏览器逐步显示画面。这种把主体实体分块的功能称为分块传输编码（Chunked Transfer Coding）。\n\n分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记大小，而实体主体的最后一块会用'0(CRLF)'来标记。\n\n使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码之前的实体主体。\n### 发送多种数据的多部分对象集合\n多部分对象集合包含的对象如下：\n* multipart/form-data\n    在Web表单上传时使用\n* multipart/byteranges\n    状态码206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。\n在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-Type。\n\n使用boundary字符串来划分多部分对象集合指明的各类实体。\n### 获取部分内容的范围请求\n指定范围发送的请求叫做范围请求（Range Request）。\n\n执行范围请求时，会使用首部字段Range来指定资源是byte范围。byte范围的指定形式如下：\n\n* 5001 ~ 10000字节\n    Range: bytes=5001-10000\n* 从5001字节之后到全部\n    Range: bytes=5001-\n* 从一开始到3000字节和5000字节到7000字节的多重范围\n    bytes: -3000, 5000-7000\n针对范围请求，响应会返回状态码为206 Partial Content的响应报文。\n\n对多重范围的范围请求，响应会在首部字段标明Content-Type为multipart/byteranges后返回响应报文。\n\n如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。\n### 内容协商返回最适合的内容\n内容协商（Content Negotiation）机制是指客户端和服务端就就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。\n\n内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。如以下的首部字段，可作为基准：\n\n* Accept\n* Accept-charset\n* Accept-Encoding\n* Accept-Language \n* Content-Language \n内容协商技术有以下三种类型：\n* 服务器驱动协商（Server-driven Negotiation）\n* 客户端驱动协商（Agent-driven Negotiation）\n* 透明协商（Transparent Negotiation）\n","source":"_posts/《图解http》第三章笔记.md","raw":"---\ntitle: 《图解http》第三章笔记\ndate: 2017-09-16\ntags: ['http']\ncategories: ['笔记']\n---\n## HTTP报文内的HTTP信息\n### HTTP报文\n用于HTTP协议交互的信息被称为HTTP报文。HTTP报文本身是由多行（使用CRLF作换行符）数据构成的字符串文本。\n\nHTTP报文大体可分为报文首部和报文实体。两者有最初出现的空行（CRLF）来划分。\n<!--more-->\n### 请求报文及响应报文的结构\n请求报文和响应报文的内容由以下数据组成：\n* 请求行\n    包含用于请求的方法，请求URI和HTTP版本。\n* 状态行\n    包含表明响应状态的状态码，原因短语和HTTP版本。\n* 首部字段\n    包含表示请求和响应的各种条件和属性的各类首部。一般有4种首部：通用首部，请求首部，响应首部，实体首部。\n* 其他\n    可能包含HTTP的RFC里未定义的首部。\n### 编码提升传输速率\n报文主体和实体主体的差异：\n* 报文（message）\n    是HTTP通信中的基本单位，由8位组字节流（octet sequence，其中octet为8个比特）组成，通过HTTP通信传输。\n* 实体（entity）\n    作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成。\n\nHTTP报文的主体用于传输请求或响应的实体主体。\n\n通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。\n\n内容编码应指明应用在实体内容上的编码格式，并保持实体信息的原样压缩。编码后的实体由客户端负责接收和解码。\n\n常用的内容编码有以下几种：\n* gzip（GNU zip）\n* compress（UNIX系统的标准压缩）\n* deflate（zlib）\n* identity不进行编码）\n在传输大数据容量时，通过把数据分割成多块，能够让浏览器逐步显示画面。这种把主体实体分块的功能称为分块传输编码（Chunked Transfer Coding）。\n\n分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记大小，而实体主体的最后一块会用'0(CRLF)'来标记。\n\n使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码之前的实体主体。\n### 发送多种数据的多部分对象集合\n多部分对象集合包含的对象如下：\n* multipart/form-data\n    在Web表单上传时使用\n* multipart/byteranges\n    状态码206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。\n在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-Type。\n\n使用boundary字符串来划分多部分对象集合指明的各类实体。\n### 获取部分内容的范围请求\n指定范围发送的请求叫做范围请求（Range Request）。\n\n执行范围请求时，会使用首部字段Range来指定资源是byte范围。byte范围的指定形式如下：\n\n* 5001 ~ 10000字节\n    Range: bytes=5001-10000\n* 从5001字节之后到全部\n    Range: bytes=5001-\n* 从一开始到3000字节和5000字节到7000字节的多重范围\n    bytes: -3000, 5000-7000\n针对范围请求，响应会返回状态码为206 Partial Content的响应报文。\n\n对多重范围的范围请求，响应会在首部字段标明Content-Type为multipart/byteranges后返回响应报文。\n\n如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。\n### 内容协商返回最适合的内容\n内容协商（Content Negotiation）机制是指客户端和服务端就就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。\n\n内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。如以下的首部字段，可作为基准：\n\n* Accept\n* Accept-charset\n* Accept-Encoding\n* Accept-Language \n* Content-Language \n内容协商技术有以下三种类型：\n* 服务器驱动协商（Server-driven Negotiation）\n* 客户端驱动协商（Agent-driven Negotiation）\n* 透明协商（Transparent Negotiation）\n","slug":"《图解http》第三章笔记","published":1,"updated":"2022-04-13T14:14:07.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffj0021g3t89be1m2tj","content":"<h2 id=\"HTTP报文内的HTTP信息\"><a href=\"#HTTP报文内的HTTP信息\" class=\"headerlink\" title=\"HTTP报文内的HTTP信息\"></a>HTTP报文内的HTTP信息</h2><h3 id=\"HTTP报文\"><a href=\"#HTTP报文\" class=\"headerlink\" title=\"HTTP报文\"></a>HTTP报文</h3><p>用于HTTP协议交互的信息被称为HTTP报文。HTTP报文本身是由多行（使用CRLF作换行符）数据构成的字符串文本。</p>\n<p>HTTP报文大体可分为报文首部和报文实体。两者有最初出现的空行（CRLF）来划分。<br><a id=\"more\"></a></p>\n<h3 id=\"请求报文及响应报文的结构\"><a href=\"#请求报文及响应报文的结构\" class=\"headerlink\" title=\"请求报文及响应报文的结构\"></a>请求报文及响应报文的结构</h3><p>请求报文和响应报文的内容由以下数据组成：</p>\n<ul>\n<li>请求行<br>  包含用于请求的方法，请求URI和HTTP版本。</li>\n<li>状态行<br>  包含表明响应状态的状态码，原因短语和HTTP版本。</li>\n<li>首部字段<br>  包含表示请求和响应的各种条件和属性的各类首部。一般有4种首部：通用首部，请求首部，响应首部，实体首部。</li>\n<li>其他<br>  可能包含HTTP的RFC里未定义的首部。<h3 id=\"编码提升传输速率\"><a href=\"#编码提升传输速率\" class=\"headerlink\" title=\"编码提升传输速率\"></a>编码提升传输速率</h3>报文主体和实体主体的差异：</li>\n<li>报文（message）<br>  是HTTP通信中的基本单位，由8位组字节流（octet sequence，其中octet为8个比特）组成，通过HTTP通信传输。</li>\n<li>实体（entity）<br>  作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成。</li>\n</ul>\n<p>HTTP报文的主体用于传输请求或响应的实体主体。</p>\n<p>通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p>\n<p>内容编码应指明应用在实体内容上的编码格式，并保持实体信息的原样压缩。编码后的实体由客户端负责接收和解码。</p>\n<p>常用的内容编码有以下几种：</p>\n<ul>\n<li>gzip（GNU zip）</li>\n<li>compress（UNIX系统的标准压缩）</li>\n<li>deflate（zlib）</li>\n<li>identity不进行编码）<br>在传输大数据容量时，通过把数据分割成多块，能够让浏览器逐步显示画面。这种把主体实体分块的功能称为分块传输编码（Chunked Transfer Coding）。</li>\n</ul>\n<p>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记大小，而实体主体的最后一块会用’0(CRLF)’来标记。</p>\n<p>使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码之前的实体主体。</p>\n<h3 id=\"发送多种数据的多部分对象集合\"><a href=\"#发送多种数据的多部分对象集合\" class=\"headerlink\" title=\"发送多种数据的多部分对象集合\"></a>发送多种数据的多部分对象集合</h3><p>多部分对象集合包含的对象如下：</p>\n<ul>\n<li>multipart/form-data<br>  在Web表单上传时使用</li>\n<li>multipart/byteranges<br>  状态码206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。<br>在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-Type。</li>\n</ul>\n<p>使用boundary字符串来划分多部分对象集合指明的各类实体。</p>\n<h3 id=\"获取部分内容的范围请求\"><a href=\"#获取部分内容的范围请求\" class=\"headerlink\" title=\"获取部分内容的范围请求\"></a>获取部分内容的范围请求</h3><p>指定范围发送的请求叫做范围请求（Range Request）。</p>\n<p>执行范围请求时，会使用首部字段Range来指定资源是byte范围。byte范围的指定形式如下：</p>\n<ul>\n<li>5001 ~ 10000字节<br>  Range: bytes=5001-10000</li>\n<li>从5001字节之后到全部<br>  Range: bytes=5001-</li>\n<li>从一开始到3000字节和5000字节到7000字节的多重范围<br>  bytes: -3000, 5000-7000<br>针对范围请求，响应会返回状态码为206 Partial Content的响应报文。</li>\n</ul>\n<p>对多重范围的范围请求，响应会在首部字段标明Content-Type为multipart/byteranges后返回响应报文。</p>\n<p>如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。</p>\n<h3 id=\"内容协商返回最适合的内容\"><a href=\"#内容协商返回最适合的内容\" class=\"headerlink\" title=\"内容协商返回最适合的内容\"></a>内容协商返回最适合的内容</h3><p>内容协商（Content Negotiation）机制是指客户端和服务端就就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。</p>\n<p>内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。如以下的首部字段，可作为基准：</p>\n<ul>\n<li>Accept</li>\n<li>Accept-charset</li>\n<li>Accept-Encoding</li>\n<li>Accept-Language </li>\n<li>Content-Language<br>内容协商技术有以下三种类型：</li>\n<li>服务器驱动协商（Server-driven Negotiation）</li>\n<li>客户端驱动协商（Agent-driven Negotiation）</li>\n<li>透明协商（Transparent Negotiation）</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"HTTP报文内的HTTP信息\"><a href=\"#HTTP报文内的HTTP信息\" class=\"headerlink\" title=\"HTTP报文内的HTTP信息\"></a>HTTP报文内的HTTP信息</h2><h3 id=\"HTTP报文\"><a href=\"#HTTP报文\" class=\"headerlink\" title=\"HTTP报文\"></a>HTTP报文</h3><p>用于HTTP协议交互的信息被称为HTTP报文。HTTP报文本身是由多行（使用CRLF作换行符）数据构成的字符串文本。</p>\n<p>HTTP报文大体可分为报文首部和报文实体。两者有最初出现的空行（CRLF）来划分。<br>","more":"</p>\n<h3 id=\"请求报文及响应报文的结构\"><a href=\"#请求报文及响应报文的结构\" class=\"headerlink\" title=\"请求报文及响应报文的结构\"></a>请求报文及响应报文的结构</h3><p>请求报文和响应报文的内容由以下数据组成：</p>\n<ul>\n<li>请求行<br>  包含用于请求的方法，请求URI和HTTP版本。</li>\n<li>状态行<br>  包含表明响应状态的状态码，原因短语和HTTP版本。</li>\n<li>首部字段<br>  包含表示请求和响应的各种条件和属性的各类首部。一般有4种首部：通用首部，请求首部，响应首部，实体首部。</li>\n<li>其他<br>  可能包含HTTP的RFC里未定义的首部。<h3 id=\"编码提升传输速率\"><a href=\"#编码提升传输速率\" class=\"headerlink\" title=\"编码提升传输速率\"></a>编码提升传输速率</h3>报文主体和实体主体的差异：</li>\n<li>报文（message）<br>  是HTTP通信中的基本单位，由8位组字节流（octet sequence，其中octet为8个比特）组成，通过HTTP通信传输。</li>\n<li>实体（entity）<br>  作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成。</li>\n</ul>\n<p>HTTP报文的主体用于传输请求或响应的实体主体。</p>\n<p>通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p>\n<p>内容编码应指明应用在实体内容上的编码格式，并保持实体信息的原样压缩。编码后的实体由客户端负责接收和解码。</p>\n<p>常用的内容编码有以下几种：</p>\n<ul>\n<li>gzip（GNU zip）</li>\n<li>compress（UNIX系统的标准压缩）</li>\n<li>deflate（zlib）</li>\n<li>identity不进行编码）<br>在传输大数据容量时，通过把数据分割成多块，能够让浏览器逐步显示画面。这种把主体实体分块的功能称为分块传输编码（Chunked Transfer Coding）。</li>\n</ul>\n<p>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记大小，而实体主体的最后一块会用’0(CRLF)’来标记。</p>\n<p>使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码之前的实体主体。</p>\n<h3 id=\"发送多种数据的多部分对象集合\"><a href=\"#发送多种数据的多部分对象集合\" class=\"headerlink\" title=\"发送多种数据的多部分对象集合\"></a>发送多种数据的多部分对象集合</h3><p>多部分对象集合包含的对象如下：</p>\n<ul>\n<li>multipart/form-data<br>  在Web表单上传时使用</li>\n<li>multipart/byteranges<br>  状态码206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。<br>在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-Type。</li>\n</ul>\n<p>使用boundary字符串来划分多部分对象集合指明的各类实体。</p>\n<h3 id=\"获取部分内容的范围请求\"><a href=\"#获取部分内容的范围请求\" class=\"headerlink\" title=\"获取部分内容的范围请求\"></a>获取部分内容的范围请求</h3><p>指定范围发送的请求叫做范围请求（Range Request）。</p>\n<p>执行范围请求时，会使用首部字段Range来指定资源是byte范围。byte范围的指定形式如下：</p>\n<ul>\n<li>5001 ~ 10000字节<br>  Range: bytes=5001-10000</li>\n<li>从5001字节之后到全部<br>  Range: bytes=5001-</li>\n<li>从一开始到3000字节和5000字节到7000字节的多重范围<br>  bytes: -3000, 5000-7000<br>针对范围请求，响应会返回状态码为206 Partial Content的响应报文。</li>\n</ul>\n<p>对多重范围的范围请求，响应会在首部字段标明Content-Type为multipart/byteranges后返回响应报文。</p>\n<p>如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。</p>\n<h3 id=\"内容协商返回最适合的内容\"><a href=\"#内容协商返回最适合的内容\" class=\"headerlink\" title=\"内容协商返回最适合的内容\"></a>内容协商返回最适合的内容</h3><p>内容协商（Content Negotiation）机制是指客户端和服务端就就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。</p>\n<p>内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。如以下的首部字段，可作为基准：</p>\n<ul>\n<li>Accept</li>\n<li>Accept-charset</li>\n<li>Accept-Encoding</li>\n<li>Accept-Language </li>\n<li>Content-Language<br>内容协商技术有以下三种类型：</li>\n<li>服务器驱动协商（Server-driven Negotiation）</li>\n<li>客户端驱动协商（Agent-driven Negotiation）</li>\n<li>透明协商（Transparent Negotiation）</li>\n</ul>"},{"title":"ES6 Promise学习笔记","date":"2017-03-03T16:00:00.000Z","_content":"## ES6 Promise\n1. [Promise的由来及含义](#a1)\n2. [Promise基本用法](#a2)\n3. [Promise.prototype.then()](#a3)\n4. [Promise.prototype.catch()](#a4)\n5. [Promise.all()](#a5)\n6. [Promise.race()](#a6)\n7. [Promise.resolve()](#a7)\n8. [Promise.reject()](#a8)\n9. [应用](#a9)\n10. [参考资料](#a10)\n<!--more-->\n***\n## <a id='a1'>1.Promise的由来及含义</a>\n一直以来，JavaScript处理异步都是以callback的方式，在前端开发领域callback机制几乎深入人心。在设计API的时候，不管是浏览器厂商还是SDK开发商亦或是各种类库的作者，基本上都已经遵循着callback的套路。\n\n在callback的模型里边，我们假设需要执行一个异步队列，代码看起来可能像这样：\n````javascript\nloadImg('a.jpg', function() {\n    loadImg('b.jpg', function() {\n        loadImg('c.jpg', function() {\n            console.log('all done!');\n        });\n    });\n});\n````\n\n近几年随着JavaScript开发模式的逐渐成熟，CommonJS规范顺势而生，其中就包括提出了Promise规范，Promise完全改变了js异步编程的写法，让异步编程变得十分的易于理解。\n\nPromise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。Promise对象有以下两个特点。\n\n（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。\n\n（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。\n## <a id='a2'>2.Promise基本用法</a>\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。\n\n下面代码创造了一个Promise实例。\n````javascript\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n````\nresolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected）\n\nPromise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数(可选)。这两个函数都接受Promise对象传出的值作为参数。\n````javascript\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n````\n## <a id='a3'>3.Promise.prototype.then()</a>\nthen方法是定义在原型对象Promise.prototype上的，因此Promise实例具有then方法。它的作用是为Promise实例添加状态改变时的回调函数。then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。\n\nthen方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\n````javascript\ngetJSON(\"/post/1.json\").then(\n  post => getJSON(post.commentURL)\n).then(\n  comments => console.log(\"Resolved: \", comments),\n  err => console.log(\"Rejected: \", err)\n);\n````\n## <a id='a4'>4.Promise.prototype.catch()</a>\nPromise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。\n\nPromise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。\n````javascript\ngetJSON('/post/1.json').then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // some code\n}).catch(function(error) {\n  // 处理前面三个Promise产生的错误\n});\n````\n跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。(Chrome浏览器不遵守这条规定)\n## <a id='a5'>5.Promise.all()</a>\nPromise.all方法用于将多个Promise实例，包装成一个新的Promise实例，类似“与”关系。\n````javascript\nvar p = Promise.all([p1, p2, p3]);\n````\np的状态由p1、p2、p3决定，分成两种情况。\n\n（1）只有p1、p2、p3的状态都变成resolve，p的状态才会变成resolve，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。\n\n（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。\n## <a id='a6'>6.Promise.race()</a>\nPromise.race方法同样是将多个Promise实例，包装成一个新的Promise实例，类似“或”关系。\n````javascript\nvar p = Promise.race([p1, p2, p3]);\n````\n只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。\n## <a id='a7'>7.Promise.resolve()</a>\nPromise.resolve()可将现有对象转为Promise对象。\n\nPromise.resolve方法的参数分成四种情况。\n\n（1）参数是一个Promise实例\n\n原封不动地返回这个实例。\n\n（2）参数是一个thenable对象\n\nPromise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。\n\n（3）参数不是具有then方法的对象，或根本就不是对象\n\n返回一个新的Promise对象，状态为Resolved。\n\n（4）不带有任何参数\n\n直接返回一个Resolved状态的Promise对象。\n## <a id='a8'>8.Promise.reject()</a>\nPromise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected.\n\nPromise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。\n\n````javascript\nconst thenable = {\n  then(resolve, reject) {\n    reject('出错了');\n  }\n};\n\nPromise.reject(thenable)\n.catch(e => {\n  console.log(e === thenable)\n})\n// true\n````\n## <a id='a9'>9.应用</a>\n### 延时等待\n````javascript\nfunction wait(duration){\n    return new Promise((resolve, reject)=>{\n        setTimeout(resolve,duration);\n    })\n}\nwait(1000).then(()=>{console.log('hello')}).then(()=>{return wait(2000)}).then(()=>{console.log('world')})\n````\n### 加载图片\n````javascript\nconst preloadImage = function (path) {\n  return new Promise(function (resolve, reject) {\n    var image = new Image();\n    image.onload  = resolve;\n    image.onerror = reject;\n    image.src = path;\n  });\n};\n````\n## <a id='a10'>10.参考资料</a>\n* [ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/promise)\n* [JavaScript Promise启示录](https://segmentfault.com/a/1190000000492290)\n* [一道关于Promise应用的面试题](http://www.cnblogs.com/dojo-lzz/p/5495671.html)\n","source":"_posts/promise.md","raw":"---\ntitle: ES6 Promise学习笔记\ndate: 2017-03-04\ntags: ['promise']\ncategories: ['笔记']\n---\n## ES6 Promise\n1. [Promise的由来及含义](#a1)\n2. [Promise基本用法](#a2)\n3. [Promise.prototype.then()](#a3)\n4. [Promise.prototype.catch()](#a4)\n5. [Promise.all()](#a5)\n6. [Promise.race()](#a6)\n7. [Promise.resolve()](#a7)\n8. [Promise.reject()](#a8)\n9. [应用](#a9)\n10. [参考资料](#a10)\n<!--more-->\n***\n## <a id='a1'>1.Promise的由来及含义</a>\n一直以来，JavaScript处理异步都是以callback的方式，在前端开发领域callback机制几乎深入人心。在设计API的时候，不管是浏览器厂商还是SDK开发商亦或是各种类库的作者，基本上都已经遵循着callback的套路。\n\n在callback的模型里边，我们假设需要执行一个异步队列，代码看起来可能像这样：\n````javascript\nloadImg('a.jpg', function() {\n    loadImg('b.jpg', function() {\n        loadImg('c.jpg', function() {\n            console.log('all done!');\n        });\n    });\n});\n````\n\n近几年随着JavaScript开发模式的逐渐成熟，CommonJS规范顺势而生，其中就包括提出了Promise规范，Promise完全改变了js异步编程的写法，让异步编程变得十分的易于理解。\n\nPromise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。Promise对象有以下两个特点。\n\n（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。\n\n（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。\n## <a id='a2'>2.Promise基本用法</a>\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。\n\n下面代码创造了一个Promise实例。\n````javascript\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n````\nresolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected）\n\nPromise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数(可选)。这两个函数都接受Promise对象传出的值作为参数。\n````javascript\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n````\n## <a id='a3'>3.Promise.prototype.then()</a>\nthen方法是定义在原型对象Promise.prototype上的，因此Promise实例具有then方法。它的作用是为Promise实例添加状态改变时的回调函数。then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。\n\nthen方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\n````javascript\ngetJSON(\"/post/1.json\").then(\n  post => getJSON(post.commentURL)\n).then(\n  comments => console.log(\"Resolved: \", comments),\n  err => console.log(\"Rejected: \", err)\n);\n````\n## <a id='a4'>4.Promise.prototype.catch()</a>\nPromise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。\n\nPromise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。\n````javascript\ngetJSON('/post/1.json').then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // some code\n}).catch(function(error) {\n  // 处理前面三个Promise产生的错误\n});\n````\n跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。(Chrome浏览器不遵守这条规定)\n## <a id='a5'>5.Promise.all()</a>\nPromise.all方法用于将多个Promise实例，包装成一个新的Promise实例，类似“与”关系。\n````javascript\nvar p = Promise.all([p1, p2, p3]);\n````\np的状态由p1、p2、p3决定，分成两种情况。\n\n（1）只有p1、p2、p3的状态都变成resolve，p的状态才会变成resolve，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。\n\n（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。\n## <a id='a6'>6.Promise.race()</a>\nPromise.race方法同样是将多个Promise实例，包装成一个新的Promise实例，类似“或”关系。\n````javascript\nvar p = Promise.race([p1, p2, p3]);\n````\n只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。\n## <a id='a7'>7.Promise.resolve()</a>\nPromise.resolve()可将现有对象转为Promise对象。\n\nPromise.resolve方法的参数分成四种情况。\n\n（1）参数是一个Promise实例\n\n原封不动地返回这个实例。\n\n（2）参数是一个thenable对象\n\nPromise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。\n\n（3）参数不是具有then方法的对象，或根本就不是对象\n\n返回一个新的Promise对象，状态为Resolved。\n\n（4）不带有任何参数\n\n直接返回一个Resolved状态的Promise对象。\n## <a id='a8'>8.Promise.reject()</a>\nPromise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected.\n\nPromise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。\n\n````javascript\nconst thenable = {\n  then(resolve, reject) {\n    reject('出错了');\n  }\n};\n\nPromise.reject(thenable)\n.catch(e => {\n  console.log(e === thenable)\n})\n// true\n````\n## <a id='a9'>9.应用</a>\n### 延时等待\n````javascript\nfunction wait(duration){\n    return new Promise((resolve, reject)=>{\n        setTimeout(resolve,duration);\n    })\n}\nwait(1000).then(()=>{console.log('hello')}).then(()=>{return wait(2000)}).then(()=>{console.log('world')})\n````\n### 加载图片\n````javascript\nconst preloadImage = function (path) {\n  return new Promise(function (resolve, reject) {\n    var image = new Image();\n    image.onload  = resolve;\n    image.onerror = reject;\n    image.src = path;\n  });\n};\n````\n## <a id='a10'>10.参考资料</a>\n* [ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/promise)\n* [JavaScript Promise启示录](https://segmentfault.com/a/1190000000492290)\n* [一道关于Promise应用的面试题](http://www.cnblogs.com/dojo-lzz/p/5495671.html)\n","slug":"promise","published":1,"updated":"2022-04-13T14:14:07.815Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffj0023g3t83il70khv","content":"<h2 id=\"ES6-Promise\"><a href=\"#ES6-Promise\" class=\"headerlink\" title=\"ES6 Promise\"></a>ES6 Promise</h2><ol>\n<li><a href=\"#a1\">Promise的由来及含义</a></li>\n<li><a href=\"#a2\">Promise基本用法</a></li>\n<li><a href=\"#a3\">Promise.prototype.then()</a></li>\n<li><a href=\"#a4\">Promise.prototype.catch()</a></li>\n<li><a href=\"#a5\">Promise.all()</a></li>\n<li><a href=\"#a6\">Promise.race()</a></li>\n<li><a href=\"#a7\">Promise.resolve()</a></li>\n<li><a href=\"#a8\">Promise.reject()</a></li>\n<li><a href=\"#a9\">应用</a></li>\n<li><a href=\"#a10\">参考资料</a><a id=\"more\"></a>\n</li>\n</ol>\n<hr>\n<h2 id=\"1-Promise的由来及含义\"><a href=\"#1-Promise的由来及含义\" class=\"headerlink\" title=\"1.Promise的由来及含义\"></a><a id=\"a1\">1.Promise的由来及含义</a></h2><p>一直以来，JavaScript处理异步都是以callback的方式，在前端开发领域callback机制几乎深入人心。在设计API的时候，不管是浏览器厂商还是SDK开发商亦或是各种类库的作者，基本上都已经遵循着callback的套路。</p>\n<p>在callback的模型里边，我们假设需要执行一个异步队列，代码看起来可能像这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loadImg(<span class=\"string\">'a.jpg'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    loadImg(<span class=\"string\">'b.jpg'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        loadImg(<span class=\"string\">'c.jpg'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'all done!'</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>近几年随着JavaScript开发模式的逐渐成熟，CommonJS规范顺势而生，其中就包括提出了Promise规范，Promise完全改变了js异步编程的写法，让异步编程变得十分的易于理解。</p>\n<p>Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。Promise对象有以下两个特点。</p>\n<p>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</p>\n<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。</p>\n<h2 id=\"2-Promise基本用法\"><a href=\"#2-Promise基本用法\" class=\"headerlink\" title=\"2.Promise基本用法\"></a><a id=\"a2\">2.Promise基本用法</a></h2><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。</p>\n<p>下面代码创造了一个Promise实例。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... some code</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected）</p>\n<p>Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数(可选)。这两个函数都接受Promise对象传出的值作为参数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-Promise-prototype-then\"><a href=\"#3-Promise-prototype-then\" class=\"headerlink\" title=\"3.Promise.prototype.then()\"></a><a id=\"a3\">3.Promise.prototype.then()</a></h2><p>then方法是定义在原型对象Promise.prototype上的，因此Promise实例具有then方法。它的作用是为Promise实例添加状态改变时的回调函数。then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。</p>\n<p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">\"/post/1.json\"</span>).then(</span><br><span class=\"line\">  post =&gt; getJSON(post.commentURL)</span><br><span class=\"line\">).then(</span><br><span class=\"line\">  comments =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Resolved: \"</span>, comments),</span><br><span class=\"line\">  err =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Rejected: \"</span>, err)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-Promise-prototype-catch\"><a href=\"#4-Promise-prototype-catch\" class=\"headerlink\" title=\"4.Promise.prototype.catch()\"></a><a id=\"a4\">4.Promise.prototype.catch()</a></h2><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>\n<p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">'/post/1.json'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getJSON(post.commentURL);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">comments</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// some code</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理前面三个Promise产生的错误</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。(Chrome浏览器不遵守这条规定)</p>\n<h2 id=\"5-Promise-all\"><a href=\"#5-Promise-all\" class=\"headerlink\" title=\"5.Promise.all()\"></a><a id=\"a5\">5.Promise.all()</a></h2><p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例，类似“与”关系。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"built_in\">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure></p>\n<p>p的状态由p1、p2、p3决定，分成两种情况。</p>\n<p>（1）只有p1、p2、p3的状态都变成resolve，p的状态才会变成resolve，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p>\n<p>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p>\n<h2 id=\"6-Promise-race\"><a href=\"#6-Promise-race\" class=\"headerlink\" title=\"6.Promise.race()\"></a><a id=\"a6\">6.Promise.race()</a></h2><p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例，类似“或”关系。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"built_in\">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure></p>\n<p>只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p>\n<h2 id=\"7-Promise-resolve\"><a href=\"#7-Promise-resolve\" class=\"headerlink\" title=\"7.Promise.resolve()\"></a><a id=\"a7\">7.Promise.resolve()</a></h2><p>Promise.resolve()可将现有对象转为Promise对象。</p>\n<p>Promise.resolve方法的参数分成四种情况。</p>\n<p>（1）参数是一个Promise实例</p>\n<p>原封不动地返回这个实例。</p>\n<p>（2）参数是一个thenable对象</p>\n<p>Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。</p>\n<p>（3）参数不是具有then方法的对象，或根本就不是对象</p>\n<p>返回一个新的Promise对象，状态为Resolved。</p>\n<p>（4）不带有任何参数</p>\n<p>直接返回一个Resolved状态的Promise对象。</p>\n<h2 id=\"8-Promise-reject\"><a href=\"#8-Promise-reject\" class=\"headerlink\" title=\"8.Promise.reject()\"></a><a id=\"a8\">8.Promise.reject()</a></h2><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected.</p>\n<p>Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> thenable = &#123;</span><br><span class=\"line\">  then(resolve, reject) &#123;</span><br><span class=\"line\">    reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.reject(thenable)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e === thenable)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"9-应用\"><a href=\"#9-应用\" class=\"headerlink\" title=\"9.应用\"></a><a id=\"a9\">9.应用</a></h2><h3 id=\"延时等待\"><a href=\"#延时等待\" class=\"headerlink\" title=\"延时等待\"></a>延时等待</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wait</span>(<span class=\"params\">duration</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        setTimeout(resolve,duration);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wait(<span class=\"number\">1000</span>).then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>)&#125;).then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;<span class=\"keyword\">return</span> wait(<span class=\"number\">2000</span>)&#125;).then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'world'</span>)&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"加载图片\"><a href=\"#加载图片\" class=\"headerlink\" title=\"加载图片\"></a>加载图片</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> preloadImage = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> image = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">    image.onload  = resolve;</span><br><span class=\"line\">    image.onerror = reject;</span><br><span class=\"line\">    image.src = path;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-参考资料\"><a href=\"#10-参考资料\" class=\"headerlink\" title=\"10.参考资料\"></a><a id=\"a10\">10.参考资料</a></h2><ul>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"noopener\">ECMAScript 6 入门</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000000492290\" target=\"_blank\" rel=\"noopener\">JavaScript Promise启示录</a></li>\n<li><a href=\"http://www.cnblogs.com/dojo-lzz/p/5495671.html\" target=\"_blank\" rel=\"noopener\">一道关于Promise应用的面试题</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"ES6-Promise\"><a href=\"#ES6-Promise\" class=\"headerlink\" title=\"ES6 Promise\"></a>ES6 Promise</h2><ol>\n<li><a href=\"#a1\">Promise的由来及含义</a></li>\n<li><a href=\"#a2\">Promise基本用法</a></li>\n<li><a href=\"#a3\">Promise.prototype.then()</a></li>\n<li><a href=\"#a4\">Promise.prototype.catch()</a></li>\n<li><a href=\"#a5\">Promise.all()</a></li>\n<li><a href=\"#a6\">Promise.race()</a></li>\n<li><a href=\"#a7\">Promise.resolve()</a></li>\n<li><a href=\"#a8\">Promise.reject()</a></li>\n<li><a href=\"#a9\">应用</a></li>\n<li><a href=\"#a10\">参考资料</a>","more":"</li>\n</ol>\n<hr>\n<h2 id=\"1-Promise的由来及含义\"><a href=\"#1-Promise的由来及含义\" class=\"headerlink\" title=\"1.Promise的由来及含义\"></a><a id=\"a1\">1.Promise的由来及含义</a></h2><p>一直以来，JavaScript处理异步都是以callback的方式，在前端开发领域callback机制几乎深入人心。在设计API的时候，不管是浏览器厂商还是SDK开发商亦或是各种类库的作者，基本上都已经遵循着callback的套路。</p>\n<p>在callback的模型里边，我们假设需要执行一个异步队列，代码看起来可能像这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loadImg(<span class=\"string\">'a.jpg'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    loadImg(<span class=\"string\">'b.jpg'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        loadImg(<span class=\"string\">'c.jpg'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'all done!'</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>近几年随着JavaScript开发模式的逐渐成熟，CommonJS规范顺势而生，其中就包括提出了Promise规范，Promise完全改变了js异步编程的写法，让异步编程变得十分的易于理解。</p>\n<p>Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。Promise对象有以下两个特点。</p>\n<p>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</p>\n<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。</p>\n<h2 id=\"2-Promise基本用法\"><a href=\"#2-Promise基本用法\" class=\"headerlink\" title=\"2.Promise基本用法\"></a><a id=\"a2\">2.Promise基本用法</a></h2><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。</p>\n<p>下面代码创造了一个Promise实例。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... some code</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected）</p>\n<p>Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数(可选)。这两个函数都接受Promise对象传出的值作为参数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-Promise-prototype-then\"><a href=\"#3-Promise-prototype-then\" class=\"headerlink\" title=\"3.Promise.prototype.then()\"></a><a id=\"a3\">3.Promise.prototype.then()</a></h2><p>then方法是定义在原型对象Promise.prototype上的，因此Promise实例具有then方法。它的作用是为Promise实例添加状态改变时的回调函数。then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。</p>\n<p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">\"/post/1.json\"</span>).then(</span><br><span class=\"line\">  post =&gt; getJSON(post.commentURL)</span><br><span class=\"line\">).then(</span><br><span class=\"line\">  comments =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Resolved: \"</span>, comments),</span><br><span class=\"line\">  err =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Rejected: \"</span>, err)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-Promise-prototype-catch\"><a href=\"#4-Promise-prototype-catch\" class=\"headerlink\" title=\"4.Promise.prototype.catch()\"></a><a id=\"a4\">4.Promise.prototype.catch()</a></h2><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>\n<p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">'/post/1.json'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getJSON(post.commentURL);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">comments</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// some code</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理前面三个Promise产生的错误</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。(Chrome浏览器不遵守这条规定)</p>\n<h2 id=\"5-Promise-all\"><a href=\"#5-Promise-all\" class=\"headerlink\" title=\"5.Promise.all()\"></a><a id=\"a5\">5.Promise.all()</a></h2><p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例，类似“与”关系。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"built_in\">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure></p>\n<p>p的状态由p1、p2、p3决定，分成两种情况。</p>\n<p>（1）只有p1、p2、p3的状态都变成resolve，p的状态才会变成resolve，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p>\n<p>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p>\n<h2 id=\"6-Promise-race\"><a href=\"#6-Promise-race\" class=\"headerlink\" title=\"6.Promise.race()\"></a><a id=\"a6\">6.Promise.race()</a></h2><p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例，类似“或”关系。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"built_in\">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure></p>\n<p>只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p>\n<h2 id=\"7-Promise-resolve\"><a href=\"#7-Promise-resolve\" class=\"headerlink\" title=\"7.Promise.resolve()\"></a><a id=\"a7\">7.Promise.resolve()</a></h2><p>Promise.resolve()可将现有对象转为Promise对象。</p>\n<p>Promise.resolve方法的参数分成四种情况。</p>\n<p>（1）参数是一个Promise实例</p>\n<p>原封不动地返回这个实例。</p>\n<p>（2）参数是一个thenable对象</p>\n<p>Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。</p>\n<p>（3）参数不是具有then方法的对象，或根本就不是对象</p>\n<p>返回一个新的Promise对象，状态为Resolved。</p>\n<p>（4）不带有任何参数</p>\n<p>直接返回一个Resolved状态的Promise对象。</p>\n<h2 id=\"8-Promise-reject\"><a href=\"#8-Promise-reject\" class=\"headerlink\" title=\"8.Promise.reject()\"></a><a id=\"a8\">8.Promise.reject()</a></h2><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected.</p>\n<p>Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> thenable = &#123;</span><br><span class=\"line\">  then(resolve, reject) &#123;</span><br><span class=\"line\">    reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.reject(thenable)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e === thenable)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"9-应用\"><a href=\"#9-应用\" class=\"headerlink\" title=\"9.应用\"></a><a id=\"a9\">9.应用</a></h2><h3 id=\"延时等待\"><a href=\"#延时等待\" class=\"headerlink\" title=\"延时等待\"></a>延时等待</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wait</span>(<span class=\"params\">duration</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        setTimeout(resolve,duration);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wait(<span class=\"number\">1000</span>).then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>)&#125;).then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;<span class=\"keyword\">return</span> wait(<span class=\"number\">2000</span>)&#125;).then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'world'</span>)&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"加载图片\"><a href=\"#加载图片\" class=\"headerlink\" title=\"加载图片\"></a>加载图片</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> preloadImage = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> image = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">    image.onload  = resolve;</span><br><span class=\"line\">    image.onerror = reject;</span><br><span class=\"line\">    image.src = path;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-参考资料\"><a href=\"#10-参考资料\" class=\"headerlink\" title=\"10.参考资料\"></a><a id=\"a10\">10.参考资料</a></h2><ul>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"noopener\">ECMAScript 6 入门</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000000492290\" target=\"_blank\" rel=\"noopener\">JavaScript Promise启示录</a></li>\n<li><a href=\"http://www.cnblogs.com/dojo-lzz/p/5495671.html\" target=\"_blank\" rel=\"noopener\">一道关于Promise应用的面试题</a></li>\n</ul>"},{"title":"《图解http》第二章笔记","date":"2017-09-15T16:00:00.000Z","_content":"## 简单的http协议\n两台计算机使用HTTP协议进行通信时，在一条通信线路上必定有一端是客户端，另一端则是客户端。\n<!--more-->\n### 下面是客户端发给某个HTTP客户端的请求报文中的内容。\n````http\nGET /index.html HTTP/1.1\nHOST: hackr.jp\n````\nGET表示请求访问服务器的类型，称为方法（method）。\n\n随后的/index.html指明请求访问的资源对象，叫做请求URI（request-URI）。\n\n最后的HTTP/1.1表明HTTP的版本号。\n\n请求报文由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成。\n### 接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。\n````http\nHTTP/1.1 200 OK\nDate: Tue, 10 Jul 2012 06:50:15 GMT\nContent-Length: 362\nContent-Type: text/html\n\n<html>\n....\n````\n开头的HTTP/1.1代表服务端对应的HTTP版本。\n\n紧接着的200 OK代表请求的处理结果的状态码（status code）和原因短语（reason-phrase）。\n\n下一行显示创建响应的日期时间、内容长度、内容类型，是首部字段（header field）内的一个属性。\n\n接着以一空行分隔，之后的内容称为资源内容的主体（entity body）。\n\n响应报文基本上由协议版本、状态码、解释状态码的原因短语、可选的响应首部字段已经实体主体构成。\n### HTTP是一种不保存状态，即无状态（stateless）协议。\nhttp协议自身不对请求和响应之间的通信状态进行保存。\n### 请求URI定位资源\n请求指定URI的方式\n1. URI为完整的URI\n````http\nGET http://hackr.jp/index.htm HTTP/1.1\n````\n2. 在首部字段Host中写明网络域名或IP地址\n````http\nGET /index.htm HTTP/1.1\nHost: hackr.jp\n````\n### 告知服务器意图的HTTP方法\n* GET：获取资源\n    \n    用来请求访问已被URI识别的资源。指定的资源经服务端解析后返回响应的内容。\n* POST：传输主体实体\n\n    用来传输实体的主体。\n* PUT：传输文件\n    \n    要求在请求报文的主体包含文件内容，然后保存到URI指定的位置。\n\n    鉴于HTTP/1.1的PUT方法不带验证机制，任何人都可以上传文件，因此存在安全性问题,一般不使用。\n* HEAD：获得报文首部\n\n    HEAD方法和GET方法一样，这是不返回报文的主体部分。\n\n    用于确认URI的有效性及资源更新的日期时间等。\n* DELETE：删除文件\n\n    DELETE方法按请求的URI删除指定的资源。\n\n    但是DELETE方法和PUT方法一样不带验证机制，一般也不使用DELETE方法。\n* OPTIONS：查询支持的方法\n\n    用来查询针对请求URI指定的资源支持的方法。\n* TRACE：追踪路径\n\n    TRACE方法是让Web服务器将之前请求通信环回给客户端的方法。可以查询发送出去的请求是怎样被加工或者篡改的。\n* CONNECT：要求用隧道协议连接代理\n    \n    该方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。\n\n    主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。\n### 持久连接节省通信量\n1. 持久连接\n在初始版本的HTTP协议中，每进行一次HTTP通信就要断开一次TCP连接，增加通信量的开销。\n\n为解决上述TCP连接的问题，HTTP/1.1和一部分HTTP/1.0提出了持久化的连接（HTTP Persistent Connections），也叫做HTTP keep-alive或HTTP connection reuse。\n\n持久化连接的特点是，只要任意一方没有明确提出断开连接，则保持TCP连接状态。\n\n好处是减少了TCP连接的重复建立和断开所造成的额外开销，减轻服务器端的负载。减少开销的那部分时间，使得Web页面的显示速度提高。\n\n在HTTP/1.1中，默认所有连接都是持久连接。\n\n持久连接使得多数请求以管线化（pipeling）方式发送成为可能，可以并行发送请求。\n### 使用cookie的状态管理\ncookie技术通过在请求和响应的报文中写入cookie信息来控制服务端状态。\n\ncookie会根据从服务器发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存cookie。下次客户端再往服务端发送请求时，客户端会自动在请求报文中加入cookie值后发送出去。\n\n服务端接收到客户端发送过来的cookie后会去检查究竟是哪个客户端发来的连接请求，对比服务器上的记录，最后得到之前的状态信息。\n### If-Modified-Since\nIf-Modified-Since是标准的HTTP请求头标签，在发送HTTP请求时，把浏览器端缓存页面的最后修改时间一起发到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行比较。\n\n如果时间一致，那么返回HTTP状态码304（不返回文件内容），客户端接到之后，就直接把本地缓存文件显示到浏览器中。\n\n如果时间不一致，就返回HTTP状态码200和新的文件内容，客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示到浏览器中。\n### 参考资料\n* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since)\n* [http://www.cnblogs.com/zh2000g/archive/2010/03/22/1692002.html](http://www.cnblogs.com/zh2000g/archive/2010/03/22/1692002.html)\n","source":"_posts/《图解http》第二章笔记.md","raw":"---\ntitle: 《图解http》第二章笔记\ndate: 2017-09-16\ntags: ['http']\ncategories: ['笔记']\n---\n## 简单的http协议\n两台计算机使用HTTP协议进行通信时，在一条通信线路上必定有一端是客户端，另一端则是客户端。\n<!--more-->\n### 下面是客户端发给某个HTTP客户端的请求报文中的内容。\n````http\nGET /index.html HTTP/1.1\nHOST: hackr.jp\n````\nGET表示请求访问服务器的类型，称为方法（method）。\n\n随后的/index.html指明请求访问的资源对象，叫做请求URI（request-URI）。\n\n最后的HTTP/1.1表明HTTP的版本号。\n\n请求报文由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成。\n### 接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。\n````http\nHTTP/1.1 200 OK\nDate: Tue, 10 Jul 2012 06:50:15 GMT\nContent-Length: 362\nContent-Type: text/html\n\n<html>\n....\n````\n开头的HTTP/1.1代表服务端对应的HTTP版本。\n\n紧接着的200 OK代表请求的处理结果的状态码（status code）和原因短语（reason-phrase）。\n\n下一行显示创建响应的日期时间、内容长度、内容类型，是首部字段（header field）内的一个属性。\n\n接着以一空行分隔，之后的内容称为资源内容的主体（entity body）。\n\n响应报文基本上由协议版本、状态码、解释状态码的原因短语、可选的响应首部字段已经实体主体构成。\n### HTTP是一种不保存状态，即无状态（stateless）协议。\nhttp协议自身不对请求和响应之间的通信状态进行保存。\n### 请求URI定位资源\n请求指定URI的方式\n1. URI为完整的URI\n````http\nGET http://hackr.jp/index.htm HTTP/1.1\n````\n2. 在首部字段Host中写明网络域名或IP地址\n````http\nGET /index.htm HTTP/1.1\nHost: hackr.jp\n````\n### 告知服务器意图的HTTP方法\n* GET：获取资源\n    \n    用来请求访问已被URI识别的资源。指定的资源经服务端解析后返回响应的内容。\n* POST：传输主体实体\n\n    用来传输实体的主体。\n* PUT：传输文件\n    \n    要求在请求报文的主体包含文件内容，然后保存到URI指定的位置。\n\n    鉴于HTTP/1.1的PUT方法不带验证机制，任何人都可以上传文件，因此存在安全性问题,一般不使用。\n* HEAD：获得报文首部\n\n    HEAD方法和GET方法一样，这是不返回报文的主体部分。\n\n    用于确认URI的有效性及资源更新的日期时间等。\n* DELETE：删除文件\n\n    DELETE方法按请求的URI删除指定的资源。\n\n    但是DELETE方法和PUT方法一样不带验证机制，一般也不使用DELETE方法。\n* OPTIONS：查询支持的方法\n\n    用来查询针对请求URI指定的资源支持的方法。\n* TRACE：追踪路径\n\n    TRACE方法是让Web服务器将之前请求通信环回给客户端的方法。可以查询发送出去的请求是怎样被加工或者篡改的。\n* CONNECT：要求用隧道协议连接代理\n    \n    该方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。\n\n    主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。\n### 持久连接节省通信量\n1. 持久连接\n在初始版本的HTTP协议中，每进行一次HTTP通信就要断开一次TCP连接，增加通信量的开销。\n\n为解决上述TCP连接的问题，HTTP/1.1和一部分HTTP/1.0提出了持久化的连接（HTTP Persistent Connections），也叫做HTTP keep-alive或HTTP connection reuse。\n\n持久化连接的特点是，只要任意一方没有明确提出断开连接，则保持TCP连接状态。\n\n好处是减少了TCP连接的重复建立和断开所造成的额外开销，减轻服务器端的负载。减少开销的那部分时间，使得Web页面的显示速度提高。\n\n在HTTP/1.1中，默认所有连接都是持久连接。\n\n持久连接使得多数请求以管线化（pipeling）方式发送成为可能，可以并行发送请求。\n### 使用cookie的状态管理\ncookie技术通过在请求和响应的报文中写入cookie信息来控制服务端状态。\n\ncookie会根据从服务器发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存cookie。下次客户端再往服务端发送请求时，客户端会自动在请求报文中加入cookie值后发送出去。\n\n服务端接收到客户端发送过来的cookie后会去检查究竟是哪个客户端发来的连接请求，对比服务器上的记录，最后得到之前的状态信息。\n### If-Modified-Since\nIf-Modified-Since是标准的HTTP请求头标签，在发送HTTP请求时，把浏览器端缓存页面的最后修改时间一起发到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行比较。\n\n如果时间一致，那么返回HTTP状态码304（不返回文件内容），客户端接到之后，就直接把本地缓存文件显示到浏览器中。\n\n如果时间不一致，就返回HTTP状态码200和新的文件内容，客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示到浏览器中。\n### 参考资料\n* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since)\n* [http://www.cnblogs.com/zh2000g/archive/2010/03/22/1692002.html](http://www.cnblogs.com/zh2000g/archive/2010/03/22/1692002.html)\n","slug":"《图解http》第二章笔记","published":1,"updated":"2022-04-13T14:14:07.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffl0027g3t8oqwn09m6","content":"<h2 id=\"简单的http协议\"><a href=\"#简单的http协议\" class=\"headerlink\" title=\"简单的http协议\"></a>简单的http协议</h2><p>两台计算机使用HTTP协议进行通信时，在一条通信线路上必定有一端是客户端，另一端则是客户端。<br><a id=\"more\"></a></p>\n<h3 id=\"下面是客户端发给某个HTTP客户端的请求报文中的内容。\"><a href=\"#下面是客户端发给某个HTTP客户端的请求报文中的内容。\" class=\"headerlink\" title=\"下面是客户端发给某个HTTP客户端的请求报文中的内容。\"></a>下面是客户端发给某个HTTP客户端的请求报文中的内容。</h3><figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.html</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">HOST</span>: hackr.jp</span><br></pre></td></tr></table></figure>\n<p>GET表示请求访问服务器的类型，称为方法（method）。</p>\n<p>随后的/index.html指明请求访问的资源对象，叫做请求URI（request-URI）。</p>\n<p>最后的HTTP/1.1表明HTTP的版本号。</p>\n<p>请求报文由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成。</p>\n<h3 id=\"接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。\"><a href=\"#接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。\" class=\"headerlink\" title=\"接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。\"></a>接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Date</span>: Tue, 10 Jul 2012 06:50:15 GMT</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span>: 362</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: text/html</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">....</span><br></pre></td></tr></table></figure>\n<p>开头的HTTP/1.1代表服务端对应的HTTP版本。</p>\n<p>紧接着的200 OK代表请求的处理结果的状态码（status code）和原因短语（reason-phrase）。</p>\n<p>下一行显示创建响应的日期时间、内容长度、内容类型，是首部字段（header field）内的一个属性。</p>\n<p>接着以一空行分隔，之后的内容称为资源内容的主体（entity body）。</p>\n<p>响应报文基本上由协议版本、状态码、解释状态码的原因短语、可选的响应首部字段已经实体主体构成。</p>\n<h3 id=\"HTTP是一种不保存状态，即无状态（stateless）协议。\"><a href=\"#HTTP是一种不保存状态，即无状态（stateless）协议。\" class=\"headerlink\" title=\"HTTP是一种不保存状态，即无状态（stateless）协议。\"></a>HTTP是一种不保存状态，即无状态（stateless）协议。</h3><p>http协议自身不对请求和响应之间的通信状态进行保存。</p>\n<h3 id=\"请求URI定位资源\"><a href=\"#请求URI定位资源\" class=\"headerlink\" title=\"请求URI定位资源\"></a>请求URI定位资源</h3><p>请求指定URI的方式</p>\n<ol>\n<li><p>URI为完整的URI</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">http://hackr.jp/index.htm</span> HTTP/1.1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在首部字段Host中写明网络域名或IP地址</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.htm</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: hackr.jp</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"告知服务器意图的HTTP方法\"><a href=\"#告知服务器意图的HTTP方法\" class=\"headerlink\" title=\"告知服务器意图的HTTP方法\"></a>告知服务器意图的HTTP方法</h3><ul>\n<li><p>GET：获取资源</p>\n<p>  用来请求访问已被URI识别的资源。指定的资源经服务端解析后返回响应的内容。</p>\n</li>\n<li><p>POST：传输主体实体</p>\n<p>  用来传输实体的主体。</p>\n</li>\n<li><p>PUT：传输文件</p>\n<p>  要求在请求报文的主体包含文件内容，然后保存到URI指定的位置。</p>\n<p>  鉴于HTTP/1.1的PUT方法不带验证机制，任何人都可以上传文件，因此存在安全性问题,一般不使用。</p>\n</li>\n<li><p>HEAD：获得报文首部</p>\n<p>  HEAD方法和GET方法一样，这是不返回报文的主体部分。</p>\n<p>  用于确认URI的有效性及资源更新的日期时间等。</p>\n</li>\n<li><p>DELETE：删除文件</p>\n<p>  DELETE方法按请求的URI删除指定的资源。</p>\n<p>  但是DELETE方法和PUT方法一样不带验证机制，一般也不使用DELETE方法。</p>\n</li>\n<li><p>OPTIONS：查询支持的方法</p>\n<p>  用来查询针对请求URI指定的资源支持的方法。</p>\n</li>\n<li><p>TRACE：追踪路径</p>\n<p>  TRACE方法是让Web服务器将之前请求通信环回给客户端的方法。可以查询发送出去的请求是怎样被加工或者篡改的。</p>\n</li>\n<li><p>CONNECT：要求用隧道协议连接代理</p>\n<p>  该方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。</p>\n<p>  主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>\n<h3 id=\"持久连接节省通信量\"><a href=\"#持久连接节省通信量\" class=\"headerlink\" title=\"持久连接节省通信量\"></a>持久连接节省通信量</h3></li>\n</ul>\n<ol>\n<li>持久连接<br>在初始版本的HTTP协议中，每进行一次HTTP通信就要断开一次TCP连接，增加通信量的开销。</li>\n</ol>\n<p>为解决上述TCP连接的问题，HTTP/1.1和一部分HTTP/1.0提出了持久化的连接（HTTP Persistent Connections），也叫做HTTP keep-alive或HTTP connection reuse。</p>\n<p>持久化连接的特点是，只要任意一方没有明确提出断开连接，则保持TCP连接状态。</p>\n<p>好处是减少了TCP连接的重复建立和断开所造成的额外开销，减轻服务器端的负载。减少开销的那部分时间，使得Web页面的显示速度提高。</p>\n<p>在HTTP/1.1中，默认所有连接都是持久连接。</p>\n<p>持久连接使得多数请求以管线化（pipeling）方式发送成为可能，可以并行发送请求。</p>\n<h3 id=\"使用cookie的状态管理\"><a href=\"#使用cookie的状态管理\" class=\"headerlink\" title=\"使用cookie的状态管理\"></a>使用cookie的状态管理</h3><p>cookie技术通过在请求和响应的报文中写入cookie信息来控制服务端状态。</p>\n<p>cookie会根据从服务器发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存cookie。下次客户端再往服务端发送请求时，客户端会自动在请求报文中加入cookie值后发送出去。</p>\n<p>服务端接收到客户端发送过来的cookie后会去检查究竟是哪个客户端发来的连接请求，对比服务器上的记录，最后得到之前的状态信息。</p>\n<h3 id=\"If-Modified-Since\"><a href=\"#If-Modified-Since\" class=\"headerlink\" title=\"If-Modified-Since\"></a>If-Modified-Since</h3><p>If-Modified-Since是标准的HTTP请求头标签，在发送HTTP请求时，把浏览器端缓存页面的最后修改时间一起发到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行比较。</p>\n<p>如果时间一致，那么返回HTTP状态码304（不返回文件内容），客户端接到之后，就直接把本地缓存文件显示到浏览器中。</p>\n<p>如果时间不一致，就返回HTTP状态码200和新的文件内容，客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示到浏览器中。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since</a></li>\n<li><a href=\"http://www.cnblogs.com/zh2000g/archive/2010/03/22/1692002.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/zh2000g/archive/2010/03/22/1692002.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"简单的http协议\"><a href=\"#简单的http协议\" class=\"headerlink\" title=\"简单的http协议\"></a>简单的http协议</h2><p>两台计算机使用HTTP协议进行通信时，在一条通信线路上必定有一端是客户端，另一端则是客户端。<br>","more":"</p>\n<h3 id=\"下面是客户端发给某个HTTP客户端的请求报文中的内容。\"><a href=\"#下面是客户端发给某个HTTP客户端的请求报文中的内容。\" class=\"headerlink\" title=\"下面是客户端发给某个HTTP客户端的请求报文中的内容。\"></a>下面是客户端发给某个HTTP客户端的请求报文中的内容。</h3><figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.html</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">HOST</span>: hackr.jp</span><br></pre></td></tr></table></figure>\n<p>GET表示请求访问服务器的类型，称为方法（method）。</p>\n<p>随后的/index.html指明请求访问的资源对象，叫做请求URI（request-URI）。</p>\n<p>最后的HTTP/1.1表明HTTP的版本号。</p>\n<p>请求报文由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成。</p>\n<h3 id=\"接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。\"><a href=\"#接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。\" class=\"headerlink\" title=\"接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。\"></a>接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Date</span>: Tue, 10 Jul 2012 06:50:15 GMT</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span>: 362</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: text/html</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">....</span><br></pre></td></tr></table></figure>\n<p>开头的HTTP/1.1代表服务端对应的HTTP版本。</p>\n<p>紧接着的200 OK代表请求的处理结果的状态码（status code）和原因短语（reason-phrase）。</p>\n<p>下一行显示创建响应的日期时间、内容长度、内容类型，是首部字段（header field）内的一个属性。</p>\n<p>接着以一空行分隔，之后的内容称为资源内容的主体（entity body）。</p>\n<p>响应报文基本上由协议版本、状态码、解释状态码的原因短语、可选的响应首部字段已经实体主体构成。</p>\n<h3 id=\"HTTP是一种不保存状态，即无状态（stateless）协议。\"><a href=\"#HTTP是一种不保存状态，即无状态（stateless）协议。\" class=\"headerlink\" title=\"HTTP是一种不保存状态，即无状态（stateless）协议。\"></a>HTTP是一种不保存状态，即无状态（stateless）协议。</h3><p>http协议自身不对请求和响应之间的通信状态进行保存。</p>\n<h3 id=\"请求URI定位资源\"><a href=\"#请求URI定位资源\" class=\"headerlink\" title=\"请求URI定位资源\"></a>请求URI定位资源</h3><p>请求指定URI的方式</p>\n<ol>\n<li><p>URI为完整的URI</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">http://hackr.jp/index.htm</span> HTTP/1.1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在首部字段Host中写明网络域名或IP地址</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.htm</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: hackr.jp</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"告知服务器意图的HTTP方法\"><a href=\"#告知服务器意图的HTTP方法\" class=\"headerlink\" title=\"告知服务器意图的HTTP方法\"></a>告知服务器意图的HTTP方法</h3><ul>\n<li><p>GET：获取资源</p>\n<p>  用来请求访问已被URI识别的资源。指定的资源经服务端解析后返回响应的内容。</p>\n</li>\n<li><p>POST：传输主体实体</p>\n<p>  用来传输实体的主体。</p>\n</li>\n<li><p>PUT：传输文件</p>\n<p>  要求在请求报文的主体包含文件内容，然后保存到URI指定的位置。</p>\n<p>  鉴于HTTP/1.1的PUT方法不带验证机制，任何人都可以上传文件，因此存在安全性问题,一般不使用。</p>\n</li>\n<li><p>HEAD：获得报文首部</p>\n<p>  HEAD方法和GET方法一样，这是不返回报文的主体部分。</p>\n<p>  用于确认URI的有效性及资源更新的日期时间等。</p>\n</li>\n<li><p>DELETE：删除文件</p>\n<p>  DELETE方法按请求的URI删除指定的资源。</p>\n<p>  但是DELETE方法和PUT方法一样不带验证机制，一般也不使用DELETE方法。</p>\n</li>\n<li><p>OPTIONS：查询支持的方法</p>\n<p>  用来查询针对请求URI指定的资源支持的方法。</p>\n</li>\n<li><p>TRACE：追踪路径</p>\n<p>  TRACE方法是让Web服务器将之前请求通信环回给客户端的方法。可以查询发送出去的请求是怎样被加工或者篡改的。</p>\n</li>\n<li><p>CONNECT：要求用隧道协议连接代理</p>\n<p>  该方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。</p>\n<p>  主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>\n<h3 id=\"持久连接节省通信量\"><a href=\"#持久连接节省通信量\" class=\"headerlink\" title=\"持久连接节省通信量\"></a>持久连接节省通信量</h3></li>\n</ul>\n<ol>\n<li>持久连接<br>在初始版本的HTTP协议中，每进行一次HTTP通信就要断开一次TCP连接，增加通信量的开销。</li>\n</ol>\n<p>为解决上述TCP连接的问题，HTTP/1.1和一部分HTTP/1.0提出了持久化的连接（HTTP Persistent Connections），也叫做HTTP keep-alive或HTTP connection reuse。</p>\n<p>持久化连接的特点是，只要任意一方没有明确提出断开连接，则保持TCP连接状态。</p>\n<p>好处是减少了TCP连接的重复建立和断开所造成的额外开销，减轻服务器端的负载。减少开销的那部分时间，使得Web页面的显示速度提高。</p>\n<p>在HTTP/1.1中，默认所有连接都是持久连接。</p>\n<p>持久连接使得多数请求以管线化（pipeling）方式发送成为可能，可以并行发送请求。</p>\n<h3 id=\"使用cookie的状态管理\"><a href=\"#使用cookie的状态管理\" class=\"headerlink\" title=\"使用cookie的状态管理\"></a>使用cookie的状态管理</h3><p>cookie技术通过在请求和响应的报文中写入cookie信息来控制服务端状态。</p>\n<p>cookie会根据从服务器发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存cookie。下次客户端再往服务端发送请求时，客户端会自动在请求报文中加入cookie值后发送出去。</p>\n<p>服务端接收到客户端发送过来的cookie后会去检查究竟是哪个客户端发来的连接请求，对比服务器上的记录，最后得到之前的状态信息。</p>\n<h3 id=\"If-Modified-Since\"><a href=\"#If-Modified-Since\" class=\"headerlink\" title=\"If-Modified-Since\"></a>If-Modified-Since</h3><p>If-Modified-Since是标准的HTTP请求头标签，在发送HTTP请求时，把浏览器端缓存页面的最后修改时间一起发到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行比较。</p>\n<p>如果时间一致，那么返回HTTP状态码304（不返回文件内容），客户端接到之后，就直接把本地缓存文件显示到浏览器中。</p>\n<p>如果时间不一致，就返回HTTP状态码200和新的文件内容，客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示到浏览器中。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since</a></li>\n<li><a href=\"http://www.cnblogs.com/zh2000g/archive/2010/03/22/1692002.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/zh2000g/archive/2010/03/22/1692002.html</a></li>\n</ul>"},{"title":"《图解http》第五章笔记","date":"2017-09-23T16:00:00.000Z","_content":"## 用单台虚拟主机实现多个域名\n即使物理层面只有一台服务器，但只要使用虚拟主机的功能（Virtual Host），则可以假想已具有多台服务器，搭建多个WEB站点，持有各自的域名，运行各自的网站。\n<!--more-->\n客户端使用HTTP协议访问服务器时，主机名和域名会通过DNS服务映射到ip地址访问目标网站。如果一台服务器托管了多个域名，就需要知道是访问哪个域名。\n\n因此在发送HTTP请求时，必须在Host首部内完整地指定主机名或域名的URI。\n\n## 通讯数据转发程序：代理、网关、隧道\n1. 代理\n\n  代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变URI，会直接发给前方持有资源的目标服务器。\n\n  这个过程可以级联多台服务器，转发时，需要附加Via首部字段以标记出经过的主机信息。\n\n  持有资源实体的服务器叫做源服务器。从源服务器返回的响应经过代理服务器再传给客户端。\n\n  ### 使用代理服务器的理由\n  按两种基准分类，一是是否使用缓存，另一种是是否修改报文。\n  * 利用缓存技术减少带宽流量\n\n    代理转发响应时缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。\n\n    当代理再次接受到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。\n  * 透明代理\n    转发请求或响应时，不对报文做任何加工的代理类型称为透明代理（Transparent Proxy）。反之称为非透明代理。\n\n  此外使用代理服务器还可以组织内部针对特定网站进行访问控制，获取访问日志等。\n2. 网关\n\n  网关能使通讯线路上的服务器提供非HTTP通讯协议。\n  \n  利用网关能提高通讯的安全性，因为可以在客户端和网关之间的通讯线路上加密以确保通讯的安全。\n\n  接收客户端发来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端也不能分辨自己的通信目标是一个网关。\n3. 隧道\n\n  隧道是在相隔甚远的客户端和服务器之间进行中转。并保持双方通信连接的应用程序，确保客户端和服务器端能进行安全的通信。\n\n  隧道本身不解析HTTP请求，原样中转给之后的服务器。\n  \n  隧道会在通信双方断开连接时结束。\n","source":"_posts/《图解http》第五章笔记.md","raw":"---\ntitle: 《图解http》第五章笔记\ndate: 2017-9-24\ntags: ['http']\ncategories: ['笔记']\n---\n## 用单台虚拟主机实现多个域名\n即使物理层面只有一台服务器，但只要使用虚拟主机的功能（Virtual Host），则可以假想已具有多台服务器，搭建多个WEB站点，持有各自的域名，运行各自的网站。\n<!--more-->\n客户端使用HTTP协议访问服务器时，主机名和域名会通过DNS服务映射到ip地址访问目标网站。如果一台服务器托管了多个域名，就需要知道是访问哪个域名。\n\n因此在发送HTTP请求时，必须在Host首部内完整地指定主机名或域名的URI。\n\n## 通讯数据转发程序：代理、网关、隧道\n1. 代理\n\n  代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变URI，会直接发给前方持有资源的目标服务器。\n\n  这个过程可以级联多台服务器，转发时，需要附加Via首部字段以标记出经过的主机信息。\n\n  持有资源实体的服务器叫做源服务器。从源服务器返回的响应经过代理服务器再传给客户端。\n\n  ### 使用代理服务器的理由\n  按两种基准分类，一是是否使用缓存，另一种是是否修改报文。\n  * 利用缓存技术减少带宽流量\n\n    代理转发响应时缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。\n\n    当代理再次接受到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。\n  * 透明代理\n    转发请求或响应时，不对报文做任何加工的代理类型称为透明代理（Transparent Proxy）。反之称为非透明代理。\n\n  此外使用代理服务器还可以组织内部针对特定网站进行访问控制，获取访问日志等。\n2. 网关\n\n  网关能使通讯线路上的服务器提供非HTTP通讯协议。\n  \n  利用网关能提高通讯的安全性，因为可以在客户端和网关之间的通讯线路上加密以确保通讯的安全。\n\n  接收客户端发来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端也不能分辨自己的通信目标是一个网关。\n3. 隧道\n\n  隧道是在相隔甚远的客户端和服务器之间进行中转。并保持双方通信连接的应用程序，确保客户端和服务器端能进行安全的通信。\n\n  隧道本身不解析HTTP请求，原样中转给之后的服务器。\n  \n  隧道会在通信双方断开连接时结束。\n","slug":"《图解http》第五章笔记","published":1,"updated":"2022-04-13T14:14:07.856Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffm002ag3t84c0qbsf4","content":"<h2 id=\"用单台虚拟主机实现多个域名\"><a href=\"#用单台虚拟主机实现多个域名\" class=\"headerlink\" title=\"用单台虚拟主机实现多个域名\"></a>用单台虚拟主机实现多个域名</h2><p>即使物理层面只有一台服务器，但只要使用虚拟主机的功能（Virtual Host），则可以假想已具有多台服务器，搭建多个WEB站点，持有各自的域名，运行各自的网站。<br><a id=\"more\"></a><br>客户端使用HTTP协议访问服务器时，主机名和域名会通过DNS服务映射到ip地址访问目标网站。如果一台服务器托管了多个域名，就需要知道是访问哪个域名。</p>\n<p>因此在发送HTTP请求时，必须在Host首部内完整地指定主机名或域名的URI。</p>\n<h2 id=\"通讯数据转发程序：代理、网关、隧道\"><a href=\"#通讯数据转发程序：代理、网关、隧道\" class=\"headerlink\" title=\"通讯数据转发程序：代理、网关、隧道\"></a>通讯数据转发程序：代理、网关、隧道</h2><ol>\n<li><p>代理</p>\n<p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变URI，会直接发给前方持有资源的目标服务器。</p>\n<p>这个过程可以级联多台服务器，转发时，需要附加Via首部字段以标记出经过的主机信息。</p>\n<p>持有资源实体的服务器叫做源服务器。从源服务器返回的响应经过代理服务器再传给客户端。</p>\n<h3 id=\"使用代理服务器的理由\"><a href=\"#使用代理服务器的理由\" class=\"headerlink\" title=\"使用代理服务器的理由\"></a>使用代理服务器的理由</h3><p>按两种基准分类，一是是否使用缓存，另一种是是否修改报文。</p>\n<ul>\n<li><p>利用缓存技术减少带宽流量</p>\n<p>代理转发响应时缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。</p>\n<p>当代理再次接受到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。</p>\n</li>\n<li>透明代理<br>转发请求或响应时，不对报文做任何加工的代理类型称为透明代理（Transparent Proxy）。反之称为非透明代理。</li>\n</ul>\n<p>此外使用代理服务器还可以组织内部针对特定网站进行访问控制，获取访问日志等。</p>\n</li>\n<li><p>网关</p>\n<p>网关能使通讯线路上的服务器提供非HTTP通讯协议。</p>\n<p>利用网关能提高通讯的安全性，因为可以在客户端和网关之间的通讯线路上加密以确保通讯的安全。</p>\n<p>接收客户端发来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端也不能分辨自己的通信目标是一个网关。</p>\n</li>\n<li><p>隧道</p>\n<p>隧道是在相隔甚远的客户端和服务器之间进行中转。并保持双方通信连接的应用程序，确保客户端和服务器端能进行安全的通信。</p>\n<p>隧道本身不解析HTTP请求，原样中转给之后的服务器。</p>\n<p>隧道会在通信双方断开连接时结束。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"用单台虚拟主机实现多个域名\"><a href=\"#用单台虚拟主机实现多个域名\" class=\"headerlink\" title=\"用单台虚拟主机实现多个域名\"></a>用单台虚拟主机实现多个域名</h2><p>即使物理层面只有一台服务器，但只要使用虚拟主机的功能（Virtual Host），则可以假想已具有多台服务器，搭建多个WEB站点，持有各自的域名，运行各自的网站。<br>","more":"<br>客户端使用HTTP协议访问服务器时，主机名和域名会通过DNS服务映射到ip地址访问目标网站。如果一台服务器托管了多个域名，就需要知道是访问哪个域名。</p>\n<p>因此在发送HTTP请求时，必须在Host首部内完整地指定主机名或域名的URI。</p>\n<h2 id=\"通讯数据转发程序：代理、网关、隧道\"><a href=\"#通讯数据转发程序：代理、网关、隧道\" class=\"headerlink\" title=\"通讯数据转发程序：代理、网关、隧道\"></a>通讯数据转发程序：代理、网关、隧道</h2><ol>\n<li><p>代理</p>\n<p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变URI，会直接发给前方持有资源的目标服务器。</p>\n<p>这个过程可以级联多台服务器，转发时，需要附加Via首部字段以标记出经过的主机信息。</p>\n<p>持有资源实体的服务器叫做源服务器。从源服务器返回的响应经过代理服务器再传给客户端。</p>\n<h3 id=\"使用代理服务器的理由\"><a href=\"#使用代理服务器的理由\" class=\"headerlink\" title=\"使用代理服务器的理由\"></a>使用代理服务器的理由</h3><p>按两种基准分类，一是是否使用缓存，另一种是是否修改报文。</p>\n<ul>\n<li><p>利用缓存技术减少带宽流量</p>\n<p>代理转发响应时缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。</p>\n<p>当代理再次接受到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。</p>\n</li>\n<li>透明代理<br>转发请求或响应时，不对报文做任何加工的代理类型称为透明代理（Transparent Proxy）。反之称为非透明代理。</li>\n</ul>\n<p>此外使用代理服务器还可以组织内部针对特定网站进行访问控制，获取访问日志等。</p>\n</li>\n<li><p>网关</p>\n<p>网关能使通讯线路上的服务器提供非HTTP通讯协议。</p>\n<p>利用网关能提高通讯的安全性，因为可以在客户端和网关之间的通讯线路上加密以确保通讯的安全。</p>\n<p>接收客户端发来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端也不能分辨自己的通信目标是一个网关。</p>\n</li>\n<li><p>隧道</p>\n<p>隧道是在相隔甚远的客户端和服务器之间进行中转。并保持双方通信连接的应用程序，确保客户端和服务器端能进行安全的通信。</p>\n<p>隧道本身不解析HTTP请求，原样中转给之后的服务器。</p>\n<p>隧道会在通信双方断开连接时结束。</p>\n</li>\n</ol>"},{"title":"《图解http》第六章笔记","date":"2017-10-19T16:00:00.000Z","_content":"## http 报文首部\n\nHTTP报文首部起到传递额外重要信息的作用。\n\nHTTP请求报文首部由方法、URI、HTTP版本、请求首部字段、通用首部字段、实体首部字段构成。\n<!--more-->\nHTTP响应报文首部由HTTP版本、状态码、响应首部字段、通用首部字段、实体首部字段构成。\n### http 首部字段的四种类型\nHTTP首部字段根据实际用途被分为以下四类：\n* 通用首部字段（General Header Fields）\n\n  请求报文和响应报文都会使用的首部\n* 请求首部字段（Requset Header Fields）\n\n  从客户端向服务端发送请求报文时使用的首部。\n* 响应首部字段（Response Header Fields）\n\n  从服务端向客户端返回响应报文时使用的首部。\n* 实体首部字段（Entity Header Fields）\n\n  针对请求报文和响应报文的实体部分使用的首部。\n### End-to-end 首部和Hop-by-hop 首部\nHTTP首部字段将定义成缓存代理和非缓存代理的行为。\n\n* 端到端首部\n\n  分在此类别的首部会转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中。另外规定他必须被转发。\n* 逐跳首部\n\n  分在此类别的首部只对单次转发有效，会因通过缓存或代理而不再转发。\n### 通用首部字段\n#### Cache-Control\n* public指令(仅为响应指令)\n\n  表明其他用户也可利用缓存。\n* private指令(仅为响应指令)\n\n  响应只以特定的用户作为对象，对应其他用户发送过来的请求，代理服务器不会返回缓存。\n* no-cache\n\n  位于请求首部：表明客户端不接受缓存过的响应，“中间”的缓存服务器必须把客户端的请求转发给源服务器。\n\n  位于响应首部：响应中包含no-chche指令，则缓存服务器不对资源进行缓存。\n* no-store\n\n  规定缓存不能在本地存储请求或响应的任一部分。\n* max-age\n\n  当发送的请求包含max-age指令时，判断缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。值为0时，那么缓存服务器会将请求转发给源服务器。\n\n  当返回的响应包含max-age指令时，缓存服务器不再对资源的有效性进行确认，max-age代表资源保存为缓存的最长时间。\n\n  HTTP/1.1遇到同时存在Expries字段时，优先处理max-age。HTTP/1.0则相反。\n\n* s-maxage(仅为响应指令)\n\n  与max-age的唯一区别是,s-maxage仅仅应用于共享缓存。而不引用于用户代理的本地缓存,等针对单用户的缓存。另外,s-maxage的优先级要高于max-age和Expries。\n* min-frassh(仅为请求指令)\n\n  要求缓存服务器返回至少还未过指定时间的缓存资源。\n* max-stale\n\n  指示缓存资源，过期也照样接收或返回。\n  指定数值，即使过期，在指定数值之内，依然接收或返回。\n* only-if-cached(仅为请求指令)\n\n  表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。若请求缓存服务器的本地缓存无响应则返回状态码504。\n* must-revalidate(仅为响应指令)\n\n  指明代理服务器会向源服务器验证即将返回的响应缓存目前是否有效。\n\n  若无法连通源服务器，返回504。\n\n  在该指令存在的条件下，忽略max-stale指令。\n* proxy-revalidate(仅为请求指令)\n\n  要求代理服务器在接收到具有该指令的请求返回响应之前，必须再次验证资源的有效性。\n* no-transform\n\n  要求缓存不能改变实体资源的媒体类型，可防止缓存或代理压缩图片等操作。\n* cache-extension token\n\n  通过cache-extension标记（token），可以扩展Cache-Control首部字段的指令。\n\n  extension token仅对能理解它的缓存服务器来说是有意义的，不能理解则忽略。\n#### Connection\n  * 控制不再转发给代理的首部字段\n  * 管理持久连接\n\n  HTTP/1.1默认连接都是持久连接。客户端会在持久连接上连续发送请求。当服务端想明确断开连接时，则指定Connection首部字段的值为close。\n\n  HTTP/1.1之前的HTTP版本的默认连接是非持久化连接，为此，要在旧的协议版本维持持续连接需要指定Connection为keep-alive。\n#### Date\n表明创建HTTP报文的日期和时间\n#### Pragma\nHTTP/1.1之前版本的遗留字段，仅作为和HTTP/1.0向后兼容而定义。\n\n只用在客户端发送的请求中，要求所以的中间服务器不返回缓存的资源。\n\n为了兼容HTTP/1.1及其之前的版本，发送的请求会同时包含两个字段\n````http\nCache-Control: no-cache\nPragma: no-cache\n````\n#### Trailer\nTrailer会事先说明在报文主体后记录了哪些首部字段，也用于分块编码传输。\n#### Transfer-Encoding\nTransfer-Encoding规定传输报文主体时采用的编码方式。\n#### Upgrade\nUpgrade用于检测HTTP协议及其他协议是否可使用更高的版本进行通信。\n#### Via\n追踪客户端和服务器之间的请求和响应报文的传输路径，避免请求回环的发生。\n\n报文经过代理和网关时，会先在首部字段Via中附加该服务器的信息，再进行转发。\n#### Warning\n该首部通常会告知用户一些缓存相关问题的警告。\n### 请求首部字段\n#### Accept\n用于通知服务器，用户代理可以处理的媒体类型及媒体类型的相对优先级。\n\n增加优先级，使用q=来表示权重的值。范围为0~1.0,1为最大，默认为1。\n#### Accept-Charset\n通知服务器用户代理支持的字符集和字符集的相对优先顺序。权重设置方式与Accept相同。\n#### Accept-Encoding\n告知服务器用户代理支持的内容编码及内容编码的优先顺序。\n#### Accept-Language\n告知服务器用户代理支持的自然语言集及自然语言集的优先顺序。\n#### Authorization\n告知服务器，用户代理的认证信息。\n#### From\n告知服务器使用用户代理的电子邮件地址。\n#### Host\n告知服务器，请求的资源所处的互联网主机名和端口号。\n### If-Match\nIf-xxx的字段称为条件请求，服务器接受到附带条件的请求后，只有判断条件为真时，才会执行请求。\n### If-Modified-Since\n告知服务器若If-Modified-Since字段值早于资源的更新时间，则希望处理该请求。\n\n若再If-Modified-Since字段值的时间之后资源没有更新过，返回304状态码。\n\n获取资源的更新日期，可通过首部字段Last-Modified来确定。\n#### Range\n告知服务器资源的指定范围，服务器返回206 Partial Content的响应。\n#### Referer\n告知服务器请求的原始资源的URI。\n#### User-Agent\nUse-Agent字段会将创建请求的浏览器和用户代理名称等信息传达给服务器。\n### 响应首部字段\n#### Accept-Range\n告知客户端服务器是否能处理范围请求，以指定获取服务端某个部分的资源。\n\n可处理时指定为btyes，反之为none。\n#### Age\n告知客户端源服务器在多久之前创建了响应，单位为秒。\n#### ETag\n告知客户端的实体标示。\n\n服务器会为每份资源分配对应的ETag值。\n#### Location\n可以将响应接收方引导至某个与请求URI位置不同的资源。\n\n几乎所有浏览器在接收到包含Location首部字段的响应后，都会强制性地尝试对已提示的重定向资源的访问。\n#### Proxy-Authenticate\n将由代理服务器所要求的认证信息发送给客户端。\n#### Retry-After\n告知客户端多久之后再次发起请求。\n#### Server\n告知客户端当前服务器上安装的HTTP服务器应用程序的信息。\n#### WWW-Authenticate\n用于HTTP访问认证。\n### 实体首部字段\n#### Allow\n用于通知客户端能够支持的Request-URI指定资源的HTTP方法。当服服务器接受到不支持的HTTP方法时，会以状态码405 Method Not Allowed作为响应返回。\n#### Content-Encoding\n告知客户端服务端对实体的主体部分选用的内容编码方式。\n\n主要采用以下4种编码方式：\n* gzip\n* compress\n* deflate\n* identity\n#### Content-Language\n告知客户端实体主体使用的自然语言。\n#### Content-Length\n表明实体主体部分的大小，单位为字节。\n#### Content-Location\n给出与报文主体部分像对应的URI。\n#### Content-MD5\n客户端对接受的报文主体执行相同的MD5算法，然后与首部字段的Content-MD5字段值进行比较。\n#### Content-Range\n告知客户端作为响应返回的实体的哪个部分符合范围请求。\n#### Content-Type\n说明主体实体内对象的媒体类型。\n#### Expires\n将资源的实效日期告知客户端。\n#### Last-Modified\n指明资源最终修改的时间。\n### 为Cookie服务的首部字段\nCookie的工作机制是用户识别和状态管理。\n#### Set-Cookie\n当服务端开始准备管理客户端的状态时，会事先告知各种信息。\n\n|属性|说明|\n|:--|:--|\n|NAME=VALUE|赋予Cookie的名称及其值（必需项）|\n|expires=DATE|Cookie的有效期（若不指定则到浏览器关闭时为止，维持会话（Session）的时间段内）|\n|path=PATH|将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）|\n|domain=域名|作为Cookie适用对象的域名（若不指定则为创建Cookie的服务器的域名）|\n|Secure|仅在https安全通信时才会发送Cookie|\n|HttpOnly|加以限制，使Cookie不能被JavaScript脚本访问|\n#### Cookie\n告知服务器，当客户端想获得HTTP状态管理的支持时，就会在请求中包含从服务器接收到的Cookie。\n### 其他首部字段\n#### X-Frame-Options\n属于HTTP响应首部，用于控制网站内容在其他Web站点的Frame标签的显示问题。\n\n字段值：\n* DENY 拒绝\n* SAMEORIGIN 仅同源域名下的页面匹配时许可\n#### X-XSS-Protection\n属于HTTP响应首部，用于控制浏览器XSS防护机制的开关。\n字段值：\n* 0 将XSS过滤设置为无效状态\n* 1 将XSS过滤设置为有效状态\n#### DNT\n属于HTTP请求首部，全称为Do not Track，意味拒绝个人信息被收集，是表示拒绝精准广告定位的一种方法。\n* 0 同意被追踪\n* 1 拒绝被追踪\n#### P3P\n属于HTTP响应首部，利用P3P技术，让Web网站上的个人隐私变成一种仅供程序可理解的形式，已达到保护用户隐私的目的。\n","source":"_posts/《图解http》第六章笔记.md","raw":"---\ntitle: 《图解http》第六章笔记\ndate: 2017-10-20\ntags: ['http']\ncategories: ['笔记']\n---\n## http 报文首部\n\nHTTP报文首部起到传递额外重要信息的作用。\n\nHTTP请求报文首部由方法、URI、HTTP版本、请求首部字段、通用首部字段、实体首部字段构成。\n<!--more-->\nHTTP响应报文首部由HTTP版本、状态码、响应首部字段、通用首部字段、实体首部字段构成。\n### http 首部字段的四种类型\nHTTP首部字段根据实际用途被分为以下四类：\n* 通用首部字段（General Header Fields）\n\n  请求报文和响应报文都会使用的首部\n* 请求首部字段（Requset Header Fields）\n\n  从客户端向服务端发送请求报文时使用的首部。\n* 响应首部字段（Response Header Fields）\n\n  从服务端向客户端返回响应报文时使用的首部。\n* 实体首部字段（Entity Header Fields）\n\n  针对请求报文和响应报文的实体部分使用的首部。\n### End-to-end 首部和Hop-by-hop 首部\nHTTP首部字段将定义成缓存代理和非缓存代理的行为。\n\n* 端到端首部\n\n  分在此类别的首部会转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中。另外规定他必须被转发。\n* 逐跳首部\n\n  分在此类别的首部只对单次转发有效，会因通过缓存或代理而不再转发。\n### 通用首部字段\n#### Cache-Control\n* public指令(仅为响应指令)\n\n  表明其他用户也可利用缓存。\n* private指令(仅为响应指令)\n\n  响应只以特定的用户作为对象，对应其他用户发送过来的请求，代理服务器不会返回缓存。\n* no-cache\n\n  位于请求首部：表明客户端不接受缓存过的响应，“中间”的缓存服务器必须把客户端的请求转发给源服务器。\n\n  位于响应首部：响应中包含no-chche指令，则缓存服务器不对资源进行缓存。\n* no-store\n\n  规定缓存不能在本地存储请求或响应的任一部分。\n* max-age\n\n  当发送的请求包含max-age指令时，判断缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。值为0时，那么缓存服务器会将请求转发给源服务器。\n\n  当返回的响应包含max-age指令时，缓存服务器不再对资源的有效性进行确认，max-age代表资源保存为缓存的最长时间。\n\n  HTTP/1.1遇到同时存在Expries字段时，优先处理max-age。HTTP/1.0则相反。\n\n* s-maxage(仅为响应指令)\n\n  与max-age的唯一区别是,s-maxage仅仅应用于共享缓存。而不引用于用户代理的本地缓存,等针对单用户的缓存。另外,s-maxage的优先级要高于max-age和Expries。\n* min-frassh(仅为请求指令)\n\n  要求缓存服务器返回至少还未过指定时间的缓存资源。\n* max-stale\n\n  指示缓存资源，过期也照样接收或返回。\n  指定数值，即使过期，在指定数值之内，依然接收或返回。\n* only-if-cached(仅为请求指令)\n\n  表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。若请求缓存服务器的本地缓存无响应则返回状态码504。\n* must-revalidate(仅为响应指令)\n\n  指明代理服务器会向源服务器验证即将返回的响应缓存目前是否有效。\n\n  若无法连通源服务器，返回504。\n\n  在该指令存在的条件下，忽略max-stale指令。\n* proxy-revalidate(仅为请求指令)\n\n  要求代理服务器在接收到具有该指令的请求返回响应之前，必须再次验证资源的有效性。\n* no-transform\n\n  要求缓存不能改变实体资源的媒体类型，可防止缓存或代理压缩图片等操作。\n* cache-extension token\n\n  通过cache-extension标记（token），可以扩展Cache-Control首部字段的指令。\n\n  extension token仅对能理解它的缓存服务器来说是有意义的，不能理解则忽略。\n#### Connection\n  * 控制不再转发给代理的首部字段\n  * 管理持久连接\n\n  HTTP/1.1默认连接都是持久连接。客户端会在持久连接上连续发送请求。当服务端想明确断开连接时，则指定Connection首部字段的值为close。\n\n  HTTP/1.1之前的HTTP版本的默认连接是非持久化连接，为此，要在旧的协议版本维持持续连接需要指定Connection为keep-alive。\n#### Date\n表明创建HTTP报文的日期和时间\n#### Pragma\nHTTP/1.1之前版本的遗留字段，仅作为和HTTP/1.0向后兼容而定义。\n\n只用在客户端发送的请求中，要求所以的中间服务器不返回缓存的资源。\n\n为了兼容HTTP/1.1及其之前的版本，发送的请求会同时包含两个字段\n````http\nCache-Control: no-cache\nPragma: no-cache\n````\n#### Trailer\nTrailer会事先说明在报文主体后记录了哪些首部字段，也用于分块编码传输。\n#### Transfer-Encoding\nTransfer-Encoding规定传输报文主体时采用的编码方式。\n#### Upgrade\nUpgrade用于检测HTTP协议及其他协议是否可使用更高的版本进行通信。\n#### Via\n追踪客户端和服务器之间的请求和响应报文的传输路径，避免请求回环的发生。\n\n报文经过代理和网关时，会先在首部字段Via中附加该服务器的信息，再进行转发。\n#### Warning\n该首部通常会告知用户一些缓存相关问题的警告。\n### 请求首部字段\n#### Accept\n用于通知服务器，用户代理可以处理的媒体类型及媒体类型的相对优先级。\n\n增加优先级，使用q=来表示权重的值。范围为0~1.0,1为最大，默认为1。\n#### Accept-Charset\n通知服务器用户代理支持的字符集和字符集的相对优先顺序。权重设置方式与Accept相同。\n#### Accept-Encoding\n告知服务器用户代理支持的内容编码及内容编码的优先顺序。\n#### Accept-Language\n告知服务器用户代理支持的自然语言集及自然语言集的优先顺序。\n#### Authorization\n告知服务器，用户代理的认证信息。\n#### From\n告知服务器使用用户代理的电子邮件地址。\n#### Host\n告知服务器，请求的资源所处的互联网主机名和端口号。\n### If-Match\nIf-xxx的字段称为条件请求，服务器接受到附带条件的请求后，只有判断条件为真时，才会执行请求。\n### If-Modified-Since\n告知服务器若If-Modified-Since字段值早于资源的更新时间，则希望处理该请求。\n\n若再If-Modified-Since字段值的时间之后资源没有更新过，返回304状态码。\n\n获取资源的更新日期，可通过首部字段Last-Modified来确定。\n#### Range\n告知服务器资源的指定范围，服务器返回206 Partial Content的响应。\n#### Referer\n告知服务器请求的原始资源的URI。\n#### User-Agent\nUse-Agent字段会将创建请求的浏览器和用户代理名称等信息传达给服务器。\n### 响应首部字段\n#### Accept-Range\n告知客户端服务器是否能处理范围请求，以指定获取服务端某个部分的资源。\n\n可处理时指定为btyes，反之为none。\n#### Age\n告知客户端源服务器在多久之前创建了响应，单位为秒。\n#### ETag\n告知客户端的实体标示。\n\n服务器会为每份资源分配对应的ETag值。\n#### Location\n可以将响应接收方引导至某个与请求URI位置不同的资源。\n\n几乎所有浏览器在接收到包含Location首部字段的响应后，都会强制性地尝试对已提示的重定向资源的访问。\n#### Proxy-Authenticate\n将由代理服务器所要求的认证信息发送给客户端。\n#### Retry-After\n告知客户端多久之后再次发起请求。\n#### Server\n告知客户端当前服务器上安装的HTTP服务器应用程序的信息。\n#### WWW-Authenticate\n用于HTTP访问认证。\n### 实体首部字段\n#### Allow\n用于通知客户端能够支持的Request-URI指定资源的HTTP方法。当服服务器接受到不支持的HTTP方法时，会以状态码405 Method Not Allowed作为响应返回。\n#### Content-Encoding\n告知客户端服务端对实体的主体部分选用的内容编码方式。\n\n主要采用以下4种编码方式：\n* gzip\n* compress\n* deflate\n* identity\n#### Content-Language\n告知客户端实体主体使用的自然语言。\n#### Content-Length\n表明实体主体部分的大小，单位为字节。\n#### Content-Location\n给出与报文主体部分像对应的URI。\n#### Content-MD5\n客户端对接受的报文主体执行相同的MD5算法，然后与首部字段的Content-MD5字段值进行比较。\n#### Content-Range\n告知客户端作为响应返回的实体的哪个部分符合范围请求。\n#### Content-Type\n说明主体实体内对象的媒体类型。\n#### Expires\n将资源的实效日期告知客户端。\n#### Last-Modified\n指明资源最终修改的时间。\n### 为Cookie服务的首部字段\nCookie的工作机制是用户识别和状态管理。\n#### Set-Cookie\n当服务端开始准备管理客户端的状态时，会事先告知各种信息。\n\n|属性|说明|\n|:--|:--|\n|NAME=VALUE|赋予Cookie的名称及其值（必需项）|\n|expires=DATE|Cookie的有效期（若不指定则到浏览器关闭时为止，维持会话（Session）的时间段内）|\n|path=PATH|将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）|\n|domain=域名|作为Cookie适用对象的域名（若不指定则为创建Cookie的服务器的域名）|\n|Secure|仅在https安全通信时才会发送Cookie|\n|HttpOnly|加以限制，使Cookie不能被JavaScript脚本访问|\n#### Cookie\n告知服务器，当客户端想获得HTTP状态管理的支持时，就会在请求中包含从服务器接收到的Cookie。\n### 其他首部字段\n#### X-Frame-Options\n属于HTTP响应首部，用于控制网站内容在其他Web站点的Frame标签的显示问题。\n\n字段值：\n* DENY 拒绝\n* SAMEORIGIN 仅同源域名下的页面匹配时许可\n#### X-XSS-Protection\n属于HTTP响应首部，用于控制浏览器XSS防护机制的开关。\n字段值：\n* 0 将XSS过滤设置为无效状态\n* 1 将XSS过滤设置为有效状态\n#### DNT\n属于HTTP请求首部，全称为Do not Track，意味拒绝个人信息被收集，是表示拒绝精准广告定位的一种方法。\n* 0 同意被追踪\n* 1 拒绝被追踪\n#### P3P\n属于HTTP响应首部，利用P3P技术，让Web网站上的个人隐私变成一种仅供程序可理解的形式，已达到保护用户隐私的目的。\n","slug":"《图解http》第六章笔记","published":1,"updated":"2022-04-13T14:14:07.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffn002eg3t81s5jlprr","content":"<h2 id=\"http-报文首部\"><a href=\"#http-报文首部\" class=\"headerlink\" title=\"http 报文首部\"></a>http 报文首部</h2><p>HTTP报文首部起到传递额外重要信息的作用。</p>\n<p>HTTP请求报文首部由方法、URI、HTTP版本、请求首部字段、通用首部字段、实体首部字段构成。<br><a id=\"more\"></a><br>HTTP响应报文首部由HTTP版本、状态码、响应首部字段、通用首部字段、实体首部字段构成。</p>\n<h3 id=\"http-首部字段的四种类型\"><a href=\"#http-首部字段的四种类型\" class=\"headerlink\" title=\"http 首部字段的四种类型\"></a>http 首部字段的四种类型</h3><p>HTTP首部字段根据实际用途被分为以下四类：</p>\n<ul>\n<li><p>通用首部字段（General Header Fields）</p>\n<p>请求报文和响应报文都会使用的首部</p>\n</li>\n<li><p>请求首部字段（Requset Header Fields）</p>\n<p>从客户端向服务端发送请求报文时使用的首部。</p>\n</li>\n<li><p>响应首部字段（Response Header Fields）</p>\n<p>从服务端向客户端返回响应报文时使用的首部。</p>\n</li>\n<li><p>实体首部字段（Entity Header Fields）</p>\n<p>针对请求报文和响应报文的实体部分使用的首部。</p>\n<h3 id=\"End-to-end-首部和Hop-by-hop-首部\"><a href=\"#End-to-end-首部和Hop-by-hop-首部\" class=\"headerlink\" title=\"End-to-end 首部和Hop-by-hop 首部\"></a>End-to-end 首部和Hop-by-hop 首部</h3><p>HTTP首部字段将定义成缓存代理和非缓存代理的行为。</p>\n</li>\n<li><p>端到端首部</p>\n<p>分在此类别的首部会转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中。另外规定他必须被转发。</p>\n</li>\n<li><p>逐跳首部</p>\n<p>分在此类别的首部只对单次转发有效，会因通过缓存或代理而不再转发。</p>\n<h3 id=\"通用首部字段\"><a href=\"#通用首部字段\" class=\"headerlink\" title=\"通用首部字段\"></a>通用首部字段</h3><h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4></li>\n<li><p>public指令(仅为响应指令)</p>\n<p>表明其他用户也可利用缓存。</p>\n</li>\n<li><p>private指令(仅为响应指令)</p>\n<p>响应只以特定的用户作为对象，对应其他用户发送过来的请求，代理服务器不会返回缓存。</p>\n</li>\n<li><p>no-cache</p>\n<p>位于请求首部：表明客户端不接受缓存过的响应，“中间”的缓存服务器必须把客户端的请求转发给源服务器。</p>\n<p>位于响应首部：响应中包含no-chche指令，则缓存服务器不对资源进行缓存。</p>\n</li>\n<li><p>no-store</p>\n<p>规定缓存不能在本地存储请求或响应的任一部分。</p>\n</li>\n<li><p>max-age</p>\n<p>当发送的请求包含max-age指令时，判断缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。值为0时，那么缓存服务器会将请求转发给源服务器。</p>\n<p>当返回的响应包含max-age指令时，缓存服务器不再对资源的有效性进行确认，max-age代表资源保存为缓存的最长时间。</p>\n<p>HTTP/1.1遇到同时存在Expries字段时，优先处理max-age。HTTP/1.0则相反。</p>\n</li>\n<li><p>s-maxage(仅为响应指令)</p>\n<p>与max-age的唯一区别是,s-maxage仅仅应用于共享缓存。而不引用于用户代理的本地缓存,等针对单用户的缓存。另外,s-maxage的优先级要高于max-age和Expries。</p>\n</li>\n<li><p>min-frassh(仅为请求指令)</p>\n<p>要求缓存服务器返回至少还未过指定时间的缓存资源。</p>\n</li>\n<li><p>max-stale</p>\n<p>指示缓存资源，过期也照样接收或返回。<br>指定数值，即使过期，在指定数值之内，依然接收或返回。</p>\n</li>\n<li><p>only-if-cached(仅为请求指令)</p>\n<p>表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。若请求缓存服务器的本地缓存无响应则返回状态码504。</p>\n</li>\n<li><p>must-revalidate(仅为响应指令)</p>\n<p>指明代理服务器会向源服务器验证即将返回的响应缓存目前是否有效。</p>\n<p>若无法连通源服务器，返回504。</p>\n<p>在该指令存在的条件下，忽略max-stale指令。</p>\n</li>\n<li><p>proxy-revalidate(仅为请求指令)</p>\n<p>要求代理服务器在接收到具有该指令的请求返回响应之前，必须再次验证资源的有效性。</p>\n</li>\n<li><p>no-transform</p>\n<p>要求缓存不能改变实体资源的媒体类型，可防止缓存或代理压缩图片等操作。</p>\n</li>\n<li><p>cache-extension token</p>\n<p>通过cache-extension标记（token），可以扩展Cache-Control首部字段的指令。</p>\n<p>extension token仅对能理解它的缓存服务器来说是有意义的，不能理解则忽略。</p>\n<h4 id=\"Connection\"><a href=\"#Connection\" class=\"headerlink\" title=\"Connection\"></a>Connection</h4><ul>\n<li>控制不再转发给代理的首部字段</li>\n<li>管理持久连接</li>\n</ul>\n<p>HTTP/1.1默认连接都是持久连接。客户端会在持久连接上连续发送请求。当服务端想明确断开连接时，则指定Connection首部字段的值为close。</p>\n<p>HTTP/1.1之前的HTTP版本的默认连接是非持久化连接，为此，要在旧的协议版本维持持续连接需要指定Connection为keep-alive。</p>\n<h4 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h4><p>表明创建HTTP报文的日期和时间</p>\n<h4 id=\"Pragma\"><a href=\"#Pragma\" class=\"headerlink\" title=\"Pragma\"></a>Pragma</h4><p>HTTP/1.1之前版本的遗留字段，仅作为和HTTP/1.0向后兼容而定义。</p>\n</li>\n</ul>\n<p>只用在客户端发送的请求中，要求所以的中间服务器不返回缓存的资源。</p>\n<p>为了兼容HTTP/1.1及其之前的版本，发送的请求会同时包含两个字段<br><figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Cache-Control</span>: no-cache</span><br><span class=\"line\"><span class=\"attribute\">Pragma</span>: no-cache</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Trailer\"><a href=\"#Trailer\" class=\"headerlink\" title=\"Trailer\"></a>Trailer</h4><p>Trailer会事先说明在报文主体后记录了哪些首部字段，也用于分块编码传输。</p>\n<h4 id=\"Transfer-Encoding\"><a href=\"#Transfer-Encoding\" class=\"headerlink\" title=\"Transfer-Encoding\"></a>Transfer-Encoding</h4><p>Transfer-Encoding规定传输报文主体时采用的编码方式。</p>\n<h4 id=\"Upgrade\"><a href=\"#Upgrade\" class=\"headerlink\" title=\"Upgrade\"></a>Upgrade</h4><p>Upgrade用于检测HTTP协议及其他协议是否可使用更高的版本进行通信。</p>\n<h4 id=\"Via\"><a href=\"#Via\" class=\"headerlink\" title=\"Via\"></a>Via</h4><p>追踪客户端和服务器之间的请求和响应报文的传输路径，避免请求回环的发生。</p>\n<p>报文经过代理和网关时，会先在首部字段Via中附加该服务器的信息，再进行转发。</p>\n<h4 id=\"Warning\"><a href=\"#Warning\" class=\"headerlink\" title=\"Warning\"></a>Warning</h4><p>该首部通常会告知用户一些缓存相关问题的警告。</p>\n<h3 id=\"请求首部字段\"><a href=\"#请求首部字段\" class=\"headerlink\" title=\"请求首部字段\"></a>请求首部字段</h3><h4 id=\"Accept\"><a href=\"#Accept\" class=\"headerlink\" title=\"Accept\"></a>Accept</h4><p>用于通知服务器，用户代理可以处理的媒体类型及媒体类型的相对优先级。</p>\n<p>增加优先级，使用q=来表示权重的值。范围为0~1.0,1为最大，默认为1。</p>\n<h4 id=\"Accept-Charset\"><a href=\"#Accept-Charset\" class=\"headerlink\" title=\"Accept-Charset\"></a>Accept-Charset</h4><p>通知服务器用户代理支持的字符集和字符集的相对优先顺序。权重设置方式与Accept相同。</p>\n<h4 id=\"Accept-Encoding\"><a href=\"#Accept-Encoding\" class=\"headerlink\" title=\"Accept-Encoding\"></a>Accept-Encoding</h4><p>告知服务器用户代理支持的内容编码及内容编码的优先顺序。</p>\n<h4 id=\"Accept-Language\"><a href=\"#Accept-Language\" class=\"headerlink\" title=\"Accept-Language\"></a>Accept-Language</h4><p>告知服务器用户代理支持的自然语言集及自然语言集的优先顺序。</p>\n<h4 id=\"Authorization\"><a href=\"#Authorization\" class=\"headerlink\" title=\"Authorization\"></a>Authorization</h4><p>告知服务器，用户代理的认证信息。</p>\n<h4 id=\"From\"><a href=\"#From\" class=\"headerlink\" title=\"From\"></a>From</h4><p>告知服务器使用用户代理的电子邮件地址。</p>\n<h4 id=\"Host\"><a href=\"#Host\" class=\"headerlink\" title=\"Host\"></a>Host</h4><p>告知服务器，请求的资源所处的互联网主机名和端口号。</p>\n<h3 id=\"If-Match\"><a href=\"#If-Match\" class=\"headerlink\" title=\"If-Match\"></a>If-Match</h3><p>If-xxx的字段称为条件请求，服务器接受到附带条件的请求后，只有判断条件为真时，才会执行请求。</p>\n<h3 id=\"If-Modified-Since\"><a href=\"#If-Modified-Since\" class=\"headerlink\" title=\"If-Modified-Since\"></a>If-Modified-Since</h3><p>告知服务器若If-Modified-Since字段值早于资源的更新时间，则希望处理该请求。</p>\n<p>若再If-Modified-Since字段值的时间之后资源没有更新过，返回304状态码。</p>\n<p>获取资源的更新日期，可通过首部字段Last-Modified来确定。</p>\n<h4 id=\"Range\"><a href=\"#Range\" class=\"headerlink\" title=\"Range\"></a>Range</h4><p>告知服务器资源的指定范围，服务器返回206 Partial Content的响应。</p>\n<h4 id=\"Referer\"><a href=\"#Referer\" class=\"headerlink\" title=\"Referer\"></a>Referer</h4><p>告知服务器请求的原始资源的URI。</p>\n<h4 id=\"User-Agent\"><a href=\"#User-Agent\" class=\"headerlink\" title=\"User-Agent\"></a>User-Agent</h4><p>Use-Agent字段会将创建请求的浏览器和用户代理名称等信息传达给服务器。</p>\n<h3 id=\"响应首部字段\"><a href=\"#响应首部字段\" class=\"headerlink\" title=\"响应首部字段\"></a>响应首部字段</h3><h4 id=\"Accept-Range\"><a href=\"#Accept-Range\" class=\"headerlink\" title=\"Accept-Range\"></a>Accept-Range</h4><p>告知客户端服务器是否能处理范围请求，以指定获取服务端某个部分的资源。</p>\n<p>可处理时指定为btyes，反之为none。</p>\n<h4 id=\"Age\"><a href=\"#Age\" class=\"headerlink\" title=\"Age\"></a>Age</h4><p>告知客户端源服务器在多久之前创建了响应，单位为秒。</p>\n<h4 id=\"ETag\"><a href=\"#ETag\" class=\"headerlink\" title=\"ETag\"></a>ETag</h4><p>告知客户端的实体标示。</p>\n<p>服务器会为每份资源分配对应的ETag值。</p>\n<h4 id=\"Location\"><a href=\"#Location\" class=\"headerlink\" title=\"Location\"></a>Location</h4><p>可以将响应接收方引导至某个与请求URI位置不同的资源。</p>\n<p>几乎所有浏览器在接收到包含Location首部字段的响应后，都会强制性地尝试对已提示的重定向资源的访问。</p>\n<h4 id=\"Proxy-Authenticate\"><a href=\"#Proxy-Authenticate\" class=\"headerlink\" title=\"Proxy-Authenticate\"></a>Proxy-Authenticate</h4><p>将由代理服务器所要求的认证信息发送给客户端。</p>\n<h4 id=\"Retry-After\"><a href=\"#Retry-After\" class=\"headerlink\" title=\"Retry-After\"></a>Retry-After</h4><p>告知客户端多久之后再次发起请求。</p>\n<h4 id=\"Server\"><a href=\"#Server\" class=\"headerlink\" title=\"Server\"></a>Server</h4><p>告知客户端当前服务器上安装的HTTP服务器应用程序的信息。</p>\n<h4 id=\"WWW-Authenticate\"><a href=\"#WWW-Authenticate\" class=\"headerlink\" title=\"WWW-Authenticate\"></a>WWW-Authenticate</h4><p>用于HTTP访问认证。</p>\n<h3 id=\"实体首部字段\"><a href=\"#实体首部字段\" class=\"headerlink\" title=\"实体首部字段\"></a>实体首部字段</h3><h4 id=\"Allow\"><a href=\"#Allow\" class=\"headerlink\" title=\"Allow\"></a>Allow</h4><p>用于通知客户端能够支持的Request-URI指定资源的HTTP方法。当服服务器接受到不支持的HTTP方法时，会以状态码405 Method Not Allowed作为响应返回。</p>\n<h4 id=\"Content-Encoding\"><a href=\"#Content-Encoding\" class=\"headerlink\" title=\"Content-Encoding\"></a>Content-Encoding</h4><p>告知客户端服务端对实体的主体部分选用的内容编码方式。</p>\n<p>主要采用以下4种编码方式：</p>\n<ul>\n<li>gzip</li>\n<li>compress</li>\n<li>deflate</li>\n<li>identity<h4 id=\"Content-Language\"><a href=\"#Content-Language\" class=\"headerlink\" title=\"Content-Language\"></a>Content-Language</h4>告知客户端实体主体使用的自然语言。<h4 id=\"Content-Length\"><a href=\"#Content-Length\" class=\"headerlink\" title=\"Content-Length\"></a>Content-Length</h4>表明实体主体部分的大小，单位为字节。<h4 id=\"Content-Location\"><a href=\"#Content-Location\" class=\"headerlink\" title=\"Content-Location\"></a>Content-Location</h4>给出与报文主体部分像对应的URI。<h4 id=\"Content-MD5\"><a href=\"#Content-MD5\" class=\"headerlink\" title=\"Content-MD5\"></a>Content-MD5</h4>客户端对接受的报文主体执行相同的MD5算法，然后与首部字段的Content-MD5字段值进行比较。<h4 id=\"Content-Range\"><a href=\"#Content-Range\" class=\"headerlink\" title=\"Content-Range\"></a>Content-Range</h4>告知客户端作为响应返回的实体的哪个部分符合范围请求。<h4 id=\"Content-Type\"><a href=\"#Content-Type\" class=\"headerlink\" title=\"Content-Type\"></a>Content-Type</h4>说明主体实体内对象的媒体类型。<h4 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h4>将资源的实效日期告知客户端。<h4 id=\"Last-Modified\"><a href=\"#Last-Modified\" class=\"headerlink\" title=\"Last-Modified\"></a>Last-Modified</h4>指明资源最终修改的时间。<h3 id=\"为Cookie服务的首部字段\"><a href=\"#为Cookie服务的首部字段\" class=\"headerlink\" title=\"为Cookie服务的首部字段\"></a>为Cookie服务的首部字段</h3>Cookie的工作机制是用户识别和状态管理。<h4 id=\"Set-Cookie\"><a href=\"#Set-Cookie\" class=\"headerlink\" title=\"Set-Cookie\"></a>Set-Cookie</h4>当服务端开始准备管理客户端的状态时，会事先告知各种信息。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">NAME=VALUE</td>\n<td style=\"text-align:left\">赋予Cookie的名称及其值（必需项）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">expires=DATE</td>\n<td style=\"text-align:left\">Cookie的有效期（若不指定则到浏览器关闭时为止，维持会话（Session）的时间段内）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">path=PATH</td>\n<td style=\"text-align:left\">将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">domain=域名</td>\n<td style=\"text-align:left\">作为Cookie适用对象的域名（若不指定则为创建Cookie的服务器的域名）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Secure</td>\n<td style=\"text-align:left\">仅在https安全通信时才会发送Cookie</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HttpOnly</td>\n<td style=\"text-align:left\">加以限制，使Cookie不能被JavaScript脚本访问</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h4><p>告知服务器，当客户端想获得HTTP状态管理的支持时，就会在请求中包含从服务器接收到的Cookie。</p>\n<h3 id=\"其他首部字段\"><a href=\"#其他首部字段\" class=\"headerlink\" title=\"其他首部字段\"></a>其他首部字段</h3><h4 id=\"X-Frame-Options\"><a href=\"#X-Frame-Options\" class=\"headerlink\" title=\"X-Frame-Options\"></a>X-Frame-Options</h4><p>属于HTTP响应首部，用于控制网站内容在其他Web站点的Frame标签的显示问题。</p>\n<p>字段值：</p>\n<ul>\n<li>DENY 拒绝</li>\n<li>SAMEORIGIN 仅同源域名下的页面匹配时许可<h4 id=\"X-XSS-Protection\"><a href=\"#X-XSS-Protection\" class=\"headerlink\" title=\"X-XSS-Protection\"></a>X-XSS-Protection</h4>属于HTTP响应首部，用于控制浏览器XSS防护机制的开关。<br>字段值：</li>\n<li>0 将XSS过滤设置为无效状态</li>\n<li>1 将XSS过滤设置为有效状态<h4 id=\"DNT\"><a href=\"#DNT\" class=\"headerlink\" title=\"DNT\"></a>DNT</h4>属于HTTP请求首部，全称为Do not Track，意味拒绝个人信息被收集，是表示拒绝精准广告定位的一种方法。</li>\n<li>0 同意被追踪</li>\n<li>1 拒绝被追踪<h4 id=\"P3P\"><a href=\"#P3P\" class=\"headerlink\" title=\"P3P\"></a>P3P</h4>属于HTTP响应首部，利用P3P技术，让Web网站上的个人隐私变成一种仅供程序可理解的形式，已达到保护用户隐私的目的。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"http-报文首部\"><a href=\"#http-报文首部\" class=\"headerlink\" title=\"http 报文首部\"></a>http 报文首部</h2><p>HTTP报文首部起到传递额外重要信息的作用。</p>\n<p>HTTP请求报文首部由方法、URI、HTTP版本、请求首部字段、通用首部字段、实体首部字段构成。<br>","more":"<br>HTTP响应报文首部由HTTP版本、状态码、响应首部字段、通用首部字段、实体首部字段构成。</p>\n<h3 id=\"http-首部字段的四种类型\"><a href=\"#http-首部字段的四种类型\" class=\"headerlink\" title=\"http 首部字段的四种类型\"></a>http 首部字段的四种类型</h3><p>HTTP首部字段根据实际用途被分为以下四类：</p>\n<ul>\n<li><p>通用首部字段（General Header Fields）</p>\n<p>请求报文和响应报文都会使用的首部</p>\n</li>\n<li><p>请求首部字段（Requset Header Fields）</p>\n<p>从客户端向服务端发送请求报文时使用的首部。</p>\n</li>\n<li><p>响应首部字段（Response Header Fields）</p>\n<p>从服务端向客户端返回响应报文时使用的首部。</p>\n</li>\n<li><p>实体首部字段（Entity Header Fields）</p>\n<p>针对请求报文和响应报文的实体部分使用的首部。</p>\n<h3 id=\"End-to-end-首部和Hop-by-hop-首部\"><a href=\"#End-to-end-首部和Hop-by-hop-首部\" class=\"headerlink\" title=\"End-to-end 首部和Hop-by-hop 首部\"></a>End-to-end 首部和Hop-by-hop 首部</h3><p>HTTP首部字段将定义成缓存代理和非缓存代理的行为。</p>\n</li>\n<li><p>端到端首部</p>\n<p>分在此类别的首部会转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中。另外规定他必须被转发。</p>\n</li>\n<li><p>逐跳首部</p>\n<p>分在此类别的首部只对单次转发有效，会因通过缓存或代理而不再转发。</p>\n<h3 id=\"通用首部字段\"><a href=\"#通用首部字段\" class=\"headerlink\" title=\"通用首部字段\"></a>通用首部字段</h3><h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4></li>\n<li><p>public指令(仅为响应指令)</p>\n<p>表明其他用户也可利用缓存。</p>\n</li>\n<li><p>private指令(仅为响应指令)</p>\n<p>响应只以特定的用户作为对象，对应其他用户发送过来的请求，代理服务器不会返回缓存。</p>\n</li>\n<li><p>no-cache</p>\n<p>位于请求首部：表明客户端不接受缓存过的响应，“中间”的缓存服务器必须把客户端的请求转发给源服务器。</p>\n<p>位于响应首部：响应中包含no-chche指令，则缓存服务器不对资源进行缓存。</p>\n</li>\n<li><p>no-store</p>\n<p>规定缓存不能在本地存储请求或响应的任一部分。</p>\n</li>\n<li><p>max-age</p>\n<p>当发送的请求包含max-age指令时，判断缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。值为0时，那么缓存服务器会将请求转发给源服务器。</p>\n<p>当返回的响应包含max-age指令时，缓存服务器不再对资源的有效性进行确认，max-age代表资源保存为缓存的最长时间。</p>\n<p>HTTP/1.1遇到同时存在Expries字段时，优先处理max-age。HTTP/1.0则相反。</p>\n</li>\n<li><p>s-maxage(仅为响应指令)</p>\n<p>与max-age的唯一区别是,s-maxage仅仅应用于共享缓存。而不引用于用户代理的本地缓存,等针对单用户的缓存。另外,s-maxage的优先级要高于max-age和Expries。</p>\n</li>\n<li><p>min-frassh(仅为请求指令)</p>\n<p>要求缓存服务器返回至少还未过指定时间的缓存资源。</p>\n</li>\n<li><p>max-stale</p>\n<p>指示缓存资源，过期也照样接收或返回。<br>指定数值，即使过期，在指定数值之内，依然接收或返回。</p>\n</li>\n<li><p>only-if-cached(仅为请求指令)</p>\n<p>表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。若请求缓存服务器的本地缓存无响应则返回状态码504。</p>\n</li>\n<li><p>must-revalidate(仅为响应指令)</p>\n<p>指明代理服务器会向源服务器验证即将返回的响应缓存目前是否有效。</p>\n<p>若无法连通源服务器，返回504。</p>\n<p>在该指令存在的条件下，忽略max-stale指令。</p>\n</li>\n<li><p>proxy-revalidate(仅为请求指令)</p>\n<p>要求代理服务器在接收到具有该指令的请求返回响应之前，必须再次验证资源的有效性。</p>\n</li>\n<li><p>no-transform</p>\n<p>要求缓存不能改变实体资源的媒体类型，可防止缓存或代理压缩图片等操作。</p>\n</li>\n<li><p>cache-extension token</p>\n<p>通过cache-extension标记（token），可以扩展Cache-Control首部字段的指令。</p>\n<p>extension token仅对能理解它的缓存服务器来说是有意义的，不能理解则忽略。</p>\n<h4 id=\"Connection\"><a href=\"#Connection\" class=\"headerlink\" title=\"Connection\"></a>Connection</h4><ul>\n<li>控制不再转发给代理的首部字段</li>\n<li>管理持久连接</li>\n</ul>\n<p>HTTP/1.1默认连接都是持久连接。客户端会在持久连接上连续发送请求。当服务端想明确断开连接时，则指定Connection首部字段的值为close。</p>\n<p>HTTP/1.1之前的HTTP版本的默认连接是非持久化连接，为此，要在旧的协议版本维持持续连接需要指定Connection为keep-alive。</p>\n<h4 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h4><p>表明创建HTTP报文的日期和时间</p>\n<h4 id=\"Pragma\"><a href=\"#Pragma\" class=\"headerlink\" title=\"Pragma\"></a>Pragma</h4><p>HTTP/1.1之前版本的遗留字段，仅作为和HTTP/1.0向后兼容而定义。</p>\n</li>\n</ul>\n<p>只用在客户端发送的请求中，要求所以的中间服务器不返回缓存的资源。</p>\n<p>为了兼容HTTP/1.1及其之前的版本，发送的请求会同时包含两个字段<br><figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Cache-Control</span>: no-cache</span><br><span class=\"line\"><span class=\"attribute\">Pragma</span>: no-cache</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Trailer\"><a href=\"#Trailer\" class=\"headerlink\" title=\"Trailer\"></a>Trailer</h4><p>Trailer会事先说明在报文主体后记录了哪些首部字段，也用于分块编码传输。</p>\n<h4 id=\"Transfer-Encoding\"><a href=\"#Transfer-Encoding\" class=\"headerlink\" title=\"Transfer-Encoding\"></a>Transfer-Encoding</h4><p>Transfer-Encoding规定传输报文主体时采用的编码方式。</p>\n<h4 id=\"Upgrade\"><a href=\"#Upgrade\" class=\"headerlink\" title=\"Upgrade\"></a>Upgrade</h4><p>Upgrade用于检测HTTP协议及其他协议是否可使用更高的版本进行通信。</p>\n<h4 id=\"Via\"><a href=\"#Via\" class=\"headerlink\" title=\"Via\"></a>Via</h4><p>追踪客户端和服务器之间的请求和响应报文的传输路径，避免请求回环的发生。</p>\n<p>报文经过代理和网关时，会先在首部字段Via中附加该服务器的信息，再进行转发。</p>\n<h4 id=\"Warning\"><a href=\"#Warning\" class=\"headerlink\" title=\"Warning\"></a>Warning</h4><p>该首部通常会告知用户一些缓存相关问题的警告。</p>\n<h3 id=\"请求首部字段\"><a href=\"#请求首部字段\" class=\"headerlink\" title=\"请求首部字段\"></a>请求首部字段</h3><h4 id=\"Accept\"><a href=\"#Accept\" class=\"headerlink\" title=\"Accept\"></a>Accept</h4><p>用于通知服务器，用户代理可以处理的媒体类型及媒体类型的相对优先级。</p>\n<p>增加优先级，使用q=来表示权重的值。范围为0~1.0,1为最大，默认为1。</p>\n<h4 id=\"Accept-Charset\"><a href=\"#Accept-Charset\" class=\"headerlink\" title=\"Accept-Charset\"></a>Accept-Charset</h4><p>通知服务器用户代理支持的字符集和字符集的相对优先顺序。权重设置方式与Accept相同。</p>\n<h4 id=\"Accept-Encoding\"><a href=\"#Accept-Encoding\" class=\"headerlink\" title=\"Accept-Encoding\"></a>Accept-Encoding</h4><p>告知服务器用户代理支持的内容编码及内容编码的优先顺序。</p>\n<h4 id=\"Accept-Language\"><a href=\"#Accept-Language\" class=\"headerlink\" title=\"Accept-Language\"></a>Accept-Language</h4><p>告知服务器用户代理支持的自然语言集及自然语言集的优先顺序。</p>\n<h4 id=\"Authorization\"><a href=\"#Authorization\" class=\"headerlink\" title=\"Authorization\"></a>Authorization</h4><p>告知服务器，用户代理的认证信息。</p>\n<h4 id=\"From\"><a href=\"#From\" class=\"headerlink\" title=\"From\"></a>From</h4><p>告知服务器使用用户代理的电子邮件地址。</p>\n<h4 id=\"Host\"><a href=\"#Host\" class=\"headerlink\" title=\"Host\"></a>Host</h4><p>告知服务器，请求的资源所处的互联网主机名和端口号。</p>\n<h3 id=\"If-Match\"><a href=\"#If-Match\" class=\"headerlink\" title=\"If-Match\"></a>If-Match</h3><p>If-xxx的字段称为条件请求，服务器接受到附带条件的请求后，只有判断条件为真时，才会执行请求。</p>\n<h3 id=\"If-Modified-Since\"><a href=\"#If-Modified-Since\" class=\"headerlink\" title=\"If-Modified-Since\"></a>If-Modified-Since</h3><p>告知服务器若If-Modified-Since字段值早于资源的更新时间，则希望处理该请求。</p>\n<p>若再If-Modified-Since字段值的时间之后资源没有更新过，返回304状态码。</p>\n<p>获取资源的更新日期，可通过首部字段Last-Modified来确定。</p>\n<h4 id=\"Range\"><a href=\"#Range\" class=\"headerlink\" title=\"Range\"></a>Range</h4><p>告知服务器资源的指定范围，服务器返回206 Partial Content的响应。</p>\n<h4 id=\"Referer\"><a href=\"#Referer\" class=\"headerlink\" title=\"Referer\"></a>Referer</h4><p>告知服务器请求的原始资源的URI。</p>\n<h4 id=\"User-Agent\"><a href=\"#User-Agent\" class=\"headerlink\" title=\"User-Agent\"></a>User-Agent</h4><p>Use-Agent字段会将创建请求的浏览器和用户代理名称等信息传达给服务器。</p>\n<h3 id=\"响应首部字段\"><a href=\"#响应首部字段\" class=\"headerlink\" title=\"响应首部字段\"></a>响应首部字段</h3><h4 id=\"Accept-Range\"><a href=\"#Accept-Range\" class=\"headerlink\" title=\"Accept-Range\"></a>Accept-Range</h4><p>告知客户端服务器是否能处理范围请求，以指定获取服务端某个部分的资源。</p>\n<p>可处理时指定为btyes，反之为none。</p>\n<h4 id=\"Age\"><a href=\"#Age\" class=\"headerlink\" title=\"Age\"></a>Age</h4><p>告知客户端源服务器在多久之前创建了响应，单位为秒。</p>\n<h4 id=\"ETag\"><a href=\"#ETag\" class=\"headerlink\" title=\"ETag\"></a>ETag</h4><p>告知客户端的实体标示。</p>\n<p>服务器会为每份资源分配对应的ETag值。</p>\n<h4 id=\"Location\"><a href=\"#Location\" class=\"headerlink\" title=\"Location\"></a>Location</h4><p>可以将响应接收方引导至某个与请求URI位置不同的资源。</p>\n<p>几乎所有浏览器在接收到包含Location首部字段的响应后，都会强制性地尝试对已提示的重定向资源的访问。</p>\n<h4 id=\"Proxy-Authenticate\"><a href=\"#Proxy-Authenticate\" class=\"headerlink\" title=\"Proxy-Authenticate\"></a>Proxy-Authenticate</h4><p>将由代理服务器所要求的认证信息发送给客户端。</p>\n<h4 id=\"Retry-After\"><a href=\"#Retry-After\" class=\"headerlink\" title=\"Retry-After\"></a>Retry-After</h4><p>告知客户端多久之后再次发起请求。</p>\n<h4 id=\"Server\"><a href=\"#Server\" class=\"headerlink\" title=\"Server\"></a>Server</h4><p>告知客户端当前服务器上安装的HTTP服务器应用程序的信息。</p>\n<h4 id=\"WWW-Authenticate\"><a href=\"#WWW-Authenticate\" class=\"headerlink\" title=\"WWW-Authenticate\"></a>WWW-Authenticate</h4><p>用于HTTP访问认证。</p>\n<h3 id=\"实体首部字段\"><a href=\"#实体首部字段\" class=\"headerlink\" title=\"实体首部字段\"></a>实体首部字段</h3><h4 id=\"Allow\"><a href=\"#Allow\" class=\"headerlink\" title=\"Allow\"></a>Allow</h4><p>用于通知客户端能够支持的Request-URI指定资源的HTTP方法。当服服务器接受到不支持的HTTP方法时，会以状态码405 Method Not Allowed作为响应返回。</p>\n<h4 id=\"Content-Encoding\"><a href=\"#Content-Encoding\" class=\"headerlink\" title=\"Content-Encoding\"></a>Content-Encoding</h4><p>告知客户端服务端对实体的主体部分选用的内容编码方式。</p>\n<p>主要采用以下4种编码方式：</p>\n<ul>\n<li>gzip</li>\n<li>compress</li>\n<li>deflate</li>\n<li>identity<h4 id=\"Content-Language\"><a href=\"#Content-Language\" class=\"headerlink\" title=\"Content-Language\"></a>Content-Language</h4>告知客户端实体主体使用的自然语言。<h4 id=\"Content-Length\"><a href=\"#Content-Length\" class=\"headerlink\" title=\"Content-Length\"></a>Content-Length</h4>表明实体主体部分的大小，单位为字节。<h4 id=\"Content-Location\"><a href=\"#Content-Location\" class=\"headerlink\" title=\"Content-Location\"></a>Content-Location</h4>给出与报文主体部分像对应的URI。<h4 id=\"Content-MD5\"><a href=\"#Content-MD5\" class=\"headerlink\" title=\"Content-MD5\"></a>Content-MD5</h4>客户端对接受的报文主体执行相同的MD5算法，然后与首部字段的Content-MD5字段值进行比较。<h4 id=\"Content-Range\"><a href=\"#Content-Range\" class=\"headerlink\" title=\"Content-Range\"></a>Content-Range</h4>告知客户端作为响应返回的实体的哪个部分符合范围请求。<h4 id=\"Content-Type\"><a href=\"#Content-Type\" class=\"headerlink\" title=\"Content-Type\"></a>Content-Type</h4>说明主体实体内对象的媒体类型。<h4 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h4>将资源的实效日期告知客户端。<h4 id=\"Last-Modified\"><a href=\"#Last-Modified\" class=\"headerlink\" title=\"Last-Modified\"></a>Last-Modified</h4>指明资源最终修改的时间。<h3 id=\"为Cookie服务的首部字段\"><a href=\"#为Cookie服务的首部字段\" class=\"headerlink\" title=\"为Cookie服务的首部字段\"></a>为Cookie服务的首部字段</h3>Cookie的工作机制是用户识别和状态管理。<h4 id=\"Set-Cookie\"><a href=\"#Set-Cookie\" class=\"headerlink\" title=\"Set-Cookie\"></a>Set-Cookie</h4>当服务端开始准备管理客户端的状态时，会事先告知各种信息。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">NAME=VALUE</td>\n<td style=\"text-align:left\">赋予Cookie的名称及其值（必需项）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">expires=DATE</td>\n<td style=\"text-align:left\">Cookie的有效期（若不指定则到浏览器关闭时为止，维持会话（Session）的时间段内）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">path=PATH</td>\n<td style=\"text-align:left\">将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">domain=域名</td>\n<td style=\"text-align:left\">作为Cookie适用对象的域名（若不指定则为创建Cookie的服务器的域名）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Secure</td>\n<td style=\"text-align:left\">仅在https安全通信时才会发送Cookie</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HttpOnly</td>\n<td style=\"text-align:left\">加以限制，使Cookie不能被JavaScript脚本访问</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h4><p>告知服务器，当客户端想获得HTTP状态管理的支持时，就会在请求中包含从服务器接收到的Cookie。</p>\n<h3 id=\"其他首部字段\"><a href=\"#其他首部字段\" class=\"headerlink\" title=\"其他首部字段\"></a>其他首部字段</h3><h4 id=\"X-Frame-Options\"><a href=\"#X-Frame-Options\" class=\"headerlink\" title=\"X-Frame-Options\"></a>X-Frame-Options</h4><p>属于HTTP响应首部，用于控制网站内容在其他Web站点的Frame标签的显示问题。</p>\n<p>字段值：</p>\n<ul>\n<li>DENY 拒绝</li>\n<li>SAMEORIGIN 仅同源域名下的页面匹配时许可<h4 id=\"X-XSS-Protection\"><a href=\"#X-XSS-Protection\" class=\"headerlink\" title=\"X-XSS-Protection\"></a>X-XSS-Protection</h4>属于HTTP响应首部，用于控制浏览器XSS防护机制的开关。<br>字段值：</li>\n<li>0 将XSS过滤设置为无效状态</li>\n<li>1 将XSS过滤设置为有效状态<h4 id=\"DNT\"><a href=\"#DNT\" class=\"headerlink\" title=\"DNT\"></a>DNT</h4>属于HTTP请求首部，全称为Do not Track，意味拒绝个人信息被收集，是表示拒绝精准广告定位的一种方法。</li>\n<li>0 同意被追踪</li>\n<li>1 拒绝被追踪<h4 id=\"P3P\"><a href=\"#P3P\" class=\"headerlink\" title=\"P3P\"></a>P3P</h4>属于HTTP响应首部，利用P3P技术，让Web网站上的个人隐私变成一种仅供程序可理解的形式，已达到保护用户隐私的目的。</li>\n</ul>"},{"title":"《精通正则表达式》第一章笔记","date":"2017-09-07T16:00:00.000Z","_content":"## 元字符\n元字符 | 名称 | 匹配对象\n------|------|------\n.     |点号  |除了换行符以外的单个任意字符\n[...] |字符组  |列出的任意字符\n[^...]|排除型字符组  |未列出的任意字符\n^ |脱字符  |行的起始位置\n$ |美元符  |行的接受位置\n\\< |反斜线-小于  |单词的起始位置\n\\> |反斜线-大于  |单词的结束位置\n\\|  |竖线  |匹配分割两边的任意一个表达式\n(...)  |括号  |限制竖线的作用范围\n<!--more-->\n* 在字符组内部,元字符的定义规则和意义是不一样的。\n* 不用混合多选项h和字符组，字符组只能匹配一个字符，多选项可以匹配长字符串。\n* ^X 排除型字符的意思是匹配一个不为X的字符。\n* -i参数规定在匹配时不区分大小写。\n\n### 表示重复的元字符\n元字符 | 次数下限 | 次数上限 | 含义\n----|----|----|----\n?|无|1|可以不出现，也可以只出现一次\n*|无|无|可以出现无数次，也可以不出现\n+|1|无|可以出现无数次，但至少要出现一次\n\n规定重现次数的范围：区间{min,max}\n## 括号及反向引用\n使用括号的三个作用：\n1. 限制多选结构\n2. 分组\n3. 捕获文本\n一个表达式中可以使用多个括号，用\\1,\\2,\\3来表示第一，第二，第三组括号匹配的文本。\n## 转义\n如果需要匹配的某个字符本身就是元字符,使用反斜线（转义符）加上改符号来表示，作用是使元字符失去特殊含义，变成普通字符。\n","source":"_posts/《精通正则表达式》第一章笔记.md","raw":"---\ntitle: 《精通正则表达式》第一章笔记\ndate: 2017-09-08\ntags: ['正则表达式']\ncategories: ['笔记']\n---\n## 元字符\n元字符 | 名称 | 匹配对象\n------|------|------\n.     |点号  |除了换行符以外的单个任意字符\n[...] |字符组  |列出的任意字符\n[^...]|排除型字符组  |未列出的任意字符\n^ |脱字符  |行的起始位置\n$ |美元符  |行的接受位置\n\\< |反斜线-小于  |单词的起始位置\n\\> |反斜线-大于  |单词的结束位置\n\\|  |竖线  |匹配分割两边的任意一个表达式\n(...)  |括号  |限制竖线的作用范围\n<!--more-->\n* 在字符组内部,元字符的定义规则和意义是不一样的。\n* 不用混合多选项h和字符组，字符组只能匹配一个字符，多选项可以匹配长字符串。\n* ^X 排除型字符的意思是匹配一个不为X的字符。\n* -i参数规定在匹配时不区分大小写。\n\n### 表示重复的元字符\n元字符 | 次数下限 | 次数上限 | 含义\n----|----|----|----\n?|无|1|可以不出现，也可以只出现一次\n*|无|无|可以出现无数次，也可以不出现\n+|1|无|可以出现无数次，但至少要出现一次\n\n规定重现次数的范围：区间{min,max}\n## 括号及反向引用\n使用括号的三个作用：\n1. 限制多选结构\n2. 分组\n3. 捕获文本\n一个表达式中可以使用多个括号，用\\1,\\2,\\3来表示第一，第二，第三组括号匹配的文本。\n## 转义\n如果需要匹配的某个字符本身就是元字符,使用反斜线（转义符）加上改符号来表示，作用是使元字符失去特殊含义，变成普通字符。\n","slug":"《精通正则表达式》第一章笔记","published":1,"updated":"2022-04-13T14:14:07.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffo002gg3t88n0m9ypf","content":"<h2 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h2><table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>名称</th>\n<th>匹配对象</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.</td>\n<td>点号</td>\n<td>除了换行符以外的单个任意字符</td>\n</tr>\n<tr>\n<td>[…]</td>\n<td>字符组</td>\n<td>列出的任意字符</td>\n</tr>\n<tr>\n<td>[^…]</td>\n<td>排除型字符组</td>\n<td>未列出的任意字符</td>\n</tr>\n<tr>\n<td>^</td>\n<td>脱字符</td>\n<td>行的起始位置</td>\n</tr>\n<tr>\n<td>$</td>\n<td>美元符</td>\n<td>行的接受位置</td>\n</tr>\n<tr>\n<td>\\&lt;</td>\n<td>反斜线-小于</td>\n<td>单词的起始位置</td>\n</tr>\n<tr>\n<td>></td>\n<td>反斜线-大于</td>\n<td>单词的结束位置</td>\n</tr>\n<tr>\n<td>\\</td>\n<td></td>\n<td>竖线</td>\n<td>匹配分割两边的任意一个表达式</td>\n</tr>\n<tr>\n<td>(…)</td>\n<td>括号</td>\n<td>限制竖线的作用范围</td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<ul>\n<li>在字符组内部,元字符的定义规则和意义是不一样的。</li>\n<li>不用混合多选项h和字符组，字符组只能匹配一个字符，多选项可以匹配长字符串。</li>\n<li>^X 排除型字符的意思是匹配一个不为X的字符。</li>\n<li>-i参数规定在匹配时不区分大小写。</li>\n</ul>\n<h3 id=\"表示重复的元字符\"><a href=\"#表示重复的元字符\" class=\"headerlink\" title=\"表示重复的元字符\"></a>表示重复的元字符</h3><table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>次数下限</th>\n<th>次数上限</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>?</td>\n<td>无</td>\n<td>1</td>\n<td>可以不出现，也可以只出现一次</td>\n</tr>\n<tr>\n<td>*</td>\n<td>无</td>\n<td>无</td>\n<td>可以出现无数次，也可以不出现</td>\n</tr>\n<tr>\n<td>+</td>\n<td>1</td>\n<td>无</td>\n<td>可以出现无数次，但至少要出现一次</td>\n</tr>\n</tbody>\n</table>\n<p>规定重现次数的范围：区间{min,max}</p>\n<h2 id=\"括号及反向引用\"><a href=\"#括号及反向引用\" class=\"headerlink\" title=\"括号及反向引用\"></a>括号及反向引用</h2><p>使用括号的三个作用：</p>\n<ol>\n<li>限制多选结构</li>\n<li>分组</li>\n<li>捕获文本<br>一个表达式中可以使用多个括号，用\\1,\\2,\\3来表示第一，第二，第三组括号匹配的文本。<h2 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h2>如果需要匹配的某个字符本身就是元字符,使用反斜线（转义符）加上改符号来表示，作用是使元字符失去特殊含义，变成普通字符。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h2><table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>名称</th>\n<th>匹配对象</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.</td>\n<td>点号</td>\n<td>除了换行符以外的单个任意字符</td>\n</tr>\n<tr>\n<td>[…]</td>\n<td>字符组</td>\n<td>列出的任意字符</td>\n</tr>\n<tr>\n<td>[^…]</td>\n<td>排除型字符组</td>\n<td>未列出的任意字符</td>\n</tr>\n<tr>\n<td>^</td>\n<td>脱字符</td>\n<td>行的起始位置</td>\n</tr>\n<tr>\n<td>$</td>\n<td>美元符</td>\n<td>行的接受位置</td>\n</tr>\n<tr>\n<td>\\&lt;</td>\n<td>反斜线-小于</td>\n<td>单词的起始位置</td>\n</tr>\n<tr>\n<td>></td>\n<td>反斜线-大于</td>\n<td>单词的结束位置</td>\n</tr>\n<tr>\n<td>\\</td>\n<td></td>\n<td>竖线</td>\n<td>匹配分割两边的任意一个表达式</td>\n</tr>\n<tr>\n<td>(…)</td>\n<td>括号</td>\n<td>限制竖线的作用范围</td>\n</tr>\n</tbody>\n</table>","more":"<ul>\n<li>在字符组内部,元字符的定义规则和意义是不一样的。</li>\n<li>不用混合多选项h和字符组，字符组只能匹配一个字符，多选项可以匹配长字符串。</li>\n<li>^X 排除型字符的意思是匹配一个不为X的字符。</li>\n<li>-i参数规定在匹配时不区分大小写。</li>\n</ul>\n<h3 id=\"表示重复的元字符\"><a href=\"#表示重复的元字符\" class=\"headerlink\" title=\"表示重复的元字符\"></a>表示重复的元字符</h3><table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>次数下限</th>\n<th>次数上限</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>?</td>\n<td>无</td>\n<td>1</td>\n<td>可以不出现，也可以只出现一次</td>\n</tr>\n<tr>\n<td>*</td>\n<td>无</td>\n<td>无</td>\n<td>可以出现无数次，也可以不出现</td>\n</tr>\n<tr>\n<td>+</td>\n<td>1</td>\n<td>无</td>\n<td>可以出现无数次，但至少要出现一次</td>\n</tr>\n</tbody>\n</table>\n<p>规定重现次数的范围：区间{min,max}</p>\n<h2 id=\"括号及反向引用\"><a href=\"#括号及反向引用\" class=\"headerlink\" title=\"括号及反向引用\"></a>括号及反向引用</h2><p>使用括号的三个作用：</p>\n<ol>\n<li>限制多选结构</li>\n<li>分组</li>\n<li>捕获文本<br>一个表达式中可以使用多个括号，用\\1,\\2,\\3来表示第一，第二，第三组括号匹配的文本。<h2 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h2>如果需要匹配的某个字符本身就是元字符,使用反斜线（转义符）加上改符号来表示，作用是使元字符失去特殊含义，变成普通字符。</li>\n</ol>"},{"title":"《图解http》第四章笔记","date":"2017-09-22T16:00:00.000Z","_content":"## 返回结果的HTTP状态码\n### 状态码告知从服务器端返回的请求结果\n状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。\n\n状态码由3位数字和原因短语组成。数字中的第一位指明响应类别，后两位无分类。\n<!--more-->\n状态码的类别\n状态码 | 类别 | 原因短语\n------:|------|------\n1xx   | Informational（信息性状态码） | 接收的请求这种处理\n2xx   | Success（成功状态码） | 请求正常，处理完毕\n3xx   | Redirection（重定向状态码） | 需要进行附加操作以完成请求\n4xx   | Client Error（客户端错误性状态码） | 服务器无法处理请求\n5xx   | Server Error（服务端错误状态码） | 服务器处理请求出错\n### 2xx 成功\n* 200 OK\n    表示从客户端发来的请求被服务端正常处理了\n* 204 No Content\n    表示服务器接收的请求处理成功，但在返回的响应报文中不含实体的主体部分。\n* 206 Partial Content\n    表示客户端进行了范围请求，而服务器成功执行了这部分GET请求。\n\n    响应报文中由Content-Range指定范围的实体内容。\n### 3xx 重定向\n* 301 Move Permanently\n    永久性重定向，表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。\n* 302 Found\n    临时性重定向，表示请求的资源已经被分配了新的URI，希望用户（本次）能够使用新的URI访问。\n* 303 See Other\n    表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。和302的区别是，明确表示使用GET获取。\n* 304 Not Modified\n    表示客户端发送附带条件的请求时，服务端允许请求访问资源，但为满足条件的情况。\n\n    304状态码返回时，不包含任何响应的主体部分。\n    \n    附带的条件值采用GET方法的请求报文中包含If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中的任意首部。\n* 307 Temporary Redirect\n    表示临时重定向\n### 4xx 错误\n* 400 Bad Request\n    表示请求报文中发生语法错误。\n* 401 Unauthorized\n    表示发送的请求需要有通过HTTP认证（BASIC认证， DIFEST认证）的认证信息。\n\n    返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询（challenge）用户信息。\n* 403 Fobbiden\n    标明对请求资源的访问被服务器拒绝了。\n* 404 Not Found\n    表明服务器上无法找到请求的资源。\n### 5xx 服务器错误\n* 500 Internal Server Error\n    表明服务端在执行请求是发生了错误。\n* 503 Server Unavailable\n    表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。\n\n    如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。\n","source":"_posts/《图解http》第四章笔记.md","raw":"---\ntitle: 《图解http》第四章笔记\ndate: 2017-09-23\ntags: ['http']\ncategories: ['笔记']\n---\n## 返回结果的HTTP状态码\n### 状态码告知从服务器端返回的请求结果\n状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。\n\n状态码由3位数字和原因短语组成。数字中的第一位指明响应类别，后两位无分类。\n<!--more-->\n状态码的类别\n状态码 | 类别 | 原因短语\n------:|------|------\n1xx   | Informational（信息性状态码） | 接收的请求这种处理\n2xx   | Success（成功状态码） | 请求正常，处理完毕\n3xx   | Redirection（重定向状态码） | 需要进行附加操作以完成请求\n4xx   | Client Error（客户端错误性状态码） | 服务器无法处理请求\n5xx   | Server Error（服务端错误状态码） | 服务器处理请求出错\n### 2xx 成功\n* 200 OK\n    表示从客户端发来的请求被服务端正常处理了\n* 204 No Content\n    表示服务器接收的请求处理成功，但在返回的响应报文中不含实体的主体部分。\n* 206 Partial Content\n    表示客户端进行了范围请求，而服务器成功执行了这部分GET请求。\n\n    响应报文中由Content-Range指定范围的实体内容。\n### 3xx 重定向\n* 301 Move Permanently\n    永久性重定向，表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。\n* 302 Found\n    临时性重定向，表示请求的资源已经被分配了新的URI，希望用户（本次）能够使用新的URI访问。\n* 303 See Other\n    表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。和302的区别是，明确表示使用GET获取。\n* 304 Not Modified\n    表示客户端发送附带条件的请求时，服务端允许请求访问资源，但为满足条件的情况。\n\n    304状态码返回时，不包含任何响应的主体部分。\n    \n    附带的条件值采用GET方法的请求报文中包含If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中的任意首部。\n* 307 Temporary Redirect\n    表示临时重定向\n### 4xx 错误\n* 400 Bad Request\n    表示请求报文中发生语法错误。\n* 401 Unauthorized\n    表示发送的请求需要有通过HTTP认证（BASIC认证， DIFEST认证）的认证信息。\n\n    返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询（challenge）用户信息。\n* 403 Fobbiden\n    标明对请求资源的访问被服务器拒绝了。\n* 404 Not Found\n    表明服务器上无法找到请求的资源。\n### 5xx 服务器错误\n* 500 Internal Server Error\n    表明服务端在执行请求是发生了错误。\n* 503 Server Unavailable\n    表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。\n\n    如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。\n","slug":"《图解http》第四章笔记","published":1,"updated":"2022-04-13T14:14:07.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffp002jg3t8y0nisj8h","content":"<h2 id=\"返回结果的HTTP状态码\"><a href=\"#返回结果的HTTP状态码\" class=\"headerlink\" title=\"返回结果的HTTP状态码\"></a>返回结果的HTTP状态码</h2><h3 id=\"状态码告知从服务器端返回的请求结果\"><a href=\"#状态码告知从服务器端返回的请求结果\" class=\"headerlink\" title=\"状态码告知从服务器端返回的请求结果\"></a>状态码告知从服务器端返回的请求结果</h3><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。</p>\n<p>状态码由3位数字和原因短语组成。数字中的第一位指明响应类别，后两位无分类。<br><a id=\"more\"></a><br>状态码的类别<br>状态码 | 类别 | 原因短语<br>——:|——|——<br>1xx   | Informational（信息性状态码） | 接收的请求这种处理<br>2xx   | Success（成功状态码） | 请求正常，处理完毕<br>3xx   | Redirection（重定向状态码） | 需要进行附加操作以完成请求<br>4xx   | Client Error（客户端错误性状态码） | 服务器无法处理请求<br>5xx   | Server Error（服务端错误状态码） | 服务器处理请求出错</p>\n<h3 id=\"2xx-成功\"><a href=\"#2xx-成功\" class=\"headerlink\" title=\"2xx 成功\"></a>2xx 成功</h3><ul>\n<li>200 OK<br>  表示从客户端发来的请求被服务端正常处理了</li>\n<li>204 No Content<br>  表示服务器接收的请求处理成功，但在返回的响应报文中不含实体的主体部分。</li>\n<li><p>206 Partial Content<br>  表示客户端进行了范围请求，而服务器成功执行了这部分GET请求。</p>\n<p>  响应报文中由Content-Range指定范围的实体内容。</p>\n<h3 id=\"3xx-重定向\"><a href=\"#3xx-重定向\" class=\"headerlink\" title=\"3xx 重定向\"></a>3xx 重定向</h3></li>\n<li>301 Move Permanently<br>  永久性重定向，表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。</li>\n<li>302 Found<br>  临时性重定向，表示请求的资源已经被分配了新的URI，希望用户（本次）能够使用新的URI访问。</li>\n<li>303 See Other<br>  表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。和302的区别是，明确表示使用GET获取。</li>\n<li><p>304 Not Modified<br>  表示客户端发送附带条件的请求时，服务端允许请求访问资源，但为满足条件的情况。</p>\n<p>  304状态码返回时，不包含任何响应的主体部分。</p>\n<p>  附带的条件值采用GET方法的请求报文中包含If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中的任意首部。</p>\n</li>\n<li>307 Temporary Redirect<br>  表示临时重定向<h3 id=\"4xx-错误\"><a href=\"#4xx-错误\" class=\"headerlink\" title=\"4xx 错误\"></a>4xx 错误</h3></li>\n<li>400 Bad Request<br>  表示请求报文中发生语法错误。</li>\n<li><p>401 Unauthorized<br>  表示发送的请求需要有通过HTTP认证（BASIC认证， DIFEST认证）的认证信息。</p>\n<p>  返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询（challenge）用户信息。</p>\n</li>\n<li>403 Fobbiden<br>  标明对请求资源的访问被服务器拒绝了。</li>\n<li>404 Not Found<br>  表明服务器上无法找到请求的资源。<h3 id=\"5xx-服务器错误\"><a href=\"#5xx-服务器错误\" class=\"headerlink\" title=\"5xx 服务器错误\"></a>5xx 服务器错误</h3></li>\n<li>500 Internal Server Error<br>  表明服务端在执行请求是发生了错误。</li>\n<li><p>503 Server Unavailable<br>  表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>\n<p>  如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"返回结果的HTTP状态码\"><a href=\"#返回结果的HTTP状态码\" class=\"headerlink\" title=\"返回结果的HTTP状态码\"></a>返回结果的HTTP状态码</h2><h3 id=\"状态码告知从服务器端返回的请求结果\"><a href=\"#状态码告知从服务器端返回的请求结果\" class=\"headerlink\" title=\"状态码告知从服务器端返回的请求结果\"></a>状态码告知从服务器端返回的请求结果</h3><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。</p>\n<p>状态码由3位数字和原因短语组成。数字中的第一位指明响应类别，后两位无分类。<br>","more":"<br>状态码的类别<br>状态码 | 类别 | 原因短语<br>——:|——|——<br>1xx   | Informational（信息性状态码） | 接收的请求这种处理<br>2xx   | Success（成功状态码） | 请求正常，处理完毕<br>3xx   | Redirection（重定向状态码） | 需要进行附加操作以完成请求<br>4xx   | Client Error（客户端错误性状态码） | 服务器无法处理请求<br>5xx   | Server Error（服务端错误状态码） | 服务器处理请求出错</p>\n<h3 id=\"2xx-成功\"><a href=\"#2xx-成功\" class=\"headerlink\" title=\"2xx 成功\"></a>2xx 成功</h3><ul>\n<li>200 OK<br>  表示从客户端发来的请求被服务端正常处理了</li>\n<li>204 No Content<br>  表示服务器接收的请求处理成功，但在返回的响应报文中不含实体的主体部分。</li>\n<li><p>206 Partial Content<br>  表示客户端进行了范围请求，而服务器成功执行了这部分GET请求。</p>\n<p>  响应报文中由Content-Range指定范围的实体内容。</p>\n<h3 id=\"3xx-重定向\"><a href=\"#3xx-重定向\" class=\"headerlink\" title=\"3xx 重定向\"></a>3xx 重定向</h3></li>\n<li>301 Move Permanently<br>  永久性重定向，表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。</li>\n<li>302 Found<br>  临时性重定向，表示请求的资源已经被分配了新的URI，希望用户（本次）能够使用新的URI访问。</li>\n<li>303 See Other<br>  表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。和302的区别是，明确表示使用GET获取。</li>\n<li><p>304 Not Modified<br>  表示客户端发送附带条件的请求时，服务端允许请求访问资源，但为满足条件的情况。</p>\n<p>  304状态码返回时，不包含任何响应的主体部分。</p>\n<p>  附带的条件值采用GET方法的请求报文中包含If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中的任意首部。</p>\n</li>\n<li>307 Temporary Redirect<br>  表示临时重定向<h3 id=\"4xx-错误\"><a href=\"#4xx-错误\" class=\"headerlink\" title=\"4xx 错误\"></a>4xx 错误</h3></li>\n<li>400 Bad Request<br>  表示请求报文中发生语法错误。</li>\n<li><p>401 Unauthorized<br>  表示发送的请求需要有通过HTTP认证（BASIC认证， DIFEST认证）的认证信息。</p>\n<p>  返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询（challenge）用户信息。</p>\n</li>\n<li>403 Fobbiden<br>  标明对请求资源的访问被服务器拒绝了。</li>\n<li>404 Not Found<br>  表明服务器上无法找到请求的资源。<h3 id=\"5xx-服务器错误\"><a href=\"#5xx-服务器错误\" class=\"headerlink\" title=\"5xx 服务器错误\"></a>5xx 服务器错误</h3></li>\n<li>500 Internal Server Error<br>  表明服务端在执行请求是发生了错误。</li>\n<li><p>503 Server Unavailable<br>  表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>\n<p>  如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。</p>\n</li>\n</ul>"},{"title":"二叉树的遍历","date":"2018-03-16T16:00:00.000Z","_content":"## 二叉树的结构\n````javascript\nvar tree = {\n  val:'F',\n  left: {\n    val: 'B',\n    left: {val: 'A'},\n    right: {\n      val: 'D',\n      left: {val: 'C'},\n      right: {val: 'E'}\n    }\n  },\n  right: {\n    val: 'G',\n    right: {\n      val: 'I',\n      left:{val: 'H'}\n    }\n  }\n}\n````\n<!--more-->\n## 深度优先搜索\n\n深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。\n\n常见的做法是采用栈（LIFO）或队列（FIFO）。由于树本身是一种自我引用（即递归定义）的数据结构，因此很自然也可以用递归方式，或者更准确地说，用corecursion，来实现延迟节点的保存。这时（采用递归的情况）这些节点被保存在call stack中。\n### 前序遍历(Pre-Order Traversal)\n\n指先访问根，然后访问左子树，再访问右子树的遍历方式。\n\n![深度优先遍历 - 前序遍历：F, B, A, D, C, E, G, I, H.](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Sorted_binary_tree_preorder.svg/220px-Sorted_binary_tree_preorder.svg.png)\n\n遍历顺序：F, B, A, D, C, E, G, I, H\n* 使用递归\n\n递归调用遍历方法，唯一的区别只是在于访问自身节点的位置不同：前序在所有节点之前，后序在所有节点之后，中序则是在两节点之间。\n````javascript\nfunction pre_order_traversal_recursion(root) {\n  if(root) {\n    console.log(root.val)\n    pre_order_traversal_recursion(root.left)\n    pre_order_traversal_recursion(root.right)\n  }\n}\n````\n* 非递归 使用栈\n\n栈的特点是先进后出，所以进栈是要先进根节点，出栈的时候访问，再进右子节点再进左子节点，再出栈访问，重复以上操作，直到栈空。\n\n在入栈前判定空节点，这样可以减少出入栈的次数，也减少内存使用。\n````javascript\nfunction pre_order_traversal(root) {\n  if(root) {\n    let stack = []\n    stack.push(root)\n\n    while(stack.length > 0) {\n      //console.log(stack.map(item => item.val))\n      root = stack.pop()\n      console.log(root.val)\n\n      if(root.right) {\n        stack.push(root.right)\n      }\n\n      if(root.left) {\n        stack.push(root.left)\n      }\n    }\n  }\n}\n````\n### 中序遍历(In-Order Traversal)\n\n指先访问左（右）子树，然后访问根，最后访问右（左）子树的遍历方式。\n\n![深度优先遍历 - 中序遍历：A, B, C, D, E, F, G, H, I.](https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Sorted_binary_tree_inorder.svg/220px-Sorted_binary_tree_inorder.svg.png)\n\n遍历顺序：A, B, C, D, E, F, G, H, I.\n* 使用递归\n````javascript\nfunction in_order_traversal_recursion (root) {\n  if(root) {\n    in_order_traversal_recursion(root.left)\n    console.log(root.val)\n    in_order_traversal_recursion(root.right)\n  }\n}\n````\n* 非递归 使用栈\n中序遍历的非递归实现需要不停地将左子节点入栈，直到遇到空节点为止。然后就可以出栈输出一个节点进行访问，之后将转向其右子节点。\n````javascript\nfunction in_order_traversal(root) {\n  if(root) {\n    let stack = []\n\n    while(stack.length > 0 || !!root) {\n      //console.log(stack.map(item => item.val))\n      if(root) {\n        stack.push(root)\n        root = root.left\n      }else {\n        root = stack.pop()\n        console.log(root.val)\n        root = root.right\n      }\n    }\n  }\n}\n````\n### 后序遍历(Post-Order Traversal)\n\n指先访问子树，然后访问根的遍历方式\n\n![深度优先搜索 - 后序遍历：A, C, E, D, B, H, I, G, F.](https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Sorted_binary_tree_postorder.svg/220px-Sorted_binary_tree_postorder.svg.png)\n\n遍历顺序：A, C, E, D, B, H, I, G, F.\n* 使用递归\n````javascript\nfunction post_order_traversal_recursion(root) {\n  if(root) {\n    post_order_traversal_recursion(root.left)\n    post_order_traversal_recursion(root.right)\n    console.log(root.val)\n  }\n}\n````\n* 非递归 使用栈\n\n使用一个栈实现\n\n对于任一节点，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的节点，此时该节点出现在栈顶，但是此时不能将其出栈并访问，因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该节点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个节点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该节点是否是第一次出现在栈顶。\n\n````javascript\nfunction post_order_traversal(root) {\n  if(root) {\n    let stack = []\n    stack.push(root)\n    let tmp = null\n\n    while(stack.length > 0) {\n      //console.log(stack.map(item => item.val))\n      tmp = stack[stack.length - 1]\n      \n      if(tmp.left && root !== tmp.left && root !== tmp.right) {\n        stack.push(tmp.left)\n      }else if(tmp.right && root !== tmp.right) {\n        stack.push(tmp.right)\n      }else {\n        console.log(stack.pop().val)\n        root = tmp\n      }\n    }\n  }\n}\n````\n\n使用两个栈实现\n\n后序遍历的结构，相当于前序遍历访问左右子树的顺序互换，再把最后的结构前后反一下就可以了。\n\n此方式是先遍历根节点，再遍历右子树，最后遍历左子树。\n\n再借助第二个栈，将顺序倒转过来访问，就是后序遍历的顺序了。\n\n````javascript\nfunction post_order_traversal_two_stack(root) {\n  if(root) {\n    let stack1 = []\n    let stack2 = []\n    stack1.push(root)\n\n    while(stack1.length > 0) {\n      // console.log('stack1:',stack1.map(item => item.val))\n      // console.log('stack2:',stack2.map(item => item.val))\n      root = stack1.pop()\n      stack2.push(root)\n\n      if(root.left) {\n        stack1.push(root.left)\n      }\n      if(root.right) {\n        stack1.push(root.right)\n      }\n    }\n\n    while(stack2.length !== 0) {\n      console.log(stack2.pop().val);\n    }\n\n\n  }\n}\n````\n\n## 广度优先搜索\n和深度优先遍历不同，广度优先遍历会先访问离根节点最近的节点。二叉树的广度优先遍历又称按层次遍历。算法借助队列实现。\n\n![广度优先遍历 - 层次遍历：F, B, G, A, D, I, C, E, H.](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d1/Sorted_binary_tree_breadth-first_traversal.svg/220px-Sorted_binary_tree_breadth-first_traversal.svg.png)\n\n使用数组模拟队列。首先将根节点归入队列。当队列不为空的时候，执行循环：取出队列的一个节点，如果该节点的左子树为非空，则将该节点的左子树入队列；如果该节点的右子树为非空，则将该节点的右子树入队列。\n\n````javascript\nfunction layer_traversal(note) {\n   if(!node) {\n    throw new Error('Empty Tree')\n  }\n\n  var que = []\n  que.push(node)\n  while(que.length !== 0) {\n    node = que.shift()\n    console.log(node.value)\n    if(node.left) que.push(node.left)\n    if(node.right) que.push(node.right)\n  }\n}\n````\n## 参考资料\n* [树的遍历](https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86)\n* [二叉树 前序、中序、后序、层次遍历及非递归实现 查找、统计个数、比较、求深度的递归实现](https://blog.csdn.net/fansongy/article/details/6798278)","source":"_posts/二叉树的遍历.md","raw":"---\ntitle: 二叉树的遍历\ndate: 2018-03-17\ntags: ['tree', 'js']\ncategories: ['算法']\n---\n## 二叉树的结构\n````javascript\nvar tree = {\n  val:'F',\n  left: {\n    val: 'B',\n    left: {val: 'A'},\n    right: {\n      val: 'D',\n      left: {val: 'C'},\n      right: {val: 'E'}\n    }\n  },\n  right: {\n    val: 'G',\n    right: {\n      val: 'I',\n      left:{val: 'H'}\n    }\n  }\n}\n````\n<!--more-->\n## 深度优先搜索\n\n深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。\n\n常见的做法是采用栈（LIFO）或队列（FIFO）。由于树本身是一种自我引用（即递归定义）的数据结构，因此很自然也可以用递归方式，或者更准确地说，用corecursion，来实现延迟节点的保存。这时（采用递归的情况）这些节点被保存在call stack中。\n### 前序遍历(Pre-Order Traversal)\n\n指先访问根，然后访问左子树，再访问右子树的遍历方式。\n\n![深度优先遍历 - 前序遍历：F, B, A, D, C, E, G, I, H.](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Sorted_binary_tree_preorder.svg/220px-Sorted_binary_tree_preorder.svg.png)\n\n遍历顺序：F, B, A, D, C, E, G, I, H\n* 使用递归\n\n递归调用遍历方法，唯一的区别只是在于访问自身节点的位置不同：前序在所有节点之前，后序在所有节点之后，中序则是在两节点之间。\n````javascript\nfunction pre_order_traversal_recursion(root) {\n  if(root) {\n    console.log(root.val)\n    pre_order_traversal_recursion(root.left)\n    pre_order_traversal_recursion(root.right)\n  }\n}\n````\n* 非递归 使用栈\n\n栈的特点是先进后出，所以进栈是要先进根节点，出栈的时候访问，再进右子节点再进左子节点，再出栈访问，重复以上操作，直到栈空。\n\n在入栈前判定空节点，这样可以减少出入栈的次数，也减少内存使用。\n````javascript\nfunction pre_order_traversal(root) {\n  if(root) {\n    let stack = []\n    stack.push(root)\n\n    while(stack.length > 0) {\n      //console.log(stack.map(item => item.val))\n      root = stack.pop()\n      console.log(root.val)\n\n      if(root.right) {\n        stack.push(root.right)\n      }\n\n      if(root.left) {\n        stack.push(root.left)\n      }\n    }\n  }\n}\n````\n### 中序遍历(In-Order Traversal)\n\n指先访问左（右）子树，然后访问根，最后访问右（左）子树的遍历方式。\n\n![深度优先遍历 - 中序遍历：A, B, C, D, E, F, G, H, I.](https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Sorted_binary_tree_inorder.svg/220px-Sorted_binary_tree_inorder.svg.png)\n\n遍历顺序：A, B, C, D, E, F, G, H, I.\n* 使用递归\n````javascript\nfunction in_order_traversal_recursion (root) {\n  if(root) {\n    in_order_traversal_recursion(root.left)\n    console.log(root.val)\n    in_order_traversal_recursion(root.right)\n  }\n}\n````\n* 非递归 使用栈\n中序遍历的非递归实现需要不停地将左子节点入栈，直到遇到空节点为止。然后就可以出栈输出一个节点进行访问，之后将转向其右子节点。\n````javascript\nfunction in_order_traversal(root) {\n  if(root) {\n    let stack = []\n\n    while(stack.length > 0 || !!root) {\n      //console.log(stack.map(item => item.val))\n      if(root) {\n        stack.push(root)\n        root = root.left\n      }else {\n        root = stack.pop()\n        console.log(root.val)\n        root = root.right\n      }\n    }\n  }\n}\n````\n### 后序遍历(Post-Order Traversal)\n\n指先访问子树，然后访问根的遍历方式\n\n![深度优先搜索 - 后序遍历：A, C, E, D, B, H, I, G, F.](https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Sorted_binary_tree_postorder.svg/220px-Sorted_binary_tree_postorder.svg.png)\n\n遍历顺序：A, C, E, D, B, H, I, G, F.\n* 使用递归\n````javascript\nfunction post_order_traversal_recursion(root) {\n  if(root) {\n    post_order_traversal_recursion(root.left)\n    post_order_traversal_recursion(root.right)\n    console.log(root.val)\n  }\n}\n````\n* 非递归 使用栈\n\n使用一个栈实现\n\n对于任一节点，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的节点，此时该节点出现在栈顶，但是此时不能将其出栈并访问，因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该节点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个节点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该节点是否是第一次出现在栈顶。\n\n````javascript\nfunction post_order_traversal(root) {\n  if(root) {\n    let stack = []\n    stack.push(root)\n    let tmp = null\n\n    while(stack.length > 0) {\n      //console.log(stack.map(item => item.val))\n      tmp = stack[stack.length - 1]\n      \n      if(tmp.left && root !== tmp.left && root !== tmp.right) {\n        stack.push(tmp.left)\n      }else if(tmp.right && root !== tmp.right) {\n        stack.push(tmp.right)\n      }else {\n        console.log(stack.pop().val)\n        root = tmp\n      }\n    }\n  }\n}\n````\n\n使用两个栈实现\n\n后序遍历的结构，相当于前序遍历访问左右子树的顺序互换，再把最后的结构前后反一下就可以了。\n\n此方式是先遍历根节点，再遍历右子树，最后遍历左子树。\n\n再借助第二个栈，将顺序倒转过来访问，就是后序遍历的顺序了。\n\n````javascript\nfunction post_order_traversal_two_stack(root) {\n  if(root) {\n    let stack1 = []\n    let stack2 = []\n    stack1.push(root)\n\n    while(stack1.length > 0) {\n      // console.log('stack1:',stack1.map(item => item.val))\n      // console.log('stack2:',stack2.map(item => item.val))\n      root = stack1.pop()\n      stack2.push(root)\n\n      if(root.left) {\n        stack1.push(root.left)\n      }\n      if(root.right) {\n        stack1.push(root.right)\n      }\n    }\n\n    while(stack2.length !== 0) {\n      console.log(stack2.pop().val);\n    }\n\n\n  }\n}\n````\n\n## 广度优先搜索\n和深度优先遍历不同，广度优先遍历会先访问离根节点最近的节点。二叉树的广度优先遍历又称按层次遍历。算法借助队列实现。\n\n![广度优先遍历 - 层次遍历：F, B, G, A, D, I, C, E, H.](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d1/Sorted_binary_tree_breadth-first_traversal.svg/220px-Sorted_binary_tree_breadth-first_traversal.svg.png)\n\n使用数组模拟队列。首先将根节点归入队列。当队列不为空的时候，执行循环：取出队列的一个节点，如果该节点的左子树为非空，则将该节点的左子树入队列；如果该节点的右子树为非空，则将该节点的右子树入队列。\n\n````javascript\nfunction layer_traversal(note) {\n   if(!node) {\n    throw new Error('Empty Tree')\n  }\n\n  var que = []\n  que.push(node)\n  while(que.length !== 0) {\n    node = que.shift()\n    console.log(node.value)\n    if(node.left) que.push(node.left)\n    if(node.right) que.push(node.right)\n  }\n}\n````\n## 参考资料\n* [树的遍历](https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86)\n* [二叉树 前序、中序、后序、层次遍历及非递归实现 查找、统计个数、比较、求深度的递归实现](https://blog.csdn.net/fansongy/article/details/6798278)","slug":"二叉树的遍历","published":1,"updated":"2022-04-13T14:14:07.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffq002mg3t8h1r60lqg","content":"<h2 id=\"二叉树的结构\"><a href=\"#二叉树的结构\" class=\"headerlink\" title=\"二叉树的结构\"></a>二叉树的结构</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tree = &#123;</span><br><span class=\"line\">  val:<span class=\"string\">'F'</span>,</span><br><span class=\"line\">  left: &#123;</span><br><span class=\"line\">    val: <span class=\"string\">'B'</span>,</span><br><span class=\"line\">    left: &#123;<span class=\"attr\">val</span>: <span class=\"string\">'A'</span>&#125;,</span><br><span class=\"line\">    right: &#123;</span><br><span class=\"line\">      val: <span class=\"string\">'D'</span>,</span><br><span class=\"line\">      left: &#123;<span class=\"attr\">val</span>: <span class=\"string\">'C'</span>&#125;,</span><br><span class=\"line\">      right: &#123;<span class=\"attr\">val</span>: <span class=\"string\">'E'</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  right: &#123;</span><br><span class=\"line\">    val: <span class=\"string\">'G'</span>,</span><br><span class=\"line\">    right: &#123;</span><br><span class=\"line\">      val: <span class=\"string\">'I'</span>,</span><br><span class=\"line\">      left:&#123;<span class=\"attr\">val</span>: <span class=\"string\">'H'</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"深度优先搜索\"><a href=\"#深度优先搜索\" class=\"headerlink\" title=\"深度优先搜索\"></a>深度优先搜索</h2><p>深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。</p>\n<p>常见的做法是采用栈（LIFO）或队列（FIFO）。由于树本身是一种自我引用（即递归定义）的数据结构，因此很自然也可以用递归方式，或者更准确地说，用corecursion，来实现延迟节点的保存。这时（采用递归的情况）这些节点被保存在call stack中。</p>\n<h3 id=\"前序遍历-Pre-Order-Traversal\"><a href=\"#前序遍历-Pre-Order-Traversal\" class=\"headerlink\" title=\"前序遍历(Pre-Order Traversal)\"></a>前序遍历(Pre-Order Traversal)</h3><p>指先访问根，然后访问左子树，再访问右子树的遍历方式。</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Sorted_binary_tree_preorder.svg/220px-Sorted_binary_tree_preorder.svg.png\" alt=\"深度优先遍历 - 前序遍历：F, B, A, D, C, E, G, I, H.\"></p>\n<p>遍历顺序：F, B, A, D, C, E, G, I, H</p>\n<ul>\n<li>使用递归</li>\n</ul>\n<p>递归调用遍历方法，唯一的区别只是在于访问自身节点的位置不同：前序在所有节点之前，后序在所有节点之后，中序则是在两节点之间。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pre_order_traversal_recursion</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(root) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(root.val)</span><br><span class=\"line\">    pre_order_traversal_recursion(root.left)</span><br><span class=\"line\">    pre_order_traversal_recursion(root.right)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>非递归 使用栈</li>\n</ul>\n<p>栈的特点是先进后出，所以进栈是要先进根节点，出栈的时候访问，再进右子节点再进左子节点，再出栈访问，重复以上操作，直到栈空。</p>\n<p>在入栈前判定空节点，这样可以减少出入栈的次数，也减少内存使用。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pre_order_traversal</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(root) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> stack = []</span><br><span class=\"line\">    stack.push(root)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//console.log(stack.map(item =&gt; item.val))</span></span><br><span class=\"line\">      root = stack.pop()</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(root.val)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(root.right) &#123;</span><br><span class=\"line\">        stack.push(root.right)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(root.left) &#123;</span><br><span class=\"line\">        stack.push(root.left)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"中序遍历-In-Order-Traversal\"><a href=\"#中序遍历-In-Order-Traversal\" class=\"headerlink\" title=\"中序遍历(In-Order Traversal)\"></a>中序遍历(In-Order Traversal)</h3><p>指先访问左（右）子树，然后访问根，最后访问右（左）子树的遍历方式。</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Sorted_binary_tree_inorder.svg/220px-Sorted_binary_tree_inorder.svg.png\" alt=\"深度优先遍历 - 中序遍历：A, B, C, D, E, F, G, H, I.\"></p>\n<p>遍历顺序：A, B, C, D, E, F, G, H, I.</p>\n<ul>\n<li><p>使用递归</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">in_order_traversal_recursion</span> (<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(root) &#123;</span><br><span class=\"line\">    in_order_traversal_recursion(root.left)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(root.val)</span><br><span class=\"line\">    in_order_traversal_recursion(root.right)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>非递归 使用栈<br>中序遍历的非递归实现需要不停地将左子节点入栈，直到遇到空节点为止。然后就可以出栈输出一个节点进行访问，之后将转向其右子节点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">in_order_traversal</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(root) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> stack = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span> || !!root) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//console.log(stack.map(item =&gt; item.val))</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(root) &#123;</span><br><span class=\"line\">        stack.push(root)</span><br><span class=\"line\">        root = root.left</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        root = stack.pop()</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(root.val)</span><br><span class=\"line\">        root = root.right</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"后序遍历-Post-Order-Traversal\"><a href=\"#后序遍历-Post-Order-Traversal\" class=\"headerlink\" title=\"后序遍历(Post-Order Traversal)\"></a>后序遍历(Post-Order Traversal)</h3><p>指先访问子树，然后访问根的遍历方式</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Sorted_binary_tree_postorder.svg/220px-Sorted_binary_tree_postorder.svg.png\" alt=\"深度优先搜索 - 后序遍历：A, C, E, D, B, H, I, G, F.\"></p>\n<p>遍历顺序：A, C, E, D, B, H, I, G, F.</p>\n<ul>\n<li><p>使用递归</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">post_order_traversal_recursion</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(root) &#123;</span><br><span class=\"line\">    post_order_traversal_recursion(root.left)</span><br><span class=\"line\">    post_order_traversal_recursion(root.right)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(root.val)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>非递归 使用栈</p>\n</li>\n</ul>\n<p>使用一个栈实现</p>\n<p>对于任一节点，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的节点，此时该节点出现在栈顶，但是此时不能将其出栈并访问，因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该节点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个节点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该节点是否是第一次出现在栈顶。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">post_order_traversal</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(root) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> stack = []</span><br><span class=\"line\">    stack.push(root)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> tmp = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//console.log(stack.map(item =&gt; item.val))</span></span><br><span class=\"line\">      tmp = stack[stack.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">if</span>(tmp.left &amp;&amp; root !== tmp.left &amp;&amp; root !== tmp.right) &#123;</span><br><span class=\"line\">        stack.push(tmp.left)</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(tmp.right &amp;&amp; root !== tmp.right) &#123;</span><br><span class=\"line\">        stack.push(tmp.right)</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(stack.pop().val)</span><br><span class=\"line\">        root = tmp</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用两个栈实现</p>\n<p>后序遍历的结构，相当于前序遍历访问左右子树的顺序互换，再把最后的结构前后反一下就可以了。</p>\n<p>此方式是先遍历根节点，再遍历右子树，最后遍历左子树。</p>\n<p>再借助第二个栈，将顺序倒转过来访问，就是后序遍历的顺序了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">post_order_traversal_two_stack</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(root) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> stack1 = []</span><br><span class=\"line\">    <span class=\"keyword\">let</span> stack2 = []</span><br><span class=\"line\">    stack1.push(root)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(stack1.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// console.log('stack1:',stack1.map(item =&gt; item.val))</span></span><br><span class=\"line\">      <span class=\"comment\">// console.log('stack2:',stack2.map(item =&gt; item.val))</span></span><br><span class=\"line\">      root = stack1.pop()</span><br><span class=\"line\">      stack2.push(root)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(root.left) &#123;</span><br><span class=\"line\">        stack1.push(root.left)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(root.right) &#123;</span><br><span class=\"line\">        stack1.push(root.right)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(stack2.length !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(stack2.pop().val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"广度优先搜索\"><a href=\"#广度优先搜索\" class=\"headerlink\" title=\"广度优先搜索\"></a>广度优先搜索</h2><p>和深度优先遍历不同，广度优先遍历会先访问离根节点最近的节点。二叉树的广度优先遍历又称按层次遍历。算法借助队列实现。</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/d/d1/Sorted_binary_tree_breadth-first_traversal.svg/220px-Sorted_binary_tree_breadth-first_traversal.svg.png\" alt=\"广度优先遍历 - 层次遍历：F, B, G, A, D, I, C, E, H.\"></p>\n<p>使用数组模拟队列。首先将根节点归入队列。当队列不为空的时候，执行循环：取出队列的一个节点，如果该节点的左子树为非空，则将该节点的左子树入队列；如果该节点的右子树为非空，则将该节点的右子树入队列。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">layer_traversal</span>(<span class=\"params\">note</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(!node) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Empty Tree'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> que = []</span><br><span class=\"line\">  que.push(node)</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(que.length !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    node = que.shift()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(node.value)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node.left) que.push(node.left)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node.right) que.push(node.right)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86\" target=\"_blank\" rel=\"noopener\">树的遍历</a></li>\n<li><a href=\"https://blog.csdn.net/fansongy/article/details/6798278\" target=\"_blank\" rel=\"noopener\">二叉树 前序、中序、后序、层次遍历及非递归实现 查找、统计个数、比较、求深度的递归实现</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"二叉树的结构\"><a href=\"#二叉树的结构\" class=\"headerlink\" title=\"二叉树的结构\"></a>二叉树的结构</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tree = &#123;</span><br><span class=\"line\">  val:<span class=\"string\">'F'</span>,</span><br><span class=\"line\">  left: &#123;</span><br><span class=\"line\">    val: <span class=\"string\">'B'</span>,</span><br><span class=\"line\">    left: &#123;<span class=\"attr\">val</span>: <span class=\"string\">'A'</span>&#125;,</span><br><span class=\"line\">    right: &#123;</span><br><span class=\"line\">      val: <span class=\"string\">'D'</span>,</span><br><span class=\"line\">      left: &#123;<span class=\"attr\">val</span>: <span class=\"string\">'C'</span>&#125;,</span><br><span class=\"line\">      right: &#123;<span class=\"attr\">val</span>: <span class=\"string\">'E'</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  right: &#123;</span><br><span class=\"line\">    val: <span class=\"string\">'G'</span>,</span><br><span class=\"line\">    right: &#123;</span><br><span class=\"line\">      val: <span class=\"string\">'I'</span>,</span><br><span class=\"line\">      left:&#123;<span class=\"attr\">val</span>: <span class=\"string\">'H'</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"深度优先搜索\"><a href=\"#深度优先搜索\" class=\"headerlink\" title=\"深度优先搜索\"></a>深度优先搜索</h2><p>深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。</p>\n<p>常见的做法是采用栈（LIFO）或队列（FIFO）。由于树本身是一种自我引用（即递归定义）的数据结构，因此很自然也可以用递归方式，或者更准确地说，用corecursion，来实现延迟节点的保存。这时（采用递归的情况）这些节点被保存在call stack中。</p>\n<h3 id=\"前序遍历-Pre-Order-Traversal\"><a href=\"#前序遍历-Pre-Order-Traversal\" class=\"headerlink\" title=\"前序遍历(Pre-Order Traversal)\"></a>前序遍历(Pre-Order Traversal)</h3><p>指先访问根，然后访问左子树，再访问右子树的遍历方式。</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Sorted_binary_tree_preorder.svg/220px-Sorted_binary_tree_preorder.svg.png\" alt=\"深度优先遍历 - 前序遍历：F, B, A, D, C, E, G, I, H.\"></p>\n<p>遍历顺序：F, B, A, D, C, E, G, I, H</p>\n<ul>\n<li>使用递归</li>\n</ul>\n<p>递归调用遍历方法，唯一的区别只是在于访问自身节点的位置不同：前序在所有节点之前，后序在所有节点之后，中序则是在两节点之间。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pre_order_traversal_recursion</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(root) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(root.val)</span><br><span class=\"line\">    pre_order_traversal_recursion(root.left)</span><br><span class=\"line\">    pre_order_traversal_recursion(root.right)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>非递归 使用栈</li>\n</ul>\n<p>栈的特点是先进后出，所以进栈是要先进根节点，出栈的时候访问，再进右子节点再进左子节点，再出栈访问，重复以上操作，直到栈空。</p>\n<p>在入栈前判定空节点，这样可以减少出入栈的次数，也减少内存使用。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pre_order_traversal</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(root) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> stack = []</span><br><span class=\"line\">    stack.push(root)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//console.log(stack.map(item =&gt; item.val))</span></span><br><span class=\"line\">      root = stack.pop()</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(root.val)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(root.right) &#123;</span><br><span class=\"line\">        stack.push(root.right)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(root.left) &#123;</span><br><span class=\"line\">        stack.push(root.left)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"中序遍历-In-Order-Traversal\"><a href=\"#中序遍历-In-Order-Traversal\" class=\"headerlink\" title=\"中序遍历(In-Order Traversal)\"></a>中序遍历(In-Order Traversal)</h3><p>指先访问左（右）子树，然后访问根，最后访问右（左）子树的遍历方式。</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Sorted_binary_tree_inorder.svg/220px-Sorted_binary_tree_inorder.svg.png\" alt=\"深度优先遍历 - 中序遍历：A, B, C, D, E, F, G, H, I.\"></p>\n<p>遍历顺序：A, B, C, D, E, F, G, H, I.</p>\n<ul>\n<li><p>使用递归</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">in_order_traversal_recursion</span> (<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(root) &#123;</span><br><span class=\"line\">    in_order_traversal_recursion(root.left)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(root.val)</span><br><span class=\"line\">    in_order_traversal_recursion(root.right)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>非递归 使用栈<br>中序遍历的非递归实现需要不停地将左子节点入栈，直到遇到空节点为止。然后就可以出栈输出一个节点进行访问，之后将转向其右子节点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">in_order_traversal</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(root) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> stack = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span> || !!root) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//console.log(stack.map(item =&gt; item.val))</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(root) &#123;</span><br><span class=\"line\">        stack.push(root)</span><br><span class=\"line\">        root = root.left</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        root = stack.pop()</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(root.val)</span><br><span class=\"line\">        root = root.right</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"后序遍历-Post-Order-Traversal\"><a href=\"#后序遍历-Post-Order-Traversal\" class=\"headerlink\" title=\"后序遍历(Post-Order Traversal)\"></a>后序遍历(Post-Order Traversal)</h3><p>指先访问子树，然后访问根的遍历方式</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Sorted_binary_tree_postorder.svg/220px-Sorted_binary_tree_postorder.svg.png\" alt=\"深度优先搜索 - 后序遍历：A, C, E, D, B, H, I, G, F.\"></p>\n<p>遍历顺序：A, C, E, D, B, H, I, G, F.</p>\n<ul>\n<li><p>使用递归</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">post_order_traversal_recursion</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(root) &#123;</span><br><span class=\"line\">    post_order_traversal_recursion(root.left)</span><br><span class=\"line\">    post_order_traversal_recursion(root.right)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(root.val)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>非递归 使用栈</p>\n</li>\n</ul>\n<p>使用一个栈实现</p>\n<p>对于任一节点，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的节点，此时该节点出现在栈顶，但是此时不能将其出栈并访问，因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该节点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个节点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该节点是否是第一次出现在栈顶。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">post_order_traversal</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(root) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> stack = []</span><br><span class=\"line\">    stack.push(root)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> tmp = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(stack.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//console.log(stack.map(item =&gt; item.val))</span></span><br><span class=\"line\">      tmp = stack[stack.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">if</span>(tmp.left &amp;&amp; root !== tmp.left &amp;&amp; root !== tmp.right) &#123;</span><br><span class=\"line\">        stack.push(tmp.left)</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(tmp.right &amp;&amp; root !== tmp.right) &#123;</span><br><span class=\"line\">        stack.push(tmp.right)</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(stack.pop().val)</span><br><span class=\"line\">        root = tmp</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用两个栈实现</p>\n<p>后序遍历的结构，相当于前序遍历访问左右子树的顺序互换，再把最后的结构前后反一下就可以了。</p>\n<p>此方式是先遍历根节点，再遍历右子树，最后遍历左子树。</p>\n<p>再借助第二个栈，将顺序倒转过来访问，就是后序遍历的顺序了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">post_order_traversal_two_stack</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(root) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> stack1 = []</span><br><span class=\"line\">    <span class=\"keyword\">let</span> stack2 = []</span><br><span class=\"line\">    stack1.push(root)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(stack1.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// console.log('stack1:',stack1.map(item =&gt; item.val))</span></span><br><span class=\"line\">      <span class=\"comment\">// console.log('stack2:',stack2.map(item =&gt; item.val))</span></span><br><span class=\"line\">      root = stack1.pop()</span><br><span class=\"line\">      stack2.push(root)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(root.left) &#123;</span><br><span class=\"line\">        stack1.push(root.left)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(root.right) &#123;</span><br><span class=\"line\">        stack1.push(root.right)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(stack2.length !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(stack2.pop().val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"广度优先搜索\"><a href=\"#广度优先搜索\" class=\"headerlink\" title=\"广度优先搜索\"></a>广度优先搜索</h2><p>和深度优先遍历不同，广度优先遍历会先访问离根节点最近的节点。二叉树的广度优先遍历又称按层次遍历。算法借助队列实现。</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/d/d1/Sorted_binary_tree_breadth-first_traversal.svg/220px-Sorted_binary_tree_breadth-first_traversal.svg.png\" alt=\"广度优先遍历 - 层次遍历：F, B, G, A, D, I, C, E, H.\"></p>\n<p>使用数组模拟队列。首先将根节点归入队列。当队列不为空的时候，执行循环：取出队列的一个节点，如果该节点的左子树为非空，则将该节点的左子树入队列；如果该节点的右子树为非空，则将该节点的右子树入队列。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">layer_traversal</span>(<span class=\"params\">note</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(!node) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Empty Tree'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> que = []</span><br><span class=\"line\">  que.push(node)</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(que.length !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    node = que.shift()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(node.value)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node.left) que.push(node.left)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node.right) que.push(node.right)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86\" target=\"_blank\" rel=\"noopener\">树的遍历</a></li>\n<li><a href=\"https://blog.csdn.net/fansongy/article/details/6798278\" target=\"_blank\" rel=\"noopener\">二叉树 前序、中序、后序、层次遍历及非递归实现 查找、统计个数、比较、求深度的递归实现</a></li>\n</ul>"},{"title":"使用karma+mocha+chai为vue组件进行单元测试","date":"2017-06-23T16:00:00.000Z","_content":"最近学习前端的单元测试，并对vue组件进行了单元测试。\n## 主要工具\n### karma\nKarma是一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。\n\n负责提供测试的浏览器环境，执行测试框架，已经生成覆盖率报告。\n<!--more-->\n关于karma的配置\n````javascript\nvar webpackConfig = require('../../build/webpack.test.conf')\n\nmodule.exports = function (config) {\n  config.set({\n    // to run in additional browsers:\n    // 1. install corresponding karma launcher\n    //    http://karma-runner.github.io/0.13/config/browsers.html\n    // 2. add it to the `browsers` array below.\n    browsers: ['PhantomJS'],// 测试采用的浏览器环境\n    frameworks: ['mocha', 'sinon-chai', 'phantomjs-shim'],// 使用的测试框架\n    reporters: ['spec', 'coverage'],// 设定报告输出插件\n    files: ['./index.js'],// 执行文件入口，（如果是使用vue-cli生成的index.js，会去读specs文件夹下的测试代码）\n    preprocessors: {\n      './index.js': ['webpack', 'sourcemap']\n    },// 预处理器，测试之前对文件进行处理less编译，coffeeScript编译之类的，这里是加入webpack与sourcemap插件\n    webpack: webpackConfig, // webpack配置\n    webpackMiddleware: {\n      noInfo: true\n    }, // webpack中间件配置，可配置不输出信息，或者只输出错误信息等\n    coverageReporter: {\n      dir: './coverage',\n      reporters: [\n        { type: 'lcov', subdir: '.' },\n        { type: 'text-summary' }\n      ]\n    }// 生成覆盖率报告的配置\n  })\n}\n````\n### mocha\nmocha是一个Javascript测试框架，用来运行测试。\nmocha使用多个describe块来展示不同的组件，然后在其中添加it块来制定一个单一的测试。\n### chai\nchai支持BDD风格和TDD风格的断言库，可以和任何的javascript测试框架配合使用。\n\n'断言'就是判断源码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误。\n\n下面的例子采用expect的断言风格。\n\nTDD指的是Test Driven Development，测试驱动开发，先编写单元测试代码，再编写代码实现功能，运行单元测试代码，循环此过程，直到整个单元测试都通过。\n\nBDD指的是Behavior Driven Development，行为驱动开发，是一种敏捷软件开发的技术，它鼓励软件项目中的开发者、QA和非技术人员或商业参与者之间的协作，是从用户的需求出发，强调系统行为。\n## 对vue分页组件进行单元测试\n项目采用vue-cli生成的，初始化的时候把测试相关的选项都选是。\n\nvue-cli生成的目录结构里，和测试相关的是test文件夹。\n````javascript\n├─test\n   ├─e2e // 端到端测试\n   │\n   │\n   └─unit // 单元测试\n      ├─specs\n      │    └─Pagination.spec.js // 组件对应的测试代码\n      │──.eslintrc // eslint配置\n      │──idnex.js // karma执行的入口文件\n      │──utils.js // 工具方法\n      └──karma.conf.js // karma配置\n````\n\n### 创建vue的组件实例\n根据[vue官方文档对单元测试的介绍](https://cn.vuejs.org/v2/guide/unit-testing.html)，可以使用Vue.extend()创建一个实例并检查渲染输出,同时使用$mount()进行挂载。\n\n将该方法进行封装：\n````javascript\nimport Vue from 'vue'\n\nexport const createCompInstance = (Component, propsData) => {\n  const Constructor = Vue.extend(Component)\n  return new Constructor({\n    propsData\n  }).$mount()\n}\n\n````\n### 针对分页组件编写的单元测试\n测试组件被创建成功。\n\n通过exist断言判断组件实例是否创建，挂载。\n````javascript\nlet vm\nit('create', () => {\n  vm = createCompInstance(Pagination, {\n    totalNum: 100\n  })\n  const elm = vm.$el\n  // prev\n  expect(elm.querySelector('.prev')).to.exist\n  // pager\n  expect(elm.querySelector('.pager')).to.exist\n  // next\n  expect(elm.querySelector('.next')).to.exist\n  // jumper\n  expect(elm.querySelector('input')).to.exist\n  expect(elm.querySelector('.btn')).to.exist\n})\n````\n测试页码的点击。\n\n获取组件挂载的DOM进行点击，再进行equal断言，判断当页码是否已经改变。\n````javascript\nit('event: click page', () => {\n  vm = createCompInstance(Pagination, {\n    pageSizes: [5, 10, 20],\n    buttonCount: 10,\n    totalNum: 100\n  })\n  const elm = vm.$el\n\n  // click 3\n  elm.querySelectorAll('.pager')[2].click()\n\n  setTimeout(() => {\n    expect(elm.querySelectorAll('.pager')[2].className).to.equal('current')\n    expect(vm.currentPage).to.equal(3)\n    done()\n  }, 100)\n})\n````\n实现按钮点击：通过获取相关元素el，执行 el.click() 方法实现。\n\n> 由于 Vue 进行 异步更新DOM 的情况，一些依赖DOM更新结果的断言必须在 Vue.nextTick 回调中进行。\n\n涉及到 Vue.nextTick 和 setTimeout 等异步操作的测试，要使用 done() 来标记完成时间点。\n\n在describe的回调函数传入done，之后才能进行调用。\n\n一开始的测试覆盖率很低，经过不断的调整和补充测试用例，最后的测试结果如下：\n![test result](http://oq8q06ybp.bkt.clouddn.com/image/unittest.PNG)\n以及测试覆盖率报告\n![test coverage](http://oq8q06ybp.bkt.clouddn.com/image/testCoverage.PNG)\n结果测试的覆盖率还是没有达到百分之百，好像还有一些分支条件没有覆盖到，得继续完善。\n## 参考资料\n1. [karma](http://karma-runner.github.io)\n2. [mocha](https://mochajs.org/)\n3. [chai](http://chaijs.com/)\n4. [vue单元测试](https://cn.vuejs.org/v2/guide/unit-testing.html)","source":"_posts/使用karma+mocha+chai为vue组件进行单元测试.md","raw":"---\ntitle: 使用karma+mocha+chai为vue组件进行单元测试\ndate: 2017-06-24\ntags: ['vue','karma','mocha','chai']\ncategories: ['测试']\n---\n最近学习前端的单元测试，并对vue组件进行了单元测试。\n## 主要工具\n### karma\nKarma是一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。\n\n负责提供测试的浏览器环境，执行测试框架，已经生成覆盖率报告。\n<!--more-->\n关于karma的配置\n````javascript\nvar webpackConfig = require('../../build/webpack.test.conf')\n\nmodule.exports = function (config) {\n  config.set({\n    // to run in additional browsers:\n    // 1. install corresponding karma launcher\n    //    http://karma-runner.github.io/0.13/config/browsers.html\n    // 2. add it to the `browsers` array below.\n    browsers: ['PhantomJS'],// 测试采用的浏览器环境\n    frameworks: ['mocha', 'sinon-chai', 'phantomjs-shim'],// 使用的测试框架\n    reporters: ['spec', 'coverage'],// 设定报告输出插件\n    files: ['./index.js'],// 执行文件入口，（如果是使用vue-cli生成的index.js，会去读specs文件夹下的测试代码）\n    preprocessors: {\n      './index.js': ['webpack', 'sourcemap']\n    },// 预处理器，测试之前对文件进行处理less编译，coffeeScript编译之类的，这里是加入webpack与sourcemap插件\n    webpack: webpackConfig, // webpack配置\n    webpackMiddleware: {\n      noInfo: true\n    }, // webpack中间件配置，可配置不输出信息，或者只输出错误信息等\n    coverageReporter: {\n      dir: './coverage',\n      reporters: [\n        { type: 'lcov', subdir: '.' },\n        { type: 'text-summary' }\n      ]\n    }// 生成覆盖率报告的配置\n  })\n}\n````\n### mocha\nmocha是一个Javascript测试框架，用来运行测试。\nmocha使用多个describe块来展示不同的组件，然后在其中添加it块来制定一个单一的测试。\n### chai\nchai支持BDD风格和TDD风格的断言库，可以和任何的javascript测试框架配合使用。\n\n'断言'就是判断源码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误。\n\n下面的例子采用expect的断言风格。\n\nTDD指的是Test Driven Development，测试驱动开发，先编写单元测试代码，再编写代码实现功能，运行单元测试代码，循环此过程，直到整个单元测试都通过。\n\nBDD指的是Behavior Driven Development，行为驱动开发，是一种敏捷软件开发的技术，它鼓励软件项目中的开发者、QA和非技术人员或商业参与者之间的协作，是从用户的需求出发，强调系统行为。\n## 对vue分页组件进行单元测试\n项目采用vue-cli生成的，初始化的时候把测试相关的选项都选是。\n\nvue-cli生成的目录结构里，和测试相关的是test文件夹。\n````javascript\n├─test\n   ├─e2e // 端到端测试\n   │\n   │\n   └─unit // 单元测试\n      ├─specs\n      │    └─Pagination.spec.js // 组件对应的测试代码\n      │──.eslintrc // eslint配置\n      │──idnex.js // karma执行的入口文件\n      │──utils.js // 工具方法\n      └──karma.conf.js // karma配置\n````\n\n### 创建vue的组件实例\n根据[vue官方文档对单元测试的介绍](https://cn.vuejs.org/v2/guide/unit-testing.html)，可以使用Vue.extend()创建一个实例并检查渲染输出,同时使用$mount()进行挂载。\n\n将该方法进行封装：\n````javascript\nimport Vue from 'vue'\n\nexport const createCompInstance = (Component, propsData) => {\n  const Constructor = Vue.extend(Component)\n  return new Constructor({\n    propsData\n  }).$mount()\n}\n\n````\n### 针对分页组件编写的单元测试\n测试组件被创建成功。\n\n通过exist断言判断组件实例是否创建，挂载。\n````javascript\nlet vm\nit('create', () => {\n  vm = createCompInstance(Pagination, {\n    totalNum: 100\n  })\n  const elm = vm.$el\n  // prev\n  expect(elm.querySelector('.prev')).to.exist\n  // pager\n  expect(elm.querySelector('.pager')).to.exist\n  // next\n  expect(elm.querySelector('.next')).to.exist\n  // jumper\n  expect(elm.querySelector('input')).to.exist\n  expect(elm.querySelector('.btn')).to.exist\n})\n````\n测试页码的点击。\n\n获取组件挂载的DOM进行点击，再进行equal断言，判断当页码是否已经改变。\n````javascript\nit('event: click page', () => {\n  vm = createCompInstance(Pagination, {\n    pageSizes: [5, 10, 20],\n    buttonCount: 10,\n    totalNum: 100\n  })\n  const elm = vm.$el\n\n  // click 3\n  elm.querySelectorAll('.pager')[2].click()\n\n  setTimeout(() => {\n    expect(elm.querySelectorAll('.pager')[2].className).to.equal('current')\n    expect(vm.currentPage).to.equal(3)\n    done()\n  }, 100)\n})\n````\n实现按钮点击：通过获取相关元素el，执行 el.click() 方法实现。\n\n> 由于 Vue 进行 异步更新DOM 的情况，一些依赖DOM更新结果的断言必须在 Vue.nextTick 回调中进行。\n\n涉及到 Vue.nextTick 和 setTimeout 等异步操作的测试，要使用 done() 来标记完成时间点。\n\n在describe的回调函数传入done，之后才能进行调用。\n\n一开始的测试覆盖率很低，经过不断的调整和补充测试用例，最后的测试结果如下：\n![test result](http://oq8q06ybp.bkt.clouddn.com/image/unittest.PNG)\n以及测试覆盖率报告\n![test coverage](http://oq8q06ybp.bkt.clouddn.com/image/testCoverage.PNG)\n结果测试的覆盖率还是没有达到百分之百，好像还有一些分支条件没有覆盖到，得继续完善。\n## 参考资料\n1. [karma](http://karma-runner.github.io)\n2. [mocha](https://mochajs.org/)\n3. [chai](http://chaijs.com/)\n4. [vue单元测试](https://cn.vuejs.org/v2/guide/unit-testing.html)","slug":"使用karma+mocha+chai为vue组件进行单元测试","published":1,"updated":"2022-04-13T14:14:07.957Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffr002qg3t8xyp7ve83","content":"<p>最近学习前端的单元测试，并对vue组件进行了单元测试。</p>\n<h2 id=\"主要工具\"><a href=\"#主要工具\" class=\"headerlink\" title=\"主要工具\"></a>主要工具</h2><h3 id=\"karma\"><a href=\"#karma\" class=\"headerlink\" title=\"karma\"></a>karma</h3><p>Karma是一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。</p>\n<p>负责提供测试的浏览器环境，执行测试框架，已经生成覆盖率报告。<br><a id=\"more\"></a><br>关于karma的配置<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> webpackConfig = <span class=\"built_in\">require</span>(<span class=\"string\">'../../build/webpack.test.conf'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">  config.set(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// to run in additional browsers:</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. install corresponding karma launcher</span></span><br><span class=\"line\">    <span class=\"comment\">//    http://karma-runner.github.io/0.13/config/browsers.html</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. add it to the `browsers` array below.</span></span><br><span class=\"line\">    browsers: [<span class=\"string\">'PhantomJS'</span>],<span class=\"comment\">// 测试采用的浏览器环境</span></span><br><span class=\"line\">    frameworks: [<span class=\"string\">'mocha'</span>, <span class=\"string\">'sinon-chai'</span>, <span class=\"string\">'phantomjs-shim'</span>],<span class=\"comment\">// 使用的测试框架</span></span><br><span class=\"line\">    reporters: [<span class=\"string\">'spec'</span>, <span class=\"string\">'coverage'</span>],<span class=\"comment\">// 设定报告输出插件</span></span><br><span class=\"line\">    files: [<span class=\"string\">'./index.js'</span>],<span class=\"comment\">// 执行文件入口，（如果是使用vue-cli生成的index.js，会去读specs文件夹下的测试代码）</span></span><br><span class=\"line\">    preprocessors: &#123;</span><br><span class=\"line\">      <span class=\"string\">'./index.js'</span>: [<span class=\"string\">'webpack'</span>, <span class=\"string\">'sourcemap'</span>]</span><br><span class=\"line\">    &#125;,<span class=\"comment\">// 预处理器，测试之前对文件进行处理less编译，coffeeScript编译之类的，这里是加入webpack与sourcemap插件</span></span><br><span class=\"line\">    webpack: webpackConfig, <span class=\"comment\">// webpack配置</span></span><br><span class=\"line\">    webpackMiddleware: &#123;</span><br><span class=\"line\">      noInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;, <span class=\"comment\">// webpack中间件配置，可配置不输出信息，或者只输出错误信息等</span></span><br><span class=\"line\">    coverageReporter: &#123;</span><br><span class=\"line\">      dir: <span class=\"string\">'./coverage'</span>,</span><br><span class=\"line\">      reporters: [</span><br><span class=\"line\">        &#123; <span class=\"attr\">type</span>: <span class=\"string\">'lcov'</span>, <span class=\"attr\">subdir</span>: <span class=\"string\">'.'</span> &#125;,</span><br><span class=\"line\">        &#123; <span class=\"attr\">type</span>: <span class=\"string\">'text-summary'</span> &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;<span class=\"comment\">// 生成覆盖率报告的配置</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"mocha\"><a href=\"#mocha\" class=\"headerlink\" title=\"mocha\"></a>mocha</h3><p>mocha是一个Javascript测试框架，用来运行测试。<br>mocha使用多个describe块来展示不同的组件，然后在其中添加it块来制定一个单一的测试。</p>\n<h3 id=\"chai\"><a href=\"#chai\" class=\"headerlink\" title=\"chai\"></a>chai</h3><p>chai支持BDD风格和TDD风格的断言库，可以和任何的javascript测试框架配合使用。</p>\n<p>‘断言’就是判断源码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误。</p>\n<p>下面的例子采用expect的断言风格。</p>\n<p>TDD指的是Test Driven Development，测试驱动开发，先编写单元测试代码，再编写代码实现功能，运行单元测试代码，循环此过程，直到整个单元测试都通过。</p>\n<p>BDD指的是Behavior Driven Development，行为驱动开发，是一种敏捷软件开发的技术，它鼓励软件项目中的开发者、QA和非技术人员或商业参与者之间的协作，是从用户的需求出发，强调系统行为。</p>\n<h2 id=\"对vue分页组件进行单元测试\"><a href=\"#对vue分页组件进行单元测试\" class=\"headerlink\" title=\"对vue分页组件进行单元测试\"></a>对vue分页组件进行单元测试</h2><p>项目采用vue-cli生成的，初始化的时候把测试相关的选项都选是。</p>\n<p>vue-cli生成的目录结构里，和测试相关的是test文件夹。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├─test</span><br><span class=\"line\">   ├─e2e <span class=\"comment\">// 端到端测试</span></span><br><span class=\"line\">   │</span><br><span class=\"line\">   │</span><br><span class=\"line\">   └─unit <span class=\"comment\">// 单元测试</span></span><br><span class=\"line\">      ├─specs</span><br><span class=\"line\">      │    └─Pagination.spec.js <span class=\"comment\">// 组件对应的测试代码</span></span><br><span class=\"line\">      │──.eslintrc <span class=\"comment\">// eslint配置</span></span><br><span class=\"line\">      │──idnex.js <span class=\"comment\">// karma执行的入口文件</span></span><br><span class=\"line\">      │──utils.js <span class=\"comment\">// 工具方法</span></span><br><span class=\"line\">      └──karma.conf.js <span class=\"comment\">// karma配置</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"创建vue的组件实例\"><a href=\"#创建vue的组件实例\" class=\"headerlink\" title=\"创建vue的组件实例\"></a>创建vue的组件实例</h3><p>根据<a href=\"https://cn.vuejs.org/v2/guide/unit-testing.html\" target=\"_blank\" rel=\"noopener\">vue官方文档对单元测试的介绍</a>，可以使用Vue.extend()创建一个实例并检查渲染输出,同时使用$mount()进行挂载。</p>\n<p>将该方法进行封装：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> createCompInstance = <span class=\"function\">(<span class=\"params\">Component, propsData</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> Constructor = Vue.extend(Component)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Constructor(&#123;</span><br><span class=\"line\">    propsData</span><br><span class=\"line\">  &#125;).$mount()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"针对分页组件编写的单元测试\"><a href=\"#针对分页组件编写的单元测试\" class=\"headerlink\" title=\"针对分页组件编写的单元测试\"></a>针对分页组件编写的单元测试</h3><p>测试组件被创建成功。</p>\n<p>通过exist断言判断组件实例是否创建，挂载。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> vm</span><br><span class=\"line\">it(<span class=\"string\">'create'</span>, () =&gt; &#123;</span><br><span class=\"line\">  vm = createCompInstance(Pagination, &#123;</span><br><span class=\"line\">    totalNum: <span class=\"number\">100</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> elm = vm.$el</span><br><span class=\"line\">  <span class=\"comment\">// prev</span></span><br><span class=\"line\">  expect(elm.querySelector(<span class=\"string\">'.prev'</span>)).to.exist</span><br><span class=\"line\">  <span class=\"comment\">// pager</span></span><br><span class=\"line\">  expect(elm.querySelector(<span class=\"string\">'.pager'</span>)).to.exist</span><br><span class=\"line\">  <span class=\"comment\">// next</span></span><br><span class=\"line\">  expect(elm.querySelector(<span class=\"string\">'.next'</span>)).to.exist</span><br><span class=\"line\">  <span class=\"comment\">// jumper</span></span><br><span class=\"line\">  expect(elm.querySelector(<span class=\"string\">'input'</span>)).to.exist</span><br><span class=\"line\">  expect(elm.querySelector(<span class=\"string\">'.btn'</span>)).to.exist</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>测试页码的点击。</p>\n<p>获取组件挂载的DOM进行点击，再进行equal断言，判断当页码是否已经改变。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'event: click page'</span>, () =&gt; &#123;</span><br><span class=\"line\">  vm = createCompInstance(Pagination, &#123;</span><br><span class=\"line\">    pageSizes: [<span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">20</span>],</span><br><span class=\"line\">    buttonCount: <span class=\"number\">10</span>,</span><br><span class=\"line\">    totalNum: <span class=\"number\">100</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> elm = vm.$el</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// click 3</span></span><br><span class=\"line\">  elm.querySelectorAll(<span class=\"string\">'.pager'</span>)[<span class=\"number\">2</span>].click()</span><br><span class=\"line\"></span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    expect(elm.querySelectorAll(<span class=\"string\">'.pager'</span>)[<span class=\"number\">2</span>].className).to.equal(<span class=\"string\">'current'</span>)</span><br><span class=\"line\">    expect(vm.currentPage).to.equal(<span class=\"number\">3</span>)</span><br><span class=\"line\">    done()</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>实现按钮点击：通过获取相关元素el，执行 el.click() 方法实现。</p>\n<blockquote>\n<p>由于 Vue 进行 异步更新DOM 的情况，一些依赖DOM更新结果的断言必须在 Vue.nextTick 回调中进行。</p>\n</blockquote>\n<p>涉及到 Vue.nextTick 和 setTimeout 等异步操作的测试，要使用 done() 来标记完成时间点。</p>\n<p>在describe的回调函数传入done，之后才能进行调用。</p>\n<p>一开始的测试覆盖率很低，经过不断的调整和补充测试用例，最后的测试结果如下：<br><img src=\"http://oq8q06ybp.bkt.clouddn.com/image/unittest.PNG\" alt=\"test result\"><br>以及测试覆盖率报告<br><img src=\"http://oq8q06ybp.bkt.clouddn.com/image/testCoverage.PNG\" alt=\"test coverage\"><br>结果测试的覆盖率还是没有达到百分之百，好像还有一些分支条件没有覆盖到，得继续完善。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"http://karma-runner.github.io\" target=\"_blank\" rel=\"noopener\">karma</a></li>\n<li><a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"noopener\">mocha</a></li>\n<li><a href=\"http://chaijs.com/\" target=\"_blank\" rel=\"noopener\">chai</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/guide/unit-testing.html\" target=\"_blank\" rel=\"noopener\">vue单元测试</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>最近学习前端的单元测试，并对vue组件进行了单元测试。</p>\n<h2 id=\"主要工具\"><a href=\"#主要工具\" class=\"headerlink\" title=\"主要工具\"></a>主要工具</h2><h3 id=\"karma\"><a href=\"#karma\" class=\"headerlink\" title=\"karma\"></a>karma</h3><p>Karma是一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。</p>\n<p>负责提供测试的浏览器环境，执行测试框架，已经生成覆盖率报告。<br>","more":"<br>关于karma的配置<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> webpackConfig = <span class=\"built_in\">require</span>(<span class=\"string\">'../../build/webpack.test.conf'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">  config.set(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// to run in additional browsers:</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. install corresponding karma launcher</span></span><br><span class=\"line\">    <span class=\"comment\">//    http://karma-runner.github.io/0.13/config/browsers.html</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. add it to the `browsers` array below.</span></span><br><span class=\"line\">    browsers: [<span class=\"string\">'PhantomJS'</span>],<span class=\"comment\">// 测试采用的浏览器环境</span></span><br><span class=\"line\">    frameworks: [<span class=\"string\">'mocha'</span>, <span class=\"string\">'sinon-chai'</span>, <span class=\"string\">'phantomjs-shim'</span>],<span class=\"comment\">// 使用的测试框架</span></span><br><span class=\"line\">    reporters: [<span class=\"string\">'spec'</span>, <span class=\"string\">'coverage'</span>],<span class=\"comment\">// 设定报告输出插件</span></span><br><span class=\"line\">    files: [<span class=\"string\">'./index.js'</span>],<span class=\"comment\">// 执行文件入口，（如果是使用vue-cli生成的index.js，会去读specs文件夹下的测试代码）</span></span><br><span class=\"line\">    preprocessors: &#123;</span><br><span class=\"line\">      <span class=\"string\">'./index.js'</span>: [<span class=\"string\">'webpack'</span>, <span class=\"string\">'sourcemap'</span>]</span><br><span class=\"line\">    &#125;,<span class=\"comment\">// 预处理器，测试之前对文件进行处理less编译，coffeeScript编译之类的，这里是加入webpack与sourcemap插件</span></span><br><span class=\"line\">    webpack: webpackConfig, <span class=\"comment\">// webpack配置</span></span><br><span class=\"line\">    webpackMiddleware: &#123;</span><br><span class=\"line\">      noInfo: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;, <span class=\"comment\">// webpack中间件配置，可配置不输出信息，或者只输出错误信息等</span></span><br><span class=\"line\">    coverageReporter: &#123;</span><br><span class=\"line\">      dir: <span class=\"string\">'./coverage'</span>,</span><br><span class=\"line\">      reporters: [</span><br><span class=\"line\">        &#123; <span class=\"attr\">type</span>: <span class=\"string\">'lcov'</span>, <span class=\"attr\">subdir</span>: <span class=\"string\">'.'</span> &#125;,</span><br><span class=\"line\">        &#123; <span class=\"attr\">type</span>: <span class=\"string\">'text-summary'</span> &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;<span class=\"comment\">// 生成覆盖率报告的配置</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"mocha\"><a href=\"#mocha\" class=\"headerlink\" title=\"mocha\"></a>mocha</h3><p>mocha是一个Javascript测试框架，用来运行测试。<br>mocha使用多个describe块来展示不同的组件，然后在其中添加it块来制定一个单一的测试。</p>\n<h3 id=\"chai\"><a href=\"#chai\" class=\"headerlink\" title=\"chai\"></a>chai</h3><p>chai支持BDD风格和TDD风格的断言库，可以和任何的javascript测试框架配合使用。</p>\n<p>‘断言’就是判断源码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误。</p>\n<p>下面的例子采用expect的断言风格。</p>\n<p>TDD指的是Test Driven Development，测试驱动开发，先编写单元测试代码，再编写代码实现功能，运行单元测试代码，循环此过程，直到整个单元测试都通过。</p>\n<p>BDD指的是Behavior Driven Development，行为驱动开发，是一种敏捷软件开发的技术，它鼓励软件项目中的开发者、QA和非技术人员或商业参与者之间的协作，是从用户的需求出发，强调系统行为。</p>\n<h2 id=\"对vue分页组件进行单元测试\"><a href=\"#对vue分页组件进行单元测试\" class=\"headerlink\" title=\"对vue分页组件进行单元测试\"></a>对vue分页组件进行单元测试</h2><p>项目采用vue-cli生成的，初始化的时候把测试相关的选项都选是。</p>\n<p>vue-cli生成的目录结构里，和测试相关的是test文件夹。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├─test</span><br><span class=\"line\">   ├─e2e <span class=\"comment\">// 端到端测试</span></span><br><span class=\"line\">   │</span><br><span class=\"line\">   │</span><br><span class=\"line\">   └─unit <span class=\"comment\">// 单元测试</span></span><br><span class=\"line\">      ├─specs</span><br><span class=\"line\">      │    └─Pagination.spec.js <span class=\"comment\">// 组件对应的测试代码</span></span><br><span class=\"line\">      │──.eslintrc <span class=\"comment\">// eslint配置</span></span><br><span class=\"line\">      │──idnex.js <span class=\"comment\">// karma执行的入口文件</span></span><br><span class=\"line\">      │──utils.js <span class=\"comment\">// 工具方法</span></span><br><span class=\"line\">      └──karma.conf.js <span class=\"comment\">// karma配置</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"创建vue的组件实例\"><a href=\"#创建vue的组件实例\" class=\"headerlink\" title=\"创建vue的组件实例\"></a>创建vue的组件实例</h3><p>根据<a href=\"https://cn.vuejs.org/v2/guide/unit-testing.html\" target=\"_blank\" rel=\"noopener\">vue官方文档对单元测试的介绍</a>，可以使用Vue.extend()创建一个实例并检查渲染输出,同时使用$mount()进行挂载。</p>\n<p>将该方法进行封装：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> createCompInstance = <span class=\"function\">(<span class=\"params\">Component, propsData</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> Constructor = Vue.extend(Component)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Constructor(&#123;</span><br><span class=\"line\">    propsData</span><br><span class=\"line\">  &#125;).$mount()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"针对分页组件编写的单元测试\"><a href=\"#针对分页组件编写的单元测试\" class=\"headerlink\" title=\"针对分页组件编写的单元测试\"></a>针对分页组件编写的单元测试</h3><p>测试组件被创建成功。</p>\n<p>通过exist断言判断组件实例是否创建，挂载。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> vm</span><br><span class=\"line\">it(<span class=\"string\">'create'</span>, () =&gt; &#123;</span><br><span class=\"line\">  vm = createCompInstance(Pagination, &#123;</span><br><span class=\"line\">    totalNum: <span class=\"number\">100</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> elm = vm.$el</span><br><span class=\"line\">  <span class=\"comment\">// prev</span></span><br><span class=\"line\">  expect(elm.querySelector(<span class=\"string\">'.prev'</span>)).to.exist</span><br><span class=\"line\">  <span class=\"comment\">// pager</span></span><br><span class=\"line\">  expect(elm.querySelector(<span class=\"string\">'.pager'</span>)).to.exist</span><br><span class=\"line\">  <span class=\"comment\">// next</span></span><br><span class=\"line\">  expect(elm.querySelector(<span class=\"string\">'.next'</span>)).to.exist</span><br><span class=\"line\">  <span class=\"comment\">// jumper</span></span><br><span class=\"line\">  expect(elm.querySelector(<span class=\"string\">'input'</span>)).to.exist</span><br><span class=\"line\">  expect(elm.querySelector(<span class=\"string\">'.btn'</span>)).to.exist</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>测试页码的点击。</p>\n<p>获取组件挂载的DOM进行点击，再进行equal断言，判断当页码是否已经改变。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'event: click page'</span>, () =&gt; &#123;</span><br><span class=\"line\">  vm = createCompInstance(Pagination, &#123;</span><br><span class=\"line\">    pageSizes: [<span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">20</span>],</span><br><span class=\"line\">    buttonCount: <span class=\"number\">10</span>,</span><br><span class=\"line\">    totalNum: <span class=\"number\">100</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> elm = vm.$el</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// click 3</span></span><br><span class=\"line\">  elm.querySelectorAll(<span class=\"string\">'.pager'</span>)[<span class=\"number\">2</span>].click()</span><br><span class=\"line\"></span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    expect(elm.querySelectorAll(<span class=\"string\">'.pager'</span>)[<span class=\"number\">2</span>].className).to.equal(<span class=\"string\">'current'</span>)</span><br><span class=\"line\">    expect(vm.currentPage).to.equal(<span class=\"number\">3</span>)</span><br><span class=\"line\">    done()</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>实现按钮点击：通过获取相关元素el，执行 el.click() 方法实现。</p>\n<blockquote>\n<p>由于 Vue 进行 异步更新DOM 的情况，一些依赖DOM更新结果的断言必须在 Vue.nextTick 回调中进行。</p>\n</blockquote>\n<p>涉及到 Vue.nextTick 和 setTimeout 等异步操作的测试，要使用 done() 来标记完成时间点。</p>\n<p>在describe的回调函数传入done，之后才能进行调用。</p>\n<p>一开始的测试覆盖率很低，经过不断的调整和补充测试用例，最后的测试结果如下：<br><img src=\"http://oq8q06ybp.bkt.clouddn.com/image/unittest.PNG\" alt=\"test result\"><br>以及测试覆盖率报告<br><img src=\"http://oq8q06ybp.bkt.clouddn.com/image/testCoverage.PNG\" alt=\"test coverage\"><br>结果测试的覆盖率还是没有达到百分之百，好像还有一些分支条件没有覆盖到，得继续完善。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"http://karma-runner.github.io\" target=\"_blank\" rel=\"noopener\">karma</a></li>\n<li><a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"noopener\">mocha</a></li>\n<li><a href=\"http://chaijs.com/\" target=\"_blank\" rel=\"noopener\">chai</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/guide/unit-testing.html\" target=\"_blank\" rel=\"noopener\">vue单元测试</a></li>\n</ol>"},{"title":"使用gulp为静态资源添加版本号","date":"2017-05-19T16:00:00.000Z","_content":"##　背景\n日常使用gulp，使用的比较多的功能是为静态资源文件添加版本号，实现在强缓存下的静态资源缓存命中，增量更新。\n<!--more-->\n在这里记录一下实现过程。\n## gulp插件\n1. gulp-rev \n\n将静态资源的命名后面添加上文件指纹hash的值，插件是根据文件内容生成hash，所以可以实现增量更新。\n2. gulp-rev-collector \n\n比较命名变化前后的资源文件名，生成rev-manifest.json文件名对照映射。\n3. gulp-clean \n\n每次执行前，用来清除旧的文件。\n4. run-sequence\n控制gulp任务的执行顺序。\n## 过程\n### 定义路径\n````javascript\nvar path = 'src'// 源文件夹\nvar dist = 'dist'// 目标文件夹\n// 定义css、js源文件路径\nvar cssSrc = path + '/css/*.css',\n    jsSrc = path + '/js/*.js',\n    imgSrc = path + '/img/*.*'\n````\n### 添加hash值，生成文件名对照映射\n````javascript\n// 处理图片\ngulp.task('revImg', function(){\n    return gulp.src(imgSrc)// 源文件\n        .pipe(rev())// 为文件名添加hash值\n        .pipe(gulp.dest(dist+'/img'))// 存放到目标文件夹\n        .pipe(rev.manifest())// 生成rev-manifest.json文件名对照映射\n        .pipe(gulp.dest('rev/img')) // 将rev-manifest.json存放到rev文件夹\n});\n// 处理css\ngulp.task('revCss', function(){\n  return gulp.src(['rev/img/*.json', cssSrc])\n    .pipe(rev())\n    .pipe(revCollector())// 使用revImg任务生成的rev-manifest.json，替换css里面的图片文件名。\n    .pipe(gulp.dest(dist+'/css'))\n    .pipe(rev.manifest())\n    .pipe(gulp.dest('rev/css'))\n})\n// 处理js\ngulp.task('revJs', function(){\n  return gulp.src(jsSrc)\n    .pipe(rev())\n    .pipe(gulp.dest(dist+'/js'))\n    .pipe(rev.manifest())\n    .pipe(gulp.dest('rev/js'))\n})\n````\n### 更新html文件里的图片，js，css文件名。\n````javascript\ngulp.task('revHtml', function () {\n  return gulp.src(['rev/**/*.json', 'src/*.html'])\n    .pipe(revCollector())// 依照rev-manifest.json里的文件名映射进行替换\n    .pipe(gulp.dest(dist))\n})\n````\n### 定义主任务，控制执行顺序\n````javascript\ngulp.task('default', function (done) {\n  condition = false;\n  runSequence(\n    ['clean'],\n    ['revImg'],\n    ['revCss'],// revCss必须在revImg之后执行，因为依赖img/rev-manifest.json替换css里面的图片名。\n    ['revJs'],\n    ['revHtml'],\n    done);\n});\n````\n## 结果\n````javascript\n│  gulpfile.js\n│  package.json\n│\n├─dist\n│  │  index.html\n│  │\n│  ├─css\n│  │      style-12d9df9be6.css\n│  │\n│  ├─img\n│  │      imgA-67ada573aa.png\n│  │      imgB-efc888043f.png\n│  │      imgC-3ba7a2eca0.png\n│  │\n│  └─js\n│          index-fd3859f5fc.js\n│\n├─rev\n│  ├─css\n│  │      rev-manifest.json\n│  │\n│  ├─img\n│  │      rev-manifest.json\n│  │\n│  └─js\n│          rev-manifest.json\n│\n└─src\n    │  index.html\n    │\n    ├─css\n    │      style.css\n    │\n    ├─img\n    │      imgA.png\n    │      imgB.png\n    │      imgC.png\n    │\n    └─js\n            index.js\n````\ncss文件和html里面的资源文件名也对应改变。\n\nindex.html\n````html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n    <link rel=\"stylesheet\" href=\"./css/style-12d9df9be6.css\">\n    <script src='./js/index-fd3859f5fc.js'></script>\n</head>\n<body>\n    <p>title</p>\n    <div>\n        <img src=\"./img/imgA-67ada573aa.png\" alt=\"\">\n        <img src=\"./img/imgB-efc888043f.png\" alt=\"\">\n        <img src=\"./img/imgC-3ba7a2eca0.png\" alt=\"\">\n    </div>\n</body>\n</html>\n````\nstyle.css\n````css\np,span {\n    color: grey;\n    background-image: url('../img/imgA-67ada573aa.png')\n}\n````\n## 完整代码\n````javascript\n// gulpfile.js\n//引入gulp和gulp插件\nvar gulp = require('gulp'),\n  runSequence = require('run-sequence'),\n  rev = require('gulp-rev'),\n  revCollector = require('gulp-rev-collector'),\n  clean = require('gulp-clean');\n\nvar path = 'src'// 源文件夹\nvar dist = 'dist'// 目标文件夹\n// 定义css、js源文件路径\nvar cssSrc = path + '/css/*.css',\n  jsSrc = path + '/js/*.js',\n  imgSrc = path + '/img/*.*';\n\n// CSS生成文件hash编码并生成 rev-manifest.json文件名对照映射\ngulp.task('revCss', function(){\n  return gulp.src(['rev/img/*.json', cssSrc])\n    .pipe(rev())\n    .pipe(revCollector())\n    .pipe(gulp.dest(dist+'/css'))\n    .pipe(rev.manifest())\n    .pipe(gulp.dest('rev/css'));\n});\n\n// 处理图片\ngulp.task('revImg', function(){\n    return gulp.src(imgSrc)\n        .pipe(rev())\n        .pipe(gulp.dest(dist+'/img'))\n        .pipe(rev.manifest())\n        .pipe(gulp.dest('rev/img'));\n});\n\n// js生成文件hash编码并生成 rev-manifest.json文件名对照映射\ngulp.task('revJs', function(){\n  return gulp.src(jsSrc)\n    .pipe(rev())\n    .pipe(gulp.dest(dist+'/js'))\n    .pipe(rev.manifest())\n    .pipe(gulp.dest('rev/js'));\n});\n\n\n// Html替换css、js文件版本\ngulp.task('revHtml', function () {\n  return gulp.src(['rev/**/*.json', 'src/*.html'])\n    .pipe(revCollector())\n    .pipe(gulp.dest(dist));\n});\n\ngulp.task('clean', function () {\n    return gulp.src(dist+'/*/*', {read: false})\n        .pipe(clean())\n})\n\n// 开发构建\ngulp.task('default', function (done) {\n  condition = false;\n  runSequence(\n    ['clean'],\n    ['revImg'],\n    ['revCss'],\n    ['revJs'],\n    ['revHtml'],\n    done);\n});\n````","source":"_posts/使用gulp为静态资源添加版本号.md","raw":"---\ntitle: 使用gulp为静态资源添加版本号\ndate: 2017-05-20\ntags: ['gulp','效率']\ncategories: ['工具']\n---\n##　背景\n日常使用gulp，使用的比较多的功能是为静态资源文件添加版本号，实现在强缓存下的静态资源缓存命中，增量更新。\n<!--more-->\n在这里记录一下实现过程。\n## gulp插件\n1. gulp-rev \n\n将静态资源的命名后面添加上文件指纹hash的值，插件是根据文件内容生成hash，所以可以实现增量更新。\n2. gulp-rev-collector \n\n比较命名变化前后的资源文件名，生成rev-manifest.json文件名对照映射。\n3. gulp-clean \n\n每次执行前，用来清除旧的文件。\n4. run-sequence\n控制gulp任务的执行顺序。\n## 过程\n### 定义路径\n````javascript\nvar path = 'src'// 源文件夹\nvar dist = 'dist'// 目标文件夹\n// 定义css、js源文件路径\nvar cssSrc = path + '/css/*.css',\n    jsSrc = path + '/js/*.js',\n    imgSrc = path + '/img/*.*'\n````\n### 添加hash值，生成文件名对照映射\n````javascript\n// 处理图片\ngulp.task('revImg', function(){\n    return gulp.src(imgSrc)// 源文件\n        .pipe(rev())// 为文件名添加hash值\n        .pipe(gulp.dest(dist+'/img'))// 存放到目标文件夹\n        .pipe(rev.manifest())// 生成rev-manifest.json文件名对照映射\n        .pipe(gulp.dest('rev/img')) // 将rev-manifest.json存放到rev文件夹\n});\n// 处理css\ngulp.task('revCss', function(){\n  return gulp.src(['rev/img/*.json', cssSrc])\n    .pipe(rev())\n    .pipe(revCollector())// 使用revImg任务生成的rev-manifest.json，替换css里面的图片文件名。\n    .pipe(gulp.dest(dist+'/css'))\n    .pipe(rev.manifest())\n    .pipe(gulp.dest('rev/css'))\n})\n// 处理js\ngulp.task('revJs', function(){\n  return gulp.src(jsSrc)\n    .pipe(rev())\n    .pipe(gulp.dest(dist+'/js'))\n    .pipe(rev.manifest())\n    .pipe(gulp.dest('rev/js'))\n})\n````\n### 更新html文件里的图片，js，css文件名。\n````javascript\ngulp.task('revHtml', function () {\n  return gulp.src(['rev/**/*.json', 'src/*.html'])\n    .pipe(revCollector())// 依照rev-manifest.json里的文件名映射进行替换\n    .pipe(gulp.dest(dist))\n})\n````\n### 定义主任务，控制执行顺序\n````javascript\ngulp.task('default', function (done) {\n  condition = false;\n  runSequence(\n    ['clean'],\n    ['revImg'],\n    ['revCss'],// revCss必须在revImg之后执行，因为依赖img/rev-manifest.json替换css里面的图片名。\n    ['revJs'],\n    ['revHtml'],\n    done);\n});\n````\n## 结果\n````javascript\n│  gulpfile.js\n│  package.json\n│\n├─dist\n│  │  index.html\n│  │\n│  ├─css\n│  │      style-12d9df9be6.css\n│  │\n│  ├─img\n│  │      imgA-67ada573aa.png\n│  │      imgB-efc888043f.png\n│  │      imgC-3ba7a2eca0.png\n│  │\n│  └─js\n│          index-fd3859f5fc.js\n│\n├─rev\n│  ├─css\n│  │      rev-manifest.json\n│  │\n│  ├─img\n│  │      rev-manifest.json\n│  │\n│  └─js\n│          rev-manifest.json\n│\n└─src\n    │  index.html\n    │\n    ├─css\n    │      style.css\n    │\n    ├─img\n    │      imgA.png\n    │      imgB.png\n    │      imgC.png\n    │\n    └─js\n            index.js\n````\ncss文件和html里面的资源文件名也对应改变。\n\nindex.html\n````html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n    <link rel=\"stylesheet\" href=\"./css/style-12d9df9be6.css\">\n    <script src='./js/index-fd3859f5fc.js'></script>\n</head>\n<body>\n    <p>title</p>\n    <div>\n        <img src=\"./img/imgA-67ada573aa.png\" alt=\"\">\n        <img src=\"./img/imgB-efc888043f.png\" alt=\"\">\n        <img src=\"./img/imgC-3ba7a2eca0.png\" alt=\"\">\n    </div>\n</body>\n</html>\n````\nstyle.css\n````css\np,span {\n    color: grey;\n    background-image: url('../img/imgA-67ada573aa.png')\n}\n````\n## 完整代码\n````javascript\n// gulpfile.js\n//引入gulp和gulp插件\nvar gulp = require('gulp'),\n  runSequence = require('run-sequence'),\n  rev = require('gulp-rev'),\n  revCollector = require('gulp-rev-collector'),\n  clean = require('gulp-clean');\n\nvar path = 'src'// 源文件夹\nvar dist = 'dist'// 目标文件夹\n// 定义css、js源文件路径\nvar cssSrc = path + '/css/*.css',\n  jsSrc = path + '/js/*.js',\n  imgSrc = path + '/img/*.*';\n\n// CSS生成文件hash编码并生成 rev-manifest.json文件名对照映射\ngulp.task('revCss', function(){\n  return gulp.src(['rev/img/*.json', cssSrc])\n    .pipe(rev())\n    .pipe(revCollector())\n    .pipe(gulp.dest(dist+'/css'))\n    .pipe(rev.manifest())\n    .pipe(gulp.dest('rev/css'));\n});\n\n// 处理图片\ngulp.task('revImg', function(){\n    return gulp.src(imgSrc)\n        .pipe(rev())\n        .pipe(gulp.dest(dist+'/img'))\n        .pipe(rev.manifest())\n        .pipe(gulp.dest('rev/img'));\n});\n\n// js生成文件hash编码并生成 rev-manifest.json文件名对照映射\ngulp.task('revJs', function(){\n  return gulp.src(jsSrc)\n    .pipe(rev())\n    .pipe(gulp.dest(dist+'/js'))\n    .pipe(rev.manifest())\n    .pipe(gulp.dest('rev/js'));\n});\n\n\n// Html替换css、js文件版本\ngulp.task('revHtml', function () {\n  return gulp.src(['rev/**/*.json', 'src/*.html'])\n    .pipe(revCollector())\n    .pipe(gulp.dest(dist));\n});\n\ngulp.task('clean', function () {\n    return gulp.src(dist+'/*/*', {read: false})\n        .pipe(clean())\n})\n\n// 开发构建\ngulp.task('default', function (done) {\n  condition = false;\n  runSequence(\n    ['clean'],\n    ['revImg'],\n    ['revCss'],\n    ['revJs'],\n    ['revHtml'],\n    done);\n});\n````","slug":"使用gulp为静态资源添加版本号","published":1,"updated":"2022-04-13T14:14:07.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffs002ug3t88o5r92la","content":"<p>##　背景<br>日常使用gulp，使用的比较多的功能是为静态资源文件添加版本号，实现在强缓存下的静态资源缓存命中，增量更新。<br><a id=\"more\"></a><br>在这里记录一下实现过程。</p>\n<h2 id=\"gulp插件\"><a href=\"#gulp插件\" class=\"headerlink\" title=\"gulp插件\"></a>gulp插件</h2><ol>\n<li>gulp-rev </li>\n</ol>\n<p>将静态资源的命名后面添加上文件指纹hash的值，插件是根据文件内容生成hash，所以可以实现增量更新。</p>\n<ol start=\"2\">\n<li>gulp-rev-collector </li>\n</ol>\n<p>比较命名变化前后的资源文件名，生成rev-manifest.json文件名对照映射。</p>\n<ol start=\"3\">\n<li>gulp-clean </li>\n</ol>\n<p>每次执行前，用来清除旧的文件。</p>\n<ol start=\"4\">\n<li>run-sequence<br>控制gulp任务的执行顺序。<h2 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h2><h3 id=\"定义路径\"><a href=\"#定义路径\" class=\"headerlink\" title=\"定义路径\"></a>定义路径</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"string\">'src'</span><span class=\"comment\">// 源文件夹</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> dist = <span class=\"string\">'dist'</span><span class=\"comment\">// 目标文件夹</span></span><br><span class=\"line\"><span class=\"comment\">// 定义css、js源文件路径</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cssSrc = path + <span class=\"string\">'/css/*.css'</span>,</span><br><span class=\"line\">    jsSrc = path + <span class=\"string\">'/js/*.js'</span>,</span><br><span class=\"line\">    imgSrc = path + <span class=\"string\">'/img/*.*'</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"添加hash值，生成文件名对照映射\"><a href=\"#添加hash值，生成文件名对照映射\" class=\"headerlink\" title=\"添加hash值，生成文件名对照映射\"></a>添加hash值，生成文件名对照映射</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 处理图片</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'revImg'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gulp.src(imgSrc)<span class=\"comment\">// 源文件</span></span><br><span class=\"line\">        .pipe(rev())<span class=\"comment\">// 为文件名添加hash值</span></span><br><span class=\"line\">        .pipe(gulp.dest(dist+<span class=\"string\">'/img'</span>))<span class=\"comment\">// 存放到目标文件夹</span></span><br><span class=\"line\">        .pipe(rev.manifest())<span class=\"comment\">// 生成rev-manifest.json文件名对照映射</span></span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">'rev/img'</span>)) <span class=\"comment\">// 将rev-manifest.json存放到rev文件夹</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 处理css</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'revCss'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src([<span class=\"string\">'rev/img/*.json'</span>, cssSrc])</span><br><span class=\"line\">    .pipe(rev())</span><br><span class=\"line\">    .pipe(revCollector())<span class=\"comment\">// 使用revImg任务生成的rev-manifest.json，替换css里面的图片文件名。</span></span><br><span class=\"line\">    .pipe(gulp.dest(dist+<span class=\"string\">'/css'</span>))</span><br><span class=\"line\">    .pipe(rev.manifest())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'rev/css'</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 处理js</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'revJs'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(jsSrc)</span><br><span class=\"line\">    .pipe(rev())</span><br><span class=\"line\">    .pipe(gulp.dest(dist+<span class=\"string\">'/js'</span>))</span><br><span class=\"line\">    .pipe(rev.manifest())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'rev/js'</span>))</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"更新html文件里的图片，js，css文件名。\"><a href=\"#更新html文件里的图片，js，css文件名。\" class=\"headerlink\" title=\"更新html文件里的图片，js，css文件名。\"></a>更新html文件里的图片，js，css文件名。</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'revHtml'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src([<span class=\"string\">'rev/**/*.json'</span>, <span class=\"string\">'src/*.html'</span>])</span><br><span class=\"line\">    .pipe(revCollector())<span class=\"comment\">// 依照rev-manifest.json里的文件名映射进行替换</span></span><br><span class=\"line\">    .pipe(gulp.dest(dist))</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"定义主任务，控制执行顺序\"><a href=\"#定义主任务，控制执行顺序\" class=\"headerlink\" title=\"定义主任务，控制执行顺序\"></a>定义主任务，控制执行顺序</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'default'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">done</span>) </span>&#123;</span><br><span class=\"line\">  condition = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  runSequence(</span><br><span class=\"line\">    [<span class=\"string\">'clean'</span>],</span><br><span class=\"line\">    [<span class=\"string\">'revImg'</span>],</span><br><span class=\"line\">    [<span class=\"string\">'revCss'</span>],<span class=\"comment\">// revCss必须在revImg之后执行，因为依赖img/rev-manifest.json替换css里面的图片名。</span></span><br><span class=\"line\">    [<span class=\"string\">'revJs'</span>],</span><br><span class=\"line\">    [<span class=\"string\">'revHtml'</span>],</span><br><span class=\"line\">    done);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">│  gulpfile.js</span><br><span class=\"line\">│  package.json</span><br><span class=\"line\">│</span><br><span class=\"line\">├─dist</span><br><span class=\"line\">│  │  index.html</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  ├─css</span><br><span class=\"line\">│  │      style<span class=\"number\">-12</span>d9df9be6.css</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  ├─img</span><br><span class=\"line\">│  │      imgA<span class=\"number\">-67</span>ada573aa.png</span><br><span class=\"line\">│  │      imgB-efc888043f.png</span><br><span class=\"line\">│  │      imgC<span class=\"number\">-3</span>ba7a2eca0.png</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  └─js</span><br><span class=\"line\">│          index-fd3859f5fc.js</span><br><span class=\"line\">│</span><br><span class=\"line\">├─rev</span><br><span class=\"line\">│  ├─css</span><br><span class=\"line\">│  │      rev-manifest.json</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  ├─img</span><br><span class=\"line\">│  │      rev-manifest.json</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  └─js</span><br><span class=\"line\">│          rev-manifest.json</span><br><span class=\"line\">│</span><br><span class=\"line\">└─src</span><br><span class=\"line\">    │  index.html</span><br><span class=\"line\">    │</span><br><span class=\"line\">    ├─css</span><br><span class=\"line\">    │      style.css</span><br><span class=\"line\">    │</span><br><span class=\"line\">    ├─img</span><br><span class=\"line\">    │      imgA.png</span><br><span class=\"line\">    │      imgB.png</span><br><span class=\"line\">    │      imgC.png</span><br><span class=\"line\">    │</span><br><span class=\"line\">    └─js</span><br><span class=\"line\">            index.js</span><br></pre></td></tr></table></figure>\n<p>css文件和html里面的资源文件名也对应改变。</p>\n<p>index.html<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"./css/style-12d9df9be6.css\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">'./js/index-fd3859f5fc.js'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>title<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./img/imgA-67ada573aa.png\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./img/imgB-efc888043f.png\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./img/imgC-3ba7a2eca0.png\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>style.css<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span>,<span class=\"selector-tag\">span</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: grey;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">'../img/imgA-67ada573aa.png'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// gulpfile.js</span></span><br><span class=\"line\"><span class=\"comment\">//引入gulp和gulp插件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>),</span><br><span class=\"line\">  runSequence = <span class=\"built_in\">require</span>(<span class=\"string\">'run-sequence'</span>),</span><br><span class=\"line\">  rev = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-rev'</span>),</span><br><span class=\"line\">  revCollector = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-rev-collector'</span>),</span><br><span class=\"line\">  clean = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-clean'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"string\">'src'</span><span class=\"comment\">// 源文件夹</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> dist = <span class=\"string\">'dist'</span><span class=\"comment\">// 目标文件夹</span></span><br><span class=\"line\"><span class=\"comment\">// 定义css、js源文件路径</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cssSrc = path + <span class=\"string\">'/css/*.css'</span>,</span><br><span class=\"line\">  jsSrc = path + <span class=\"string\">'/js/*.js'</span>,</span><br><span class=\"line\">  imgSrc = path + <span class=\"string\">'/img/*.*'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// CSS生成文件hash编码并生成 rev-manifest.json文件名对照映射</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'revCss'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src([<span class=\"string\">'rev/img/*.json'</span>, cssSrc])</span><br><span class=\"line\">    .pipe(rev())</span><br><span class=\"line\">    .pipe(revCollector())</span><br><span class=\"line\">    .pipe(gulp.dest(dist+<span class=\"string\">'/css'</span>))</span><br><span class=\"line\">    .pipe(rev.manifest())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'rev/css'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理图片</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'revImg'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gulp.src(imgSrc)</span><br><span class=\"line\">        .pipe(rev())</span><br><span class=\"line\">        .pipe(gulp.dest(dist+<span class=\"string\">'/img'</span>))</span><br><span class=\"line\">        .pipe(rev.manifest())</span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">'rev/img'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// js生成文件hash编码并生成 rev-manifest.json文件名对照映射</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'revJs'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(jsSrc)</span><br><span class=\"line\">    .pipe(rev())</span><br><span class=\"line\">    .pipe(gulp.dest(dist+<span class=\"string\">'/js'</span>))</span><br><span class=\"line\">    .pipe(rev.manifest())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'rev/js'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Html替换css、js文件版本</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'revHtml'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src([<span class=\"string\">'rev/**/*.json'</span>, <span class=\"string\">'src/*.html'</span>])</span><br><span class=\"line\">    .pipe(revCollector())</span><br><span class=\"line\">    .pipe(gulp.dest(dist));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'clean'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gulp.src(dist+<span class=\"string\">'/*/*'</span>, &#123;<span class=\"attr\">read</span>: <span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\">        .pipe(clean())</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开发构建</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'default'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">done</span>) </span>&#123;</span><br><span class=\"line\">  condition = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  runSequence(</span><br><span class=\"line\">    [<span class=\"string\">'clean'</span>],</span><br><span class=\"line\">    [<span class=\"string\">'revImg'</span>],</span><br><span class=\"line\">    [<span class=\"string\">'revCss'</span>],</span><br><span class=\"line\">    [<span class=\"string\">'revJs'</span>],</span><br><span class=\"line\">    [<span class=\"string\">'revHtml'</span>],</span><br><span class=\"line\">    done);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>##　背景<br>日常使用gulp，使用的比较多的功能是为静态资源文件添加版本号，实现在强缓存下的静态资源缓存命中，增量更新。<br>","more":"<br>在这里记录一下实现过程。</p>\n<h2 id=\"gulp插件\"><a href=\"#gulp插件\" class=\"headerlink\" title=\"gulp插件\"></a>gulp插件</h2><ol>\n<li>gulp-rev </li>\n</ol>\n<p>将静态资源的命名后面添加上文件指纹hash的值，插件是根据文件内容生成hash，所以可以实现增量更新。</p>\n<ol start=\"2\">\n<li>gulp-rev-collector </li>\n</ol>\n<p>比较命名变化前后的资源文件名，生成rev-manifest.json文件名对照映射。</p>\n<ol start=\"3\">\n<li>gulp-clean </li>\n</ol>\n<p>每次执行前，用来清除旧的文件。</p>\n<ol start=\"4\">\n<li>run-sequence<br>控制gulp任务的执行顺序。<h2 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h2><h3 id=\"定义路径\"><a href=\"#定义路径\" class=\"headerlink\" title=\"定义路径\"></a>定义路径</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"string\">'src'</span><span class=\"comment\">// 源文件夹</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> dist = <span class=\"string\">'dist'</span><span class=\"comment\">// 目标文件夹</span></span><br><span class=\"line\"><span class=\"comment\">// 定义css、js源文件路径</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cssSrc = path + <span class=\"string\">'/css/*.css'</span>,</span><br><span class=\"line\">    jsSrc = path + <span class=\"string\">'/js/*.js'</span>,</span><br><span class=\"line\">    imgSrc = path + <span class=\"string\">'/img/*.*'</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"添加hash值，生成文件名对照映射\"><a href=\"#添加hash值，生成文件名对照映射\" class=\"headerlink\" title=\"添加hash值，生成文件名对照映射\"></a>添加hash值，生成文件名对照映射</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 处理图片</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'revImg'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gulp.src(imgSrc)<span class=\"comment\">// 源文件</span></span><br><span class=\"line\">        .pipe(rev())<span class=\"comment\">// 为文件名添加hash值</span></span><br><span class=\"line\">        .pipe(gulp.dest(dist+<span class=\"string\">'/img'</span>))<span class=\"comment\">// 存放到目标文件夹</span></span><br><span class=\"line\">        .pipe(rev.manifest())<span class=\"comment\">// 生成rev-manifest.json文件名对照映射</span></span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">'rev/img'</span>)) <span class=\"comment\">// 将rev-manifest.json存放到rev文件夹</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 处理css</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'revCss'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src([<span class=\"string\">'rev/img/*.json'</span>, cssSrc])</span><br><span class=\"line\">    .pipe(rev())</span><br><span class=\"line\">    .pipe(revCollector())<span class=\"comment\">// 使用revImg任务生成的rev-manifest.json，替换css里面的图片文件名。</span></span><br><span class=\"line\">    .pipe(gulp.dest(dist+<span class=\"string\">'/css'</span>))</span><br><span class=\"line\">    .pipe(rev.manifest())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'rev/css'</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 处理js</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'revJs'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(jsSrc)</span><br><span class=\"line\">    .pipe(rev())</span><br><span class=\"line\">    .pipe(gulp.dest(dist+<span class=\"string\">'/js'</span>))</span><br><span class=\"line\">    .pipe(rev.manifest())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'rev/js'</span>))</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"更新html文件里的图片，js，css文件名。\"><a href=\"#更新html文件里的图片，js，css文件名。\" class=\"headerlink\" title=\"更新html文件里的图片，js，css文件名。\"></a>更新html文件里的图片，js，css文件名。</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'revHtml'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src([<span class=\"string\">'rev/**/*.json'</span>, <span class=\"string\">'src/*.html'</span>])</span><br><span class=\"line\">    .pipe(revCollector())<span class=\"comment\">// 依照rev-manifest.json里的文件名映射进行替换</span></span><br><span class=\"line\">    .pipe(gulp.dest(dist))</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"定义主任务，控制执行顺序\"><a href=\"#定义主任务，控制执行顺序\" class=\"headerlink\" title=\"定义主任务，控制执行顺序\"></a>定义主任务，控制执行顺序</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'default'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">done</span>) </span>&#123;</span><br><span class=\"line\">  condition = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  runSequence(</span><br><span class=\"line\">    [<span class=\"string\">'clean'</span>],</span><br><span class=\"line\">    [<span class=\"string\">'revImg'</span>],</span><br><span class=\"line\">    [<span class=\"string\">'revCss'</span>],<span class=\"comment\">// revCss必须在revImg之后执行，因为依赖img/rev-manifest.json替换css里面的图片名。</span></span><br><span class=\"line\">    [<span class=\"string\">'revJs'</span>],</span><br><span class=\"line\">    [<span class=\"string\">'revHtml'</span>],</span><br><span class=\"line\">    done);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">│  gulpfile.js</span><br><span class=\"line\">│  package.json</span><br><span class=\"line\">│</span><br><span class=\"line\">├─dist</span><br><span class=\"line\">│  │  index.html</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  ├─css</span><br><span class=\"line\">│  │      style<span class=\"number\">-12</span>d9df9be6.css</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  ├─img</span><br><span class=\"line\">│  │      imgA<span class=\"number\">-67</span>ada573aa.png</span><br><span class=\"line\">│  │      imgB-efc888043f.png</span><br><span class=\"line\">│  │      imgC<span class=\"number\">-3</span>ba7a2eca0.png</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  └─js</span><br><span class=\"line\">│          index-fd3859f5fc.js</span><br><span class=\"line\">│</span><br><span class=\"line\">├─rev</span><br><span class=\"line\">│  ├─css</span><br><span class=\"line\">│  │      rev-manifest.json</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  ├─img</span><br><span class=\"line\">│  │      rev-manifest.json</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  └─js</span><br><span class=\"line\">│          rev-manifest.json</span><br><span class=\"line\">│</span><br><span class=\"line\">└─src</span><br><span class=\"line\">    │  index.html</span><br><span class=\"line\">    │</span><br><span class=\"line\">    ├─css</span><br><span class=\"line\">    │      style.css</span><br><span class=\"line\">    │</span><br><span class=\"line\">    ├─img</span><br><span class=\"line\">    │      imgA.png</span><br><span class=\"line\">    │      imgB.png</span><br><span class=\"line\">    │      imgC.png</span><br><span class=\"line\">    │</span><br><span class=\"line\">    └─js</span><br><span class=\"line\">            index.js</span><br></pre></td></tr></table></figure>\n<p>css文件和html里面的资源文件名也对应改变。</p>\n<p>index.html<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"./css/style-12d9df9be6.css\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">'./js/index-fd3859f5fc.js'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>title<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./img/imgA-67ada573aa.png\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./img/imgB-efc888043f.png\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./img/imgC-3ba7a2eca0.png\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>style.css<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span>,<span class=\"selector-tag\">span</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: grey;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">'../img/imgA-67ada573aa.png'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// gulpfile.js</span></span><br><span class=\"line\"><span class=\"comment\">//引入gulp和gulp插件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>),</span><br><span class=\"line\">  runSequence = <span class=\"built_in\">require</span>(<span class=\"string\">'run-sequence'</span>),</span><br><span class=\"line\">  rev = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-rev'</span>),</span><br><span class=\"line\">  revCollector = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-rev-collector'</span>),</span><br><span class=\"line\">  clean = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-clean'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"string\">'src'</span><span class=\"comment\">// 源文件夹</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> dist = <span class=\"string\">'dist'</span><span class=\"comment\">// 目标文件夹</span></span><br><span class=\"line\"><span class=\"comment\">// 定义css、js源文件路径</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cssSrc = path + <span class=\"string\">'/css/*.css'</span>,</span><br><span class=\"line\">  jsSrc = path + <span class=\"string\">'/js/*.js'</span>,</span><br><span class=\"line\">  imgSrc = path + <span class=\"string\">'/img/*.*'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// CSS生成文件hash编码并生成 rev-manifest.json文件名对照映射</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'revCss'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src([<span class=\"string\">'rev/img/*.json'</span>, cssSrc])</span><br><span class=\"line\">    .pipe(rev())</span><br><span class=\"line\">    .pipe(revCollector())</span><br><span class=\"line\">    .pipe(gulp.dest(dist+<span class=\"string\">'/css'</span>))</span><br><span class=\"line\">    .pipe(rev.manifest())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'rev/css'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理图片</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'revImg'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gulp.src(imgSrc)</span><br><span class=\"line\">        .pipe(rev())</span><br><span class=\"line\">        .pipe(gulp.dest(dist+<span class=\"string\">'/img'</span>))</span><br><span class=\"line\">        .pipe(rev.manifest())</span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">'rev/img'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// js生成文件hash编码并生成 rev-manifest.json文件名对照映射</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'revJs'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(jsSrc)</span><br><span class=\"line\">    .pipe(rev())</span><br><span class=\"line\">    .pipe(gulp.dest(dist+<span class=\"string\">'/js'</span>))</span><br><span class=\"line\">    .pipe(rev.manifest())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'rev/js'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Html替换css、js文件版本</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'revHtml'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src([<span class=\"string\">'rev/**/*.json'</span>, <span class=\"string\">'src/*.html'</span>])</span><br><span class=\"line\">    .pipe(revCollector())</span><br><span class=\"line\">    .pipe(gulp.dest(dist));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'clean'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gulp.src(dist+<span class=\"string\">'/*/*'</span>, &#123;<span class=\"attr\">read</span>: <span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\">        .pipe(clean())</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开发构建</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'default'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">done</span>) </span>&#123;</span><br><span class=\"line\">  condition = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  runSequence(</span><br><span class=\"line\">    [<span class=\"string\">'clean'</span>],</span><br><span class=\"line\">    [<span class=\"string\">'revImg'</span>],</span><br><span class=\"line\">    [<span class=\"string\">'revCss'</span>],</span><br><span class=\"line\">    [<span class=\"string\">'revJs'</span>],</span><br><span class=\"line\">    [<span class=\"string\">'revHtml'</span>],</span><br><span class=\"line\">    done);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"},{"title":"使用react和vue实现支付宝微信风格的密码输入框","date":"2017-10-07T16:00:00.000Z","_content":"# 需求背景\n最近的一个项目需要实现一个类似支付宝密码输入的验证码框，即确定好格子的数量，让用户输入密码或者验证码。\n\n在此基础上进一步扩展，实现具有以下功能的公共组件：\n1. 仿支付宝微信密码输入的输入方式，即确定好格子的数量，用户输入。\n2. 支持自定义格子数，4位到8位。\n3. 输入格子可显示出明文或者使用密码黑点代替。\n4. 支持调起数字键盘或混合键盘。\n5. 自定义标题。\n6. 支持按钮提交或者输入完成时自动提交\n<!--more-->\n# 实现过程\n## 基本思路\n这次实现的是mvvm框架(react和vue)下的组件，通过设置一个隐藏的输入框，借助mvvm框架的数据绑定功能，将用户输入的值分别映射到每个格子上。\n\n格子本身不是给用户直接输入的，用户可直接输入的只有隐藏的输入框。\n## 样式\n1. 隐藏输入框\n首先设置position：absolute，让input元素脱离文档流，不占据空间。\n\n接着将input元素设置为透明，这个时候在电脑上查看是隐藏的，但是手机查看，输入的内容是隐藏了，但还是会有一个闪烁的光标。\n\n后面将input元素的margin-left的值设置为一个很大的值，直接将这个input元素挤出屏幕外，这样就彻底看不到了。\n2. 格子\n格子的排列采用flex局部，将父元素设置为display: flex，同时将justify-content设置为space-around，这样将格子均匀地分布。\n\n格子的数量在4个到8个之间，格子的长宽采用em作单位，同时值的大小根据格子的数量动态进行调整，实现当格子的数量增多时，格子的大小会相对进行缩小。\n\n格子得满足实现密码输入时显示黑点，因此格子采用input元素来实现，设置disable为true，不可输入。这里有个注意的点，disabled的input元素opacity默认是0.3,所以样式里要加上opacity:1。\n3. 输入时页面放大\n在手机下进行输入时，当隐藏的input元素被聚焦输入时，此时页面会被手机浏览器放大。\n\n为了禁止这种行为，需要为页面增加以下meta\n````html\n<meta name=\"viewport\" content=\"width=device-width,minimum-scale=1.0,maximum-scale=1.0,initial-scale=1.0,user-scalable=no\">\n````\nwidth - viewport的宽度\n\ninitial-scale - 初始的缩放比例\n\nminimum-scale - 允许用户缩放到的最小比例\n\nmaximum-scale - 允许用户缩放到的最大比例\n\nuser-scalable - 用户是否可以手动缩放\n## 功能逻辑\n1. 控制隐藏框的输入\n根据规定输入的位数，监听隐藏框的输入事件，使用String的slice方法截取符合长度的值。\n2. 自定义格子数 \n通过设置组件的属性，组件内部获取到格子的数量进行渲染。\n3. 格子显示明文或黑点\n显示明文，是借助mvvm框架的数据绑定功能，将隐藏input的值按位置绑定到对应的格子上。\n\n根据传入组件的属性，当需要显示黑点时，设置input的type属性为password。\n\n在react中，根据传入的属性，是这样设置的\n````html\n<input type={this.props.isPassword ? 'password' : 'text'} />\n````\n但是在vue中使用类似的写法，会报如下错误\n> v-model does not support dynamic input types\n> \n> What this error is saying is that, if you dynamically change the input type being sent to the component, Vue will not update the input element to change its type.\n\n原因是vue不支持动态设置input的type属性，解决方法是设置两个不同type的input，借助vue指令v-if和v-else切换。\n\n4. 调起数字键盘或混合键盘\n根据传入组件的属性，需要显示数字键盘时，设置隐藏input元素的type属性为tel。\n````html\n<input type={this.props.isNumber ? 'tel' : 'text'} />\n````\nvue里面遇到的问题同上。\n# 组件属性和事件\n## Props\nName | type | default | description\n---:| --- | ---| ---\ntip | String | '请输入密码' | 输入提示语\npasswordLength | Number | 6 | 格子位数\nisPassword | Boolean | true | 显示明文或者密码黑点\nisNumber | Boolean | true | 调出数字键盘或者混合键盘\nisBtnCtr | Boolean | true | 使用确认按钮或者自动提交\n\n## Events\nName | isRequire | description\n---:| --- | --- \nonConfirm | require | 输入完成时的回调函数\nonClose | require | 关闭输入框时的回调函数\n# 演示页面\n[![手机扫描二维码查看](http://oq8q06ybp.bkt.clouddn.com/image/qrCode.png)](http://60kmlh.ink/vue-GridPassword/)\n# 源码\n[react版本](http://github.com/60kmlh/react-GridPassword/)\n\n[vue版本](https://github.com/60kmlh/vue-GridPassword/)\n","source":"_posts/使用react和vue实现支付宝微信风格的密码输入框.md","raw":"---\ntitle: 使用react和vue实现支付宝微信风格的密码输入框\ndate: 2017-10-08\ntags: ['react','vue']\ncategories: ['公共组件']\n---\n# 需求背景\n最近的一个项目需要实现一个类似支付宝密码输入的验证码框，即确定好格子的数量，让用户输入密码或者验证码。\n\n在此基础上进一步扩展，实现具有以下功能的公共组件：\n1. 仿支付宝微信密码输入的输入方式，即确定好格子的数量，用户输入。\n2. 支持自定义格子数，4位到8位。\n3. 输入格子可显示出明文或者使用密码黑点代替。\n4. 支持调起数字键盘或混合键盘。\n5. 自定义标题。\n6. 支持按钮提交或者输入完成时自动提交\n<!--more-->\n# 实现过程\n## 基本思路\n这次实现的是mvvm框架(react和vue)下的组件，通过设置一个隐藏的输入框，借助mvvm框架的数据绑定功能，将用户输入的值分别映射到每个格子上。\n\n格子本身不是给用户直接输入的，用户可直接输入的只有隐藏的输入框。\n## 样式\n1. 隐藏输入框\n首先设置position：absolute，让input元素脱离文档流，不占据空间。\n\n接着将input元素设置为透明，这个时候在电脑上查看是隐藏的，但是手机查看，输入的内容是隐藏了，但还是会有一个闪烁的光标。\n\n后面将input元素的margin-left的值设置为一个很大的值，直接将这个input元素挤出屏幕外，这样就彻底看不到了。\n2. 格子\n格子的排列采用flex局部，将父元素设置为display: flex，同时将justify-content设置为space-around，这样将格子均匀地分布。\n\n格子的数量在4个到8个之间，格子的长宽采用em作单位，同时值的大小根据格子的数量动态进行调整，实现当格子的数量增多时，格子的大小会相对进行缩小。\n\n格子得满足实现密码输入时显示黑点，因此格子采用input元素来实现，设置disable为true，不可输入。这里有个注意的点，disabled的input元素opacity默认是0.3,所以样式里要加上opacity:1。\n3. 输入时页面放大\n在手机下进行输入时，当隐藏的input元素被聚焦输入时，此时页面会被手机浏览器放大。\n\n为了禁止这种行为，需要为页面增加以下meta\n````html\n<meta name=\"viewport\" content=\"width=device-width,minimum-scale=1.0,maximum-scale=1.0,initial-scale=1.0,user-scalable=no\">\n````\nwidth - viewport的宽度\n\ninitial-scale - 初始的缩放比例\n\nminimum-scale - 允许用户缩放到的最小比例\n\nmaximum-scale - 允许用户缩放到的最大比例\n\nuser-scalable - 用户是否可以手动缩放\n## 功能逻辑\n1. 控制隐藏框的输入\n根据规定输入的位数，监听隐藏框的输入事件，使用String的slice方法截取符合长度的值。\n2. 自定义格子数 \n通过设置组件的属性，组件内部获取到格子的数量进行渲染。\n3. 格子显示明文或黑点\n显示明文，是借助mvvm框架的数据绑定功能，将隐藏input的值按位置绑定到对应的格子上。\n\n根据传入组件的属性，当需要显示黑点时，设置input的type属性为password。\n\n在react中，根据传入的属性，是这样设置的\n````html\n<input type={this.props.isPassword ? 'password' : 'text'} />\n````\n但是在vue中使用类似的写法，会报如下错误\n> v-model does not support dynamic input types\n> \n> What this error is saying is that, if you dynamically change the input type being sent to the component, Vue will not update the input element to change its type.\n\n原因是vue不支持动态设置input的type属性，解决方法是设置两个不同type的input，借助vue指令v-if和v-else切换。\n\n4. 调起数字键盘或混合键盘\n根据传入组件的属性，需要显示数字键盘时，设置隐藏input元素的type属性为tel。\n````html\n<input type={this.props.isNumber ? 'tel' : 'text'} />\n````\nvue里面遇到的问题同上。\n# 组件属性和事件\n## Props\nName | type | default | description\n---:| --- | ---| ---\ntip | String | '请输入密码' | 输入提示语\npasswordLength | Number | 6 | 格子位数\nisPassword | Boolean | true | 显示明文或者密码黑点\nisNumber | Boolean | true | 调出数字键盘或者混合键盘\nisBtnCtr | Boolean | true | 使用确认按钮或者自动提交\n\n## Events\nName | isRequire | description\n---:| --- | --- \nonConfirm | require | 输入完成时的回调函数\nonClose | require | 关闭输入框时的回调函数\n# 演示页面\n[![手机扫描二维码查看](http://oq8q06ybp.bkt.clouddn.com/image/qrCode.png)](http://60kmlh.ink/vue-GridPassword/)\n# 源码\n[react版本](http://github.com/60kmlh/react-GridPassword/)\n\n[vue版本](https://github.com/60kmlh/vue-GridPassword/)\n","slug":"使用react和vue实现支付宝微信风格的密码输入框","published":1,"updated":"2022-04-13T14:14:07.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfft002xg3t8yezbgiba","content":"<h1 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景\"></a>需求背景</h1><p>最近的一个项目需要实现一个类似支付宝密码输入的验证码框，即确定好格子的数量，让用户输入密码或者验证码。</p>\n<p>在此基础上进一步扩展，实现具有以下功能的公共组件：</p>\n<ol>\n<li>仿支付宝微信密码输入的输入方式，即确定好格子的数量，用户输入。</li>\n<li>支持自定义格子数，4位到8位。</li>\n<li>输入格子可显示出明文或者使用密码黑点代替。</li>\n<li>支持调起数字键盘或混合键盘。</li>\n<li>自定义标题。</li>\n<li>支持按钮提交或者输入完成时自动提交<a id=\"more\"></a>\n<h1 id=\"实现过程\"><a href=\"#实现过程\" class=\"headerlink\" title=\"实现过程\"></a>实现过程</h1><h2 id=\"基本思路\"><a href=\"#基本思路\" class=\"headerlink\" title=\"基本思路\"></a>基本思路</h2>这次实现的是mvvm框架(react和vue)下的组件，通过设置一个隐藏的输入框，借助mvvm框架的数据绑定功能，将用户输入的值分别映射到每个格子上。</li>\n</ol>\n<p>格子本身不是给用户直接输入的，用户可直接输入的只有隐藏的输入框。</p>\n<h2 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h2><ol>\n<li>隐藏输入框<br>首先设置position：absolute，让input元素脱离文档流，不占据空间。</li>\n</ol>\n<p>接着将input元素设置为透明，这个时候在电脑上查看是隐藏的，但是手机查看，输入的内容是隐藏了，但还是会有一个闪烁的光标。</p>\n<p>后面将input元素的margin-left的值设置为一个很大的值，直接将这个input元素挤出屏幕外，这样就彻底看不到了。</p>\n<ol start=\"2\">\n<li>格子<br>格子的排列采用flex局部，将父元素设置为display: flex，同时将justify-content设置为space-around，这样将格子均匀地分布。</li>\n</ol>\n<p>格子的数量在4个到8个之间，格子的长宽采用em作单位，同时值的大小根据格子的数量动态进行调整，实现当格子的数量增多时，格子的大小会相对进行缩小。</p>\n<p>格子得满足实现密码输入时显示黑点，因此格子采用input元素来实现，设置disable为true，不可输入。这里有个注意的点，disabled的input元素opacity默认是0.3,所以样式里要加上opacity:1。</p>\n<ol start=\"3\">\n<li>输入时页面放大<br>在手机下进行输入时，当隐藏的input元素被聚焦输入时，此时页面会被手机浏览器放大。</li>\n</ol>\n<p>为了禁止这种行为，需要为页面增加以下meta<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width,minimum-scale=1.0,maximum-scale=1.0,initial-scale=1.0,user-scalable=no\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>width - viewport的宽度</p>\n<p>initial-scale - 初始的缩放比例</p>\n<p>minimum-scale - 允许用户缩放到的最小比例</p>\n<p>maximum-scale - 允许用户缩放到的最大比例</p>\n<p>user-scalable - 用户是否可以手动缩放</p>\n<h2 id=\"功能逻辑\"><a href=\"#功能逻辑\" class=\"headerlink\" title=\"功能逻辑\"></a>功能逻辑</h2><ol>\n<li>控制隐藏框的输入<br>根据规定输入的位数，监听隐藏框的输入事件，使用String的slice方法截取符合长度的值。</li>\n<li>自定义格子数<br>通过设置组件的属性，组件内部获取到格子的数量进行渲染。</li>\n<li>格子显示明文或黑点<br>显示明文，是借助mvvm框架的数据绑定功能，将隐藏input的值按位置绑定到对应的格子上。</li>\n</ol>\n<p>根据传入组件的属性，当需要显示黑点时，设置input的type属性为password。</p>\n<p>在react中，根据传入的属性，是这样设置的<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&#123;this.props.isPassword</span> ? '<span class=\"attr\">password</span>' <span class=\"attr\">:</span> '<span class=\"attr\">text</span>'&#125; /&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>但是在vue中使用类似的写法，会报如下错误</p>\n<blockquote>\n<p>v-model does not support dynamic input types</p>\n<p>What this error is saying is that, if you dynamically change the input type being sent to the component, Vue will not update the input element to change its type.</p>\n</blockquote>\n<p>原因是vue不支持动态设置input的type属性，解决方法是设置两个不同type的input，借助vue指令v-if和v-else切换。</p>\n<ol start=\"4\">\n<li>调起数字键盘或混合键盘<br>根据传入组件的属性，需要显示数字键盘时，设置隐藏input元素的type属性为tel。<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&#123;this.props.isNumber</span> ? '<span class=\"attr\">tel</span>' <span class=\"attr\">:</span> '<span class=\"attr\">text</span>'&#125; /&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>vue里面遇到的问题同上。</p>\n<h1 id=\"组件属性和事件\"><a href=\"#组件属性和事件\" class=\"headerlink\" title=\"组件属性和事件\"></a>组件属性和事件</h1><h2 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a>Props</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:right\">Name</th>\n<th>type</th>\n<th>default</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:right\">tip</td>\n<td>String</td>\n<td>‘请输入密码’</td>\n<td>输入提示语</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">passwordLength</td>\n<td>Number</td>\n<td>6</td>\n<td>格子位数</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">isPassword</td>\n<td>Boolean</td>\n<td>true</td>\n<td>显示明文或者密码黑点</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">isNumber</td>\n<td>Boolean</td>\n<td>true</td>\n<td>调出数字键盘或者混合键盘</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">isBtnCtr</td>\n<td>Boolean</td>\n<td>true</td>\n<td>使用确认按钮或者自动提交</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Events\"><a href=\"#Events\" class=\"headerlink\" title=\"Events\"></a>Events</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:right\">Name</th>\n<th>isRequire</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:right\">onConfirm</td>\n<td>require</td>\n<td>输入完成时的回调函数</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">onClose</td>\n<td>require</td>\n<td>关闭输入框时的回调函数</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"演示页面\"><a href=\"#演示页面\" class=\"headerlink\" title=\"演示页面\"></a>演示页面</h1><p><a href=\"http://60kmlh.ink/vue-GridPassword/\" target=\"_blank\" rel=\"noopener\"><img src=\"http://oq8q06ybp.bkt.clouddn.com/image/qrCode.png\" alt=\"手机扫描二维码查看\"></a></p>\n<h1 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h1><p><a href=\"http://github.com/60kmlh/react-GridPassword/\" target=\"_blank\" rel=\"noopener\">react版本</a></p>\n<p><a href=\"https://github.com/60kmlh/vue-GridPassword/\" target=\"_blank\" rel=\"noopener\">vue版本</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景\"></a>需求背景</h1><p>最近的一个项目需要实现一个类似支付宝密码输入的验证码框，即确定好格子的数量，让用户输入密码或者验证码。</p>\n<p>在此基础上进一步扩展，实现具有以下功能的公共组件：</p>\n<ol>\n<li>仿支付宝微信密码输入的输入方式，即确定好格子的数量，用户输入。</li>\n<li>支持自定义格子数，4位到8位。</li>\n<li>输入格子可显示出明文或者使用密码黑点代替。</li>\n<li>支持调起数字键盘或混合键盘。</li>\n<li>自定义标题。</li>\n<li>支持按钮提交或者输入完成时自动提交","more":"<h1 id=\"实现过程\"><a href=\"#实现过程\" class=\"headerlink\" title=\"实现过程\"></a>实现过程</h1><h2 id=\"基本思路\"><a href=\"#基本思路\" class=\"headerlink\" title=\"基本思路\"></a>基本思路</h2>这次实现的是mvvm框架(react和vue)下的组件，通过设置一个隐藏的输入框，借助mvvm框架的数据绑定功能，将用户输入的值分别映射到每个格子上。</li>\n</ol>\n<p>格子本身不是给用户直接输入的，用户可直接输入的只有隐藏的输入框。</p>\n<h2 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h2><ol>\n<li>隐藏输入框<br>首先设置position：absolute，让input元素脱离文档流，不占据空间。</li>\n</ol>\n<p>接着将input元素设置为透明，这个时候在电脑上查看是隐藏的，但是手机查看，输入的内容是隐藏了，但还是会有一个闪烁的光标。</p>\n<p>后面将input元素的margin-left的值设置为一个很大的值，直接将这个input元素挤出屏幕外，这样就彻底看不到了。</p>\n<ol start=\"2\">\n<li>格子<br>格子的排列采用flex局部，将父元素设置为display: flex，同时将justify-content设置为space-around，这样将格子均匀地分布。</li>\n</ol>\n<p>格子的数量在4个到8个之间，格子的长宽采用em作单位，同时值的大小根据格子的数量动态进行调整，实现当格子的数量增多时，格子的大小会相对进行缩小。</p>\n<p>格子得满足实现密码输入时显示黑点，因此格子采用input元素来实现，设置disable为true，不可输入。这里有个注意的点，disabled的input元素opacity默认是0.3,所以样式里要加上opacity:1。</p>\n<ol start=\"3\">\n<li>输入时页面放大<br>在手机下进行输入时，当隐藏的input元素被聚焦输入时，此时页面会被手机浏览器放大。</li>\n</ol>\n<p>为了禁止这种行为，需要为页面增加以下meta<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width,minimum-scale=1.0,maximum-scale=1.0,initial-scale=1.0,user-scalable=no\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>width - viewport的宽度</p>\n<p>initial-scale - 初始的缩放比例</p>\n<p>minimum-scale - 允许用户缩放到的最小比例</p>\n<p>maximum-scale - 允许用户缩放到的最大比例</p>\n<p>user-scalable - 用户是否可以手动缩放</p>\n<h2 id=\"功能逻辑\"><a href=\"#功能逻辑\" class=\"headerlink\" title=\"功能逻辑\"></a>功能逻辑</h2><ol>\n<li>控制隐藏框的输入<br>根据规定输入的位数，监听隐藏框的输入事件，使用String的slice方法截取符合长度的值。</li>\n<li>自定义格子数<br>通过设置组件的属性，组件内部获取到格子的数量进行渲染。</li>\n<li>格子显示明文或黑点<br>显示明文，是借助mvvm框架的数据绑定功能，将隐藏input的值按位置绑定到对应的格子上。</li>\n</ol>\n<p>根据传入组件的属性，当需要显示黑点时，设置input的type属性为password。</p>\n<p>在react中，根据传入的属性，是这样设置的<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&#123;this.props.isPassword</span> ? '<span class=\"attr\">password</span>' <span class=\"attr\">:</span> '<span class=\"attr\">text</span>'&#125; /&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>但是在vue中使用类似的写法，会报如下错误</p>\n<blockquote>\n<p>v-model does not support dynamic input types</p>\n<p>What this error is saying is that, if you dynamically change the input type being sent to the component, Vue will not update the input element to change its type.</p>\n</blockquote>\n<p>原因是vue不支持动态设置input的type属性，解决方法是设置两个不同type的input，借助vue指令v-if和v-else切换。</p>\n<ol start=\"4\">\n<li>调起数字键盘或混合键盘<br>根据传入组件的属性，需要显示数字键盘时，设置隐藏input元素的type属性为tel。<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&#123;this.props.isNumber</span> ? '<span class=\"attr\">tel</span>' <span class=\"attr\">:</span> '<span class=\"attr\">text</span>'&#125; /&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>vue里面遇到的问题同上。</p>\n<h1 id=\"组件属性和事件\"><a href=\"#组件属性和事件\" class=\"headerlink\" title=\"组件属性和事件\"></a>组件属性和事件</h1><h2 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a>Props</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:right\">Name</th>\n<th>type</th>\n<th>default</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:right\">tip</td>\n<td>String</td>\n<td>‘请输入密码’</td>\n<td>输入提示语</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">passwordLength</td>\n<td>Number</td>\n<td>6</td>\n<td>格子位数</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">isPassword</td>\n<td>Boolean</td>\n<td>true</td>\n<td>显示明文或者密码黑点</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">isNumber</td>\n<td>Boolean</td>\n<td>true</td>\n<td>调出数字键盘或者混合键盘</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">isBtnCtr</td>\n<td>Boolean</td>\n<td>true</td>\n<td>使用确认按钮或者自动提交</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Events\"><a href=\"#Events\" class=\"headerlink\" title=\"Events\"></a>Events</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:right\">Name</th>\n<th>isRequire</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:right\">onConfirm</td>\n<td>require</td>\n<td>输入完成时的回调函数</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">onClose</td>\n<td>require</td>\n<td>关闭输入框时的回调函数</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"演示页面\"><a href=\"#演示页面\" class=\"headerlink\" title=\"演示页面\"></a>演示页面</h1><p><a href=\"http://60kmlh.ink/vue-GridPassword/\" target=\"_blank\" rel=\"noopener\"><img src=\"http://oq8q06ybp.bkt.clouddn.com/image/qrCode.png\" alt=\"手机扫描二维码查看\"></a></p>\n<h1 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h1><p><a href=\"http://github.com/60kmlh/react-GridPassword/\" target=\"_blank\" rel=\"noopener\">react版本</a></p>\n<p><a href=\"https://github.com/60kmlh/vue-GridPassword/\" target=\"_blank\" rel=\"noopener\">vue版本</a></p>"},{"title":"关于npm依赖包版本号的规则","date":"2017-08-04T16:00:00.000Z","_content":"之前有新同事接手项目，npm包安装完后，发现有功能失效了，经过排查后发现，有个依赖包安装完后的版本和package.json写的不一样。同时包的api有大的变动，导致了问题的发生。package.json为什么没有“生效”，带着疑惑，在官网上面找到了答案。\n<!--more-->\n# semantic versioning\n根据官网的描述，npm包的版本采用semantic versioning，即语义化版本。\n\n研究了semantic versioning的[规范](https://docs.npmjs.com/misc/semver)后，找到了问题产生的原因。\n\n1. semantic versioning的命名规则：\n> 版本格式：主版本号.次版本号.修订号，\n> \n> 版本号递增规则如下：\n> \n> 主版本号：当你做了不兼容的 API 修改， \n> \n> 次版本号：当你做了向下兼容的功能性新增，\n> \n> 修订号：当你做了向下兼容的问题修正。\n> \n> 先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。\n2. 高级范围语法\n\n以^开头的版本号规则叫做Caret Ranges，官网是这样描述Caret Ranges的：\n> Allows changes that do not modify the left-most non-zero digit in the [major, minor, patch] tuple. In other words, this allows patch and minor updates for versions 1.0.0 and above, patch updates for versions 0.X >=0.1.0, and no updates for versions 0.0.X.\n\n也就是说^开头的版本号， 不允许对[主版本号, 次版本号, 修订号]元组中最左边非零数字的更改，其他两位是可以更改的。\n\n以~开头的版本号规则叫做Tilde Ranges，Tilde Ranges的规则如下：\n> Allows patch-level changes if a minor version is specified on the comparator. Allows minor-level changes if not.\n\n和Caret Ranges相比，Tile Ranges只允许更改[主版本号, 次版本号, 修订号]的最后一位，即修订号。\n\n例子如下：\n\n^1.2.1 := >=1.2.1 <2.0.0\n\n~1.2.1 :=  >=1.2.1 <1.3.0\n\n而当运行npm i --save xx的时候，npm会优先考虑Caret Ranges，package.json里面的依赖包版本号就是^开头的。\n\n当包的次版本号或修订号有更新的时候，执行npm i安装下来的就是符合规则的最新的包了，而不一定是正确安装的版本。\n\n关于之前的问题，更新小版本的同时，包的api又发生了变动，才导致了问题的发生。\n\nsemantic versioning的规范里有一条是这样的：\n> Major version X (X.y.z | X > 0) MUST be incremented if any backwards incompatible changes are introduced to the public API. \n\n主版本号 X（X.y.z | X > 0）必须在有任何不兼容的修改被加入公共 API 时递增。\n\n也就是说之前出问题的包，如果严格遵循了semantic versioning,在api有break change是主版本号进行递增，是不会升级到api不兼容的版本，导致功能失效的。\n# 解决办法\n一般默认npm安装使用^开头的版本号是比较好的选择，可以接受小版本和补丁版本的变化，保证包中的小bug可以得到修复，使用~版本更改会更小。\n\n也可以指定特定的版本号，直接写1.1.2，前面不加~^或其它符号，这样就是写死了版本，但是如果依赖包发布新版本修复了一些小bug，则需要手动取更改package.json文件里对应的版本号。\n# 参考资料\n1. [https://docs.npmjs.com/misc/semver](https://docs.npmjs.com/misc/semver)\n2. [http://semver.org](http://semver.org)\n","source":"_posts/关于npm依赖包版本号的规则.md","raw":"---\ntitle: 关于npm依赖包版本号的规则\ndate: 2017-08-05\ntags: ['npm','版本']\ncategories: ['工具']\n---\n之前有新同事接手项目，npm包安装完后，发现有功能失效了，经过排查后发现，有个依赖包安装完后的版本和package.json写的不一样。同时包的api有大的变动，导致了问题的发生。package.json为什么没有“生效”，带着疑惑，在官网上面找到了答案。\n<!--more-->\n# semantic versioning\n根据官网的描述，npm包的版本采用semantic versioning，即语义化版本。\n\n研究了semantic versioning的[规范](https://docs.npmjs.com/misc/semver)后，找到了问题产生的原因。\n\n1. semantic versioning的命名规则：\n> 版本格式：主版本号.次版本号.修订号，\n> \n> 版本号递增规则如下：\n> \n> 主版本号：当你做了不兼容的 API 修改， \n> \n> 次版本号：当你做了向下兼容的功能性新增，\n> \n> 修订号：当你做了向下兼容的问题修正。\n> \n> 先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。\n2. 高级范围语法\n\n以^开头的版本号规则叫做Caret Ranges，官网是这样描述Caret Ranges的：\n> Allows changes that do not modify the left-most non-zero digit in the [major, minor, patch] tuple. In other words, this allows patch and minor updates for versions 1.0.0 and above, patch updates for versions 0.X >=0.1.0, and no updates for versions 0.0.X.\n\n也就是说^开头的版本号， 不允许对[主版本号, 次版本号, 修订号]元组中最左边非零数字的更改，其他两位是可以更改的。\n\n以~开头的版本号规则叫做Tilde Ranges，Tilde Ranges的规则如下：\n> Allows patch-level changes if a minor version is specified on the comparator. Allows minor-level changes if not.\n\n和Caret Ranges相比，Tile Ranges只允许更改[主版本号, 次版本号, 修订号]的最后一位，即修订号。\n\n例子如下：\n\n^1.2.1 := >=1.2.1 <2.0.0\n\n~1.2.1 :=  >=1.2.1 <1.3.0\n\n而当运行npm i --save xx的时候，npm会优先考虑Caret Ranges，package.json里面的依赖包版本号就是^开头的。\n\n当包的次版本号或修订号有更新的时候，执行npm i安装下来的就是符合规则的最新的包了，而不一定是正确安装的版本。\n\n关于之前的问题，更新小版本的同时，包的api又发生了变动，才导致了问题的发生。\n\nsemantic versioning的规范里有一条是这样的：\n> Major version X (X.y.z | X > 0) MUST be incremented if any backwards incompatible changes are introduced to the public API. \n\n主版本号 X（X.y.z | X > 0）必须在有任何不兼容的修改被加入公共 API 时递增。\n\n也就是说之前出问题的包，如果严格遵循了semantic versioning,在api有break change是主版本号进行递增，是不会升级到api不兼容的版本，导致功能失效的。\n# 解决办法\n一般默认npm安装使用^开头的版本号是比较好的选择，可以接受小版本和补丁版本的变化，保证包中的小bug可以得到修复，使用~版本更改会更小。\n\n也可以指定特定的版本号，直接写1.1.2，前面不加~^或其它符号，这样就是写死了版本，但是如果依赖包发布新版本修复了一些小bug，则需要手动取更改package.json文件里对应的版本号。\n# 参考资料\n1. [https://docs.npmjs.com/misc/semver](https://docs.npmjs.com/misc/semver)\n2. [http://semver.org](http://semver.org)\n","slug":"关于npm依赖包版本号的规则","published":1,"updated":"2022-04-13T14:14:08.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffu0030g3t8vxfnik15","content":"<p>之前有新同事接手项目，npm包安装完后，发现有功能失效了，经过排查后发现，有个依赖包安装完后的版本和package.json写的不一样。同时包的api有大的变动，导致了问题的发生。package.json为什么没有“生效”，带着疑惑，在官网上面找到了答案。<br><a id=\"more\"></a></p>\n<h1 id=\"semantic-versioning\"><a href=\"#semantic-versioning\" class=\"headerlink\" title=\"semantic versioning\"></a>semantic versioning</h1><p>根据官网的描述，npm包的版本采用semantic versioning，即语义化版本。</p>\n<p>研究了semantic versioning的<a href=\"https://docs.npmjs.com/misc/semver\" target=\"_blank\" rel=\"noopener\">规范</a>后，找到了问题产生的原因。</p>\n<ol>\n<li>semantic versioning的命名规则：<blockquote>\n<p>版本格式：主版本号.次版本号.修订号，</p>\n<p>版本号递增规则如下：</p>\n<p>主版本号：当你做了不兼容的 API 修改， </p>\n<p>次版本号：当你做了向下兼容的功能性新增，</p>\n<p>修订号：当你做了向下兼容的问题修正。</p>\n<p>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p>\n</blockquote>\n</li>\n<li>高级范围语法</li>\n</ol>\n<p>以^开头的版本号规则叫做Caret Ranges，官网是这样描述Caret Ranges的：</p>\n<blockquote>\n<p>Allows changes that do not modify the left-most non-zero digit in the [major, minor, patch] tuple. In other words, this allows patch and minor updates for versions 1.0.0 and above, patch updates for versions 0.X &gt;=0.1.0, and no updates for versions 0.0.X.</p>\n</blockquote>\n<p>也就是说^开头的版本号， 不允许对[主版本号, 次版本号, 修订号]元组中最左边非零数字的更改，其他两位是可以更改的。</p>\n<p>以~开头的版本号规则叫做Tilde Ranges，Tilde Ranges的规则如下：</p>\n<blockquote>\n<p>Allows patch-level changes if a minor version is specified on the comparator. Allows minor-level changes if not.</p>\n</blockquote>\n<p>和Caret Ranges相比，Tile Ranges只允许更改[主版本号, 次版本号, 修订号]的最后一位，即修订号。</p>\n<p>例子如下：</p>\n<p>^1.2.1 := &gt;=1.2.1 &lt;2.0.0</p>\n<p>~1.2.1 :=  &gt;=1.2.1 &lt;1.3.0</p>\n<p>而当运行npm i –save xx的时候，npm会优先考虑Caret Ranges，package.json里面的依赖包版本号就是^开头的。</p>\n<p>当包的次版本号或修订号有更新的时候，执行npm i安装下来的就是符合规则的最新的包了，而不一定是正确安装的版本。</p>\n<p>关于之前的问题，更新小版本的同时，包的api又发生了变动，才导致了问题的发生。</p>\n<p>semantic versioning的规范里有一条是这样的：</p>\n<blockquote>\n<p>Major version X (X.y.z | X &gt; 0) MUST be incremented if any backwards incompatible changes are introduced to the public API. </p>\n</blockquote>\n<p>主版本号 X（X.y.z | X &gt; 0）必须在有任何不兼容的修改被加入公共 API 时递增。</p>\n<p>也就是说之前出问题的包，如果严格遵循了semantic versioning,在api有break change是主版本号进行递增，是不会升级到api不兼容的版本，导致功能失效的。</p>\n<h1 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h1><p>一般默认npm安装使用^开头的版本号是比较好的选择，可以接受小版本和补丁版本的变化，保证包中的小bug可以得到修复，使用~版本更改会更小。</p>\n<p>也可以指定特定的版本号，直接写1.1.2，前面不加~^或其它符号，这样就是写死了版本，但是如果依赖包发布新版本修复了一些小bug，则需要手动取更改package.json文件里对应的版本号。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ol>\n<li><a href=\"https://docs.npmjs.com/misc/semver\" target=\"_blank\" rel=\"noopener\">https://docs.npmjs.com/misc/semver</a></li>\n<li><a href=\"http://semver.org\" target=\"_blank\" rel=\"noopener\">http://semver.org</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>之前有新同事接手项目，npm包安装完后，发现有功能失效了，经过排查后发现，有个依赖包安装完后的版本和package.json写的不一样。同时包的api有大的变动，导致了问题的发生。package.json为什么没有“生效”，带着疑惑，在官网上面找到了答案。<br>","more":"</p>\n<h1 id=\"semantic-versioning\"><a href=\"#semantic-versioning\" class=\"headerlink\" title=\"semantic versioning\"></a>semantic versioning</h1><p>根据官网的描述，npm包的版本采用semantic versioning，即语义化版本。</p>\n<p>研究了semantic versioning的<a href=\"https://docs.npmjs.com/misc/semver\" target=\"_blank\" rel=\"noopener\">规范</a>后，找到了问题产生的原因。</p>\n<ol>\n<li>semantic versioning的命名规则：<blockquote>\n<p>版本格式：主版本号.次版本号.修订号，</p>\n<p>版本号递增规则如下：</p>\n<p>主版本号：当你做了不兼容的 API 修改， </p>\n<p>次版本号：当你做了向下兼容的功能性新增，</p>\n<p>修订号：当你做了向下兼容的问题修正。</p>\n<p>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p>\n</blockquote>\n</li>\n<li>高级范围语法</li>\n</ol>\n<p>以^开头的版本号规则叫做Caret Ranges，官网是这样描述Caret Ranges的：</p>\n<blockquote>\n<p>Allows changes that do not modify the left-most non-zero digit in the [major, minor, patch] tuple. In other words, this allows patch and minor updates for versions 1.0.0 and above, patch updates for versions 0.X &gt;=0.1.0, and no updates for versions 0.0.X.</p>\n</blockquote>\n<p>也就是说^开头的版本号， 不允许对[主版本号, 次版本号, 修订号]元组中最左边非零数字的更改，其他两位是可以更改的。</p>\n<p>以~开头的版本号规则叫做Tilde Ranges，Tilde Ranges的规则如下：</p>\n<blockquote>\n<p>Allows patch-level changes if a minor version is specified on the comparator. Allows minor-level changes if not.</p>\n</blockquote>\n<p>和Caret Ranges相比，Tile Ranges只允许更改[主版本号, 次版本号, 修订号]的最后一位，即修订号。</p>\n<p>例子如下：</p>\n<p>^1.2.1 := &gt;=1.2.1 &lt;2.0.0</p>\n<p>~1.2.1 :=  &gt;=1.2.1 &lt;1.3.0</p>\n<p>而当运行npm i –save xx的时候，npm会优先考虑Caret Ranges，package.json里面的依赖包版本号就是^开头的。</p>\n<p>当包的次版本号或修订号有更新的时候，执行npm i安装下来的就是符合规则的最新的包了，而不一定是正确安装的版本。</p>\n<p>关于之前的问题，更新小版本的同时，包的api又发生了变动，才导致了问题的发生。</p>\n<p>semantic versioning的规范里有一条是这样的：</p>\n<blockquote>\n<p>Major version X (X.y.z | X &gt; 0) MUST be incremented if any backwards incompatible changes are introduced to the public API. </p>\n</blockquote>\n<p>主版本号 X（X.y.z | X &gt; 0）必须在有任何不兼容的修改被加入公共 API 时递增。</p>\n<p>也就是说之前出问题的包，如果严格遵循了semantic versioning,在api有break change是主版本号进行递增，是不会升级到api不兼容的版本，导致功能失效的。</p>\n<h1 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h1><p>一般默认npm安装使用^开头的版本号是比较好的选择，可以接受小版本和补丁版本的变化，保证包中的小bug可以得到修复，使用~版本更改会更小。</p>\n<p>也可以指定特定的版本号，直接写1.1.2，前面不加~^或其它符号，这样就是写死了版本，但是如果依赖包发布新版本修复了一些小bug，则需要手动取更改package.json文件里对应的版本号。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ol>\n<li><a href=\"https://docs.npmjs.com/misc/semver\" target=\"_blank\" rel=\"noopener\">https://docs.npmjs.com/misc/semver</a></li>\n<li><a href=\"http://semver.org\" target=\"_blank\" rel=\"noopener\">http://semver.org</a></li>\n</ol>"},{"title":"借助webpack实现前端代码的懒加载","date":"2017-08-25T16:00:00.000Z","_content":"## 背景\n随着前端项目的复杂度越来越大，要加载的js文件体积也越来越大。为了提高项目的首屏加载速度，实现在首屏时只加载首屏需要用到的js文件，用户使用其他功能时再加载对应的js文件，我们需要对js进行代码分割和懒加载。\n<!--more-->\n## webppack的懒加载方案\n### require.ensure()\nwebpack1(webpack2以上也可使用，但不推荐)使用require.ensure()定义一个代码切割点。\n> Note: require.ensure only loads the modules, it doesn’t evaluate them.\n````javascript\nrequire.ensure(dependencies: String[], callback: function(require), errorCallback: function(error), chunkName: String)\n````\ndependencies定义异步加载模块的依赖的一些模块，会和加载的模块打包到一起。\n\ncallback定义回调函数，使用require参数可以在回调函数内动态引入其他模块。\n\nerrorCallback定义加载错误时的回调函数。\n\nchunkName定义打包的chunk名称。\n#### 加载js函数\n````javascript\nfunction fn2() {\n  require.ensure([],function(){\n    var utils = require('./utils')\n    utils(function(){console.log('module2')})\n  },'utils')\n}\n\nmodule.exports = fn2\n````\n#### 加载react组件\n````javascript\nloadTimeComponent() {\n  if(this.state.timeComponent) {\n    return true\n  }\n  var that = this\n  require.ensure([],function(){\n    var Time = require('./Time.js').default\n    that.setState({\n      timeComponent: <Time alertTime={(time) => that.alertTime(time)} />\n    })\n  },'Time')\n}\n````\n#### 配合react-router3加载路由组件\n````javascript\nconst Home = (location, cb) => {\n  require.ensure([], require => {\n    cb(null, require('./components/Home').default)\n  }, 'Home')\n}\n\nfunction errorLoading(err) {\n  console.error('Dynamic page loading failed', err);\n}\n\nclass App extends Component {\n  render() {\n    return (\n      <div>\n        <Router history={hashHistory}>\n          <Route path='/' getComponent={(Home)} />\n        </Router>\n      </div>\n    )\n  }\n}\n````\n#### 配合react-router4加载路由组件\n由于react-router4没有getComponent方法，需要借助bundle-loader\n````javascript\nimport Bundle from './components/Bundle.js'\nimport HomeContainer from 'bundle-loader?lazy&name=[name]!./components/Home'\n\nconst Home = () => (\n  <Bundle load={HomeContainer}>\n    {(Home) => <Home />}\n  </Bundle>\n)\nclass App extends Component {\n  render() {\n    return (\n      <div>\n        <Route exact path='/' component={Home} />\n      </div>\n    )\n  }\n}\n\nexport default App\n\n````\n当Bundle组件的load方法被调用时，才会去加载对应的js文件。\n\n\n### import()\nwebpack2 的ES2015 loader中提供了import()方法在运行时动态按需加载ES2015 Module。\n\nwebpack将import()看做一个分割点并将其请求的module打包为一个独立的chunk。import()以模块名称作为参数名并且返回一个Promise对象。\n\n在Babel中使用import()方法，需要安装 dynamic-import插件并选择使用babel-preset-stage-3处理解析错误。\n\n#### 加载js函数\n```` javascript\nfunction fn2() {\n  import(/* webpackChunkName: \"utils\" */'./utils').then(module => {\n    var utils = module //es6模块 module.default\n    utils(function(){console.log('module2')})\n  })\n}\n\nmodule.exports = fn2\n// webpackChunkNam定义chunk名称\n````\n#### 加载react组件\n配合异步组件asyncComponent实现，内部借助async和await实现异步加载。\nreact-router4中使用也是可以配合asyncComponent。\n````javascript\nimport asyncComponent from './AsyncComponent'\nconst Head = asyncComponent(() => import(/* webpackChunkName: \"Head\" */'./Head'))\n\nclass App extends Component {\n  render() {\n    return (\n      <div>\n        <Head />\n      </div>\n    )\n  }\n} \n\nexport default App\n````\n#### 配合react-router3加载路由\n同样是借助getComponenet方法。\n````javascript\n<Route\n  path='time' \n  getComponent={\n    (location, cb) => import(/* webpackChunkName: \"Time\" */'./components/Time').\n                      then(module => cb(null, module.default)).\n                      catch(errorLoading)} \n/>\n````\n### bundle-loader和Bundle组件的实现原理\n#### bundle-loader核心源码\n````javascript\nif(query.lazy) {\n\t\tresult = [\n\t\t\t\"module.exports = function(cb) {\\n\",\n\t\t\t\"\trequire.ensure([], function(require) {\\n\",\n\t\t\t\"\t\tcb(require(\", loaderUtils.stringifyRequest(this, \"!!\" + remainingRequest), \"));\\n\",\n\t\t\t\"\t}\" + chunkNameParam + \");\\n\",\n\t\t\t\"}\"];\n\t} else {\n\t\tresult = [\n\t\t\t\"var cbs = [], \\n\",\n\t\t\t\"\tdata;\\n\",\n\t\t\t\"module.exports = function(cb) {\\n\",\n\t\t\t\"\tif(cbs) cbs.push(cb);\\n\",\n\t\t\t\"\telse cb(data);\\n\",\n\t\t\t\"}\\n\",\n\t\t\t\"require.ensure([], function(require) {\\n\",\n\t\t\t\"\tdata = require(\", loaderUtils.stringifyRequest(this, \"!!\" + remainingRequest), \");\\n\",\n\t\t\t\"\tvar callbacks = cbs;\\n\",\n\t\t\t\"\tcbs = null;\\n\",\n\t\t\t\"\tfor(var i = 0, l = callbacks.length; i < l; i++) {\\n\",\n\t\t\t\"\t\tcallbacks[i](data);\\n\",\n\t\t\t\"\t}\\n\",\n\t\t\t\"}\" + chunkNameParam + \");\"];\n\t}\n````\n可以看到bundle-loader也是借助require.ensure()实现异步加载，而且对方法进行了封装，可以传参name和lazy，分别定义chunk的名称和是否懒加载。\n\n#### Bundle组件的核心源码\n````javascript\nconstructor(props) {\n  super(props);\n\n  this.state = {\n      mod: null\n  };\n}\n\ncomponentWillMount() {\n    this.load(this.props)\n}\n\ncomponentWillReceiveProps(nextProps) {\n    if (nextProps.load !== this.props.load) {\n        this.load(nextProps)\n    }\n}\n\nload(props) {\n    this.setState({\n        mod: null\n    })\n    props.load((mod) => {\n        this.setState({\n            // handle both es imports and cjs\n            mod: mod.default ? mod.default : mod\n        })\n    })\n}\n\nrender() {\n    if(!this.state.mod)\n        return false\n    return this.props.children(this.state.mod)\n}\n````\n\n当bundle-loader加载文件加载完成时，Bundle组件的componentWillReceiveProps钩子被触发，调用load方法设置加载到的组件，最后将组件返回。\n\n### 完整代码\n\n[源码](https://github.com/60kmlh/codeSplitting)\n\n### 参考资料\n[webpack1 code-splitting](http://webpack.github.io/docs/code-splitting.html)\n\n[webpack1 lazy-loading](https://webpack.js.org/guides/lazy-loading/)\n\n[基于webpack Code Splitting实现react组件的按需加载](https://yq.aliyun.com/articles/71200)\n","source":"_posts/借助webpack实现前端代码的懒加载.md","raw":"---\ntitle: 借助webpack实现前端代码的懒加载\ndate: 2017-08-26\ntags: ['webpack','性能优化']\ncategories: ['工具']\n---\n## 背景\n随着前端项目的复杂度越来越大，要加载的js文件体积也越来越大。为了提高项目的首屏加载速度，实现在首屏时只加载首屏需要用到的js文件，用户使用其他功能时再加载对应的js文件，我们需要对js进行代码分割和懒加载。\n<!--more-->\n## webppack的懒加载方案\n### require.ensure()\nwebpack1(webpack2以上也可使用，但不推荐)使用require.ensure()定义一个代码切割点。\n> Note: require.ensure only loads the modules, it doesn’t evaluate them.\n````javascript\nrequire.ensure(dependencies: String[], callback: function(require), errorCallback: function(error), chunkName: String)\n````\ndependencies定义异步加载模块的依赖的一些模块，会和加载的模块打包到一起。\n\ncallback定义回调函数，使用require参数可以在回调函数内动态引入其他模块。\n\nerrorCallback定义加载错误时的回调函数。\n\nchunkName定义打包的chunk名称。\n#### 加载js函数\n````javascript\nfunction fn2() {\n  require.ensure([],function(){\n    var utils = require('./utils')\n    utils(function(){console.log('module2')})\n  },'utils')\n}\n\nmodule.exports = fn2\n````\n#### 加载react组件\n````javascript\nloadTimeComponent() {\n  if(this.state.timeComponent) {\n    return true\n  }\n  var that = this\n  require.ensure([],function(){\n    var Time = require('./Time.js').default\n    that.setState({\n      timeComponent: <Time alertTime={(time) => that.alertTime(time)} />\n    })\n  },'Time')\n}\n````\n#### 配合react-router3加载路由组件\n````javascript\nconst Home = (location, cb) => {\n  require.ensure([], require => {\n    cb(null, require('./components/Home').default)\n  }, 'Home')\n}\n\nfunction errorLoading(err) {\n  console.error('Dynamic page loading failed', err);\n}\n\nclass App extends Component {\n  render() {\n    return (\n      <div>\n        <Router history={hashHistory}>\n          <Route path='/' getComponent={(Home)} />\n        </Router>\n      </div>\n    )\n  }\n}\n````\n#### 配合react-router4加载路由组件\n由于react-router4没有getComponent方法，需要借助bundle-loader\n````javascript\nimport Bundle from './components/Bundle.js'\nimport HomeContainer from 'bundle-loader?lazy&name=[name]!./components/Home'\n\nconst Home = () => (\n  <Bundle load={HomeContainer}>\n    {(Home) => <Home />}\n  </Bundle>\n)\nclass App extends Component {\n  render() {\n    return (\n      <div>\n        <Route exact path='/' component={Home} />\n      </div>\n    )\n  }\n}\n\nexport default App\n\n````\n当Bundle组件的load方法被调用时，才会去加载对应的js文件。\n\n\n### import()\nwebpack2 的ES2015 loader中提供了import()方法在运行时动态按需加载ES2015 Module。\n\nwebpack将import()看做一个分割点并将其请求的module打包为一个独立的chunk。import()以模块名称作为参数名并且返回一个Promise对象。\n\n在Babel中使用import()方法，需要安装 dynamic-import插件并选择使用babel-preset-stage-3处理解析错误。\n\n#### 加载js函数\n```` javascript\nfunction fn2() {\n  import(/* webpackChunkName: \"utils\" */'./utils').then(module => {\n    var utils = module //es6模块 module.default\n    utils(function(){console.log('module2')})\n  })\n}\n\nmodule.exports = fn2\n// webpackChunkNam定义chunk名称\n````\n#### 加载react组件\n配合异步组件asyncComponent实现，内部借助async和await实现异步加载。\nreact-router4中使用也是可以配合asyncComponent。\n````javascript\nimport asyncComponent from './AsyncComponent'\nconst Head = asyncComponent(() => import(/* webpackChunkName: \"Head\" */'./Head'))\n\nclass App extends Component {\n  render() {\n    return (\n      <div>\n        <Head />\n      </div>\n    )\n  }\n} \n\nexport default App\n````\n#### 配合react-router3加载路由\n同样是借助getComponenet方法。\n````javascript\n<Route\n  path='time' \n  getComponent={\n    (location, cb) => import(/* webpackChunkName: \"Time\" */'./components/Time').\n                      then(module => cb(null, module.default)).\n                      catch(errorLoading)} \n/>\n````\n### bundle-loader和Bundle组件的实现原理\n#### bundle-loader核心源码\n````javascript\nif(query.lazy) {\n\t\tresult = [\n\t\t\t\"module.exports = function(cb) {\\n\",\n\t\t\t\"\trequire.ensure([], function(require) {\\n\",\n\t\t\t\"\t\tcb(require(\", loaderUtils.stringifyRequest(this, \"!!\" + remainingRequest), \"));\\n\",\n\t\t\t\"\t}\" + chunkNameParam + \");\\n\",\n\t\t\t\"}\"];\n\t} else {\n\t\tresult = [\n\t\t\t\"var cbs = [], \\n\",\n\t\t\t\"\tdata;\\n\",\n\t\t\t\"module.exports = function(cb) {\\n\",\n\t\t\t\"\tif(cbs) cbs.push(cb);\\n\",\n\t\t\t\"\telse cb(data);\\n\",\n\t\t\t\"}\\n\",\n\t\t\t\"require.ensure([], function(require) {\\n\",\n\t\t\t\"\tdata = require(\", loaderUtils.stringifyRequest(this, \"!!\" + remainingRequest), \");\\n\",\n\t\t\t\"\tvar callbacks = cbs;\\n\",\n\t\t\t\"\tcbs = null;\\n\",\n\t\t\t\"\tfor(var i = 0, l = callbacks.length; i < l; i++) {\\n\",\n\t\t\t\"\t\tcallbacks[i](data);\\n\",\n\t\t\t\"\t}\\n\",\n\t\t\t\"}\" + chunkNameParam + \");\"];\n\t}\n````\n可以看到bundle-loader也是借助require.ensure()实现异步加载，而且对方法进行了封装，可以传参name和lazy，分别定义chunk的名称和是否懒加载。\n\n#### Bundle组件的核心源码\n````javascript\nconstructor(props) {\n  super(props);\n\n  this.state = {\n      mod: null\n  };\n}\n\ncomponentWillMount() {\n    this.load(this.props)\n}\n\ncomponentWillReceiveProps(nextProps) {\n    if (nextProps.load !== this.props.load) {\n        this.load(nextProps)\n    }\n}\n\nload(props) {\n    this.setState({\n        mod: null\n    })\n    props.load((mod) => {\n        this.setState({\n            // handle both es imports and cjs\n            mod: mod.default ? mod.default : mod\n        })\n    })\n}\n\nrender() {\n    if(!this.state.mod)\n        return false\n    return this.props.children(this.state.mod)\n}\n````\n\n当bundle-loader加载文件加载完成时，Bundle组件的componentWillReceiveProps钩子被触发，调用load方法设置加载到的组件，最后将组件返回。\n\n### 完整代码\n\n[源码](https://github.com/60kmlh/codeSplitting)\n\n### 参考资料\n[webpack1 code-splitting](http://webpack.github.io/docs/code-splitting.html)\n\n[webpack1 lazy-loading](https://webpack.js.org/guides/lazy-loading/)\n\n[基于webpack Code Splitting实现react组件的按需加载](https://yq.aliyun.com/articles/71200)\n","slug":"借助webpack实现前端代码的懒加载","published":1,"updated":"2022-04-13T14:14:07.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffv0034g3t8dp5b1hzl","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>随着前端项目的复杂度越来越大，要加载的js文件体积也越来越大。为了提高项目的首屏加载速度，实现在首屏时只加载首屏需要用到的js文件，用户使用其他功能时再加载对应的js文件，我们需要对js进行代码分割和懒加载。<br><a id=\"more\"></a></p>\n<h2 id=\"webppack的懒加载方案\"><a href=\"#webppack的懒加载方案\" class=\"headerlink\" title=\"webppack的懒加载方案\"></a>webppack的懒加载方案</h2><h3 id=\"require-ensure\"><a href=\"#require-ensure\" class=\"headerlink\" title=\"require.ensure()\"></a>require.ensure()</h3><p>webpack1(webpack2以上也可使用，但不推荐)使用require.ensure()定义一个代码切割点。</p>\n<blockquote>\n<p>Note: require.ensure only loads the modules, it doesn’t evaluate them.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.ensure(dependencies: <span class=\"built_in\">String</span>[], <span class=\"attr\">callback</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>), <span class=\"title\">errorCallback</span>: <span class=\"title\">function</span>(<span class=\"params\">error</span>), <span class=\"title\">chunkName</span>: <span class=\"title\">String</span>)</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>dependencies定义异步加载模块的依赖的一些模块，会和加载的模块打包到一起。</p>\n<p>callback定义回调函数，使用require参数可以在回调函数内动态引入其他模块。</p>\n<p>errorCallback定义加载错误时的回调函数。</p>\n<p>chunkName定义打包的chunk名称。</p>\n<h4 id=\"加载js函数\"><a href=\"#加载js函数\" class=\"headerlink\" title=\"加载js函数\"></a>加载js函数</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">require</span>.ensure([],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> utils = <span class=\"built_in\">require</span>(<span class=\"string\">'./utils'</span>)</span><br><span class=\"line\">    utils(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'module2'</span>)&#125;)</span><br><span class=\"line\">  &#125;,<span class=\"string\">'utils'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = fn2</span><br></pre></td></tr></table></figure>\n<h4 id=\"加载react组件\"><a href=\"#加载react组件\" class=\"headerlink\" title=\"加载react组件\"></a>加载react组件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loadTimeComponent() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.state.timeComponent) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"built_in\">require</span>.ensure([],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> Time = <span class=\"built_in\">require</span>(<span class=\"string\">'./Time.js'</span>).default</span><br><span class=\"line\">    that.setState(&#123;</span><br><span class=\"line\">      timeComponent: <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Time</span> <span class=\"attr\">alertTime</span>=<span class=\"string\">&#123;(time)</span> =&gt;</span> that.alertTime(time)&#125; /&gt;</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,<span class=\"string\">'Time'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"配合react-router3加载路由组件\"><a href=\"#配合react-router3加载路由组件\" class=\"headerlink\" title=\"配合react-router3加载路由组件\"></a>配合react-router3加载路由组件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Home = <span class=\"function\">(<span class=\"params\">location, cb</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">require</span>.ensure([], <span class=\"built_in\">require</span> =&gt; &#123;</span><br><span class=\"line\">    cb(<span class=\"literal\">null</span>, <span class=\"built_in\">require</span>(<span class=\"string\">'./components/Home'</span>).default)</span><br><span class=\"line\">  &#125;, <span class=\"string\">'Home'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">errorLoading</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.error(<span class=\"string\">'Dynamic page loading failed'</span>, err);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class=\"line\">          &lt;Route path=<span class=\"string\">'/'</span> getComponent=&#123;(Home)&#125; /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Router&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"配合react-router4加载路由组件\"><a href=\"#配合react-router4加载路由组件\" class=\"headerlink\" title=\"配合react-router4加载路由组件\"></a>配合react-router4加载路由组件</h4><p>由于react-router4没有getComponent方法，需要借助bundle-loader<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Bundle <span class=\"keyword\">from</span> <span class=\"string\">'./components/Bundle.js'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> HomeContainer <span class=\"keyword\">from</span> <span class=\"string\">'bundle-loader?lazy&amp;name=[name]!./components/Home'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Home = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (</span><br><span class=\"line\">  &lt;Bundle load=&#123;HomeContainer&#125;&gt;</span><br><span class=\"line\">    &#123;(Home) =&gt; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Home</span> /&gt;</span></span>&#125;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Bundle&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br><span class=\"line\"><span class=\"regexp\">class App extends Component &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  render() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;Route exact path='/</span><span class=\"string\">' component=&#123;Home&#125; /&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    )</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">export default App</span></span><br></pre></td></tr></table></figure></p>\n<p>当Bundle组件的load方法被调用时，才会去加载对应的js文件。</p>\n<h3 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import()\"></a>import()</h3><p>webpack2 的ES2015 loader中提供了import()方法在运行时动态按需加载ES2015 Module。</p>\n<p>webpack将import()看做一个分割点并将其请求的module打包为一个独立的chunk。import()以模块名称作为参数名并且返回一个Promise对象。</p>\n<p>在Babel中使用import()方法，需要安装 dynamic-import插件并选择使用babel-preset-stage-3处理解析错误。</p>\n<h4 id=\"加载js函数-1\"><a href=\"#加载js函数-1\" class=\"headerlink\" title=\"加载js函数\"></a>加载js函数</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: \"utils\" */</span><span class=\"string\">'./utils'</span>).then(<span class=\"function\"><span class=\"params\">module</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> utils = <span class=\"built_in\">module</span> <span class=\"comment\">//es6模块 module.default</span></span><br><span class=\"line\">    utils(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'module2'</span>)&#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = fn2</span><br><span class=\"line\"><span class=\"comment\">// webpackChunkNam定义chunk名称</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"加载react组件-1\"><a href=\"#加载react组件-1\" class=\"headerlink\" title=\"加载react组件\"></a>加载react组件</h4><p>配合异步组件asyncComponent实现，内部借助async和await实现异步加载。<br>react-router4中使用也是可以配合asyncComponent。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> asyncComponent <span class=\"keyword\">from</span> <span class=\"string\">'./AsyncComponent'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Head = asyncComponent(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: \"Head\" */</span><span class=\"string\">'./Head'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;Head /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125; </span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default App</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"配合react-router3加载路由\"><a href=\"#配合react-router3加载路由\" class=\"headerlink\" title=\"配合react-router3加载路由\"></a>配合react-router3加载路由</h4><p>同样是借助getComponenet方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Route</span><br><span class=\"line\">  path=<span class=\"string\">'time'</span> </span><br><span class=\"line\">  getComponent=&#123;</span><br><span class=\"line\">    (location, cb) =&gt; <span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: \"Time\" */</span><span class=\"string\">'./components/Time'</span>).</span><br><span class=\"line\">                      then(<span class=\"function\"><span class=\"params\">module</span> =&gt;</span> cb(<span class=\"literal\">null</span>, <span class=\"built_in\">module</span>.default)).</span><br><span class=\"line\">                      <span class=\"keyword\">catch</span>(errorLoading)&#125; </span><br><span class=\"line\">/&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"bundle-loader和Bundle组件的实现原理\"><a href=\"#bundle-loader和Bundle组件的实现原理\" class=\"headerlink\" title=\"bundle-loader和Bundle组件的实现原理\"></a>bundle-loader和Bundle组件的实现原理</h3><h4 id=\"bundle-loader核心源码\"><a href=\"#bundle-loader核心源码\" class=\"headerlink\" title=\"bundle-loader核心源码\"></a>bundle-loader核心源码</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(query.lazy) &#123;</span><br><span class=\"line\">\t\tresult = [</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"module.exports = function(cb) &#123;\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\trequire.ensure([], function(require) &#123;\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\t\tcb(require(\"</span>, loaderUtils.stringifyRequest(<span class=\"keyword\">this</span>, <span class=\"string\">\"!!\"</span> + remainingRequest), <span class=\"string\">\"));\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\t&#125;\"</span> + chunkNameParam + <span class=\"string\">\");\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"&#125;\"</span>];</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tresult = [</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"var cbs = [], \\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\tdata;\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"module.exports = function(cb) &#123;\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\tif(cbs) cbs.push(cb);\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\telse cb(data);\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"&#125;\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"require.ensure([], function(require) &#123;\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\tdata = require(\"</span>, loaderUtils.stringifyRequest(<span class=\"keyword\">this</span>, <span class=\"string\">\"!!\"</span> + remainingRequest), <span class=\"string\">\");\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\tvar callbacks = cbs;\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\tcbs = null;\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\tfor(var i = 0, l = callbacks.length; i &lt; l; i++) &#123;\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\t\tcallbacks[i](data);\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\t&#125;\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"&#125;\"</span> + chunkNameParam + <span class=\"string\">\");\"</span>];</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到bundle-loader也是借助require.ensure()实现异步加载，而且对方法进行了封装，可以传参name和lazy，分别定义chunk的名称和是否懒加载。</p>\n<h4 id=\"Bundle组件的核心源码\"><a href=\"#Bundle组件的核心源码\" class=\"headerlink\" title=\"Bundle组件的核心源码\"></a>Bundle组件的核心源码</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      mod: <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">componentWillMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.load(<span class=\"keyword\">this</span>.props)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextProps.load !== <span class=\"keyword\">this</span>.props.load) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.load(nextProps)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">load(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        mod: <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    props.load(<span class=\"function\">(<span class=\"params\">mod</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            <span class=\"comment\">// handle both es imports and cjs</span></span><br><span class=\"line\">            mod: mod.default ? mod.default : mod</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.state.mod)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children(<span class=\"keyword\">this</span>.state.mod)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当bundle-loader加载文件加载完成时，Bundle组件的componentWillReceiveProps钩子被触发，调用load方法设置加载到的组件，最后将组件返回。</p>\n<h3 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><p><a href=\"https://github.com/60kmlh/codeSplitting\" target=\"_blank\" rel=\"noopener\">源码</a></p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"http://webpack.github.io/docs/code-splitting.html\" target=\"_blank\" rel=\"noopener\">webpack1 code-splitting</a></p>\n<p><a href=\"https://webpack.js.org/guides/lazy-loading/\" target=\"_blank\" rel=\"noopener\">webpack1 lazy-loading</a></p>\n<p><a href=\"https://yq.aliyun.com/articles/71200\" target=\"_blank\" rel=\"noopener\">基于webpack Code Splitting实现react组件的按需加载</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>随着前端项目的复杂度越来越大，要加载的js文件体积也越来越大。为了提高项目的首屏加载速度，实现在首屏时只加载首屏需要用到的js文件，用户使用其他功能时再加载对应的js文件，我们需要对js进行代码分割和懒加载。<br>","more":"</p>\n<h2 id=\"webppack的懒加载方案\"><a href=\"#webppack的懒加载方案\" class=\"headerlink\" title=\"webppack的懒加载方案\"></a>webppack的懒加载方案</h2><h3 id=\"require-ensure\"><a href=\"#require-ensure\" class=\"headerlink\" title=\"require.ensure()\"></a>require.ensure()</h3><p>webpack1(webpack2以上也可使用，但不推荐)使用require.ensure()定义一个代码切割点。</p>\n<blockquote>\n<p>Note: require.ensure only loads the modules, it doesn’t evaluate them.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.ensure(dependencies: <span class=\"built_in\">String</span>[], <span class=\"attr\">callback</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>), <span class=\"title\">errorCallback</span>: <span class=\"title\">function</span>(<span class=\"params\">error</span>), <span class=\"title\">chunkName</span>: <span class=\"title\">String</span>)</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>dependencies定义异步加载模块的依赖的一些模块，会和加载的模块打包到一起。</p>\n<p>callback定义回调函数，使用require参数可以在回调函数内动态引入其他模块。</p>\n<p>errorCallback定义加载错误时的回调函数。</p>\n<p>chunkName定义打包的chunk名称。</p>\n<h4 id=\"加载js函数\"><a href=\"#加载js函数\" class=\"headerlink\" title=\"加载js函数\"></a>加载js函数</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">require</span>.ensure([],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> utils = <span class=\"built_in\">require</span>(<span class=\"string\">'./utils'</span>)</span><br><span class=\"line\">    utils(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'module2'</span>)&#125;)</span><br><span class=\"line\">  &#125;,<span class=\"string\">'utils'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = fn2</span><br></pre></td></tr></table></figure>\n<h4 id=\"加载react组件\"><a href=\"#加载react组件\" class=\"headerlink\" title=\"加载react组件\"></a>加载react组件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loadTimeComponent() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.state.timeComponent) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"built_in\">require</span>.ensure([],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> Time = <span class=\"built_in\">require</span>(<span class=\"string\">'./Time.js'</span>).default</span><br><span class=\"line\">    that.setState(&#123;</span><br><span class=\"line\">      timeComponent: <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Time</span> <span class=\"attr\">alertTime</span>=<span class=\"string\">&#123;(time)</span> =&gt;</span> that.alertTime(time)&#125; /&gt;</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,<span class=\"string\">'Time'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"配合react-router3加载路由组件\"><a href=\"#配合react-router3加载路由组件\" class=\"headerlink\" title=\"配合react-router3加载路由组件\"></a>配合react-router3加载路由组件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Home = <span class=\"function\">(<span class=\"params\">location, cb</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">require</span>.ensure([], <span class=\"built_in\">require</span> =&gt; &#123;</span><br><span class=\"line\">    cb(<span class=\"literal\">null</span>, <span class=\"built_in\">require</span>(<span class=\"string\">'./components/Home'</span>).default)</span><br><span class=\"line\">  &#125;, <span class=\"string\">'Home'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">errorLoading</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.error(<span class=\"string\">'Dynamic page loading failed'</span>, err);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class=\"line\">          &lt;Route path=<span class=\"string\">'/'</span> getComponent=&#123;(Home)&#125; /&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Router&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"配合react-router4加载路由组件\"><a href=\"#配合react-router4加载路由组件\" class=\"headerlink\" title=\"配合react-router4加载路由组件\"></a>配合react-router4加载路由组件</h4><p>由于react-router4没有getComponent方法，需要借助bundle-loader<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Bundle <span class=\"keyword\">from</span> <span class=\"string\">'./components/Bundle.js'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> HomeContainer <span class=\"keyword\">from</span> <span class=\"string\">'bundle-loader?lazy&amp;name=[name]!./components/Home'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Home = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (</span><br><span class=\"line\">  &lt;Bundle load=&#123;HomeContainer&#125;&gt;</span><br><span class=\"line\">    &#123;(Home) =&gt; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Home</span> /&gt;</span></span>&#125;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Bundle&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br><span class=\"line\"><span class=\"regexp\">class App extends Component &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  render() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;Route exact path='/</span><span class=\"string\">' component=&#123;Home&#125; /&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    )</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">export default App</span></span><br></pre></td></tr></table></figure></p>\n<p>当Bundle组件的load方法被调用时，才会去加载对应的js文件。</p>\n<h3 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import()\"></a>import()</h3><p>webpack2 的ES2015 loader中提供了import()方法在运行时动态按需加载ES2015 Module。</p>\n<p>webpack将import()看做一个分割点并将其请求的module打包为一个独立的chunk。import()以模块名称作为参数名并且返回一个Promise对象。</p>\n<p>在Babel中使用import()方法，需要安装 dynamic-import插件并选择使用babel-preset-stage-3处理解析错误。</p>\n<h4 id=\"加载js函数-1\"><a href=\"#加载js函数-1\" class=\"headerlink\" title=\"加载js函数\"></a>加载js函数</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: \"utils\" */</span><span class=\"string\">'./utils'</span>).then(<span class=\"function\"><span class=\"params\">module</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> utils = <span class=\"built_in\">module</span> <span class=\"comment\">//es6模块 module.default</span></span><br><span class=\"line\">    utils(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'module2'</span>)&#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = fn2</span><br><span class=\"line\"><span class=\"comment\">// webpackChunkNam定义chunk名称</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"加载react组件-1\"><a href=\"#加载react组件-1\" class=\"headerlink\" title=\"加载react组件\"></a>加载react组件</h4><p>配合异步组件asyncComponent实现，内部借助async和await实现异步加载。<br>react-router4中使用也是可以配合asyncComponent。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> asyncComponent <span class=\"keyword\">from</span> <span class=\"string\">'./AsyncComponent'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Head = asyncComponent(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: \"Head\" */</span><span class=\"string\">'./Head'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;Head /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125; </span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default App</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"配合react-router3加载路由\"><a href=\"#配合react-router3加载路由\" class=\"headerlink\" title=\"配合react-router3加载路由\"></a>配合react-router3加载路由</h4><p>同样是借助getComponenet方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Route</span><br><span class=\"line\">  path=<span class=\"string\">'time'</span> </span><br><span class=\"line\">  getComponent=&#123;</span><br><span class=\"line\">    (location, cb) =&gt; <span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: \"Time\" */</span><span class=\"string\">'./components/Time'</span>).</span><br><span class=\"line\">                      then(<span class=\"function\"><span class=\"params\">module</span> =&gt;</span> cb(<span class=\"literal\">null</span>, <span class=\"built_in\">module</span>.default)).</span><br><span class=\"line\">                      <span class=\"keyword\">catch</span>(errorLoading)&#125; </span><br><span class=\"line\">/&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"bundle-loader和Bundle组件的实现原理\"><a href=\"#bundle-loader和Bundle组件的实现原理\" class=\"headerlink\" title=\"bundle-loader和Bundle组件的实现原理\"></a>bundle-loader和Bundle组件的实现原理</h3><h4 id=\"bundle-loader核心源码\"><a href=\"#bundle-loader核心源码\" class=\"headerlink\" title=\"bundle-loader核心源码\"></a>bundle-loader核心源码</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(query.lazy) &#123;</span><br><span class=\"line\">\t\tresult = [</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"module.exports = function(cb) &#123;\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\trequire.ensure([], function(require) &#123;\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\t\tcb(require(\"</span>, loaderUtils.stringifyRequest(<span class=\"keyword\">this</span>, <span class=\"string\">\"!!\"</span> + remainingRequest), <span class=\"string\">\"));\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\t&#125;\"</span> + chunkNameParam + <span class=\"string\">\");\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"&#125;\"</span>];</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tresult = [</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"var cbs = [], \\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\tdata;\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"module.exports = function(cb) &#123;\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\tif(cbs) cbs.push(cb);\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\telse cb(data);\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"&#125;\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"require.ensure([], function(require) &#123;\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\tdata = require(\"</span>, loaderUtils.stringifyRequest(<span class=\"keyword\">this</span>, <span class=\"string\">\"!!\"</span> + remainingRequest), <span class=\"string\">\");\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\tvar callbacks = cbs;\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\tcbs = null;\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\tfor(var i = 0, l = callbacks.length; i &lt; l; i++) &#123;\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\t\tcallbacks[i](data);\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"\t&#125;\\n\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"&#125;\"</span> + chunkNameParam + <span class=\"string\">\");\"</span>];</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到bundle-loader也是借助require.ensure()实现异步加载，而且对方法进行了封装，可以传参name和lazy，分别定义chunk的名称和是否懒加载。</p>\n<h4 id=\"Bundle组件的核心源码\"><a href=\"#Bundle组件的核心源码\" class=\"headerlink\" title=\"Bundle组件的核心源码\"></a>Bundle组件的核心源码</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      mod: <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">componentWillMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.load(<span class=\"keyword\">this</span>.props)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextProps.load !== <span class=\"keyword\">this</span>.props.load) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.load(nextProps)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">load(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        mod: <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    props.load(<span class=\"function\">(<span class=\"params\">mod</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            <span class=\"comment\">// handle both es imports and cjs</span></span><br><span class=\"line\">            mod: mod.default ? mod.default : mod</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.state.mod)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children(<span class=\"keyword\">this</span>.state.mod)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当bundle-loader加载文件加载完成时，Bundle组件的componentWillReceiveProps钩子被触发，调用load方法设置加载到的组件，最后将组件返回。</p>\n<h3 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><p><a href=\"https://github.com/60kmlh/codeSplitting\" target=\"_blank\" rel=\"noopener\">源码</a></p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"http://webpack.github.io/docs/code-splitting.html\" target=\"_blank\" rel=\"noopener\">webpack1 code-splitting</a></p>\n<p><a href=\"https://webpack.js.org/guides/lazy-loading/\" target=\"_blank\" rel=\"noopener\">webpack1 lazy-loading</a></p>\n<p><a href=\"https://yq.aliyun.com/articles/71200\" target=\"_blank\" rel=\"noopener\">基于webpack Code Splitting实现react组件的按需加载</a></p>"},{"title":"使用队列解决两道题目","date":"2018-04-20T16:00:00.000Z","_content":"## 题目一 LazyMan\n\n* 描述\n\n> 实现一个LazyMan，可以按照以下方式调用:\n>\n> LazyMan(“Hank”)输出:\n>\n> Hi! This is Hank!\n>  \n> LazyMan(“Hank”).sleep(10).eat(“dinner”)输出\n>\n> Hi! This is Hank!\n>\n> //等待10秒..\n>\n> Wake up after 10\n>\n> Eat dinner~\n> \n> LazyMan(“Hank”).eat(“dinner”).eat(“supper”)输出\n>\n> Hi This is Hank!\n>\n> Eat dinner~\n>\n> Eat supper~\n>  \n> LazyMan(“Hank”).sleepFirst(5).eat(“supper”)输出\n>\n> //等待5秒\n>\n> Wake up after 5\n>\n> Hi This is Hank!\n>\n> Eat supper\n>\n>  \n> 以此类推。\n\n* 思路\n\n1. 借助队列的先进先出特性实现异步流的控制\n2. 利用闭包将事件保存至队列中\n3. 创建一个中间件next()用来触发事件\n4. 通过在每次事件结束之后返回对象本身，来实现链式调用。\n\n* 实现\n\n创建一个_LazyMan类，构造函数里面创建一个数组当做队列使用，存储排队执行的事件。\n````javascript\nclass _LazyMan {\n  constructor(name) {\n    this.task = [] //事件存储队列\n    var self = this //绑定this指向 可用箭头函数代替\n    var fn = (function(name) {\n      //借助闭包绑定作用域\n      return function() {\n        console.log(`Hi! This is ${name} !`)\n        self.next()\n      }\n    })(name)\n    this.task.push(fn)\n    //使用setTimeout方法，初始化任务，将执行函数放到下一次事件循环当中，从而达到先注册事件，后执行的目的\n    setTimeout(function() {\n      self.next()\n    }, 0)\n  } \n}\n````\n加下来添加next方法,每次触发next方法，从队列头部读取事件执行。\n````javascript\nnext() {\n  var fn = this.task.shift()\n  if(fn) fn()\n}\n````\n添加eat方法，函数执行结束之后，调用next进入下一个事件，同时通过返回this实现链式调用。\n````javascript\neat(food) {\n  var self = this \n  var fn = (function(food) {\n    return function() {\n      console.log(`Eat ${name} '~'`)\n      self.next()\n    }\n  })(food)\n  this.task.push(fn)\n  return this\n}\n````\n添加sleep方法，借助setTimeout实现延迟的效果\n````javascript\nsleep(time) {\n  var self = this\n  var fn = (function(name) {\n    return function() {\n      setTimeout(function() {\n        console.log(\"Wake up after \" + time + \"s!\");\n        self.next()\n      }, time * 1000)\n    }\n  })(name)\n  this.task.push(fn)\n  return this\n}\n````\n添加sleepFirst方法，sleepFirst函数需要最先执行，所以我们需要在任务队列前面放入，然后再执行后面的任务\n````javascript\nsleepFirst(time) {\n  var self = this\n  var fn = (function(name) {\n    return function() {\n      setTimeout(function() {\n        console.log(\"Wake up after \" + time + \"s!\");\n        self.next()\n      }, time * 1000)\n    }\n  })(name)\n  this.task.unshift(fn)\n  return this\n}\n````\n调用Lazyman的时候不需要用到new关键字，这意味着我们需要使用工厂函数返回Layman实例\n````javascript\nfunction LazyMan(name){\n  return new _LazyMan(name);\n}\n````\n这样，Lazyman这一题就实现了。\n* 使用Promise\n\n使用Promise的解法，本质上也是事先构造一个事件队列，在下一次事件循环开始时，开始执行。\n\n与上一个解法不同的是，先前的解法，是在每次的事件结束之后手动调用 next() 方法，去推动事件的执行流程。\n\n而Promise的解法，是借助了Promise的状态resolved之后，触发then方法进行回调。（手动返回Promise也行，下面会演示）\n\n* Promise版的实现\n\n创建一个_LazyMan类\n\n````javascript\nclass _LazyMan {\n  constructor(name) {\n    this.task = [] //事件存储队列\n    var start = Promise.resolve() //构造第一个Promise，借助其then回调触发事件流程，亦可用第一个task任务来生成该Promise。\n\n    var fn = (function(name) {\n      return new Promise(function(resolve, reject) {\n        console.log(`Hi! This is ${name} !`)\n        resolve()\n      })\n    })(name)\n\n    //或者手动返回一个Promise，后面的eat方法同理\n    // var fn = (function(name) {\n    //   return function() {\n    //     console.log(`Hi! This is ${name} !`)\n    //     return Promise.resolve()\n    //   }\n    // })(name)\n\n    this.task.push(fn)\n\n    setTimeout(() => {\n      this.task.forEach(task => {\n        start = start.then(task)\n      })\n    }, 0)\n  }\n}\n````\n\neat方法\n````javascript\n  eat(food) {\n    var fn = function() {\n      return new Promise(function(resolve, reject) {\n        console.log(`Eat ${food} '~'`)\n        resolve()\n      })\n    }\n    this.task.push(fn)\n    return this\n  }\n````\n其余方法同理，不赘述，具体实现见源码。\n\n## 题目二 AJAX按钮\n\n* 描述\n\n> 某个应用模块由文本框 input，以及按钮 A，按钮 B 组成。点击按钮 A，会向地址 urlA 发出一个 ajax 请求，并将返回的字符串填充到 input 中（覆盖 input 中原有的数据），点击按钮 B，会向地址 urlB 发出一个 ajax 请求，并将返回的字符串填充到 input 中（覆盖 > input 中原有的数据）。\n> \n> 当用户依次点击按钮 A、B 的时候，预期的效果是 input 依次被 urlA、urlB 返回的数据填充，但是由于到 urlA 的请求返回比较慢，导致 urlB 返回的数据被 urlA 返回的数据覆盖了，与用户预期的顺序不一致。\n>\n> 请问如何设计代码，解决这个问题？\n\n* 思路\n\n借助队列，点击事件触发时，将将请求塞进压进队列，通过进出队列控制两次请求的触发的顺序。\n\n* 实现\n\nhtml结构\n````html\n<body>\n    <input type=\"text\"/>\n    <button id=\"btnA\">A</button>\n    <button id=\"btnB\">B</button>\n</body>\n````\n借助Promise和setTimeout模拟接口返回\n````javascript\nlet btnA = document.querySelector('#btnA')\nlet btnB = document.querySelector('#btnB')\nlet input = document.querySelector('input');\n//模拟ajax\nlet ajaxA = () => new Promise((resolve, reject) => {\n    setTimeout(() => {\n        input.value = 'ajaxA response';\n        resolve()\n    }, 4000)\n})\nlet ajaxB = () => new Promise((resolve, reject) => {\n    setTimeout(() => {\n        input.value = 'ajaxB response';\n        resolve()\n    }, 1000)\n})\n````\n构造一个队列类以及队列操作方法的实现\n````javascript\nclass Queue {\n  constructor() {\n    this.list = []\n  }\n  enqueue(ele) {\n    this.list.push(ele)\n  }\n  dequeue(ele) {\n    return this.list.shift(ele)\n  }\n  isEmpty() {\n    return this.list.length === 0\n  }\n}\n````\n构建队列实例，点击时将事件压入队列,然后推动队列执行流程。\n````javascript\nlet eventQueue = new Queue()\nlet flag = false\n\nlet run = async function() {\n  flag = true\n  while(!eventQueue.isEmpty()) {\n    await eventQueue.dequeue()()\n  }\n  flag = false\n}\n\nbtnA.addEventListener('click', () => {\n  eventQueue.enqueue(ajaxA);\n  if (!flag) { run() }\n})\nbtnB.addEventListener('click', () => {\n  eventQueue.enqueue(ajaxB);\n  if (!flag) { run() }\n})\n````\n以上就是这道题的解法，但是这里的是把整个请求方法塞进队列，一个个取出来执行，相当于是同步的方法。\n\n下面可以改成异步的，修改成将请求方法执行完之后返回的Promise塞进队列，这个时候不会阻塞的执行，读取队列的时候，借助async判断Promise的状态已经变成resolved即可。\n\n* 实现\n\n修改按钮的请求方法，Promise状态变为resolved时，将响应返回。\n\n````javascript\nlet ajaxA = () => new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('ajaxA response')\n    }, 4000)\n})\n````\n修改按钮点击事件，点击时执行请求方法，将Promise压入队列。\n````javascript\nbtnA.addEventListener('click', () => {\n  eventQueue.enqueue(ajaxA());\n  if (!flag) { run() }\n})\n````\nrun方法修改为借助await控制异步队列。\n````javascript\nlet run = async function() {\n  flag = true\n  while(!eventQueue.isEmpty()) {\n    let res = await eventQueue.dequeue()\n    input.value = res\n    console.log('inputValue:',res)\n  }\n  flag = false\n}\n````\n## 源码\n* Lazyman\n````javascript\nclass _LazyMan {\n  constructor(name) {\n    this.task = []\n    var self = this\n    var fn = (function(name) {\n      return function() {\n        console.log(`Hi! This is ${name} !`)\n        self.next()\n      }\n    })(name)\n    this.task.push(fn)\n\n    setTimeout(function() {\n      self.next()\n    }, 0)\n  }\n  \n  next() {\n    var fn = this.task.shift()\n    fn && fn()\n  }\n\n  eat(food) {\n    var self = this\n    var fn = (function(food) {\n      return function() {\n        console.log(`Eat ${food} '~'`)\n        self.next()\n      }\n    })(food)\n    this.task.push(fn)\n    return this\n  }\n\n\n  sleep(time) {\n    var self = this\n    var fn = (function(name) {\n      return function() {\n        setTimeout(function() {\n          console.log(\"Wake up after \" + time + \"s!\");\n          self.next()\n        }, time * 1000)\n      }\n    })(name)\n    this.task.push(fn)\n    return this\n  }\n\n  sleepFirst(time) {\n    var self = this\n    var fn = (function(name) {\n      return function() {\n        setTimeout(function() {\n          console.log(\"Wake up after \" + time + \"s!\");\n          self.next()\n        }, time * 1000)\n      }\n    })(name)\n    this.task.unshift(fn)\n    return this\n  }\n}\n\nfunction LazyMan(name){\n  return new _LazyMan(name);\n}\n````\n* Pormise版Lazyman\n````javascript\nclass _LazyMan {\n  constructor(name) {\n    this.task = []\n    var start = Promise.resolve()\n\n    var fn = (function(name) {\n      return new Promise(function(resolve, reject) {\n        console.log(`Hi! This is ${name} !`)\n        resolve()\n      })\n    })(name)\n\n    this.task.push(fn)\n\n    setTimeout(() => {\n      this.task.forEach(task => {\n        start = start.then(task)\n      })\n    }, 0)\n  }\n\n  eat(food) {\n    var fn = function() {\n      return new Promise(function(resolve, reject) {\n        console.log(`Eat ${food} '~'`)\n        resolve()\n      })\n    }\n    this.task.push(fn)\n    return this\n  }\n\n  sleep(time) {\n    var fn = function() {\n      return new Promise(function(resolve, reject) {\n        setTimeout(function(){\n          console.log(\"Wake up after \" + time + \"s!\");\n          resolve()\n        }, time * 1000)\n      })\n    }\n\n    this.task.push(fn)\n    return this\n  }\n\n  sleepFirst(time) {\n    var fn = function() {\n      return new Promise(function(resolve, reject) {\n        setTimeout(function(){\n          console.log(\"Wake up after \" + time + \"s!\");\n          resolve()\n        }, time * 1000)\n      })\n    }\n\n    this.task.unshift(fn)\n    return this\n  }\n\n}\n\nfunction LazyMan(name) {\n  return new _LazyMan(name)\n}\n````\n* AJAX按钮 同步的解法\n````javascript\nlet btnA = document.querySelector('#btnA')\nlet btnB = document.querySelector('#btnB')\nlet input = document.querySelector('input');\n\nlet ajaxA = () => new Promise((resolve, reject) => {\n    setTimeout(() => {\n        console.log('ajaxA end')\n        input.value = 'ajaxA end';\n        resolve()\n    }, 4000)\n})\nlet ajaxB = () => new Promise((resolve, reject) => {\n    setTimeout(() => {\n        console.log('ajaxB end')\n        input.value = 'ajaxB end';\n        resolve()\n    }, 1000)\n})\n\nclass Queue {\n  constructor() {\n    this.list = []\n  }\n  enqueue(ele) {\n    this.list.push(ele)\n  }\n  dequeue(ele) {\n    return this.list.shift(ele)\n  }\n  isEmpty() {\n    return this.list.length === 0\n  }\n}\n\nlet eventQueue = new Queue()\nlet flag = false\n\nlet run = async function() {\n  flag = true\n  while(!eventQueue.isEmpty()) {\n    await eventQueue.dequeue()()\n  }\n  flag = false\n}\n\nbtnA.addEventListener('click', () => {\n  eventQueue.enqueue(ajaxA);\n  if (!flag) { run() }\n})\nbtnB.addEventListener('click', () => {\n  eventQueue.enqueue(ajaxB);\n  if (!flag) { run() }\n})\n````\n* AJAX按钮 异步的解法\n````javascript\nlet btnA = document.querySelector('#btnA')\nlet btnB = document.querySelector('#btnB')\nlet input = document.querySelector('input');\n\nlet ajaxA = () => new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('ajaxA response')\n    }, 1500)\n})\nlet ajaxB = () => new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('ajaxB response')\n    }, 2000)\n})\n\nclass Queue {\n  constructor() {\n    this.list = []\n  }\n  enqueue(ele) {\n    this.list.push(ele)\n  }\n  dequeue(ele) {\n    return this.list.shift(ele)\n  }\n  isEmpty() {\n    return this.list.length === 0\n  }\n}\n\nlet eventQueue = new Queue()\nlet flag = false\n\nlet run = async function() {\n  flag = true\n  while(!eventQueue.isEmpty()) {\n    let res = await eventQueue.dequeue()\n    input.value = res\n    console.log('inputValue:',res)\n  }\n  flag = false\n}\n\nbtnA.addEventListener('click', () => {\n  eventQueue.enqueue(ajaxA());\n  if (!flag) { run() }\n})\nbtnB.addEventListener('click', () => {\n  eventQueue.enqueue(ajaxB());\n  if (!flag) { run() }\n})\n````","source":"_posts/使用队列解决两道题目.md","raw":"---\ntitle: 使用队列解决两道题目\ndate: 2018-04-21\ntags: ['queue', 'js']\ncategories: ['算法']\n---\n## 题目一 LazyMan\n\n* 描述\n\n> 实现一个LazyMan，可以按照以下方式调用:\n>\n> LazyMan(“Hank”)输出:\n>\n> Hi! This is Hank!\n>  \n> LazyMan(“Hank”).sleep(10).eat(“dinner”)输出\n>\n> Hi! This is Hank!\n>\n> //等待10秒..\n>\n> Wake up after 10\n>\n> Eat dinner~\n> \n> LazyMan(“Hank”).eat(“dinner”).eat(“supper”)输出\n>\n> Hi This is Hank!\n>\n> Eat dinner~\n>\n> Eat supper~\n>  \n> LazyMan(“Hank”).sleepFirst(5).eat(“supper”)输出\n>\n> //等待5秒\n>\n> Wake up after 5\n>\n> Hi This is Hank!\n>\n> Eat supper\n>\n>  \n> 以此类推。\n\n* 思路\n\n1. 借助队列的先进先出特性实现异步流的控制\n2. 利用闭包将事件保存至队列中\n3. 创建一个中间件next()用来触发事件\n4. 通过在每次事件结束之后返回对象本身，来实现链式调用。\n\n* 实现\n\n创建一个_LazyMan类，构造函数里面创建一个数组当做队列使用，存储排队执行的事件。\n````javascript\nclass _LazyMan {\n  constructor(name) {\n    this.task = [] //事件存储队列\n    var self = this //绑定this指向 可用箭头函数代替\n    var fn = (function(name) {\n      //借助闭包绑定作用域\n      return function() {\n        console.log(`Hi! This is ${name} !`)\n        self.next()\n      }\n    })(name)\n    this.task.push(fn)\n    //使用setTimeout方法，初始化任务，将执行函数放到下一次事件循环当中，从而达到先注册事件，后执行的目的\n    setTimeout(function() {\n      self.next()\n    }, 0)\n  } \n}\n````\n加下来添加next方法,每次触发next方法，从队列头部读取事件执行。\n````javascript\nnext() {\n  var fn = this.task.shift()\n  if(fn) fn()\n}\n````\n添加eat方法，函数执行结束之后，调用next进入下一个事件，同时通过返回this实现链式调用。\n````javascript\neat(food) {\n  var self = this \n  var fn = (function(food) {\n    return function() {\n      console.log(`Eat ${name} '~'`)\n      self.next()\n    }\n  })(food)\n  this.task.push(fn)\n  return this\n}\n````\n添加sleep方法，借助setTimeout实现延迟的效果\n````javascript\nsleep(time) {\n  var self = this\n  var fn = (function(name) {\n    return function() {\n      setTimeout(function() {\n        console.log(\"Wake up after \" + time + \"s!\");\n        self.next()\n      }, time * 1000)\n    }\n  })(name)\n  this.task.push(fn)\n  return this\n}\n````\n添加sleepFirst方法，sleepFirst函数需要最先执行，所以我们需要在任务队列前面放入，然后再执行后面的任务\n````javascript\nsleepFirst(time) {\n  var self = this\n  var fn = (function(name) {\n    return function() {\n      setTimeout(function() {\n        console.log(\"Wake up after \" + time + \"s!\");\n        self.next()\n      }, time * 1000)\n    }\n  })(name)\n  this.task.unshift(fn)\n  return this\n}\n````\n调用Lazyman的时候不需要用到new关键字，这意味着我们需要使用工厂函数返回Layman实例\n````javascript\nfunction LazyMan(name){\n  return new _LazyMan(name);\n}\n````\n这样，Lazyman这一题就实现了。\n* 使用Promise\n\n使用Promise的解法，本质上也是事先构造一个事件队列，在下一次事件循环开始时，开始执行。\n\n与上一个解法不同的是，先前的解法，是在每次的事件结束之后手动调用 next() 方法，去推动事件的执行流程。\n\n而Promise的解法，是借助了Promise的状态resolved之后，触发then方法进行回调。（手动返回Promise也行，下面会演示）\n\n* Promise版的实现\n\n创建一个_LazyMan类\n\n````javascript\nclass _LazyMan {\n  constructor(name) {\n    this.task = [] //事件存储队列\n    var start = Promise.resolve() //构造第一个Promise，借助其then回调触发事件流程，亦可用第一个task任务来生成该Promise。\n\n    var fn = (function(name) {\n      return new Promise(function(resolve, reject) {\n        console.log(`Hi! This is ${name} !`)\n        resolve()\n      })\n    })(name)\n\n    //或者手动返回一个Promise，后面的eat方法同理\n    // var fn = (function(name) {\n    //   return function() {\n    //     console.log(`Hi! This is ${name} !`)\n    //     return Promise.resolve()\n    //   }\n    // })(name)\n\n    this.task.push(fn)\n\n    setTimeout(() => {\n      this.task.forEach(task => {\n        start = start.then(task)\n      })\n    }, 0)\n  }\n}\n````\n\neat方法\n````javascript\n  eat(food) {\n    var fn = function() {\n      return new Promise(function(resolve, reject) {\n        console.log(`Eat ${food} '~'`)\n        resolve()\n      })\n    }\n    this.task.push(fn)\n    return this\n  }\n````\n其余方法同理，不赘述，具体实现见源码。\n\n## 题目二 AJAX按钮\n\n* 描述\n\n> 某个应用模块由文本框 input，以及按钮 A，按钮 B 组成。点击按钮 A，会向地址 urlA 发出一个 ajax 请求，并将返回的字符串填充到 input 中（覆盖 input 中原有的数据），点击按钮 B，会向地址 urlB 发出一个 ajax 请求，并将返回的字符串填充到 input 中（覆盖 > input 中原有的数据）。\n> \n> 当用户依次点击按钮 A、B 的时候，预期的效果是 input 依次被 urlA、urlB 返回的数据填充，但是由于到 urlA 的请求返回比较慢，导致 urlB 返回的数据被 urlA 返回的数据覆盖了，与用户预期的顺序不一致。\n>\n> 请问如何设计代码，解决这个问题？\n\n* 思路\n\n借助队列，点击事件触发时，将将请求塞进压进队列，通过进出队列控制两次请求的触发的顺序。\n\n* 实现\n\nhtml结构\n````html\n<body>\n    <input type=\"text\"/>\n    <button id=\"btnA\">A</button>\n    <button id=\"btnB\">B</button>\n</body>\n````\n借助Promise和setTimeout模拟接口返回\n````javascript\nlet btnA = document.querySelector('#btnA')\nlet btnB = document.querySelector('#btnB')\nlet input = document.querySelector('input');\n//模拟ajax\nlet ajaxA = () => new Promise((resolve, reject) => {\n    setTimeout(() => {\n        input.value = 'ajaxA response';\n        resolve()\n    }, 4000)\n})\nlet ajaxB = () => new Promise((resolve, reject) => {\n    setTimeout(() => {\n        input.value = 'ajaxB response';\n        resolve()\n    }, 1000)\n})\n````\n构造一个队列类以及队列操作方法的实现\n````javascript\nclass Queue {\n  constructor() {\n    this.list = []\n  }\n  enqueue(ele) {\n    this.list.push(ele)\n  }\n  dequeue(ele) {\n    return this.list.shift(ele)\n  }\n  isEmpty() {\n    return this.list.length === 0\n  }\n}\n````\n构建队列实例，点击时将事件压入队列,然后推动队列执行流程。\n````javascript\nlet eventQueue = new Queue()\nlet flag = false\n\nlet run = async function() {\n  flag = true\n  while(!eventQueue.isEmpty()) {\n    await eventQueue.dequeue()()\n  }\n  flag = false\n}\n\nbtnA.addEventListener('click', () => {\n  eventQueue.enqueue(ajaxA);\n  if (!flag) { run() }\n})\nbtnB.addEventListener('click', () => {\n  eventQueue.enqueue(ajaxB);\n  if (!flag) { run() }\n})\n````\n以上就是这道题的解法，但是这里的是把整个请求方法塞进队列，一个个取出来执行，相当于是同步的方法。\n\n下面可以改成异步的，修改成将请求方法执行完之后返回的Promise塞进队列，这个时候不会阻塞的执行，读取队列的时候，借助async判断Promise的状态已经变成resolved即可。\n\n* 实现\n\n修改按钮的请求方法，Promise状态变为resolved时，将响应返回。\n\n````javascript\nlet ajaxA = () => new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('ajaxA response')\n    }, 4000)\n})\n````\n修改按钮点击事件，点击时执行请求方法，将Promise压入队列。\n````javascript\nbtnA.addEventListener('click', () => {\n  eventQueue.enqueue(ajaxA());\n  if (!flag) { run() }\n})\n````\nrun方法修改为借助await控制异步队列。\n````javascript\nlet run = async function() {\n  flag = true\n  while(!eventQueue.isEmpty()) {\n    let res = await eventQueue.dequeue()\n    input.value = res\n    console.log('inputValue:',res)\n  }\n  flag = false\n}\n````\n## 源码\n* Lazyman\n````javascript\nclass _LazyMan {\n  constructor(name) {\n    this.task = []\n    var self = this\n    var fn = (function(name) {\n      return function() {\n        console.log(`Hi! This is ${name} !`)\n        self.next()\n      }\n    })(name)\n    this.task.push(fn)\n\n    setTimeout(function() {\n      self.next()\n    }, 0)\n  }\n  \n  next() {\n    var fn = this.task.shift()\n    fn && fn()\n  }\n\n  eat(food) {\n    var self = this\n    var fn = (function(food) {\n      return function() {\n        console.log(`Eat ${food} '~'`)\n        self.next()\n      }\n    })(food)\n    this.task.push(fn)\n    return this\n  }\n\n\n  sleep(time) {\n    var self = this\n    var fn = (function(name) {\n      return function() {\n        setTimeout(function() {\n          console.log(\"Wake up after \" + time + \"s!\");\n          self.next()\n        }, time * 1000)\n      }\n    })(name)\n    this.task.push(fn)\n    return this\n  }\n\n  sleepFirst(time) {\n    var self = this\n    var fn = (function(name) {\n      return function() {\n        setTimeout(function() {\n          console.log(\"Wake up after \" + time + \"s!\");\n          self.next()\n        }, time * 1000)\n      }\n    })(name)\n    this.task.unshift(fn)\n    return this\n  }\n}\n\nfunction LazyMan(name){\n  return new _LazyMan(name);\n}\n````\n* Pormise版Lazyman\n````javascript\nclass _LazyMan {\n  constructor(name) {\n    this.task = []\n    var start = Promise.resolve()\n\n    var fn = (function(name) {\n      return new Promise(function(resolve, reject) {\n        console.log(`Hi! This is ${name} !`)\n        resolve()\n      })\n    })(name)\n\n    this.task.push(fn)\n\n    setTimeout(() => {\n      this.task.forEach(task => {\n        start = start.then(task)\n      })\n    }, 0)\n  }\n\n  eat(food) {\n    var fn = function() {\n      return new Promise(function(resolve, reject) {\n        console.log(`Eat ${food} '~'`)\n        resolve()\n      })\n    }\n    this.task.push(fn)\n    return this\n  }\n\n  sleep(time) {\n    var fn = function() {\n      return new Promise(function(resolve, reject) {\n        setTimeout(function(){\n          console.log(\"Wake up after \" + time + \"s!\");\n          resolve()\n        }, time * 1000)\n      })\n    }\n\n    this.task.push(fn)\n    return this\n  }\n\n  sleepFirst(time) {\n    var fn = function() {\n      return new Promise(function(resolve, reject) {\n        setTimeout(function(){\n          console.log(\"Wake up after \" + time + \"s!\");\n          resolve()\n        }, time * 1000)\n      })\n    }\n\n    this.task.unshift(fn)\n    return this\n  }\n\n}\n\nfunction LazyMan(name) {\n  return new _LazyMan(name)\n}\n````\n* AJAX按钮 同步的解法\n````javascript\nlet btnA = document.querySelector('#btnA')\nlet btnB = document.querySelector('#btnB')\nlet input = document.querySelector('input');\n\nlet ajaxA = () => new Promise((resolve, reject) => {\n    setTimeout(() => {\n        console.log('ajaxA end')\n        input.value = 'ajaxA end';\n        resolve()\n    }, 4000)\n})\nlet ajaxB = () => new Promise((resolve, reject) => {\n    setTimeout(() => {\n        console.log('ajaxB end')\n        input.value = 'ajaxB end';\n        resolve()\n    }, 1000)\n})\n\nclass Queue {\n  constructor() {\n    this.list = []\n  }\n  enqueue(ele) {\n    this.list.push(ele)\n  }\n  dequeue(ele) {\n    return this.list.shift(ele)\n  }\n  isEmpty() {\n    return this.list.length === 0\n  }\n}\n\nlet eventQueue = new Queue()\nlet flag = false\n\nlet run = async function() {\n  flag = true\n  while(!eventQueue.isEmpty()) {\n    await eventQueue.dequeue()()\n  }\n  flag = false\n}\n\nbtnA.addEventListener('click', () => {\n  eventQueue.enqueue(ajaxA);\n  if (!flag) { run() }\n})\nbtnB.addEventListener('click', () => {\n  eventQueue.enqueue(ajaxB);\n  if (!flag) { run() }\n})\n````\n* AJAX按钮 异步的解法\n````javascript\nlet btnA = document.querySelector('#btnA')\nlet btnB = document.querySelector('#btnB')\nlet input = document.querySelector('input');\n\nlet ajaxA = () => new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('ajaxA response')\n    }, 1500)\n})\nlet ajaxB = () => new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('ajaxB response')\n    }, 2000)\n})\n\nclass Queue {\n  constructor() {\n    this.list = []\n  }\n  enqueue(ele) {\n    this.list.push(ele)\n  }\n  dequeue(ele) {\n    return this.list.shift(ele)\n  }\n  isEmpty() {\n    return this.list.length === 0\n  }\n}\n\nlet eventQueue = new Queue()\nlet flag = false\n\nlet run = async function() {\n  flag = true\n  while(!eventQueue.isEmpty()) {\n    let res = await eventQueue.dequeue()\n    input.value = res\n    console.log('inputValue:',res)\n  }\n  flag = false\n}\n\nbtnA.addEventListener('click', () => {\n  eventQueue.enqueue(ajaxA());\n  if (!flag) { run() }\n})\nbtnB.addEventListener('click', () => {\n  eventQueue.enqueue(ajaxB());\n  if (!flag) { run() }\n})\n````","slug":"使用队列解决两道题目","published":1,"updated":"2022-04-13T14:14:07.975Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffw0037g3t8lyvwse5r","content":"<h2 id=\"题目一-LazyMan\"><a href=\"#题目一-LazyMan\" class=\"headerlink\" title=\"题目一 LazyMan\"></a>题目一 LazyMan</h2><ul>\n<li>描述</li>\n</ul>\n<blockquote>\n<p>实现一个LazyMan，可以按照以下方式调用:</p>\n<p>LazyMan(“Hank”)输出:</p>\n<p>Hi! This is Hank!<br> <br>LazyMan(“Hank”).sleep(10).eat(“dinner”)输出</p>\n<p>Hi! This is Hank!</p>\n<p>//等待10秒..</p>\n<p>Wake up after 10</p>\n<p>Eat dinner~<br> <br>LazyMan(“Hank”).eat(“dinner”).eat(“supper”)输出</p>\n<p>Hi This is Hank!</p>\n<p>Eat dinner~</p>\n<p>Eat supper~<br> <br>LazyMan(“Hank”).sleepFirst(5).eat(“supper”)输出</p>\n<p>//等待5秒</p>\n<p>Wake up after 5</p>\n<p>Hi This is Hank!</p>\n<p>Eat supper</p>\n<p> <br>以此类推。</p>\n</blockquote>\n<ul>\n<li>思路</li>\n</ul>\n<ol>\n<li>借助队列的先进先出特性实现异步流的控制</li>\n<li>利用闭包将事件保存至队列中</li>\n<li>创建一个中间件next()用来触发事件</li>\n<li>通过在每次事件结束之后返回对象本身，来实现链式调用。</li>\n</ol>\n<ul>\n<li>实现</li>\n</ul>\n<p>创建一个_LazyMan类，构造函数里面创建一个数组当做队列使用，存储排队执行的事件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_LazyMan</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task = [] <span class=\"comment\">//事件存储队列</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span> <span class=\"comment\">//绑定this指向 可用箭头函数代替</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//借助闭包绑定作用域</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi! This is <span class=\"subst\">$&#123;name&#125;</span> !`</span>)</span><br><span class=\"line\">        self.next()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)(name)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\">    <span class=\"comment\">//使用setTimeout方法，初始化任务，将执行函数放到下一次事件循环当中，从而达到先注册事件，后执行的目的</span></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      self.next()</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>加下来添加next方法,每次触发next方法，从队列头部读取事件执行。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = <span class=\"keyword\">this</span>.task.shift()</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(fn) fn()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>添加eat方法，函数执行结束之后，调用next进入下一个事件，同时通过返回this实现链式调用。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eat(food) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span> </span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">food</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`Eat <span class=\"subst\">$&#123;name&#125;</span> '~'`</span>)</span><br><span class=\"line\">      self.next()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)(food)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>添加sleep方法，借助setTimeout实现延迟的效果<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sleep(time) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Wake up after \"</span> + time + <span class=\"string\">\"s!\"</span>);</span><br><span class=\"line\">        self.next()</span><br><span class=\"line\">      &#125;, time * <span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)(name)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>添加sleepFirst方法，sleepFirst函数需要最先执行，所以我们需要在任务队列前面放入，然后再执行后面的任务<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sleepFirst(time) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Wake up after \"</span> + time + <span class=\"string\">\"s!\"</span>);</span><br><span class=\"line\">        self.next()</span><br><span class=\"line\">      &#125;, time * <span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)(name)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.task.unshift(fn)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用Lazyman的时候不需要用到new关键字，这意味着我们需要使用工厂函数返回Layman实例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LazyMan</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _LazyMan(name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样，Lazyman这一题就实现了。</p>\n<ul>\n<li>使用Promise</li>\n</ul>\n<p>使用Promise的解法，本质上也是事先构造一个事件队列，在下一次事件循环开始时，开始执行。</p>\n<p>与上一个解法不同的是，先前的解法，是在每次的事件结束之后手动调用 next() 方法，去推动事件的执行流程。</p>\n<p>而Promise的解法，是借助了Promise的状态resolved之后，触发then方法进行回调。（手动返回Promise也行，下面会演示）</p>\n<ul>\n<li>Promise版的实现</li>\n</ul>\n<p>创建一个_LazyMan类</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_LazyMan</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task = [] <span class=\"comment\">//事件存储队列</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> start = <span class=\"built_in\">Promise</span>.resolve() <span class=\"comment\">//构造第一个Promise，借助其then回调触发事件流程，亦可用第一个task任务来生成该Promise。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi! This is <span class=\"subst\">$&#123;name&#125;</span> !`</span>)</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)(name)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//或者手动返回一个Promise，后面的eat方法同理</span></span><br><span class=\"line\">    <span class=\"comment\">// var fn = (function(name) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//   return function() &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     console.log(`Hi! This is $&#123;name&#125; !`)</span></span><br><span class=\"line\">    <span class=\"comment\">//     return Promise.resolve()</span></span><br><span class=\"line\">    <span class=\"comment\">//   &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;)(name)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.task.forEach(<span class=\"function\"><span class=\"params\">task</span> =&gt;</span> &#123;</span><br><span class=\"line\">        start = start.then(task)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>eat方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eat(food) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`Eat <span class=\"subst\">$&#123;food&#125;</span> '~'`</span>)</span><br><span class=\"line\">      resolve()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其余方法同理，不赘述，具体实现见源码。</p>\n<h2 id=\"题目二-AJAX按钮\"><a href=\"#题目二-AJAX按钮\" class=\"headerlink\" title=\"题目二 AJAX按钮\"></a>题目二 AJAX按钮</h2><ul>\n<li>描述</li>\n</ul>\n<blockquote>\n<p>某个应用模块由文本框 input，以及按钮 A，按钮 B 组成。点击按钮 A，会向地址 urlA 发出一个 ajax 请求，并将返回的字符串填充到 input 中（覆盖 input 中原有的数据），点击按钮 B，会向地址 urlB 发出一个 ajax 请求，并将返回的字符串填充到 input 中（覆盖 &gt; input 中原有的数据）。</p>\n<p>当用户依次点击按钮 A、B 的时候，预期的效果是 input 依次被 urlA、urlB 返回的数据填充，但是由于到 urlA 的请求返回比较慢，导致 urlB 返回的数据被 urlA 返回的数据覆盖了，与用户预期的顺序不一致。</p>\n<p>请问如何设计代码，解决这个问题？</p>\n</blockquote>\n<ul>\n<li>思路</li>\n</ul>\n<p>借助队列，点击事件触发时，将将请求塞进压进队列，通过进出队列控制两次请求的触发的顺序。</p>\n<ul>\n<li>实现</li>\n</ul>\n<p>html结构<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"btnA\"</span>&gt;</span>A<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"btnB\"</span>&gt;</span>B<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>借助Promise和setTimeout模拟接口返回<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> btnA = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#btnA'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> btnB = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#btnB'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> input = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'input'</span>);</span><br><span class=\"line\"><span class=\"comment\">//模拟ajax</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> ajaxA = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        input.value = <span class=\"string\">'ajaxA response'</span>;</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">    &#125;, <span class=\"number\">4000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">let</span> ajaxB = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        input.value = <span class=\"string\">'ajaxB response'</span>;</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>构造一个队列类以及队列操作方法的实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.list = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  enqueue(ele) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.list.push(ele)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dequeue(ele) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.list.shift(ele)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.list.length === <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>构建队列实例，点击时将事件压入队列,然后推动队列执行流程。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> eventQueue = <span class=\"keyword\">new</span> Queue()</span><br><span class=\"line\"><span class=\"keyword\">let</span> flag = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> run = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  flag = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!eventQueue.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> eventQueue.dequeue()()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  flag = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">btnA.addEventListener(<span class=\"string\">'click'</span>, () =&gt; &#123;</span><br><span class=\"line\">  eventQueue.enqueue(ajaxA);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!flag) &#123; run() &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">btnB.addEventListener(<span class=\"string\">'click'</span>, () =&gt; &#123;</span><br><span class=\"line\">  eventQueue.enqueue(ajaxB);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!flag) &#123; run() &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>以上就是这道题的解法，但是这里的是把整个请求方法塞进队列，一个个取出来执行，相当于是同步的方法。</p>\n<p>下面可以改成异步的，修改成将请求方法执行完之后返回的Promise塞进队列，这个时候不会阻塞的执行，读取队列的时候，借助async判断Promise的状态已经变成resolved即可。</p>\n<ul>\n<li>实现</li>\n</ul>\n<p>修改按钮的请求方法，Promise状态变为resolved时，将响应返回。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> ajaxA = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      resolve(<span class=\"string\">'ajaxA response'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">4000</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>修改按钮点击事件，点击时执行请求方法，将Promise压入队列。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btnA.addEventListener(<span class=\"string\">'click'</span>, () =&gt; &#123;</span><br><span class=\"line\">  eventQueue.enqueue(ajaxA());</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!flag) &#123; run() &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>run方法修改为借助await控制异步队列。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> run = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  flag = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!eventQueue.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"keyword\">await</span> eventQueue.dequeue()</span><br><span class=\"line\">    input.value = res</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'inputValue:'</span>,res)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  flag = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><ul>\n<li><p>Lazyman</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_LazyMan</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task = []</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi! This is <span class=\"subst\">$&#123;name&#125;</span> !`</span>)</span><br><span class=\"line\">        self.next()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)(name)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      self.next()</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  next() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"keyword\">this</span>.task.shift()</span><br><span class=\"line\">    fn &amp;&amp; fn()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  eat(food) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">food</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Eat <span class=\"subst\">$&#123;food&#125;</span> '~'`</span>)</span><br><span class=\"line\">        self.next()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)(food)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  sleep(time) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Wake up after \"</span> + time + <span class=\"string\">\"s!\"</span>);</span><br><span class=\"line\">          self.next()</span><br><span class=\"line\">        &#125;, time * <span class=\"number\">1000</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)(name)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  sleepFirst(time) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Wake up after \"</span> + time + <span class=\"string\">\"s!\"</span>);</span><br><span class=\"line\">          self.next()</span><br><span class=\"line\">        &#125;, time * <span class=\"number\">1000</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)(name)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task.unshift(fn)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LazyMan</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _LazyMan(name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Pormise版Lazyman</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_LazyMan</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task = []</span><br><span class=\"line\">    <span class=\"keyword\">var</span> start = <span class=\"built_in\">Promise</span>.resolve()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi! This is <span class=\"subst\">$&#123;name&#125;</span> !`</span>)</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)(name)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.task.forEach(<span class=\"function\"><span class=\"params\">task</span> =&gt;</span> &#123;</span><br><span class=\"line\">        start = start.then(task)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  eat(food) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Eat <span class=\"subst\">$&#123;food&#125;</span> '~'`</span>)</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  sleep(time) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Wake up after \"</span> + time + <span class=\"string\">\"s!\"</span>);</span><br><span class=\"line\">          resolve()</span><br><span class=\"line\">        &#125;, time * <span class=\"number\">1000</span>)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  sleepFirst(time) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Wake up after \"</span> + time + <span class=\"string\">\"s!\"</span>);</span><br><span class=\"line\">          resolve()</span><br><span class=\"line\">        &#125;, time * <span class=\"number\">1000</span>)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task.unshift(fn)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LazyMan</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _LazyMan(name)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>AJAX按钮 同步的解法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> btnA = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#btnA'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> btnB = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#btnB'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> input = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'input'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> ajaxA = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'ajaxA end'</span>)</span><br><span class=\"line\">        input.value = <span class=\"string\">'ajaxA end'</span>;</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">    &#125;, <span class=\"number\">4000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">let</span> ajaxB = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'ajaxB end'</span>)</span><br><span class=\"line\">        input.value = <span class=\"string\">'ajaxB end'</span>;</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.list = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  enqueue(ele) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.list.push(ele)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dequeue(ele) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.list.shift(ele)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.list.length === <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> eventQueue = <span class=\"keyword\">new</span> Queue()</span><br><span class=\"line\"><span class=\"keyword\">let</span> flag = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> run = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  flag = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!eventQueue.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> eventQueue.dequeue()()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  flag = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">btnA.addEventListener(<span class=\"string\">'click'</span>, () =&gt; &#123;</span><br><span class=\"line\">  eventQueue.enqueue(ajaxA);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!flag) &#123; run() &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">btnB.addEventListener(<span class=\"string\">'click'</span>, () =&gt; &#123;</span><br><span class=\"line\">  eventQueue.enqueue(ajaxB);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!flag) &#123; run() &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>AJAX按钮 异步的解法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> btnA = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#btnA'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> btnB = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#btnB'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> input = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'input'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> ajaxA = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">'ajaxA response'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1500</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">let</span> ajaxB = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">'ajaxB response'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.list = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  enqueue(ele) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.list.push(ele)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dequeue(ele) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.list.shift(ele)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.list.length === <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> eventQueue = <span class=\"keyword\">new</span> Queue()</span><br><span class=\"line\"><span class=\"keyword\">let</span> flag = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> run = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  flag = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!eventQueue.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"keyword\">await</span> eventQueue.dequeue()</span><br><span class=\"line\">    input.value = res</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'inputValue:'</span>,res)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  flag = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">btnA.addEventListener(<span class=\"string\">'click'</span>, () =&gt; &#123;</span><br><span class=\"line\">  eventQueue.enqueue(ajaxA());</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!flag) &#123; run() &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">btnB.addEventListener(<span class=\"string\">'click'</span>, () =&gt; &#123;</span><br><span class=\"line\">  eventQueue.enqueue(ajaxB());</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!flag) &#123; run() &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目一-LazyMan\"><a href=\"#题目一-LazyMan\" class=\"headerlink\" title=\"题目一 LazyMan\"></a>题目一 LazyMan</h2><ul>\n<li>描述</li>\n</ul>\n<blockquote>\n<p>实现一个LazyMan，可以按照以下方式调用:</p>\n<p>LazyMan(“Hank”)输出:</p>\n<p>Hi! This is Hank!<br> <br>LazyMan(“Hank”).sleep(10).eat(“dinner”)输出</p>\n<p>Hi! This is Hank!</p>\n<p>//等待10秒..</p>\n<p>Wake up after 10</p>\n<p>Eat dinner~<br> <br>LazyMan(“Hank”).eat(“dinner”).eat(“supper”)输出</p>\n<p>Hi This is Hank!</p>\n<p>Eat dinner~</p>\n<p>Eat supper~<br> <br>LazyMan(“Hank”).sleepFirst(5).eat(“supper”)输出</p>\n<p>//等待5秒</p>\n<p>Wake up after 5</p>\n<p>Hi This is Hank!</p>\n<p>Eat supper</p>\n<p> <br>以此类推。</p>\n</blockquote>\n<ul>\n<li>思路</li>\n</ul>\n<ol>\n<li>借助队列的先进先出特性实现异步流的控制</li>\n<li>利用闭包将事件保存至队列中</li>\n<li>创建一个中间件next()用来触发事件</li>\n<li>通过在每次事件结束之后返回对象本身，来实现链式调用。</li>\n</ol>\n<ul>\n<li>实现</li>\n</ul>\n<p>创建一个_LazyMan类，构造函数里面创建一个数组当做队列使用，存储排队执行的事件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_LazyMan</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task = [] <span class=\"comment\">//事件存储队列</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span> <span class=\"comment\">//绑定this指向 可用箭头函数代替</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//借助闭包绑定作用域</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi! This is <span class=\"subst\">$&#123;name&#125;</span> !`</span>)</span><br><span class=\"line\">        self.next()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)(name)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\">    <span class=\"comment\">//使用setTimeout方法，初始化任务，将执行函数放到下一次事件循环当中，从而达到先注册事件，后执行的目的</span></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      self.next()</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>加下来添加next方法,每次触发next方法，从队列头部读取事件执行。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = <span class=\"keyword\">this</span>.task.shift()</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(fn) fn()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>添加eat方法，函数执行结束之后，调用next进入下一个事件，同时通过返回this实现链式调用。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eat(food) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span> </span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">food</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`Eat <span class=\"subst\">$&#123;name&#125;</span> '~'`</span>)</span><br><span class=\"line\">      self.next()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)(food)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>添加sleep方法，借助setTimeout实现延迟的效果<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sleep(time) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Wake up after \"</span> + time + <span class=\"string\">\"s!\"</span>);</span><br><span class=\"line\">        self.next()</span><br><span class=\"line\">      &#125;, time * <span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)(name)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>添加sleepFirst方法，sleepFirst函数需要最先执行，所以我们需要在任务队列前面放入，然后再执行后面的任务<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sleepFirst(time) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Wake up after \"</span> + time + <span class=\"string\">\"s!\"</span>);</span><br><span class=\"line\">        self.next()</span><br><span class=\"line\">      &#125;, time * <span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)(name)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.task.unshift(fn)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用Lazyman的时候不需要用到new关键字，这意味着我们需要使用工厂函数返回Layman实例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LazyMan</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _LazyMan(name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样，Lazyman这一题就实现了。</p>\n<ul>\n<li>使用Promise</li>\n</ul>\n<p>使用Promise的解法，本质上也是事先构造一个事件队列，在下一次事件循环开始时，开始执行。</p>\n<p>与上一个解法不同的是，先前的解法，是在每次的事件结束之后手动调用 next() 方法，去推动事件的执行流程。</p>\n<p>而Promise的解法，是借助了Promise的状态resolved之后，触发then方法进行回调。（手动返回Promise也行，下面会演示）</p>\n<ul>\n<li>Promise版的实现</li>\n</ul>\n<p>创建一个_LazyMan类</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_LazyMan</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task = [] <span class=\"comment\">//事件存储队列</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> start = <span class=\"built_in\">Promise</span>.resolve() <span class=\"comment\">//构造第一个Promise，借助其then回调触发事件流程，亦可用第一个task任务来生成该Promise。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi! This is <span class=\"subst\">$&#123;name&#125;</span> !`</span>)</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)(name)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//或者手动返回一个Promise，后面的eat方法同理</span></span><br><span class=\"line\">    <span class=\"comment\">// var fn = (function(name) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//   return function() &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     console.log(`Hi! This is $&#123;name&#125; !`)</span></span><br><span class=\"line\">    <span class=\"comment\">//     return Promise.resolve()</span></span><br><span class=\"line\">    <span class=\"comment\">//   &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;)(name)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.task.forEach(<span class=\"function\"><span class=\"params\">task</span> =&gt;</span> &#123;</span><br><span class=\"line\">        start = start.then(task)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>eat方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eat(food) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`Eat <span class=\"subst\">$&#123;food&#125;</span> '~'`</span>)</span><br><span class=\"line\">      resolve()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其余方法同理，不赘述，具体实现见源码。</p>\n<h2 id=\"题目二-AJAX按钮\"><a href=\"#题目二-AJAX按钮\" class=\"headerlink\" title=\"题目二 AJAX按钮\"></a>题目二 AJAX按钮</h2><ul>\n<li>描述</li>\n</ul>\n<blockquote>\n<p>某个应用模块由文本框 input，以及按钮 A，按钮 B 组成。点击按钮 A，会向地址 urlA 发出一个 ajax 请求，并将返回的字符串填充到 input 中（覆盖 input 中原有的数据），点击按钮 B，会向地址 urlB 发出一个 ajax 请求，并将返回的字符串填充到 input 中（覆盖 &gt; input 中原有的数据）。</p>\n<p>当用户依次点击按钮 A、B 的时候，预期的效果是 input 依次被 urlA、urlB 返回的数据填充，但是由于到 urlA 的请求返回比较慢，导致 urlB 返回的数据被 urlA 返回的数据覆盖了，与用户预期的顺序不一致。</p>\n<p>请问如何设计代码，解决这个问题？</p>\n</blockquote>\n<ul>\n<li>思路</li>\n</ul>\n<p>借助队列，点击事件触发时，将将请求塞进压进队列，通过进出队列控制两次请求的触发的顺序。</p>\n<ul>\n<li>实现</li>\n</ul>\n<p>html结构<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"btnA\"</span>&gt;</span>A<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"btnB\"</span>&gt;</span>B<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>借助Promise和setTimeout模拟接口返回<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> btnA = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#btnA'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> btnB = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#btnB'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> input = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'input'</span>);</span><br><span class=\"line\"><span class=\"comment\">//模拟ajax</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> ajaxA = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        input.value = <span class=\"string\">'ajaxA response'</span>;</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">    &#125;, <span class=\"number\">4000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">let</span> ajaxB = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        input.value = <span class=\"string\">'ajaxB response'</span>;</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>构造一个队列类以及队列操作方法的实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.list = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  enqueue(ele) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.list.push(ele)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dequeue(ele) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.list.shift(ele)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.list.length === <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>构建队列实例，点击时将事件压入队列,然后推动队列执行流程。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> eventQueue = <span class=\"keyword\">new</span> Queue()</span><br><span class=\"line\"><span class=\"keyword\">let</span> flag = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> run = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  flag = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!eventQueue.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> eventQueue.dequeue()()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  flag = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">btnA.addEventListener(<span class=\"string\">'click'</span>, () =&gt; &#123;</span><br><span class=\"line\">  eventQueue.enqueue(ajaxA);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!flag) &#123; run() &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">btnB.addEventListener(<span class=\"string\">'click'</span>, () =&gt; &#123;</span><br><span class=\"line\">  eventQueue.enqueue(ajaxB);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!flag) &#123; run() &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>以上就是这道题的解法，但是这里的是把整个请求方法塞进队列，一个个取出来执行，相当于是同步的方法。</p>\n<p>下面可以改成异步的，修改成将请求方法执行完之后返回的Promise塞进队列，这个时候不会阻塞的执行，读取队列的时候，借助async判断Promise的状态已经变成resolved即可。</p>\n<ul>\n<li>实现</li>\n</ul>\n<p>修改按钮的请求方法，Promise状态变为resolved时，将响应返回。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> ajaxA = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      resolve(<span class=\"string\">'ajaxA response'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">4000</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>修改按钮点击事件，点击时执行请求方法，将Promise压入队列。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btnA.addEventListener(<span class=\"string\">'click'</span>, () =&gt; &#123;</span><br><span class=\"line\">  eventQueue.enqueue(ajaxA());</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!flag) &#123; run() &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>run方法修改为借助await控制异步队列。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> run = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  flag = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!eventQueue.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"keyword\">await</span> eventQueue.dequeue()</span><br><span class=\"line\">    input.value = res</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'inputValue:'</span>,res)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  flag = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><ul>\n<li><p>Lazyman</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_LazyMan</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task = []</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi! This is <span class=\"subst\">$&#123;name&#125;</span> !`</span>)</span><br><span class=\"line\">        self.next()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)(name)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      self.next()</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  next() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"keyword\">this</span>.task.shift()</span><br><span class=\"line\">    fn &amp;&amp; fn()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  eat(food) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">food</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Eat <span class=\"subst\">$&#123;food&#125;</span> '~'`</span>)</span><br><span class=\"line\">        self.next()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)(food)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  sleep(time) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Wake up after \"</span> + time + <span class=\"string\">\"s!\"</span>);</span><br><span class=\"line\">          self.next()</span><br><span class=\"line\">        &#125;, time * <span class=\"number\">1000</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)(name)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  sleepFirst(time) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Wake up after \"</span> + time + <span class=\"string\">\"s!\"</span>);</span><br><span class=\"line\">          self.next()</span><br><span class=\"line\">        &#125;, time * <span class=\"number\">1000</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)(name)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task.unshift(fn)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LazyMan</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _LazyMan(name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Pormise版Lazyman</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_LazyMan</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task = []</span><br><span class=\"line\">    <span class=\"keyword\">var</span> start = <span class=\"built_in\">Promise</span>.resolve()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hi! This is <span class=\"subst\">$&#123;name&#125;</span> !`</span>)</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)(name)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.task.forEach(<span class=\"function\"><span class=\"params\">task</span> =&gt;</span> &#123;</span><br><span class=\"line\">        start = start.then(task)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  eat(food) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Eat <span class=\"subst\">$&#123;food&#125;</span> '~'`</span>)</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  sleep(time) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Wake up after \"</span> + time + <span class=\"string\">\"s!\"</span>);</span><br><span class=\"line\">          resolve()</span><br><span class=\"line\">        &#125;, time * <span class=\"number\">1000</span>)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  sleepFirst(time) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Wake up after \"</span> + time + <span class=\"string\">\"s!\"</span>);</span><br><span class=\"line\">          resolve()</span><br><span class=\"line\">        &#125;, time * <span class=\"number\">1000</span>)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.task.unshift(fn)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LazyMan</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _LazyMan(name)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>AJAX按钮 同步的解法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> btnA = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#btnA'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> btnB = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#btnB'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> input = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'input'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> ajaxA = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'ajaxA end'</span>)</span><br><span class=\"line\">        input.value = <span class=\"string\">'ajaxA end'</span>;</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">    &#125;, <span class=\"number\">4000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">let</span> ajaxB = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'ajaxB end'</span>)</span><br><span class=\"line\">        input.value = <span class=\"string\">'ajaxB end'</span>;</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.list = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  enqueue(ele) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.list.push(ele)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dequeue(ele) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.list.shift(ele)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.list.length === <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> eventQueue = <span class=\"keyword\">new</span> Queue()</span><br><span class=\"line\"><span class=\"keyword\">let</span> flag = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> run = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  flag = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!eventQueue.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> eventQueue.dequeue()()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  flag = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">btnA.addEventListener(<span class=\"string\">'click'</span>, () =&gt; &#123;</span><br><span class=\"line\">  eventQueue.enqueue(ajaxA);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!flag) &#123; run() &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">btnB.addEventListener(<span class=\"string\">'click'</span>, () =&gt; &#123;</span><br><span class=\"line\">  eventQueue.enqueue(ajaxB);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!flag) &#123; run() &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>AJAX按钮 异步的解法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> btnA = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#btnA'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> btnB = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#btnB'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> input = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'input'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> ajaxA = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">'ajaxA response'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1500</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">let</span> ajaxB = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">'ajaxB response'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.list = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  enqueue(ele) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.list.push(ele)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dequeue(ele) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.list.shift(ele)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  isEmpty() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.list.length === <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> eventQueue = <span class=\"keyword\">new</span> Queue()</span><br><span class=\"line\"><span class=\"keyword\">let</span> flag = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> run = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  flag = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!eventQueue.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"keyword\">await</span> eventQueue.dequeue()</span><br><span class=\"line\">    input.value = res</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'inputValue:'</span>,res)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  flag = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">btnA.addEventListener(<span class=\"string\">'click'</span>, () =&gt; &#123;</span><br><span class=\"line\">  eventQueue.enqueue(ajaxA());</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!flag) &#123; run() &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">btnB.addEventListener(<span class=\"string\">'click'</span>, () =&gt; &#123;</span><br><span class=\"line\">  eventQueue.enqueue(ajaxB());</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!flag) &#123; run() &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"关于页面自动播放音频文件","date":"2017-04-17T16:00:00.000Z","_content":"之前在做一个项目的时候，产品经理提出一个页面自动播放音频的需求。\n\n一开始直接用上audio标签加上autoplay属性，但是一经测试，兼容性却很一般。\n\n经过网上查找资料和一番探索，实践，总结得出的结论如下:\n<!--more-->\n#PC端\n1. 对于支持<audio>标签的浏览器，设置autoplay属性可实现音频自动播放，同时设置style='display:none'可以隐藏节点。\n````html\n<audio src=\"./audio.mp3\" autoplay=\"autoplay\" style='display:none'></audio>\n````\n<audio>标签的相关属性：\n1、自动播放：\n语法：autoplay\n说明：如果出现该属性，则音频在就绪后马上播放。\n2、控制按钮：\n语法：controls\n说明：\t如果出现该属性，则向用户显示控件，比如播放按钮。\n3、循环播放：\n语法：loop\n说明：\t如果出现该属性，则每当音频结束时重新开始播放。\n\n2. 对于不支持audio标签的浏览器，主要是ie8及以下。使用<embed>标签配合ie条件注释来实现。\n````html\n<!--[if lte IE 10]>\n    <embed type=\"audio/midi\" src=\"../audio/secretary.mp3\" style='display:none' autostart=true loop=false></embed>\n<![endif]-->\n````\n<embed>标签的相关属性：\n1、自动播放：\n语法：autostart=true、false\n说明：该属性规定音频或视频文件是否在下载完之后就自动播放。\ntrue：音乐文件在下载完之后自动播放；\nfalse：音乐文件在下载完之后不自动播放。\n\n2、循环播放：\n语法：loop=正整数、true、false\n说明：该属性规定音频或视频文件是否循环及循环次数。\n属性值为正整数值时，音频或视频文件的循环次数与正整数值相同；\n属性值为true时，音频或视频文件循环；\n属性值为false时，音频或视频文件不循环。\n\n3、面板显示：\n语法：hidden=ture、no\n说明：该属性规定控制面板是否显示，默认值为no。\nture：隐藏面板；\nno：显示面板。\n\n4、开始时间：\n语法：starttime=mm:ss（分：秒）\n说明：该属性规定音频或视频文件开始播放的时间。未定义则从文件开头播放。\n#移动端\n<audio>标签在移动端的兼容性比较好，但是ios和android为了用户体验，避免用户浪费过多流量，屏蔽了autoplay属性，因此无法自动播放。\n实测发现ios不能自动播放，android部分机型可以自动播放，部分机型不能自动播放。\n\n因此只能借助用户的操作来触发播放，在移动端上，用户会习惯的来进行触摸屏幕来看页面，那就借助监听touchstart事件来触发播放，模拟自动播放的效果。经过与产品沟通，最终采用这种解决方案。\n````javascript\nvar audio = window.document.getElementById('audio');\nvar that=this;\nwindow.document.addEventListener('touchstart', function(){\n    if(that.once==true&&(that.$route.path=='/')){\n        that.once=false;\n        audio.play();\n    }\n}, false);\n/*once变量用于阻止多次播放，由于是单页应用，需求是只能是首页自动播放，因此加上路由判断*/\n````\n微信浏览器中，可借助js sdk实现自动播放\n````javascript\n document.addEventListener(\"WeixinJSBridgeReady\", function () {  \n        play();  \n    }, false);\n````\n","source":"_posts/关于页面自动播放音频文件.md","raw":"---\ntitle: 关于页面自动播放音频文件\ndate: 2017-04-18\ntags: ['audio','用户体验']\ncategories: ['工作总结']\n---\n之前在做一个项目的时候，产品经理提出一个页面自动播放音频的需求。\n\n一开始直接用上audio标签加上autoplay属性，但是一经测试，兼容性却很一般。\n\n经过网上查找资料和一番探索，实践，总结得出的结论如下:\n<!--more-->\n#PC端\n1. 对于支持<audio>标签的浏览器，设置autoplay属性可实现音频自动播放，同时设置style='display:none'可以隐藏节点。\n````html\n<audio src=\"./audio.mp3\" autoplay=\"autoplay\" style='display:none'></audio>\n````\n<audio>标签的相关属性：\n1、自动播放：\n语法：autoplay\n说明：如果出现该属性，则音频在就绪后马上播放。\n2、控制按钮：\n语法：controls\n说明：\t如果出现该属性，则向用户显示控件，比如播放按钮。\n3、循环播放：\n语法：loop\n说明：\t如果出现该属性，则每当音频结束时重新开始播放。\n\n2. 对于不支持audio标签的浏览器，主要是ie8及以下。使用<embed>标签配合ie条件注释来实现。\n````html\n<!--[if lte IE 10]>\n    <embed type=\"audio/midi\" src=\"../audio/secretary.mp3\" style='display:none' autostart=true loop=false></embed>\n<![endif]-->\n````\n<embed>标签的相关属性：\n1、自动播放：\n语法：autostart=true、false\n说明：该属性规定音频或视频文件是否在下载完之后就自动播放。\ntrue：音乐文件在下载完之后自动播放；\nfalse：音乐文件在下载完之后不自动播放。\n\n2、循环播放：\n语法：loop=正整数、true、false\n说明：该属性规定音频或视频文件是否循环及循环次数。\n属性值为正整数值时，音频或视频文件的循环次数与正整数值相同；\n属性值为true时，音频或视频文件循环；\n属性值为false时，音频或视频文件不循环。\n\n3、面板显示：\n语法：hidden=ture、no\n说明：该属性规定控制面板是否显示，默认值为no。\nture：隐藏面板；\nno：显示面板。\n\n4、开始时间：\n语法：starttime=mm:ss（分：秒）\n说明：该属性规定音频或视频文件开始播放的时间。未定义则从文件开头播放。\n#移动端\n<audio>标签在移动端的兼容性比较好，但是ios和android为了用户体验，避免用户浪费过多流量，屏蔽了autoplay属性，因此无法自动播放。\n实测发现ios不能自动播放，android部分机型可以自动播放，部分机型不能自动播放。\n\n因此只能借助用户的操作来触发播放，在移动端上，用户会习惯的来进行触摸屏幕来看页面，那就借助监听touchstart事件来触发播放，模拟自动播放的效果。经过与产品沟通，最终采用这种解决方案。\n````javascript\nvar audio = window.document.getElementById('audio');\nvar that=this;\nwindow.document.addEventListener('touchstart', function(){\n    if(that.once==true&&(that.$route.path=='/')){\n        that.once=false;\n        audio.play();\n    }\n}, false);\n/*once变量用于阻止多次播放，由于是单页应用，需求是只能是首页自动播放，因此加上路由判断*/\n````\n微信浏览器中，可借助js sdk实现自动播放\n````javascript\n document.addEventListener(\"WeixinJSBridgeReady\", function () {  \n        play();  \n    }, false);\n````\n","slug":"关于页面自动播放音频文件","published":1,"updated":"2022-04-13T14:14:08.006Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffx003ag3t85q8elvov","content":"<p>之前在做一个项目的时候，产品经理提出一个页面自动播放音频的需求。</p>\n<p>一开始直接用上audio标签加上autoplay属性，但是一经测试，兼容性却很一般。</p>\n<p>经过网上查找资料和一番探索，实践，总结得出的结论如下:<br><a id=\"more\"></a></p>\n<p>#PC端</p>\n<ol>\n<li>对于支持<audio>标签的浏览器，设置autoplay属性可实现音频自动播放，同时设置style=’display:none’可以隐藏节点。<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">audio</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./audio.mp3\"</span> <span class=\"attr\">autoplay</span>=<span class=\"string\">\"autoplay\"</span> <span class=\"attr\">style</span>=<span class=\"string\">'display:none'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</audio></li>\n</ol>\n<p><audio>标签的相关属性：<br>1、自动播放：<br>语法：autoplay<br>说明：如果出现该属性，则音频在就绪后马上播放。<br>2、控制按钮：<br>语法：controls<br>说明：    如果出现该属性，则向用户显示控件，比如播放按钮。<br>3、循环播放：<br>语法：loop<br>说明：    如果出现该属性，则每当音频结束时重新开始播放。</audio></p>\n<ol start=\"2\">\n<li>对于不支持audio标签的浏览器，主要是ie8及以下。使用<embed>标签配合ie条件注释来实现。<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if lte IE 10]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;embed type=\"audio/midi\" src=\"../audio/secretary.mp3\" style='display:none' autostart=true loop=false&gt;&lt;/embed&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><embed>标签的相关属性：<br>1、自动播放：<br>语法：autostart=true、false<br>说明：该属性规定音频或视频文件是否在下载完之后就自动播放。<br>true：音乐文件在下载完之后自动播放；<br>false：音乐文件在下载完之后不自动播放。</p>\n<p>2、循环播放：<br>语法：loop=正整数、true、false<br>说明：该属性规定音频或视频文件是否循环及循环次数。<br>属性值为正整数值时，音频或视频文件的循环次数与正整数值相同；<br>属性值为true时，音频或视频文件循环；<br>属性值为false时，音频或视频文件不循环。</p>\n<p>3、面板显示：<br>语法：hidden=ture、no<br>说明：该属性规定控制面板是否显示，默认值为no。<br>ture：隐藏面板；<br>no：显示面板。</p>\n<p>4、开始时间：<br>语法：starttime=mm:ss（分：秒）<br>说明：该属性规定音频或视频文件开始播放的时间。未定义则从文件开头播放。</p>\n<p>#移动端</p>\n<p><audio>标签在移动端的兼容性比较好，但是ios和android为了用户体验，避免用户浪费过多流量，屏蔽了autoplay属性，因此无法自动播放。<br>实测发现ios不能自动播放，android部分机型可以自动播放，部分机型不能自动播放。</audio></p>\n<p>因此只能借助用户的操作来触发播放，在移动端上，用户会习惯的来进行触摸屏幕来看页面，那就借助监听touchstart事件来触发播放，模拟自动播放的效果。经过与产品沟通，最终采用这种解决方案。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> audio = <span class=\"built_in\">window</span>.document.getElementById(<span class=\"string\">'audio'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> that=<span class=\"keyword\">this</span>;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.document.addEventListener(<span class=\"string\">'touchstart'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(that.once==<span class=\"literal\">true</span>&amp;&amp;(that.$route.path==<span class=\"string\">'/'</span>))&#123;</span><br><span class=\"line\">        that.once=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        audio.play();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">/*once变量用于阻止多次播放，由于是单页应用，需求是只能是首页自动播放，因此加上路由判断*/</span></span><br></pre></td></tr></table></figure></p>\n<p>微信浏览器中，可借助js sdk实现自动播放<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">\"WeixinJSBridgeReady\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">       play();  </span><br><span class=\"line\">   &#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>之前在做一个项目的时候，产品经理提出一个页面自动播放音频的需求。</p>\n<p>一开始直接用上audio标签加上autoplay属性，但是一经测试，兼容性却很一般。</p>\n<p>经过网上查找资料和一番探索，实践，总结得出的结论如下:<br>","more":"</p>\n<p>#PC端</p>\n<ol>\n<li>对于支持<audio>标签的浏览器，设置autoplay属性可实现音频自动播放，同时设置style=’display:none’可以隐藏节点。<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">audio</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./audio.mp3\"</span> <span class=\"attr\">autoplay</span>=<span class=\"string\">\"autoplay\"</span> <span class=\"attr\">style</span>=<span class=\"string\">'display:none'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</audio></li>\n</ol>\n<p><audio>标签的相关属性：<br>1、自动播放：<br>语法：autoplay<br>说明：如果出现该属性，则音频在就绪后马上播放。<br>2、控制按钮：<br>语法：controls<br>说明：    如果出现该属性，则向用户显示控件，比如播放按钮。<br>3、循环播放：<br>语法：loop<br>说明：    如果出现该属性，则每当音频结束时重新开始播放。</audio></p>\n<ol start=\"2\">\n<li>对于不支持audio标签的浏览器，主要是ie8及以下。使用<embed>标签配合ie条件注释来实现。<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--[if lte IE 10]&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;embed type=\"audio/midi\" src=\"../audio/secretary.mp3\" style='display:none' autostart=true loop=false&gt;&lt;/embed&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><embed>标签的相关属性：<br>1、自动播放：<br>语法：autostart=true、false<br>说明：该属性规定音频或视频文件是否在下载完之后就自动播放。<br>true：音乐文件在下载完之后自动播放；<br>false：音乐文件在下载完之后不自动播放。</p>\n<p>2、循环播放：<br>语法：loop=正整数、true、false<br>说明：该属性规定音频或视频文件是否循环及循环次数。<br>属性值为正整数值时，音频或视频文件的循环次数与正整数值相同；<br>属性值为true时，音频或视频文件循环；<br>属性值为false时，音频或视频文件不循环。</p>\n<p>3、面板显示：<br>语法：hidden=ture、no<br>说明：该属性规定控制面板是否显示，默认值为no。<br>ture：隐藏面板；<br>no：显示面板。</p>\n<p>4、开始时间：<br>语法：starttime=mm:ss（分：秒）<br>说明：该属性规定音频或视频文件开始播放的时间。未定义则从文件开头播放。</p>\n<p>#移动端</p>\n<p><audio>标签在移动端的兼容性比较好，但是ios和android为了用户体验，避免用户浪费过多流量，屏蔽了autoplay属性，因此无法自动播放。<br>实测发现ios不能自动播放，android部分机型可以自动播放，部分机型不能自动播放。</audio></p>\n<p>因此只能借助用户的操作来触发播放，在移动端上，用户会习惯的来进行触摸屏幕来看页面，那就借助监听touchstart事件来触发播放，模拟自动播放的效果。经过与产品沟通，最终采用这种解决方案。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> audio = <span class=\"built_in\">window</span>.document.getElementById(<span class=\"string\">'audio'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> that=<span class=\"keyword\">this</span>;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.document.addEventListener(<span class=\"string\">'touchstart'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(that.once==<span class=\"literal\">true</span>&amp;&amp;(that.$route.path==<span class=\"string\">'/'</span>))&#123;</span><br><span class=\"line\">        that.once=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        audio.play();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">/*once变量用于阻止多次播放，由于是单页应用，需求是只能是首页自动播放，因此加上路由判断*/</span></span><br></pre></td></tr></table></figure></p>\n<p>微信浏览器中，可借助js sdk实现自动播放<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">\"WeixinJSBridgeReady\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">       play();  </span><br><span class=\"line\">   &#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure></p>"},{"title":"前端动画","date":"2018-05-18T16:00:00.000Z","_content":"## 前端动画\n\n前端界面一个很重要的内容就是动画，符合场景的动画不仅可以优化网站页面中的交互细节，提高用户体验，还可以让页面更具有吸引力，给网站带来更多的访问量。通常前端中，实现动画的方案主要有6种：JavaScript直接实现动画，可伸缩矢量图形（Scalable Vector Graphics）动画，CSS3 transition，CSS3 animation，Canvas动画，requestAnimationFrame。\n<!--more-->\n### JavaScript直接实现动画\n\n主要是通过JavaScript的setInteral方法来持续调用改变某个元素的CSS样式以达到元素样式持续变化的结果。\n\n通过JavaScript实现动画通常会导致页面频繁性重排重绘，很消耗性能，如果是稍微复杂的动画，在性能较差的浏览器上就会明显感觉到卡顿，所以我们应该尽量避免使用它。\n\n利用seTimeout实现的动画在某些低端机上会出现卡顿、抖动的现象。 这种现象的产生有两个原因：\n\n1. setTimeout的执行时间并不是确定的。在Javascript中， setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此 setTimeout 的实际执行时间一般要比其设定的时间晚一些。\n2. 刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而 setTimeout只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。\n\ndemo：\n\n<iframe width=\"100%\" height=\"300\" src=\"//jsrun.net/TIXKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n\n> 在上面例子中，我们将setInterval的时间间隔设置为16ms，一般认为人眼能识别的流畅动画为每秒60帧，16ms 比 1000ms/16 帧略小一点，这种情况下我们可以认为动画是流畅的。\n>\n> 同理对于需要作节流处理的事件，我们一般也使用 16ms 进行节流处理。\n\n### SVG动画\n\nSVG又称可伸缩矢量图形，原生支持一些动画效果，通过组合可以生成较复杂的动画，而且不需要使用JavaScript参与控制。\n\nSVG动画由SVG元素内部的元素属性控制，通常使用以下几个元素：\n\n* <set>：无动画，常用来实现延时操作\n* <animate>：单属性动画，修改元素的一个属性。\n* <animateColor>：颜色动画，已废弃，可使用<animate>替代\n* <animateTransform>：变换动画，同CSS3 的transform 常见的有rotate, skew, scale, translate等 \n* <animateMotion> : 使元素按照指定的路径移动，path 属性就是SVG图形中的path，常见的属性有：\n\n    * M = moveto \n    * L = lineto \n    * H = horizontal lineto \n    * V = vertical lineto \n    * C = curveto \n    * S = smooth curveto \n    * Q = quadratic Belzier curve \n    * T = smooth quadratic Belzier curveto \n    * A = elliptical Arc \n    * Z = closepath \n\n    大写表示绝对定位，小写表示相对定位\n\ndemo:\n\n<iframe width=\"100%\" height=\"300\" src=\"//jsrun.net/SIXKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\nSVG的一大优势是含有较为丰富的动画功能，原生绘制各种图形、滤镜和动画，并且能被js调用。但是，另一方面元素较多且复杂的动画使用svg渲染会比较慢，而且SVG格式的动画绘制方式必须让内容嵌入到HTML中使用。CSS3的出现让svg的应用变得相对少了。\n\n### CSS3 transition\n\ntransition是过度动画。但是transition并不能实现独立的动画，只能在某个标签元素样式或状态改变时进行平滑的动画效果过渡，而不是马上改变。\n\n我们一般通过改变元素的起始状态，让元素的属性自动进行平滑过度产生动画，但不能应用于处理元素独立动画的情况，而是需要不断改变元素的属性值来持续触发动画过程。\n\ndemo:\n\n<iframe width=\"100%\" height=\"300\" src=\"//jsrun.net/paXKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n> 在移动端开发中，直接使用transition动画会让页面变慢甚至卡顿。所以我们通常添加transform:translate3D(0,0,0)或transform:translateZ(0)来开启移动端动画的GPU加速，让动画过程更加流畅。\n>\n\n### CSS3 animation\n\nanimation 算是真正意义上的CSS3动画。通过对关键帧和循环次数的控制，页面标签元素会根据设定好的样式改变进行平滑过渡。而且关键帧状态的控制是通过百分比来控制的。\n\ndemo:\n\n<iframe width=\"100%\" height=\"300\" src=\"//jsrun.net/AaXKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n> CSS3最大的优势是摆脱了JavaScript的控制，并且能利用硬件加速以及实现复杂动画效果。\n\n### Canvas动画\n\ncanvas作为H5新增元素，是借助Web API来实现动画的。\n\nCanvas动画和SVG动画的主要区别是，SVG动画是通过SVG元素内部的配置规则来实现的，而Canvas是通过Javacript API来实现的。\n\n通过getContext()获取元素的绘制对象，通过clearRect不断清空画布并在新的位置上使用fillStyle绘制新矩形内容实现页面动画效果。\n\ndemo:\n\n<iframe width=\"100%\" height=\"300\" src=\"//jsrun.net/jaXKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n>使用Canvas的优势是可以应对页面中多个动画元素渲染比较慢的情况，完全通过JavaScript来控制渲染动画的执行，这就避免了DOM性能较慢的问题，可用于实现较复杂动画。\n\n### requestAnimationFrame\n\nrequestAnimationFrame是另一种Web API，原理与setTimeout和setInterval类似，都是通过javascript持续循环的方法调用来触发动画动作。但是requestAnimationFrame是浏览器针对动画专门优化形成的APi，在性能上比另两者要好。\n\nrequestAnimationFrame的方式的优势如下：\n\n1. 经过浏览器优化，动画更流畅\n2. 窗口没激活时，动画将停止，省计算资源\n3. 更省电，尤其是对移动终端\n\n> 浏览器优化是指由系统来决定回调函数的执行时机。具体一点讲，如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。\n\n## 参考资料\n\n* [前端动画大乱炖](https://juejin.im/post/5ac4386af265da23830b18c9)\n* [原生js 动画](https://juejin.im/post/5c27105af265da61285a332f)\n* [前端动画总结](https://blog.csdn.net/zxb136475688/article/details/80299225)","source":"_posts/前端动画.md","raw":"---\ntitle: 前端动画\ndate: 2018-05-19\ntags: ['animation']\ncategories: ['动画']\n---\n## 前端动画\n\n前端界面一个很重要的内容就是动画，符合场景的动画不仅可以优化网站页面中的交互细节，提高用户体验，还可以让页面更具有吸引力，给网站带来更多的访问量。通常前端中，实现动画的方案主要有6种：JavaScript直接实现动画，可伸缩矢量图形（Scalable Vector Graphics）动画，CSS3 transition，CSS3 animation，Canvas动画，requestAnimationFrame。\n<!--more-->\n### JavaScript直接实现动画\n\n主要是通过JavaScript的setInteral方法来持续调用改变某个元素的CSS样式以达到元素样式持续变化的结果。\n\n通过JavaScript实现动画通常会导致页面频繁性重排重绘，很消耗性能，如果是稍微复杂的动画，在性能较差的浏览器上就会明显感觉到卡顿，所以我们应该尽量避免使用它。\n\n利用seTimeout实现的动画在某些低端机上会出现卡顿、抖动的现象。 这种现象的产生有两个原因：\n\n1. setTimeout的执行时间并不是确定的。在Javascript中， setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此 setTimeout 的实际执行时间一般要比其设定的时间晚一些。\n2. 刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而 setTimeout只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。\n\ndemo：\n\n<iframe width=\"100%\" height=\"300\" src=\"//jsrun.net/TIXKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n\n> 在上面例子中，我们将setInterval的时间间隔设置为16ms，一般认为人眼能识别的流畅动画为每秒60帧，16ms 比 1000ms/16 帧略小一点，这种情况下我们可以认为动画是流畅的。\n>\n> 同理对于需要作节流处理的事件，我们一般也使用 16ms 进行节流处理。\n\n### SVG动画\n\nSVG又称可伸缩矢量图形，原生支持一些动画效果，通过组合可以生成较复杂的动画，而且不需要使用JavaScript参与控制。\n\nSVG动画由SVG元素内部的元素属性控制，通常使用以下几个元素：\n\n* <set>：无动画，常用来实现延时操作\n* <animate>：单属性动画，修改元素的一个属性。\n* <animateColor>：颜色动画，已废弃，可使用<animate>替代\n* <animateTransform>：变换动画，同CSS3 的transform 常见的有rotate, skew, scale, translate等 \n* <animateMotion> : 使元素按照指定的路径移动，path 属性就是SVG图形中的path，常见的属性有：\n\n    * M = moveto \n    * L = lineto \n    * H = horizontal lineto \n    * V = vertical lineto \n    * C = curveto \n    * S = smooth curveto \n    * Q = quadratic Belzier curve \n    * T = smooth quadratic Belzier curveto \n    * A = elliptical Arc \n    * Z = closepath \n\n    大写表示绝对定位，小写表示相对定位\n\ndemo:\n\n<iframe width=\"100%\" height=\"300\" src=\"//jsrun.net/SIXKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\nSVG的一大优势是含有较为丰富的动画功能，原生绘制各种图形、滤镜和动画，并且能被js调用。但是，另一方面元素较多且复杂的动画使用svg渲染会比较慢，而且SVG格式的动画绘制方式必须让内容嵌入到HTML中使用。CSS3的出现让svg的应用变得相对少了。\n\n### CSS3 transition\n\ntransition是过度动画。但是transition并不能实现独立的动画，只能在某个标签元素样式或状态改变时进行平滑的动画效果过渡，而不是马上改变。\n\n我们一般通过改变元素的起始状态，让元素的属性自动进行平滑过度产生动画，但不能应用于处理元素独立动画的情况，而是需要不断改变元素的属性值来持续触发动画过程。\n\ndemo:\n\n<iframe width=\"100%\" height=\"300\" src=\"//jsrun.net/paXKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n> 在移动端开发中，直接使用transition动画会让页面变慢甚至卡顿。所以我们通常添加transform:translate3D(0,0,0)或transform:translateZ(0)来开启移动端动画的GPU加速，让动画过程更加流畅。\n>\n\n### CSS3 animation\n\nanimation 算是真正意义上的CSS3动画。通过对关键帧和循环次数的控制，页面标签元素会根据设定好的样式改变进行平滑过渡。而且关键帧状态的控制是通过百分比来控制的。\n\ndemo:\n\n<iframe width=\"100%\" height=\"300\" src=\"//jsrun.net/AaXKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n> CSS3最大的优势是摆脱了JavaScript的控制，并且能利用硬件加速以及实现复杂动画效果。\n\n### Canvas动画\n\ncanvas作为H5新增元素，是借助Web API来实现动画的。\n\nCanvas动画和SVG动画的主要区别是，SVG动画是通过SVG元素内部的配置规则来实现的，而Canvas是通过Javacript API来实现的。\n\n通过getContext()获取元素的绘制对象，通过clearRect不断清空画布并在新的位置上使用fillStyle绘制新矩形内容实现页面动画效果。\n\ndemo:\n\n<iframe width=\"100%\" height=\"300\" src=\"//jsrun.net/jaXKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n>使用Canvas的优势是可以应对页面中多个动画元素渲染比较慢的情况，完全通过JavaScript来控制渲染动画的执行，这就避免了DOM性能较慢的问题，可用于实现较复杂动画。\n\n### requestAnimationFrame\n\nrequestAnimationFrame是另一种Web API，原理与setTimeout和setInterval类似，都是通过javascript持续循环的方法调用来触发动画动作。但是requestAnimationFrame是浏览器针对动画专门优化形成的APi，在性能上比另两者要好。\n\nrequestAnimationFrame的方式的优势如下：\n\n1. 经过浏览器优化，动画更流畅\n2. 窗口没激活时，动画将停止，省计算资源\n3. 更省电，尤其是对移动终端\n\n> 浏览器优化是指由系统来决定回调函数的执行时机。具体一点讲，如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。\n\n## 参考资料\n\n* [前端动画大乱炖](https://juejin.im/post/5ac4386af265da23830b18c9)\n* [原生js 动画](https://juejin.im/post/5c27105af265da61285a332f)\n* [前端动画总结](https://blog.csdn.net/zxb136475688/article/details/80299225)","slug":"前端动画","published":1,"updated":"2022-04-13T14:14:08.020Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvffz003cg3t83l00j09n","content":"<h2 id=\"前端动画\"><a href=\"#前端动画\" class=\"headerlink\" title=\"前端动画\"></a>前端动画</h2><p>前端界面一个很重要的内容就是动画，符合场景的动画不仅可以优化网站页面中的交互细节，提高用户体验，还可以让页面更具有吸引力，给网站带来更多的访问量。通常前端中，实现动画的方案主要有6种：JavaScript直接实现动画，可伸缩矢量图形（Scalable Vector Graphics）动画，CSS3 transition，CSS3 animation，Canvas动画，requestAnimationFrame。<br><a id=\"more\"></a></p>\n<h3 id=\"JavaScript直接实现动画\"><a href=\"#JavaScript直接实现动画\" class=\"headerlink\" title=\"JavaScript直接实现动画\"></a>JavaScript直接实现动画</h3><p>主要是通过JavaScript的setInteral方法来持续调用改变某个元素的CSS样式以达到元素样式持续变化的结果。</p>\n<p>通过JavaScript实现动画通常会导致页面频繁性重排重绘，很消耗性能，如果是稍微复杂的动画，在性能较差的浏览器上就会明显感觉到卡顿，所以我们应该尽量避免使用它。</p>\n<p>利用seTimeout实现的动画在某些低端机上会出现卡顿、抖动的现象。 这种现象的产生有两个原因：</p>\n<ol>\n<li>setTimeout的执行时间并不是确定的。在Javascript中， setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此 setTimeout 的实际执行时间一般要比其设定的时间晚一些。</li>\n<li>刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而 setTimeout只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。</li>\n</ol>\n<p>demo：</p>\n<iframe width=\"100%\" height=\"300\" src=\"//jsrun.net/TIXKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n\n<blockquote>\n<p>在上面例子中，我们将setInterval的时间间隔设置为16ms，一般认为人眼能识别的流畅动画为每秒60帧，16ms 比 1000ms/16 帧略小一点，这种情况下我们可以认为动画是流畅的。</p>\n<p>同理对于需要作节流处理的事件，我们一般也使用 16ms 进行节流处理。</p>\n</blockquote>\n<h3 id=\"SVG动画\"><a href=\"#SVG动画\" class=\"headerlink\" title=\"SVG动画\"></a>SVG动画</h3><p>SVG又称可伸缩矢量图形，原生支持一些动画效果，通过组合可以生成较复杂的动画，而且不需要使用JavaScript参与控制。</p>\n<p>SVG动画由SVG元素内部的元素属性控制，通常使用以下几个元素：</p>\n<ul>\n<li><set>：无动画，常用来实现延时操作</set></li>\n<li><animate>：单属性动画，修改元素的一个属性。</animate></li>\n<li><animatecolor>：颜色动画，已废弃，可使用<animate>替代</animate></animatecolor></li>\n<li><animatetransform>：变换动画，同CSS3 的transform 常见的有rotate, skew, scale, translate等 </animatetransform></li>\n<li><p><animatemotion> : 使元素按照指定的路径移动，path 属性就是SVG图形中的path，常见的属性有：</animatemotion></p>\n<ul>\n<li>M = moveto </li>\n<li>L = lineto </li>\n<li>H = horizontal lineto </li>\n<li>V = vertical lineto </li>\n<li>C = curveto </li>\n<li>S = smooth curveto </li>\n<li>Q = quadratic Belzier curve </li>\n<li>T = smooth quadratic Belzier curveto </li>\n<li>A = elliptical Arc </li>\n<li><p>Z = closepath </p>\n<p>大写表示绝对定位，小写表示相对定位</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>demo:</p>\n<iframe width=\"100%\" height=\"300\" src=\"//jsrun.net/SIXKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<p>SVG的一大优势是含有较为丰富的动画功能，原生绘制各种图形、滤镜和动画，并且能被js调用。但是，另一方面元素较多且复杂的动画使用svg渲染会比较慢，而且SVG格式的动画绘制方式必须让内容嵌入到HTML中使用。CSS3的出现让svg的应用变得相对少了。</p>\n<h3 id=\"CSS3-transition\"><a href=\"#CSS3-transition\" class=\"headerlink\" title=\"CSS3 transition\"></a>CSS3 transition</h3><p>transition是过度动画。但是transition并不能实现独立的动画，只能在某个标签元素样式或状态改变时进行平滑的动画效果过渡，而不是马上改变。</p>\n<p>我们一般通过改变元素的起始状态，让元素的属性自动进行平滑过度产生动画，但不能应用于处理元素独立动画的情况，而是需要不断改变元素的属性值来持续触发动画过程。</p>\n<p>demo:</p>\n<iframe width=\"100%\" height=\"300\" src=\"//jsrun.net/paXKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<blockquote>\n<p>在移动端开发中，直接使用transition动画会让页面变慢甚至卡顿。所以我们通常添加transform:translate3D(0,0,0)或transform:translateZ(0)来开启移动端动画的GPU加速，让动画过程更加流畅。</p>\n</blockquote>\n<h3 id=\"CSS3-animation\"><a href=\"#CSS3-animation\" class=\"headerlink\" title=\"CSS3 animation\"></a>CSS3 animation</h3><p>animation 算是真正意义上的CSS3动画。通过对关键帧和循环次数的控制，页面标签元素会根据设定好的样式改变进行平滑过渡。而且关键帧状态的控制是通过百分比来控制的。</p>\n<p>demo:</p>\n<iframe width=\"100%\" height=\"300\" src=\"//jsrun.net/AaXKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<blockquote>\n<p>CSS3最大的优势是摆脱了JavaScript的控制，并且能利用硬件加速以及实现复杂动画效果。</p>\n</blockquote>\n<h3 id=\"Canvas动画\"><a href=\"#Canvas动画\" class=\"headerlink\" title=\"Canvas动画\"></a>Canvas动画</h3><p>canvas作为H5新增元素，是借助Web API来实现动画的。</p>\n<p>Canvas动画和SVG动画的主要区别是，SVG动画是通过SVG元素内部的配置规则来实现的，而Canvas是通过Javacript API来实现的。</p>\n<p>通过getContext()获取元素的绘制对象，通过clearRect不断清空画布并在新的位置上使用fillStyle绘制新矩形内容实现页面动画效果。</p>\n<p>demo:</p>\n<iframe width=\"100%\" height=\"300\" src=\"//jsrun.net/jaXKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<blockquote>\n<p>使用Canvas的优势是可以应对页面中多个动画元素渲染比较慢的情况，完全通过JavaScript来控制渲染动画的执行，这就避免了DOM性能较慢的问题，可用于实现较复杂动画。</p>\n</blockquote>\n<h3 id=\"requestAnimationFrame\"><a href=\"#requestAnimationFrame\" class=\"headerlink\" title=\"requestAnimationFrame\"></a>requestAnimationFrame</h3><p>requestAnimationFrame是另一种Web API，原理与setTimeout和setInterval类似，都是通过javascript持续循环的方法调用来触发动画动作。但是requestAnimationFrame是浏览器针对动画专门优化形成的APi，在性能上比另两者要好。</p>\n<p>requestAnimationFrame的方式的优势如下：</p>\n<ol>\n<li>经过浏览器优化，动画更流畅</li>\n<li>窗口没激活时，动画将停止，省计算资源</li>\n<li>更省电，尤其是对移动终端</li>\n</ol>\n<blockquote>\n<p>浏览器优化是指由系统来决定回调函数的执行时机。具体一点讲，如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。</p>\n</blockquote>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://juejin.im/post/5ac4386af265da23830b18c9\" target=\"_blank\" rel=\"noopener\">前端动画大乱炖</a></li>\n<li><a href=\"https://juejin.im/post/5c27105af265da61285a332f\" target=\"_blank\" rel=\"noopener\">原生js 动画</a></li>\n<li><a href=\"https://blog.csdn.net/zxb136475688/article/details/80299225\" target=\"_blank\" rel=\"noopener\">前端动画总结</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"前端动画\"><a href=\"#前端动画\" class=\"headerlink\" title=\"前端动画\"></a>前端动画</h2><p>前端界面一个很重要的内容就是动画，符合场景的动画不仅可以优化网站页面中的交互细节，提高用户体验，还可以让页面更具有吸引力，给网站带来更多的访问量。通常前端中，实现动画的方案主要有6种：JavaScript直接实现动画，可伸缩矢量图形（Scalable Vector Graphics）动画，CSS3 transition，CSS3 animation，Canvas动画，requestAnimationFrame。<br>","more":"</p>\n<h3 id=\"JavaScript直接实现动画\"><a href=\"#JavaScript直接实现动画\" class=\"headerlink\" title=\"JavaScript直接实现动画\"></a>JavaScript直接实现动画</h3><p>主要是通过JavaScript的setInteral方法来持续调用改变某个元素的CSS样式以达到元素样式持续变化的结果。</p>\n<p>通过JavaScript实现动画通常会导致页面频繁性重排重绘，很消耗性能，如果是稍微复杂的动画，在性能较差的浏览器上就会明显感觉到卡顿，所以我们应该尽量避免使用它。</p>\n<p>利用seTimeout实现的动画在某些低端机上会出现卡顿、抖动的现象。 这种现象的产生有两个原因：</p>\n<ol>\n<li>setTimeout的执行时间并不是确定的。在Javascript中， setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此 setTimeout 的实际执行时间一般要比其设定的时间晚一些。</li>\n<li>刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而 setTimeout只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。</li>\n</ol>\n<p>demo：</p>\n<iframe width=\"100%\" height=\"300\" src=\"//jsrun.net/TIXKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n\n<blockquote>\n<p>在上面例子中，我们将setInterval的时间间隔设置为16ms，一般认为人眼能识别的流畅动画为每秒60帧，16ms 比 1000ms/16 帧略小一点，这种情况下我们可以认为动画是流畅的。</p>\n<p>同理对于需要作节流处理的事件，我们一般也使用 16ms 进行节流处理。</p>\n</blockquote>\n<h3 id=\"SVG动画\"><a href=\"#SVG动画\" class=\"headerlink\" title=\"SVG动画\"></a>SVG动画</h3><p>SVG又称可伸缩矢量图形，原生支持一些动画效果，通过组合可以生成较复杂的动画，而且不需要使用JavaScript参与控制。</p>\n<p>SVG动画由SVG元素内部的元素属性控制，通常使用以下几个元素：</p>\n<ul>\n<li><set>：无动画，常用来实现延时操作</set></li>\n<li><animate>：单属性动画，修改元素的一个属性。</animate></li>\n<li><animatecolor>：颜色动画，已废弃，可使用<animate>替代</animate></animatecolor></li>\n<li><animatetransform>：变换动画，同CSS3 的transform 常见的有rotate, skew, scale, translate等 </animatetransform></li>\n<li><p><animatemotion> : 使元素按照指定的路径移动，path 属性就是SVG图形中的path，常见的属性有：</animatemotion></p>\n<ul>\n<li>M = moveto </li>\n<li>L = lineto </li>\n<li>H = horizontal lineto </li>\n<li>V = vertical lineto </li>\n<li>C = curveto </li>\n<li>S = smooth curveto </li>\n<li>Q = quadratic Belzier curve </li>\n<li>T = smooth quadratic Belzier curveto </li>\n<li>A = elliptical Arc </li>\n<li><p>Z = closepath </p>\n<p>大写表示绝对定位，小写表示相对定位</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>demo:</p>\n<iframe width=\"100%\" height=\"300\" src=\"//jsrun.net/SIXKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<p>SVG的一大优势是含有较为丰富的动画功能，原生绘制各种图形、滤镜和动画，并且能被js调用。但是，另一方面元素较多且复杂的动画使用svg渲染会比较慢，而且SVG格式的动画绘制方式必须让内容嵌入到HTML中使用。CSS3的出现让svg的应用变得相对少了。</p>\n<h3 id=\"CSS3-transition\"><a href=\"#CSS3-transition\" class=\"headerlink\" title=\"CSS3 transition\"></a>CSS3 transition</h3><p>transition是过度动画。但是transition并不能实现独立的动画，只能在某个标签元素样式或状态改变时进行平滑的动画效果过渡，而不是马上改变。</p>\n<p>我们一般通过改变元素的起始状态，让元素的属性自动进行平滑过度产生动画，但不能应用于处理元素独立动画的情况，而是需要不断改变元素的属性值来持续触发动画过程。</p>\n<p>demo:</p>\n<iframe width=\"100%\" height=\"300\" src=\"//jsrun.net/paXKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<blockquote>\n<p>在移动端开发中，直接使用transition动画会让页面变慢甚至卡顿。所以我们通常添加transform:translate3D(0,0,0)或transform:translateZ(0)来开启移动端动画的GPU加速，让动画过程更加流畅。</p>\n</blockquote>\n<h3 id=\"CSS3-animation\"><a href=\"#CSS3-animation\" class=\"headerlink\" title=\"CSS3 animation\"></a>CSS3 animation</h3><p>animation 算是真正意义上的CSS3动画。通过对关键帧和循环次数的控制，页面标签元素会根据设定好的样式改变进行平滑过渡。而且关键帧状态的控制是通过百分比来控制的。</p>\n<p>demo:</p>\n<iframe width=\"100%\" height=\"300\" src=\"//jsrun.net/AaXKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<blockquote>\n<p>CSS3最大的优势是摆脱了JavaScript的控制，并且能利用硬件加速以及实现复杂动画效果。</p>\n</blockquote>\n<h3 id=\"Canvas动画\"><a href=\"#Canvas动画\" class=\"headerlink\" title=\"Canvas动画\"></a>Canvas动画</h3><p>canvas作为H5新增元素，是借助Web API来实现动画的。</p>\n<p>Canvas动画和SVG动画的主要区别是，SVG动画是通过SVG元素内部的配置规则来实现的，而Canvas是通过Javacript API来实现的。</p>\n<p>通过getContext()获取元素的绘制对象，通过clearRect不断清空画布并在新的位置上使用fillStyle绘制新矩形内容实现页面动画效果。</p>\n<p>demo:</p>\n<iframe width=\"100%\" height=\"300\" src=\"//jsrun.net/jaXKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<blockquote>\n<p>使用Canvas的优势是可以应对页面中多个动画元素渲染比较慢的情况，完全通过JavaScript来控制渲染动画的执行，这就避免了DOM性能较慢的问题，可用于实现较复杂动画。</p>\n</blockquote>\n<h3 id=\"requestAnimationFrame\"><a href=\"#requestAnimationFrame\" class=\"headerlink\" title=\"requestAnimationFrame\"></a>requestAnimationFrame</h3><p>requestAnimationFrame是另一种Web API，原理与setTimeout和setInterval类似，都是通过javascript持续循环的方法调用来触发动画动作。但是requestAnimationFrame是浏览器针对动画专门优化形成的APi，在性能上比另两者要好。</p>\n<p>requestAnimationFrame的方式的优势如下：</p>\n<ol>\n<li>经过浏览器优化，动画更流畅</li>\n<li>窗口没激活时，动画将停止，省计算资源</li>\n<li>更省电，尤其是对移动终端</li>\n</ol>\n<blockquote>\n<p>浏览器优化是指由系统来决定回调函数的执行时机。具体一点讲，如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。</p>\n</blockquote>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://juejin.im/post/5ac4386af265da23830b18c9\" target=\"_blank\" rel=\"noopener\">前端动画大乱炖</a></li>\n<li><a href=\"https://juejin.im/post/5c27105af265da61285a332f\" target=\"_blank\" rel=\"noopener\">原生js 动画</a></li>\n<li><a href=\"https://blog.csdn.net/zxb136475688/article/details/80299225\" target=\"_blank\" rel=\"noopener\">前端动画总结</a></li>\n</ul>"},{"title":"使用gulp移动打包的静态资源到java项目","date":"2017-03-24T16:00:00.000Z","_content":"## 背景\n在java项目里使用vue作为前端框架，使用webpack作为打包工具。打包完的静态资源需要移动到java项目的WebContent文件夹里，本来webpack可以指定输出的路径，但由于HtmlWebpackPlugin插件不支持使用jsp作为模板，因此决定引入gulp来实现这个功能。\n<!--more-->\n## 目标\n将webpack打包完的js,css，插入到jsp模板里，同时将静态资源移动java项目WebContent里对应的文件夹下面的(这个功能也可以用webpack实现)。\n## 实现\n\n### 需要用到的npm包和gulp插件\n````javascript\n\"devDependencies\": {\n    \"del\": \"^2.2.2\",\n    \"gulp\": \"^3.9.1\",\n    \"gulp-cheerio\": \"^0.6.2\",\n    \"gulp-replace\": \"^0.5.4\",\n    \"through2\": \"^2.0.3\"\n  }\n````\n### 过程\n\n(1)在java项目下的WebContent文件夹下，新建前端源码的文件夹src。\n\n(2)每次开发完成后，打包生成src/dist文件夹。清空WebContent下的资源文件夹，将src/dist中的静态资源js，css，img移动到对应的资源文件夹。\n````javascript\n//清空文件夹\ngulp.task('del',()=>{\n    del(['../css/*'],{force:true})//或者使用gulp-clean\n    del(['../images/*'],{force:true})\n    del(['../scripts/*'],{force:true})\n    del(['../WEB-INF/jsp/*'],{force:true})\n})\n//拷贝文件到指定文件夹\ngulp.task('cp', ()=>{\n    return gulp.src('src/*/*').pipe(gulp.dest('../'))\n})\n````\n(2)获取src/dist/scripts文件夹下的manifest.js,app.js,vendor.js,app.css的hash值，使用gulp-cheerio插件生成对应的script，link节点，插入模板，并存放入目标文件夹WebContent/WEB-INF/jsp。\n\nWebContentscr/src下的jsp模板\n````javascript\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<jsp:include page=\"common.jsp\"></jsp:include>\n <%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%>\n <% \n \tString sid=request.getParameter(\"sid\");\n %>\n<c:set var=\"cpath\" value=\"${pageContext.request.contextPath}\"></c:set>\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=UTF-8>\n        <meta name=viewport content=\"width=640,user-scalable=no,target-densitydpi=device-dpi\">\n        <title>project</title>\n    </head>\n    <body>\n        <div id=app></div>\n        <input type=\"text\" value=\"${param.notbindPhone}\" style=\"display: none\" id=\"notbindPhoneId\">\n        <input type=\"text\" value=\"${userMobile}\" style=\"display: none\" id=\"mobile\">\n    </body>\n</html>\n````\ncheerio插件操作html的,并不支持jsp的dom操作,在做dom操作的时候,首先需要把源文件html进行智能补全处理,会把未结束的标签补齐，会使页面的jsp标签乱掉了。解决的办法,在调用cheerio 之前,先把jsp标签的<% 和%>替换掉。这样cheerio 会把他们是当做普通的字符串处理.等cheerio处理结束后,再替换回来。\n\n````javascript\n//获取hash值\nlet hash = {}\ngulp.src('src/scripts/manifest.*.js').pipe(through2.obj((file, enc, cb)=>{\n   hash.manifest = file.history.toString().replace(file.base,'').split('.')[1]\n}))\n////向jsp模板插入静态资源\ngulp.src('src/index.jsp').pipe(cheerio({run:$=>{\n  $('body').append('<script src=\"../'+jsPath+'/manifest.'+hash.manifest+'.js\"></script>')\n},parserOptions:{decodeEntities: false}}))\n````\nWebContent//WEB-INF/jsp下生成的jsp\n````javascript\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<jsp:include page=\"common.jsp\"></jsp:include>\n <%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%>\n <% \n \tString sid=request.getParameter(\"sid\");\n %>\n<c:set var=\"cpath\" value=\"${pageContext.request.contextPath}\"></c:set>\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"UTF-8\">\n        <meta name=\"viewport\" content=\"width=640,user-scalable=no,target-densitydpi=device-dpi\">\n        <title>project</title>\n    <link href=\"../css/app.e34a801012871ec0a999.css\" rel=\"stylesheet\"></head>\n    <body>\n        <div id=\"app\"></div>\n        <input type=\"text\" value=\"${param.notbindPhone}\" style=\"display: none\" id=\"notbindPhoneId\">\n        <input type=\"text\" value=\"${userMobile}\" style=\"display: none\" id=\"mobile\">\n    <script src=\"../scripts/manifest.9e7be796d2fe2d9d2c84.js\"></script>\n    <script src=\"../scripts/vendor.d806109533dbf074df4e.js\"></script>\n    <script src=\"../scripts/app.e34a801012871ec0a999.js\"></script>\n    </body>\n</html>\n````\n\n### 完整源码\n\n````javascript\nvar gulp = require('gulp')\nvar del = require('del') //清空文件夹\nvar through2 = require('through2') //读取文件名\nvar cheerio = require('gulp-cheerio') // 操作jsp模板，若使用gulp-rev会重复添加hash\nvar replace = require('gulp-replace') //替换文本\nvar jsPath = 'scripts'\n\n//清空文件夹\ngulp.task('del',()=>{\n    del(['../css/*'],{force:true})//或者使用gulp-clean\n    del(['../images/*'],{force:true})\n    del(['../scripts/*'],{force:true})\n    del(['../WEB-INF/jsp/*'],{force:true})\n})\n//拷贝文件到指定文件夹\ngulp.task('cp', ()=>{\n    return gulp.src('src/*/*').pipe(gulp.dest('../'))\n})\n\n//向jsp模板插入静态资源\ngulp.task('insert',()=>{\n    let hash = {}\n    function handleJsp(hash){\n        return gulp.src('src/index.jsp')\n        .pipe(replace(\"<%\",\"~%\")) //替换掉jsp标签的<%\n        .pipe(replace(\"%>\",\"%~\"))//替换掉jsp标签的<%\n        .pipe(cheerio({run:$=>{\n            $('body').append('<script src=\"../'+jsPath+'/manifest.'+hash.manifest+'.js\"></script>')        \n            $('body').append('<script src=\"../'+jsPath+'/vendor.'+hash.vendor+'.js\"></script>')\n            $('body').append('<script src=\"../'+jsPath+'/app.'+hash.app+'.js\"></script>')\n            $('head').append('<link href=\"../css/app.'+hash.css+'.css\" rel=\"stylesheet\">')\n        },parserOptions:{decodeEntities: false}}))//防止汉字被转码\n        .pipe(replace(\"%~\",\"%>\")) //替换回来jsp标签的<%\n        .pipe(replace(\"~%\",\"<%\"))//替换回来jsp标签的<%\n        .pipe(gulp.dest('../WEB-INF/jsp/'))\n    }\n    //获取hash值\n    gulp.src('src/scripts/manifest.*.js').pipe(through2.obj((file, enc, cb)=>{\n        hash.manifest = file.history.toString().replace(file.base,'').split('.')[1]\n    }))\n    gulp.src('src/scripts/vendor.*.js').pipe(through2.obj((file, enc, cb)=>{\n        hash.vendor = file.history.toString().replace(file.base,'').split('.')[1]\n    }))\n    gulp.src('src/scripts/app.*.js').pipe(through2.obj((file, enc, cb)=>{\n        hash.app = file.history.toString().replace(file.base,'').split('.')[1]\n    }))\n    gulp.src('src/css/app.*.css').pipe(through2.obj((file, enc, cb)=>{\n        hash.css = file.history.toString().replace(file.base,'').split('.')[1]\n    }))\n    handleJsp(hash)\n})\n\ngulp.task('default',['del','cp','insert'])\n````\n","source":"_posts/使用gulp移动打包的静态资源到java项目.md","raw":"---\ntitle: 使用gulp移动打包的静态资源到java项目\ndate: 2017-03-25\ntags: ['gulp','效率']\ncategories: ['工具']\n---\n## 背景\n在java项目里使用vue作为前端框架，使用webpack作为打包工具。打包完的静态资源需要移动到java项目的WebContent文件夹里，本来webpack可以指定输出的路径，但由于HtmlWebpackPlugin插件不支持使用jsp作为模板，因此决定引入gulp来实现这个功能。\n<!--more-->\n## 目标\n将webpack打包完的js,css，插入到jsp模板里，同时将静态资源移动java项目WebContent里对应的文件夹下面的(这个功能也可以用webpack实现)。\n## 实现\n\n### 需要用到的npm包和gulp插件\n````javascript\n\"devDependencies\": {\n    \"del\": \"^2.2.2\",\n    \"gulp\": \"^3.9.1\",\n    \"gulp-cheerio\": \"^0.6.2\",\n    \"gulp-replace\": \"^0.5.4\",\n    \"through2\": \"^2.0.3\"\n  }\n````\n### 过程\n\n(1)在java项目下的WebContent文件夹下，新建前端源码的文件夹src。\n\n(2)每次开发完成后，打包生成src/dist文件夹。清空WebContent下的资源文件夹，将src/dist中的静态资源js，css，img移动到对应的资源文件夹。\n````javascript\n//清空文件夹\ngulp.task('del',()=>{\n    del(['../css/*'],{force:true})//或者使用gulp-clean\n    del(['../images/*'],{force:true})\n    del(['../scripts/*'],{force:true})\n    del(['../WEB-INF/jsp/*'],{force:true})\n})\n//拷贝文件到指定文件夹\ngulp.task('cp', ()=>{\n    return gulp.src('src/*/*').pipe(gulp.dest('../'))\n})\n````\n(2)获取src/dist/scripts文件夹下的manifest.js,app.js,vendor.js,app.css的hash值，使用gulp-cheerio插件生成对应的script，link节点，插入模板，并存放入目标文件夹WebContent/WEB-INF/jsp。\n\nWebContentscr/src下的jsp模板\n````javascript\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<jsp:include page=\"common.jsp\"></jsp:include>\n <%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%>\n <% \n \tString sid=request.getParameter(\"sid\");\n %>\n<c:set var=\"cpath\" value=\"${pageContext.request.contextPath}\"></c:set>\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=UTF-8>\n        <meta name=viewport content=\"width=640,user-scalable=no,target-densitydpi=device-dpi\">\n        <title>project</title>\n    </head>\n    <body>\n        <div id=app></div>\n        <input type=\"text\" value=\"${param.notbindPhone}\" style=\"display: none\" id=\"notbindPhoneId\">\n        <input type=\"text\" value=\"${userMobile}\" style=\"display: none\" id=\"mobile\">\n    </body>\n</html>\n````\ncheerio插件操作html的,并不支持jsp的dom操作,在做dom操作的时候,首先需要把源文件html进行智能补全处理,会把未结束的标签补齐，会使页面的jsp标签乱掉了。解决的办法,在调用cheerio 之前,先把jsp标签的<% 和%>替换掉。这样cheerio 会把他们是当做普通的字符串处理.等cheerio处理结束后,再替换回来。\n\n````javascript\n//获取hash值\nlet hash = {}\ngulp.src('src/scripts/manifest.*.js').pipe(through2.obj((file, enc, cb)=>{\n   hash.manifest = file.history.toString().replace(file.base,'').split('.')[1]\n}))\n////向jsp模板插入静态资源\ngulp.src('src/index.jsp').pipe(cheerio({run:$=>{\n  $('body').append('<script src=\"../'+jsPath+'/manifest.'+hash.manifest+'.js\"></script>')\n},parserOptions:{decodeEntities: false}}))\n````\nWebContent//WEB-INF/jsp下生成的jsp\n````javascript\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<jsp:include page=\"common.jsp\"></jsp:include>\n <%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%>\n <% \n \tString sid=request.getParameter(\"sid\");\n %>\n<c:set var=\"cpath\" value=\"${pageContext.request.contextPath}\"></c:set>\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"UTF-8\">\n        <meta name=\"viewport\" content=\"width=640,user-scalable=no,target-densitydpi=device-dpi\">\n        <title>project</title>\n    <link href=\"../css/app.e34a801012871ec0a999.css\" rel=\"stylesheet\"></head>\n    <body>\n        <div id=\"app\"></div>\n        <input type=\"text\" value=\"${param.notbindPhone}\" style=\"display: none\" id=\"notbindPhoneId\">\n        <input type=\"text\" value=\"${userMobile}\" style=\"display: none\" id=\"mobile\">\n    <script src=\"../scripts/manifest.9e7be796d2fe2d9d2c84.js\"></script>\n    <script src=\"../scripts/vendor.d806109533dbf074df4e.js\"></script>\n    <script src=\"../scripts/app.e34a801012871ec0a999.js\"></script>\n    </body>\n</html>\n````\n\n### 完整源码\n\n````javascript\nvar gulp = require('gulp')\nvar del = require('del') //清空文件夹\nvar through2 = require('through2') //读取文件名\nvar cheerio = require('gulp-cheerio') // 操作jsp模板，若使用gulp-rev会重复添加hash\nvar replace = require('gulp-replace') //替换文本\nvar jsPath = 'scripts'\n\n//清空文件夹\ngulp.task('del',()=>{\n    del(['../css/*'],{force:true})//或者使用gulp-clean\n    del(['../images/*'],{force:true})\n    del(['../scripts/*'],{force:true})\n    del(['../WEB-INF/jsp/*'],{force:true})\n})\n//拷贝文件到指定文件夹\ngulp.task('cp', ()=>{\n    return gulp.src('src/*/*').pipe(gulp.dest('../'))\n})\n\n//向jsp模板插入静态资源\ngulp.task('insert',()=>{\n    let hash = {}\n    function handleJsp(hash){\n        return gulp.src('src/index.jsp')\n        .pipe(replace(\"<%\",\"~%\")) //替换掉jsp标签的<%\n        .pipe(replace(\"%>\",\"%~\"))//替换掉jsp标签的<%\n        .pipe(cheerio({run:$=>{\n            $('body').append('<script src=\"../'+jsPath+'/manifest.'+hash.manifest+'.js\"></script>')        \n            $('body').append('<script src=\"../'+jsPath+'/vendor.'+hash.vendor+'.js\"></script>')\n            $('body').append('<script src=\"../'+jsPath+'/app.'+hash.app+'.js\"></script>')\n            $('head').append('<link href=\"../css/app.'+hash.css+'.css\" rel=\"stylesheet\">')\n        },parserOptions:{decodeEntities: false}}))//防止汉字被转码\n        .pipe(replace(\"%~\",\"%>\")) //替换回来jsp标签的<%\n        .pipe(replace(\"~%\",\"<%\"))//替换回来jsp标签的<%\n        .pipe(gulp.dest('../WEB-INF/jsp/'))\n    }\n    //获取hash值\n    gulp.src('src/scripts/manifest.*.js').pipe(through2.obj((file, enc, cb)=>{\n        hash.manifest = file.history.toString().replace(file.base,'').split('.')[1]\n    }))\n    gulp.src('src/scripts/vendor.*.js').pipe(through2.obj((file, enc, cb)=>{\n        hash.vendor = file.history.toString().replace(file.base,'').split('.')[1]\n    }))\n    gulp.src('src/scripts/app.*.js').pipe(through2.obj((file, enc, cb)=>{\n        hash.app = file.history.toString().replace(file.base,'').split('.')[1]\n    }))\n    gulp.src('src/css/app.*.css').pipe(through2.obj((file, enc, cb)=>{\n        hash.css = file.history.toString().replace(file.base,'').split('.')[1]\n    }))\n    handleJsp(hash)\n})\n\ngulp.task('default',['del','cp','insert'])\n````\n","slug":"使用gulp移动打包的静态资源到java项目","published":1,"updated":"2022-04-13T14:14:07.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfg0003gg3t8s8ih1v8l","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>在java项目里使用vue作为前端框架，使用webpack作为打包工具。打包完的静态资源需要移动到java项目的WebContent文件夹里，本来webpack可以指定输出的路径，但由于HtmlWebpackPlugin插件不支持使用jsp作为模板，因此决定引入gulp来实现这个功能。<br><a id=\"more\"></a></p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>将webpack打包完的js,css，插入到jsp模板里，同时将静态资源移动java项目WebContent里对应的文件夹下面的(这个功能也可以用webpack实现)。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><h3 id=\"需要用到的npm包和gulp插件\"><a href=\"#需要用到的npm包和gulp插件\" class=\"headerlink\" title=\"需要用到的npm包和gulp插件\"></a>需要用到的npm包和gulp插件</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"devDependencies\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"del\"</span>: <span class=\"string\">\"^2.2.2\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"gulp\"</span>: <span class=\"string\">\"^3.9.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"gulp-cheerio\"</span>: <span class=\"string\">\"^0.6.2\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"gulp-replace\"</span>: <span class=\"string\">\"^0.5.4\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"through2\"</span>: <span class=\"string\">\"^2.0.3\"</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h3><p>(1)在java项目下的WebContent文件夹下，新建前端源码的文件夹src。</p>\n<p>(2)每次开发完成后，打包生成src/dist文件夹。清空WebContent下的资源文件夹，将src/dist中的静态资源js，css，img移动到对应的资源文件夹。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//清空文件夹</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'del'</span>,()=&gt;&#123;</span><br><span class=\"line\">    del([<span class=\"string\">'../css/*'</span>],&#123;<span class=\"attr\">force</span>:<span class=\"literal\">true</span>&#125;)<span class=\"comment\">//或者使用gulp-clean</span></span><br><span class=\"line\">    del([<span class=\"string\">'../images/*'</span>],&#123;<span class=\"attr\">force</span>:<span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">    del([<span class=\"string\">'../scripts/*'</span>],&#123;<span class=\"attr\">force</span>:<span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">    del([<span class=\"string\">'../WEB-INF/jsp/*'</span>],&#123;<span class=\"attr\">force</span>:<span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">//拷贝文件到指定文件夹</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'cp'</span>, ()=&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'src/*/*'</span>).pipe(gulp.dest(<span class=\"string\">'../'</span>))</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>(2)获取src/dist/scripts文件夹下的manifest.js,app.js,vendor.js,app.css的hash值，使用gulp-cheerio插件生成对应的script，link节点，插入模板，并存放入目标文件夹WebContent/WEB-INF/jsp。</p>\n<p>WebContentscr/src下的jsp模板<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page language=<span class=\"string\">\"java\"</span> contentType=<span class=\"string\">\"text/html; charset=UTF-8\"</span></span><br><span class=\"line\">    pageEncoding=<span class=\"string\">\"UTF-8\"</span>%&gt;</span><br><span class=\"line\">&lt;jsp:include page=<span class=\"string\">\"common.jsp\"</span>&gt;&lt;<span class=\"regexp\">/jsp:include&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"> &lt;%@ taglib uri=\"http:/</span><span class=\"regexp\">/java.sun.com/</span>jsp/jstl/core<span class=\"string\">\" prefix=\"</span>c<span class=\"string\">\"%&gt;</span></span><br><span class=\"line\"><span class=\"string\"> &lt;% </span></span><br><span class=\"line\"><span class=\"string\"> \tString sid=request.getParameter(\"</span>sid<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\"> %&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;c:set var=\"</span>cpath<span class=\"string\">\" value=\"</span>$&#123;pageContext.request.contextPath&#125;<span class=\"string\">\"&gt;&lt;/c:set&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;html&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;head&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;meta charset=UTF-8&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;meta name=viewport content=\"</span>width=<span class=\"number\">640</span>,user-scalable=no,target-densitydpi=device-dpi<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;title&gt;project&lt;/title&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/head&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;body&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;div id=app&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;input type=\"</span>text<span class=\"string\">\" value=\"</span>$&#123;param.notbindPhone&#125;<span class=\"string\">\" style=\"</span>display: none<span class=\"string\">\" id=\"</span>notbindPhoneId<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;input type=\"</span>text<span class=\"string\">\" value=\"</span>$&#123;userMobile&#125;<span class=\"string\">\" style=\"</span>display: none<span class=\"string\">\" id=\"</span>mobile<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/body&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>cheerio插件操作html的,并不支持jsp的dom操作,在做dom操作的时候,首先需要把源文件html进行智能补全处理,会把未结束的标签补齐，会使页面的jsp标签乱掉了。解决的办法,在调用cheerio 之前,先把jsp标签的&lt;% 和%&gt;替换掉。这样cheerio 会把他们是当做普通的字符串处理.等cheerio处理结束后,再替换回来。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取hash值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> hash = &#123;&#125;</span><br><span class=\"line\">gulp.src(<span class=\"string\">'src/scripts/manifest.*.js'</span>).pipe(through2.obj(<span class=\"function\">(<span class=\"params\">file, enc, cb</span>)=&gt;</span>&#123;</span><br><span class=\"line\">   hash.manifest = file.history.toString().replace(file.base,<span class=\"string\">''</span>).split(<span class=\"string\">'.'</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\">&#125;))</span><br><span class=\"line\"><span class=\"comment\">////向jsp模板插入静态资源</span></span><br><span class=\"line\">gulp.src(<span class=\"string\">'src/index.jsp'</span>).pipe(cheerio(&#123;<span class=\"attr\">run</span>:<span class=\"function\"><span class=\"params\">$</span>=&gt;</span>&#123;</span><br><span class=\"line\">  $(<span class=\"string\">'body'</span>).append(<span class=\"string\">'&lt;script src=\"../'</span>+jsPath+<span class=\"string\">'/manifest.'</span>+hash.manifest+<span class=\"string\">'.js\"&gt;&lt;/script&gt;'</span>)</span><br><span class=\"line\">&#125;,<span class=\"attr\">parserOptions</span>:&#123;<span class=\"attr\">decodeEntities</span>: <span class=\"literal\">false</span>&#125;&#125;))</span><br></pre></td></tr></table></figure>\n<p>WebContent//WEB-INF/jsp下生成的jsp<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page language=<span class=\"string\">\"java\"</span> contentType=<span class=\"string\">\"text/html; charset=UTF-8\"</span></span><br><span class=\"line\">    pageEncoding=<span class=\"string\">\"UTF-8\"</span>%&gt;</span><br><span class=\"line\">&lt;jsp:include page=<span class=\"string\">\"common.jsp\"</span>&gt;&lt;<span class=\"regexp\">/jsp:include&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"> &lt;%@ taglib uri=\"http:/</span><span class=\"regexp\">/java.sun.com/</span>jsp/jstl/core<span class=\"string\">\" prefix=\"</span>c<span class=\"string\">\"%&gt;</span></span><br><span class=\"line\"><span class=\"string\"> &lt;% </span></span><br><span class=\"line\"><span class=\"string\"> \tString sid=request.getParameter(\"</span>sid<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\"> %&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;c:set var=\"</span>cpath<span class=\"string\">\" value=\"</span>$&#123;pageContext.request.contextPath&#125;<span class=\"string\">\"&gt;&lt;/c:set&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;html&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;head&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;meta charset=\"</span>UTF<span class=\"number\">-8</span><span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;meta name=\"</span>viewport<span class=\"string\">\" content=\"</span>width=<span class=\"number\">640</span>,user-scalable=no,target-densitydpi=device-dpi<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;title&gt;project&lt;/title&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;link href=\"</span>../css/app.e34a801012871ec0a999.css<span class=\"string\">\" rel=\"</span>stylesheet<span class=\"string\">\"&gt;&lt;/head&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;body&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;div id=\"</span>app<span class=\"string\">\"&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;input type=\"</span>text<span class=\"string\">\" value=\"</span>$&#123;param.notbindPhone&#125;<span class=\"string\">\" style=\"</span>display: none<span class=\"string\">\" id=\"</span>notbindPhoneId<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;input type=\"</span>text<span class=\"string\">\" value=\"</span>$&#123;userMobile&#125;<span class=\"string\">\" style=\"</span>display: none<span class=\"string\">\" id=\"</span>mobile<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;script src=\"</span>../scripts/manifest<span class=\"number\">.9e7</span>be796d2fe2d9d2c84.js<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;script src=\"</span>../scripts/vendor.d806109533dbf074df4e.js<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;script src=\"</span>../scripts/app.e34a801012871ec0a999.js<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/body&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"完整源码\"><a href=\"#完整源码\" class=\"headerlink\" title=\"完整源码\"></a>完整源码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> del = <span class=\"built_in\">require</span>(<span class=\"string\">'del'</span>) <span class=\"comment\">//清空文件夹</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> through2 = <span class=\"built_in\">require</span>(<span class=\"string\">'through2'</span>) <span class=\"comment\">//读取文件名</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cheerio = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-cheerio'</span>) <span class=\"comment\">// 操作jsp模板，若使用gulp-rev会重复添加hash</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> replace = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-replace'</span>) <span class=\"comment\">//替换文本</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> jsPath = <span class=\"string\">'scripts'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//清空文件夹</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'del'</span>,()=&gt;&#123;</span><br><span class=\"line\">    del([<span class=\"string\">'../css/*'</span>],&#123;<span class=\"attr\">force</span>:<span class=\"literal\">true</span>&#125;)<span class=\"comment\">//或者使用gulp-clean</span></span><br><span class=\"line\">    del([<span class=\"string\">'../images/*'</span>],&#123;<span class=\"attr\">force</span>:<span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">    del([<span class=\"string\">'../scripts/*'</span>],&#123;<span class=\"attr\">force</span>:<span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">    del([<span class=\"string\">'../WEB-INF/jsp/*'</span>],&#123;<span class=\"attr\">force</span>:<span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">//拷贝文件到指定文件夹</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'cp'</span>, ()=&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'src/*/*'</span>).pipe(gulp.dest(<span class=\"string\">'../'</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//向jsp模板插入静态资源</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'insert'</span>,()=&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> hash = &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleJsp</span>(<span class=\"params\">hash</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'src/index.jsp'</span>)</span><br><span class=\"line\">        .pipe(replace(<span class=\"string\">\"&lt;%\"</span>,<span class=\"string\">\"~%\"</span>)) <span class=\"comment\">//替换掉jsp标签的&lt;%</span></span><br><span class=\"line\">        .pipe(replace(<span class=\"string\">\"%&gt;\"</span>,<span class=\"string\">\"%~\"</span>))<span class=\"comment\">//替换掉jsp标签的&lt;%</span></span><br><span class=\"line\">        .pipe(cheerio(&#123;<span class=\"attr\">run</span>:<span class=\"function\"><span class=\"params\">$</span>=&gt;</span>&#123;</span><br><span class=\"line\">            $(<span class=\"string\">'body'</span>).append(<span class=\"string\">'&lt;script src=\"../'</span>+jsPath+<span class=\"string\">'/manifest.'</span>+hash.manifest+<span class=\"string\">'.js\"&gt;&lt;/script&gt;'</span>)        </span><br><span class=\"line\">            $(<span class=\"string\">'body'</span>).append(<span class=\"string\">'&lt;script src=\"../'</span>+jsPath+<span class=\"string\">'/vendor.'</span>+hash.vendor+<span class=\"string\">'.js\"&gt;&lt;/script&gt;'</span>)</span><br><span class=\"line\">            $(<span class=\"string\">'body'</span>).append(<span class=\"string\">'&lt;script src=\"../'</span>+jsPath+<span class=\"string\">'/app.'</span>+hash.app+<span class=\"string\">'.js\"&gt;&lt;/script&gt;'</span>)</span><br><span class=\"line\">            $(<span class=\"string\">'head'</span>).append(<span class=\"string\">'&lt;link href=\"../css/app.'</span>+hash.css+<span class=\"string\">'.css\" rel=\"stylesheet\"&gt;'</span>)</span><br><span class=\"line\">        &#125;,<span class=\"attr\">parserOptions</span>:&#123;<span class=\"attr\">decodeEntities</span>: <span class=\"literal\">false</span>&#125;&#125;))<span class=\"comment\">//防止汉字被转码</span></span><br><span class=\"line\">        .pipe(replace(<span class=\"string\">\"%~\"</span>,<span class=\"string\">\"%&gt;\"</span>)) <span class=\"comment\">//替换回来jsp标签的&lt;%</span></span><br><span class=\"line\">        .pipe(replace(<span class=\"string\">\"~%\"</span>,<span class=\"string\">\"&lt;%\"</span>))<span class=\"comment\">//替换回来jsp标签的&lt;%</span></span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">'../WEB-INF/jsp/'</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取hash值</span></span><br><span class=\"line\">    gulp.src(<span class=\"string\">'src/scripts/manifest.*.js'</span>).pipe(through2.obj(<span class=\"function\">(<span class=\"params\">file, enc, cb</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        hash.manifest = file.history.toString().replace(file.base,<span class=\"string\">''</span>).split(<span class=\"string\">'.'</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    gulp.src(<span class=\"string\">'src/scripts/vendor.*.js'</span>).pipe(through2.obj(<span class=\"function\">(<span class=\"params\">file, enc, cb</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        hash.vendor = file.history.toString().replace(file.base,<span class=\"string\">''</span>).split(<span class=\"string\">'.'</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    gulp.src(<span class=\"string\">'src/scripts/app.*.js'</span>).pipe(through2.obj(<span class=\"function\">(<span class=\"params\">file, enc, cb</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        hash.app = file.history.toString().replace(file.base,<span class=\"string\">''</span>).split(<span class=\"string\">'.'</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    gulp.src(<span class=\"string\">'src/css/app.*.css'</span>).pipe(through2.obj(<span class=\"function\">(<span class=\"params\">file, enc, cb</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        hash.css = file.history.toString().replace(file.base,<span class=\"string\">''</span>).split(<span class=\"string\">'.'</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    handleJsp(hash)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'default'</span>,[<span class=\"string\">'del'</span>,<span class=\"string\">'cp'</span>,<span class=\"string\">'insert'</span>])</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>在java项目里使用vue作为前端框架，使用webpack作为打包工具。打包完的静态资源需要移动到java项目的WebContent文件夹里，本来webpack可以指定输出的路径，但由于HtmlWebpackPlugin插件不支持使用jsp作为模板，因此决定引入gulp来实现这个功能。<br>","more":"</p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>将webpack打包完的js,css，插入到jsp模板里，同时将静态资源移动java项目WebContent里对应的文件夹下面的(这个功能也可以用webpack实现)。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><h3 id=\"需要用到的npm包和gulp插件\"><a href=\"#需要用到的npm包和gulp插件\" class=\"headerlink\" title=\"需要用到的npm包和gulp插件\"></a>需要用到的npm包和gulp插件</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"devDependencies\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"del\"</span>: <span class=\"string\">\"^2.2.2\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"gulp\"</span>: <span class=\"string\">\"^3.9.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"gulp-cheerio\"</span>: <span class=\"string\">\"^0.6.2\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"gulp-replace\"</span>: <span class=\"string\">\"^0.5.4\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"through2\"</span>: <span class=\"string\">\"^2.0.3\"</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h3><p>(1)在java项目下的WebContent文件夹下，新建前端源码的文件夹src。</p>\n<p>(2)每次开发完成后，打包生成src/dist文件夹。清空WebContent下的资源文件夹，将src/dist中的静态资源js，css，img移动到对应的资源文件夹。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//清空文件夹</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'del'</span>,()=&gt;&#123;</span><br><span class=\"line\">    del([<span class=\"string\">'../css/*'</span>],&#123;<span class=\"attr\">force</span>:<span class=\"literal\">true</span>&#125;)<span class=\"comment\">//或者使用gulp-clean</span></span><br><span class=\"line\">    del([<span class=\"string\">'../images/*'</span>],&#123;<span class=\"attr\">force</span>:<span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">    del([<span class=\"string\">'../scripts/*'</span>],&#123;<span class=\"attr\">force</span>:<span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">    del([<span class=\"string\">'../WEB-INF/jsp/*'</span>],&#123;<span class=\"attr\">force</span>:<span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">//拷贝文件到指定文件夹</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'cp'</span>, ()=&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'src/*/*'</span>).pipe(gulp.dest(<span class=\"string\">'../'</span>))</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>(2)获取src/dist/scripts文件夹下的manifest.js,app.js,vendor.js,app.css的hash值，使用gulp-cheerio插件生成对应的script，link节点，插入模板，并存放入目标文件夹WebContent/WEB-INF/jsp。</p>\n<p>WebContentscr/src下的jsp模板<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page language=<span class=\"string\">\"java\"</span> contentType=<span class=\"string\">\"text/html; charset=UTF-8\"</span></span><br><span class=\"line\">    pageEncoding=<span class=\"string\">\"UTF-8\"</span>%&gt;</span><br><span class=\"line\">&lt;jsp:include page=<span class=\"string\">\"common.jsp\"</span>&gt;&lt;<span class=\"regexp\">/jsp:include&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"> &lt;%@ taglib uri=\"http:/</span><span class=\"regexp\">/java.sun.com/</span>jsp/jstl/core<span class=\"string\">\" prefix=\"</span>c<span class=\"string\">\"%&gt;</span></span><br><span class=\"line\"><span class=\"string\"> &lt;% </span></span><br><span class=\"line\"><span class=\"string\"> \tString sid=request.getParameter(\"</span>sid<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\"> %&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;c:set var=\"</span>cpath<span class=\"string\">\" value=\"</span>$&#123;pageContext.request.contextPath&#125;<span class=\"string\">\"&gt;&lt;/c:set&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;html&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;head&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;meta charset=UTF-8&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;meta name=viewport content=\"</span>width=<span class=\"number\">640</span>,user-scalable=no,target-densitydpi=device-dpi<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;title&gt;project&lt;/title&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/head&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;body&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;div id=app&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;input type=\"</span>text<span class=\"string\">\" value=\"</span>$&#123;param.notbindPhone&#125;<span class=\"string\">\" style=\"</span>display: none<span class=\"string\">\" id=\"</span>notbindPhoneId<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;input type=\"</span>text<span class=\"string\">\" value=\"</span>$&#123;userMobile&#125;<span class=\"string\">\" style=\"</span>display: none<span class=\"string\">\" id=\"</span>mobile<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/body&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>cheerio插件操作html的,并不支持jsp的dom操作,在做dom操作的时候,首先需要把源文件html进行智能补全处理,会把未结束的标签补齐，会使页面的jsp标签乱掉了。解决的办法,在调用cheerio 之前,先把jsp标签的&lt;% 和%&gt;替换掉。这样cheerio 会把他们是当做普通的字符串处理.等cheerio处理结束后,再替换回来。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取hash值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> hash = &#123;&#125;</span><br><span class=\"line\">gulp.src(<span class=\"string\">'src/scripts/manifest.*.js'</span>).pipe(through2.obj(<span class=\"function\">(<span class=\"params\">file, enc, cb</span>)=&gt;</span>&#123;</span><br><span class=\"line\">   hash.manifest = file.history.toString().replace(file.base,<span class=\"string\">''</span>).split(<span class=\"string\">'.'</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\">&#125;))</span><br><span class=\"line\"><span class=\"comment\">////向jsp模板插入静态资源</span></span><br><span class=\"line\">gulp.src(<span class=\"string\">'src/index.jsp'</span>).pipe(cheerio(&#123;<span class=\"attr\">run</span>:<span class=\"function\"><span class=\"params\">$</span>=&gt;</span>&#123;</span><br><span class=\"line\">  $(<span class=\"string\">'body'</span>).append(<span class=\"string\">'&lt;script src=\"../'</span>+jsPath+<span class=\"string\">'/manifest.'</span>+hash.manifest+<span class=\"string\">'.js\"&gt;&lt;/script&gt;'</span>)</span><br><span class=\"line\">&#125;,<span class=\"attr\">parserOptions</span>:&#123;<span class=\"attr\">decodeEntities</span>: <span class=\"literal\">false</span>&#125;&#125;))</span><br></pre></td></tr></table></figure>\n<p>WebContent//WEB-INF/jsp下生成的jsp<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page language=<span class=\"string\">\"java\"</span> contentType=<span class=\"string\">\"text/html; charset=UTF-8\"</span></span><br><span class=\"line\">    pageEncoding=<span class=\"string\">\"UTF-8\"</span>%&gt;</span><br><span class=\"line\">&lt;jsp:include page=<span class=\"string\">\"common.jsp\"</span>&gt;&lt;<span class=\"regexp\">/jsp:include&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"> &lt;%@ taglib uri=\"http:/</span><span class=\"regexp\">/java.sun.com/</span>jsp/jstl/core<span class=\"string\">\" prefix=\"</span>c<span class=\"string\">\"%&gt;</span></span><br><span class=\"line\"><span class=\"string\"> &lt;% </span></span><br><span class=\"line\"><span class=\"string\"> \tString sid=request.getParameter(\"</span>sid<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\"> %&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;c:set var=\"</span>cpath<span class=\"string\">\" value=\"</span>$&#123;pageContext.request.contextPath&#125;<span class=\"string\">\"&gt;&lt;/c:set&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;html&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;head&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;meta charset=\"</span>UTF<span class=\"number\">-8</span><span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;meta name=\"</span>viewport<span class=\"string\">\" content=\"</span>width=<span class=\"number\">640</span>,user-scalable=no,target-densitydpi=device-dpi<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;title&gt;project&lt;/title&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;link href=\"</span>../css/app.e34a801012871ec0a999.css<span class=\"string\">\" rel=\"</span>stylesheet<span class=\"string\">\"&gt;&lt;/head&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;body&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;div id=\"</span>app<span class=\"string\">\"&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;input type=\"</span>text<span class=\"string\">\" value=\"</span>$&#123;param.notbindPhone&#125;<span class=\"string\">\" style=\"</span>display: none<span class=\"string\">\" id=\"</span>notbindPhoneId<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;input type=\"</span>text<span class=\"string\">\" value=\"</span>$&#123;userMobile&#125;<span class=\"string\">\" style=\"</span>display: none<span class=\"string\">\" id=\"</span>mobile<span class=\"string\">\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;script src=\"</span>../scripts/manifest<span class=\"number\">.9e7</span>be796d2fe2d9d2c84.js<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;script src=\"</span>../scripts/vendor.d806109533dbf074df4e.js<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;script src=\"</span>../scripts/app.e34a801012871ec0a999.js<span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/body&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"完整源码\"><a href=\"#完整源码\" class=\"headerlink\" title=\"完整源码\"></a>完整源码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> del = <span class=\"built_in\">require</span>(<span class=\"string\">'del'</span>) <span class=\"comment\">//清空文件夹</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> through2 = <span class=\"built_in\">require</span>(<span class=\"string\">'through2'</span>) <span class=\"comment\">//读取文件名</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cheerio = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-cheerio'</span>) <span class=\"comment\">// 操作jsp模板，若使用gulp-rev会重复添加hash</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> replace = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-replace'</span>) <span class=\"comment\">//替换文本</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> jsPath = <span class=\"string\">'scripts'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//清空文件夹</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'del'</span>,()=&gt;&#123;</span><br><span class=\"line\">    del([<span class=\"string\">'../css/*'</span>],&#123;<span class=\"attr\">force</span>:<span class=\"literal\">true</span>&#125;)<span class=\"comment\">//或者使用gulp-clean</span></span><br><span class=\"line\">    del([<span class=\"string\">'../images/*'</span>],&#123;<span class=\"attr\">force</span>:<span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">    del([<span class=\"string\">'../scripts/*'</span>],&#123;<span class=\"attr\">force</span>:<span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">    del([<span class=\"string\">'../WEB-INF/jsp/*'</span>],&#123;<span class=\"attr\">force</span>:<span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">//拷贝文件到指定文件夹</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'cp'</span>, ()=&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'src/*/*'</span>).pipe(gulp.dest(<span class=\"string\">'../'</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//向jsp模板插入静态资源</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'insert'</span>,()=&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> hash = &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleJsp</span>(<span class=\"params\">hash</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'src/index.jsp'</span>)</span><br><span class=\"line\">        .pipe(replace(<span class=\"string\">\"&lt;%\"</span>,<span class=\"string\">\"~%\"</span>)) <span class=\"comment\">//替换掉jsp标签的&lt;%</span></span><br><span class=\"line\">        .pipe(replace(<span class=\"string\">\"%&gt;\"</span>,<span class=\"string\">\"%~\"</span>))<span class=\"comment\">//替换掉jsp标签的&lt;%</span></span><br><span class=\"line\">        .pipe(cheerio(&#123;<span class=\"attr\">run</span>:<span class=\"function\"><span class=\"params\">$</span>=&gt;</span>&#123;</span><br><span class=\"line\">            $(<span class=\"string\">'body'</span>).append(<span class=\"string\">'&lt;script src=\"../'</span>+jsPath+<span class=\"string\">'/manifest.'</span>+hash.manifest+<span class=\"string\">'.js\"&gt;&lt;/script&gt;'</span>)        </span><br><span class=\"line\">            $(<span class=\"string\">'body'</span>).append(<span class=\"string\">'&lt;script src=\"../'</span>+jsPath+<span class=\"string\">'/vendor.'</span>+hash.vendor+<span class=\"string\">'.js\"&gt;&lt;/script&gt;'</span>)</span><br><span class=\"line\">            $(<span class=\"string\">'body'</span>).append(<span class=\"string\">'&lt;script src=\"../'</span>+jsPath+<span class=\"string\">'/app.'</span>+hash.app+<span class=\"string\">'.js\"&gt;&lt;/script&gt;'</span>)</span><br><span class=\"line\">            $(<span class=\"string\">'head'</span>).append(<span class=\"string\">'&lt;link href=\"../css/app.'</span>+hash.css+<span class=\"string\">'.css\" rel=\"stylesheet\"&gt;'</span>)</span><br><span class=\"line\">        &#125;,<span class=\"attr\">parserOptions</span>:&#123;<span class=\"attr\">decodeEntities</span>: <span class=\"literal\">false</span>&#125;&#125;))<span class=\"comment\">//防止汉字被转码</span></span><br><span class=\"line\">        .pipe(replace(<span class=\"string\">\"%~\"</span>,<span class=\"string\">\"%&gt;\"</span>)) <span class=\"comment\">//替换回来jsp标签的&lt;%</span></span><br><span class=\"line\">        .pipe(replace(<span class=\"string\">\"~%\"</span>,<span class=\"string\">\"&lt;%\"</span>))<span class=\"comment\">//替换回来jsp标签的&lt;%</span></span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">'../WEB-INF/jsp/'</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取hash值</span></span><br><span class=\"line\">    gulp.src(<span class=\"string\">'src/scripts/manifest.*.js'</span>).pipe(through2.obj(<span class=\"function\">(<span class=\"params\">file, enc, cb</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        hash.manifest = file.history.toString().replace(file.base,<span class=\"string\">''</span>).split(<span class=\"string\">'.'</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    gulp.src(<span class=\"string\">'src/scripts/vendor.*.js'</span>).pipe(through2.obj(<span class=\"function\">(<span class=\"params\">file, enc, cb</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        hash.vendor = file.history.toString().replace(file.base,<span class=\"string\">''</span>).split(<span class=\"string\">'.'</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    gulp.src(<span class=\"string\">'src/scripts/app.*.js'</span>).pipe(through2.obj(<span class=\"function\">(<span class=\"params\">file, enc, cb</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        hash.app = file.history.toString().replace(file.base,<span class=\"string\">''</span>).split(<span class=\"string\">'.'</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    gulp.src(<span class=\"string\">'src/css/app.*.css'</span>).pipe(through2.obj(<span class=\"function\">(<span class=\"params\">file, enc, cb</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        hash.css = file.history.toString().replace(file.base,<span class=\"string\">''</span>).split(<span class=\"string\">'.'</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    handleJsp(hash)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'default'</span>,[<span class=\"string\">'del'</span>,<span class=\"string\">'cp'</span>,<span class=\"string\">'insert'</span>])</span><br></pre></td></tr></table></figure>"},{"title":"前端路由的原理和实现","date":"2018-06-21T16:00:00.000Z","_content":"## 什么是前端路由\n\n路由是根据不同的 url 地址展示不同的内容或页面。\n\n早期的路由都是后端直接根据 url 来 reload 页面实现的，即后端控制路由。后来页面越来越复杂，服务器压力越来越大，随着 ajax（异步刷新技术） 的出现，页面实现非 reload 就能刷新数据，让前端也可以控制 url 自行管理，前端路由由此而生。\n\n单页面应用的实现，就是因为有了前端路由这个概念。\n<!--more-->\n## 前端路由的两种模式\n\n### Hash路由\n\nhash就是指在 url 中看到 #， 以及其后面的字符。这个 # 有两种情况，一个是我们所谓的锚点，本身是用来做页面定位的，它可以使对应 id 的元素显示在可视区域内。而路由里的 # 不叫锚点，我们称之为 hash。hash满足以下几个特性，才使得其可以实现前端路由：\n\n1. url中hash值的变化并不会重新加载页面，因为hash是用来指导浏览器行为的，对服务端是无用的，所以不会包括在http请求中。\n2. hash值的改变，都会在浏览器的访问历史中增加一个记录，也就是能通过浏览器的回退、前进按钮控制hash的切换\n3. 我们可以通过hashchange事件，监听到hash值的变化，从而响应不同路径的逻辑处理。\n\n触发hash值的变化有2种方法:\n\n1. 一种是通过a标签，设置href属性，当标签点击之后，地址栏会改变，同时会触发hashchange事件\n\n````html\n<a href=\"#index\">to index</a>\n````\n\n2. 一种是通过js直接赋值给location.hash，也会改变url，触发hashchange事件。\n\n````javascript\nwindow.location.hash=\"#index\"\n````\n### History路由\n\nHTML5的 History API 为浏览器的全局history对象增加了扩展方法。\n\nwindow对象提供了onpopstate事件来监听历史栈的改变,一旦历史栈信息发生改变,便会触发该事件。\n\n**特别注意的是,调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件。**\n\nhistory提供了两个操作历史栈的API:history.pushState 和 history.replaceState,这两个API都接收三个参数：\n````javascript\nwindow.history.pushState(null, null, \"http://www.google.com\");\nwindow.history.replaceState(null, null, \"http://www.google.com\");\n````\n* 状态对象（state object），一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，会触发popstate事件，并能在事件中使用该对象。\n* 标题（title） ：传入一个短标题给当前state。现在大多数浏览器不支持或者会忽略此参数，最好传入null代替；\n* 地址（URL）：新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。\n\n这两个API的相同之处是都会操作浏览器的历史记录，而不会引起页面的刷新。不同之处在于，pushState会增加一条新的历史记录，而replaceState则会替换当前的历史记录。这两个api，加上state改变触发的popstate事件，提供了单页应该的另一种路由方式。\n\n**当我们使用history模式时，如果服务器没有进行配置,刷新页面会出现404。**\n\n原因是因为history模式的url是真实的url,服务器会对url的文件路径进行资源查找,找不到资源就会返回404。\n\n解决方法就是对服务器进行配置，将所有向服务器请求的URL资源，都重定向到index.html返回给客户端。\n\n* 在nignx环境下：\n\n````shell\nlocation /{\n    root   /data/nginx/html;\n    index  index.html index.htm;\n    error_page 404 /index.html;\n}\n````\n* http-server下：\n\n安装npm包 spa-http-server，启动时增加 --push-state 参数\n````shell\nhttp-server --push-state\n````\n\n* webpack开发环境下：\n\n使用webpack-dev-server的里的historyApiFallback属性来支持HTML5 History Mode。\n````javascript\n{\n    \n    devServer: {\n        //在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html (解决histroy mode 404)\n        historyApiFallback: true\n      }\n}\n````\n\n### 兼容性\n\n出现兼容性问题主要是在IE下面，hash路由在IE8及以上可用，而history路由在IE10及以上才可用。\n\n## 实现一个简单的路由\n\n先构造一个myRouter类，根据不同的mode参数，分别为这两种方式创建对应的类,并进行实例化,完成myRouter类的实现。\n\n````javascript\nclass myRouter {\n  constructor(opts) {\n    this.router = opts.mode !== 'hash' ? new HistoryRouter(opts) : new HashRouter(opts)\n    this.router.init()\n  }\n  push(path) {\n    this.router.push(path)\n  }\n  replace(path) {\n    this.router.replace(path)\n  }\n  go(num) {\n    this.router.go(num)\n  }\n}\n````\n### hashRouter\n* 初始化\n\n插件在被调用的时候进行初始化，作用是注册路由以及绑定对应的路由切换事件的。\n````javascript\ninit() {\n  var that = this\n  // 注册路由\n  this.initRouter()\n  // debugger\n  // 页面加载匹配路由\n  window.addEventListener('load', function () {\n      that.urlChange()\n  })\n\n  // 路由切换\n  window.addEventListener('hashchange', function () {\n      that.urlChange()\n  })\n}\n````\n* 路由注册\n\n将路由对象数组参数在初始化的时候就做好路由匹配。this.routers用来存储路由对象，执行每一个路由的callback函数就是加载对应的js文件。\n````javascript\ninitRouter() {\n  // debugger\n  (this.opts.routes || []).forEach((item, index) => {\n      this.map(item)\n  })\n}\n\n// 单个路由注册\nmap(item) {\n  let path = item.path.replace(/\\s*/g, '')// 过滤空格\n  \n  this.routers[path] = {\n    callback: (state) => {\n      return this.asyncFun(item.url, state)\n    } // 回调\n  }\n}\n````\n\n* asyncFun函数\n\n异步加载目标js文件\n\n````javascript\n// 路由异步懒加载js文件\nasyncFun(file, transition) {\n  var that = this\n\n  var _body = document.getElementsByTagName('body')[0]\n  var scriptEle = document.createElement('script')\n  scriptEle.type = 'text/javascript'\n  scriptEle.src = file\n  scriptEle.async = true\n  \n  scriptEle.onload = function () {\n    that.opts.afterFun && that.opts.afterFun(transition)\n  }\n  _body.appendChild(scriptEle)\n}\n````\n* render函数\n\n作用就是渲染页面，在这里也就是执行加载路由对应的js文件。如果存在beforeFun钩子的话，则由beforeFun钩子触发render函数。\n\n````javascript\n  // 渲染视图(执行匹配到的js代码)\n  render(currentPath) {\n    this.currentPath = currentPath\n    // 全局路由守护\n    let pathObj = this.routers[currentPath.path]\n    if(!pathObj) {\n      alert('404')\n      return \n    }\n\n    if (this.opts.beforeFun) {\n      this.opts.beforeFun({\n        to: {\n          path: currentPath.path,\n          query: currentPath.query\n        },\n        next() {\n          // 执行目标路由对应的js代码（相当于是组件渲染）\n          pathObj.callback(currentPath)\n        }\n      })\n    } else {\n      pathObj.callback(currentPath)\n    }\n  }\n````\n\n### historyRouter\n\nhistoryRouter的实现与HashRouter的实现也是很类似的，下面只写下不同之处：\n* 路由监听\n\n1. historyRouter\n\n````javascript\nwindow.addEventListener('popstate', function () {\n    that.urlChange()\n})\n````\n\n2. HashRouter\n\n````javascript\nwindow.addEventListener('hashchange', function () {\n    that.urlChange()\n})\n````\n* 获取当前路由和参数\n\n1. historyRouter\n\n````javascript\n//获取当前hash\ngetPath() {\n  var hash = window.location.pathname\n  return hash \n}\n//获取参数\ngetParams() {\n  var paramsStr = window.location.search\n  var index = paramsStr.indexOf('?')\n  var params = {}\n\n  if(index !== -1) {\n    let arr = paramsStr.slice(1).split('&')\n    for(let i = 0; i < arr.length; i++){\n      let data = arr[i].split(\"=\")\n      if(data.length == 2){\n          params[data[0]] = data[1]\n    }\n    }\n  }\n  return params\n}\n````\n\n2. HashRouter\n\n````javascript\n//获取当前hash\ngetHash() {\n  var hash = window.location.hash.slice(1)\n  var index = hash.indexOf('?')\n  if(hash === '') return '/'\n\n  if(index !== -1) {\n    return hash.slice(0, index)\n  }   \n  \n  return hash \n}\n//获取参数\ngetParams() {\n  var hash = window.location.hash\n  var index = hash.indexOf('?')\n  var params = {}\n\n  if(index !== -1) {\n    let arr = hash.slice(index + 1).split('&')\n    for(let i = 0; i < arr.length; i++){\n      let data = arr[i].split(\"=\")\n      if(data.length == 2){\n          params[data[0]] = data[1]\n    }\n  }\n}\n  return params\n}\n````\n\n* push方法，压入history栈，进行路由跳转\n\n\n1. historyRouter\n\n````javascript\npush(path) {\n    window.history.pushState(null, null, path)\n    this.urlChange() //手动触发\n  }\n````\n\n2. HashRouter\n\n````javascript\npush(path) {\n    window.location.hash = path\n  }\n````\n## 完整代码\n[router](https://github.com/60kmlh/router)\n## 参考资料\n\n* [[实践系列] 前端路由](https://juejin.im/post/5c380afde51d4552232fb077)\n* [浅谈前端路由](https://github.com/kaola-fed/blog/issues/137)\n* [JS 专题系列-前端路由](https://juejin.im/post/5c4bbeaae51d453ba8104f39)\n* [前端路由实现及 react-router v4 源码分析](https://juejin.im/post/5b45c878f265da0f783c89a6)\n* [前端路由实现与 react-router 源码分析](http://web.jobbole.com/86407/)\n* [spa-http-server](https://www.npmjs.com/package/spa-http-server)","source":"_posts/前端路由的原理与实现.md","raw":"---\ntitle: 前端路由的原理和实现\ndate: 2018-06-22\ntags: ['路由']\ncategories: ['路由']\n---\n## 什么是前端路由\n\n路由是根据不同的 url 地址展示不同的内容或页面。\n\n早期的路由都是后端直接根据 url 来 reload 页面实现的，即后端控制路由。后来页面越来越复杂，服务器压力越来越大，随着 ajax（异步刷新技术） 的出现，页面实现非 reload 就能刷新数据，让前端也可以控制 url 自行管理，前端路由由此而生。\n\n单页面应用的实现，就是因为有了前端路由这个概念。\n<!--more-->\n## 前端路由的两种模式\n\n### Hash路由\n\nhash就是指在 url 中看到 #， 以及其后面的字符。这个 # 有两种情况，一个是我们所谓的锚点，本身是用来做页面定位的，它可以使对应 id 的元素显示在可视区域内。而路由里的 # 不叫锚点，我们称之为 hash。hash满足以下几个特性，才使得其可以实现前端路由：\n\n1. url中hash值的变化并不会重新加载页面，因为hash是用来指导浏览器行为的，对服务端是无用的，所以不会包括在http请求中。\n2. hash值的改变，都会在浏览器的访问历史中增加一个记录，也就是能通过浏览器的回退、前进按钮控制hash的切换\n3. 我们可以通过hashchange事件，监听到hash值的变化，从而响应不同路径的逻辑处理。\n\n触发hash值的变化有2种方法:\n\n1. 一种是通过a标签，设置href属性，当标签点击之后，地址栏会改变，同时会触发hashchange事件\n\n````html\n<a href=\"#index\">to index</a>\n````\n\n2. 一种是通过js直接赋值给location.hash，也会改变url，触发hashchange事件。\n\n````javascript\nwindow.location.hash=\"#index\"\n````\n### History路由\n\nHTML5的 History API 为浏览器的全局history对象增加了扩展方法。\n\nwindow对象提供了onpopstate事件来监听历史栈的改变,一旦历史栈信息发生改变,便会触发该事件。\n\n**特别注意的是,调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件。**\n\nhistory提供了两个操作历史栈的API:history.pushState 和 history.replaceState,这两个API都接收三个参数：\n````javascript\nwindow.history.pushState(null, null, \"http://www.google.com\");\nwindow.history.replaceState(null, null, \"http://www.google.com\");\n````\n* 状态对象（state object），一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，会触发popstate事件，并能在事件中使用该对象。\n* 标题（title） ：传入一个短标题给当前state。现在大多数浏览器不支持或者会忽略此参数，最好传入null代替；\n* 地址（URL）：新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。\n\n这两个API的相同之处是都会操作浏览器的历史记录，而不会引起页面的刷新。不同之处在于，pushState会增加一条新的历史记录，而replaceState则会替换当前的历史记录。这两个api，加上state改变触发的popstate事件，提供了单页应该的另一种路由方式。\n\n**当我们使用history模式时，如果服务器没有进行配置,刷新页面会出现404。**\n\n原因是因为history模式的url是真实的url,服务器会对url的文件路径进行资源查找,找不到资源就会返回404。\n\n解决方法就是对服务器进行配置，将所有向服务器请求的URL资源，都重定向到index.html返回给客户端。\n\n* 在nignx环境下：\n\n````shell\nlocation /{\n    root   /data/nginx/html;\n    index  index.html index.htm;\n    error_page 404 /index.html;\n}\n````\n* http-server下：\n\n安装npm包 spa-http-server，启动时增加 --push-state 参数\n````shell\nhttp-server --push-state\n````\n\n* webpack开发环境下：\n\n使用webpack-dev-server的里的historyApiFallback属性来支持HTML5 History Mode。\n````javascript\n{\n    \n    devServer: {\n        //在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html (解决histroy mode 404)\n        historyApiFallback: true\n      }\n}\n````\n\n### 兼容性\n\n出现兼容性问题主要是在IE下面，hash路由在IE8及以上可用，而history路由在IE10及以上才可用。\n\n## 实现一个简单的路由\n\n先构造一个myRouter类，根据不同的mode参数，分别为这两种方式创建对应的类,并进行实例化,完成myRouter类的实现。\n\n````javascript\nclass myRouter {\n  constructor(opts) {\n    this.router = opts.mode !== 'hash' ? new HistoryRouter(opts) : new HashRouter(opts)\n    this.router.init()\n  }\n  push(path) {\n    this.router.push(path)\n  }\n  replace(path) {\n    this.router.replace(path)\n  }\n  go(num) {\n    this.router.go(num)\n  }\n}\n````\n### hashRouter\n* 初始化\n\n插件在被调用的时候进行初始化，作用是注册路由以及绑定对应的路由切换事件的。\n````javascript\ninit() {\n  var that = this\n  // 注册路由\n  this.initRouter()\n  // debugger\n  // 页面加载匹配路由\n  window.addEventListener('load', function () {\n      that.urlChange()\n  })\n\n  // 路由切换\n  window.addEventListener('hashchange', function () {\n      that.urlChange()\n  })\n}\n````\n* 路由注册\n\n将路由对象数组参数在初始化的时候就做好路由匹配。this.routers用来存储路由对象，执行每一个路由的callback函数就是加载对应的js文件。\n````javascript\ninitRouter() {\n  // debugger\n  (this.opts.routes || []).forEach((item, index) => {\n      this.map(item)\n  })\n}\n\n// 单个路由注册\nmap(item) {\n  let path = item.path.replace(/\\s*/g, '')// 过滤空格\n  \n  this.routers[path] = {\n    callback: (state) => {\n      return this.asyncFun(item.url, state)\n    } // 回调\n  }\n}\n````\n\n* asyncFun函数\n\n异步加载目标js文件\n\n````javascript\n// 路由异步懒加载js文件\nasyncFun(file, transition) {\n  var that = this\n\n  var _body = document.getElementsByTagName('body')[0]\n  var scriptEle = document.createElement('script')\n  scriptEle.type = 'text/javascript'\n  scriptEle.src = file\n  scriptEle.async = true\n  \n  scriptEle.onload = function () {\n    that.opts.afterFun && that.opts.afterFun(transition)\n  }\n  _body.appendChild(scriptEle)\n}\n````\n* render函数\n\n作用就是渲染页面，在这里也就是执行加载路由对应的js文件。如果存在beforeFun钩子的话，则由beforeFun钩子触发render函数。\n\n````javascript\n  // 渲染视图(执行匹配到的js代码)\n  render(currentPath) {\n    this.currentPath = currentPath\n    // 全局路由守护\n    let pathObj = this.routers[currentPath.path]\n    if(!pathObj) {\n      alert('404')\n      return \n    }\n\n    if (this.opts.beforeFun) {\n      this.opts.beforeFun({\n        to: {\n          path: currentPath.path,\n          query: currentPath.query\n        },\n        next() {\n          // 执行目标路由对应的js代码（相当于是组件渲染）\n          pathObj.callback(currentPath)\n        }\n      })\n    } else {\n      pathObj.callback(currentPath)\n    }\n  }\n````\n\n### historyRouter\n\nhistoryRouter的实现与HashRouter的实现也是很类似的，下面只写下不同之处：\n* 路由监听\n\n1. historyRouter\n\n````javascript\nwindow.addEventListener('popstate', function () {\n    that.urlChange()\n})\n````\n\n2. HashRouter\n\n````javascript\nwindow.addEventListener('hashchange', function () {\n    that.urlChange()\n})\n````\n* 获取当前路由和参数\n\n1. historyRouter\n\n````javascript\n//获取当前hash\ngetPath() {\n  var hash = window.location.pathname\n  return hash \n}\n//获取参数\ngetParams() {\n  var paramsStr = window.location.search\n  var index = paramsStr.indexOf('?')\n  var params = {}\n\n  if(index !== -1) {\n    let arr = paramsStr.slice(1).split('&')\n    for(let i = 0; i < arr.length; i++){\n      let data = arr[i].split(\"=\")\n      if(data.length == 2){\n          params[data[0]] = data[1]\n    }\n    }\n  }\n  return params\n}\n````\n\n2. HashRouter\n\n````javascript\n//获取当前hash\ngetHash() {\n  var hash = window.location.hash.slice(1)\n  var index = hash.indexOf('?')\n  if(hash === '') return '/'\n\n  if(index !== -1) {\n    return hash.slice(0, index)\n  }   \n  \n  return hash \n}\n//获取参数\ngetParams() {\n  var hash = window.location.hash\n  var index = hash.indexOf('?')\n  var params = {}\n\n  if(index !== -1) {\n    let arr = hash.slice(index + 1).split('&')\n    for(let i = 0; i < arr.length; i++){\n      let data = arr[i].split(\"=\")\n      if(data.length == 2){\n          params[data[0]] = data[1]\n    }\n  }\n}\n  return params\n}\n````\n\n* push方法，压入history栈，进行路由跳转\n\n\n1. historyRouter\n\n````javascript\npush(path) {\n    window.history.pushState(null, null, path)\n    this.urlChange() //手动触发\n  }\n````\n\n2. HashRouter\n\n````javascript\npush(path) {\n    window.location.hash = path\n  }\n````\n## 完整代码\n[router](https://github.com/60kmlh/router)\n## 参考资料\n\n* [[实践系列] 前端路由](https://juejin.im/post/5c380afde51d4552232fb077)\n* [浅谈前端路由](https://github.com/kaola-fed/blog/issues/137)\n* [JS 专题系列-前端路由](https://juejin.im/post/5c4bbeaae51d453ba8104f39)\n* [前端路由实现及 react-router v4 源码分析](https://juejin.im/post/5b45c878f265da0f783c89a6)\n* [前端路由实现与 react-router 源码分析](http://web.jobbole.com/86407/)\n* [spa-http-server](https://www.npmjs.com/package/spa-http-server)","slug":"前端路由的原理与实现","published":1,"updated":"2022-04-13T14:14:08.025Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfg1003jg3t8qw7f5pit","content":"<h2 id=\"什么是前端路由\"><a href=\"#什么是前端路由\" class=\"headerlink\" title=\"什么是前端路由\"></a>什么是前端路由</h2><p>路由是根据不同的 url 地址展示不同的内容或页面。</p>\n<p>早期的路由都是后端直接根据 url 来 reload 页面实现的，即后端控制路由。后来页面越来越复杂，服务器压力越来越大，随着 ajax（异步刷新技术） 的出现，页面实现非 reload 就能刷新数据，让前端也可以控制 url 自行管理，前端路由由此而生。</p>\n<p>单页面应用的实现，就是因为有了前端路由这个概念。<br><a id=\"more\"></a></p>\n<h2 id=\"前端路由的两种模式\"><a href=\"#前端路由的两种模式\" class=\"headerlink\" title=\"前端路由的两种模式\"></a>前端路由的两种模式</h2><h3 id=\"Hash路由\"><a href=\"#Hash路由\" class=\"headerlink\" title=\"Hash路由\"></a>Hash路由</h3><p>hash就是指在 url 中看到 #， 以及其后面的字符。这个 # 有两种情况，一个是我们所谓的锚点，本身是用来做页面定位的，它可以使对应 id 的元素显示在可视区域内。而路由里的 # 不叫锚点，我们称之为 hash。hash满足以下几个特性，才使得其可以实现前端路由：</p>\n<ol>\n<li>url中hash值的变化并不会重新加载页面，因为hash是用来指导浏览器行为的，对服务端是无用的，所以不会包括在http请求中。</li>\n<li>hash值的改变，都会在浏览器的访问历史中增加一个记录，也就是能通过浏览器的回退、前进按钮控制hash的切换</li>\n<li>我们可以通过hashchange事件，监听到hash值的变化，从而响应不同路径的逻辑处理。</li>\n</ol>\n<p>触发hash值的变化有2种方法:</p>\n<ol>\n<li>一种是通过a标签，设置href属性，当标签点击之后，地址栏会改变，同时会触发hashchange事件</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#index\"</span>&gt;</span>to index<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>一种是通过js直接赋值给location.hash，也会改变url，触发hashchange事件。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.location.hash=<span class=\"string\">\"#index\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"History路由\"><a href=\"#History路由\" class=\"headerlink\" title=\"History路由\"></a>History路由</h3><p>HTML5的 History API 为浏览器的全局history对象增加了扩展方法。</p>\n<p>window对象提供了onpopstate事件来监听历史栈的改变,一旦历史栈信息发生改变,便会触发该事件。</p>\n<p><strong>特别注意的是,调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件。</strong></p>\n<p>history提供了两个操作历史栈的API:history.pushState 和 history.replaceState,这两个API都接收三个参数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.history.pushState(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"string\">\"http://www.google.com\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">window</span>.history.replaceState(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"string\">\"http://www.google.com\"</span>);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>状态对象（state object），一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，会触发popstate事件，并能在事件中使用该对象。</li>\n<li>标题（title） ：传入一个短标题给当前state。现在大多数浏览器不支持或者会忽略此参数，最好传入null代替；</li>\n<li>地址（URL）：新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。</li>\n</ul>\n<p>这两个API的相同之处是都会操作浏览器的历史记录，而不会引起页面的刷新。不同之处在于，pushState会增加一条新的历史记录，而replaceState则会替换当前的历史记录。这两个api，加上state改变触发的popstate事件，提供了单页应该的另一种路由方式。</p>\n<p><strong>当我们使用history模式时，如果服务器没有进行配置,刷新页面会出现404。</strong></p>\n<p>原因是因为history模式的url是真实的url,服务器会对url的文件路径进行资源查找,找不到资源就会返回404。</p>\n<p>解决方法就是对服务器进行配置，将所有向服务器请求的URL资源，都重定向到index.html返回给客户端。</p>\n<ul>\n<li>在nignx环境下：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /&#123;</span><br><span class=\"line\">    root   /data/nginx/html;</span><br><span class=\"line\">    index  index.html index.htm;</span><br><span class=\"line\">    error_page 404 /index.html;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>http-server下：</li>\n</ul>\n<p>安装npm包 spa-http-server，启动时增加 –push-state 参数<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-server --push-state</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>webpack开发环境下：</li>\n</ul>\n<p>使用webpack-dev-server的里的historyApiFallback属性来支持HTML5 History Mode。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    devServer: &#123;</span><br><span class=\"line\">        <span class=\"comment\">//在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html (解决histroy mode 404)</span></span><br><span class=\"line\">        historyApiFallback: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p>出现兼容性问题主要是在IE下面，hash路由在IE8及以上可用，而history路由在IE10及以上才可用。</p>\n<h2 id=\"实现一个简单的路由\"><a href=\"#实现一个简单的路由\" class=\"headerlink\" title=\"实现一个简单的路由\"></a>实现一个简单的路由</h2><p>先构造一个myRouter类，根据不同的mode参数，分别为这两种方式创建对应的类,并进行实例化,完成myRouter类的实现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">myRouter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(opts) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.router = opts.mode !== <span class=\"string\">'hash'</span> ? <span class=\"keyword\">new</span> HistoryRouter(opts) : <span class=\"keyword\">new</span> HashRouter(opts)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.router.init()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  push(path) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.router.push(path)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  replace(path) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.router.replace(path)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  go(num) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.router.go(num)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"hashRouter\"><a href=\"#hashRouter\" class=\"headerlink\" title=\"hashRouter\"></a>hashRouter</h3><ul>\n<li>初始化</li>\n</ul>\n<p>插件在被调用的时候进行初始化，作用是注册路由以及绑定对应的路由切换事件的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"comment\">// 注册路由</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.initRouter()</span><br><span class=\"line\">  <span class=\"comment\">// debugger</span></span><br><span class=\"line\">  <span class=\"comment\">// 页面加载匹配路由</span></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      that.urlChange()</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 路由切换</span></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'hashchange'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      that.urlChange()</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>路由注册</li>\n</ul>\n<p>将路由对象数组参数在初始化的时候就做好路由匹配。this.routers用来存储路由对象，执行每一个路由的callback函数就是加载对应的js文件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">initRouter() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// debugger</span></span><br><span class=\"line\">  (<span class=\"keyword\">this</span>.opts.routes || []).forEach(<span class=\"function\">(<span class=\"params\">item, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.map(item)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 单个路由注册</span></span><br><span class=\"line\">map(item) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> path = item.path.replace(<span class=\"regexp\">/\\s*/g</span>, <span class=\"string\">''</span>)<span class=\"comment\">// 过滤空格</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.routers[path] = &#123;</span><br><span class=\"line\">    callback: <span class=\"function\">(<span class=\"params\">state</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.asyncFun(item.url, state)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// 回调</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>asyncFun函数</li>\n</ul>\n<p>异步加载目标js文件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 路由异步懒加载js文件</span></span><br><span class=\"line\">asyncFun(file, transition) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> _body = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'body'</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> scriptEle = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>)</span><br><span class=\"line\">  scriptEle.type = <span class=\"string\">'text/javascript'</span></span><br><span class=\"line\">  scriptEle.src = file</span><br><span class=\"line\">  scriptEle.async = <span class=\"literal\">true</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  scriptEle.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    that.opts.afterFun &amp;&amp; that.opts.afterFun(transition)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _body.appendChild(scriptEle)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>render函数</li>\n</ul>\n<p>作用就是渲染页面，在这里也就是执行加载路由对应的js文件。如果存在beforeFun钩子的话，则由beforeFun钩子触发render函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 渲染视图(执行匹配到的js代码)</span></span><br><span class=\"line\">render(currentPath) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.currentPath = currentPath</span><br><span class=\"line\">  <span class=\"comment\">// 全局路由守护</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> pathObj = <span class=\"keyword\">this</span>.routers[currentPath.path]</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!pathObj) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'404'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.opts.beforeFun) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.opts.beforeFun(&#123;</span><br><span class=\"line\">      to: &#123;</span><br><span class=\"line\">        path: currentPath.path,</span><br><span class=\"line\">        query: currentPath.query</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      next() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行目标路由对应的js代码（相当于是组件渲染）</span></span><br><span class=\"line\">        pathObj.callback(currentPath)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    pathObj.callback(currentPath)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"historyRouter\"><a href=\"#historyRouter\" class=\"headerlink\" title=\"historyRouter\"></a>historyRouter</h3><p>historyRouter的实现与HashRouter的实现也是很类似的，下面只写下不同之处：</p>\n<ul>\n<li>路由监听</li>\n</ul>\n<ol>\n<li>historyRouter</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'popstate'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    that.urlChange()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>HashRouter</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'hashchange'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    that.urlChange()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取当前路由和参数</li>\n</ul>\n<ol>\n<li>historyRouter</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取当前hash</span></span><br><span class=\"line\">getPath() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> hash = <span class=\"built_in\">window</span>.location.pathname</span><br><span class=\"line\">  <span class=\"keyword\">return</span> hash </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//获取参数</span></span><br><span class=\"line\">getParams() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> paramsStr = <span class=\"built_in\">window</span>.location.search</span><br><span class=\"line\">  <span class=\"keyword\">var</span> index = paramsStr.indexOf(<span class=\"string\">'?'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> params = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(index !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = paramsStr.slice(<span class=\"number\">1</span>).split(<span class=\"string\">'&amp;'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> data = arr[i].split(<span class=\"string\">\"=\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(data.length == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">          params[data[<span class=\"number\">0</span>]] = data[<span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> params</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>HashRouter</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取当前hash</span></span><br><span class=\"line\">getHash() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> hash = <span class=\"built_in\">window</span>.location.hash.slice(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> index = hash.indexOf(<span class=\"string\">'?'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(hash === <span class=\"string\">''</span>) <span class=\"keyword\">return</span> <span class=\"string\">'/'</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(index !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hash.slice(<span class=\"number\">0</span>, index)</span><br><span class=\"line\">  &#125;   </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> hash </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//获取参数</span></span><br><span class=\"line\">getParams() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> hash = <span class=\"built_in\">window</span>.location.hash</span><br><span class=\"line\">  <span class=\"keyword\">var</span> index = hash.indexOf(<span class=\"string\">'?'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> params = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(index !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = hash.slice(index + <span class=\"number\">1</span>).split(<span class=\"string\">'&amp;'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> data = arr[i].split(<span class=\"string\">\"=\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(data.length == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">          params[data[<span class=\"number\">0</span>]] = data[<span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> params</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>push方法，压入history栈，进行路由跳转</li>\n</ul>\n<ol>\n<li>historyRouter</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push(path) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.history.pushState(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>, path)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.urlChange() <span class=\"comment\">//手动触发</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>HashRouter</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push(path) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.location.hash = path</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p><a href=\"https://github.com/60kmlh/router\" target=\"_blank\" rel=\"noopener\">router</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://juejin.im/post/5c380afde51d4552232fb077\" target=\"_blank\" rel=\"noopener\">[实践系列] 前端路由</a></li>\n<li><a href=\"https://github.com/kaola-fed/blog/issues/137\" target=\"_blank\" rel=\"noopener\">浅谈前端路由</a></li>\n<li><a href=\"https://juejin.im/post/5c4bbeaae51d453ba8104f39\" target=\"_blank\" rel=\"noopener\">JS 专题系列-前端路由</a></li>\n<li><a href=\"https://juejin.im/post/5b45c878f265da0f783c89a6\" target=\"_blank\" rel=\"noopener\">前端路由实现及 react-router v4 源码分析</a></li>\n<li><a href=\"http://web.jobbole.com/86407/\" target=\"_blank\" rel=\"noopener\">前端路由实现与 react-router 源码分析</a></li>\n<li><a href=\"https://www.npmjs.com/package/spa-http-server\" target=\"_blank\" rel=\"noopener\">spa-http-server</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是前端路由\"><a href=\"#什么是前端路由\" class=\"headerlink\" title=\"什么是前端路由\"></a>什么是前端路由</h2><p>路由是根据不同的 url 地址展示不同的内容或页面。</p>\n<p>早期的路由都是后端直接根据 url 来 reload 页面实现的，即后端控制路由。后来页面越来越复杂，服务器压力越来越大，随着 ajax（异步刷新技术） 的出现，页面实现非 reload 就能刷新数据，让前端也可以控制 url 自行管理，前端路由由此而生。</p>\n<p>单页面应用的实现，就是因为有了前端路由这个概念。<br>","more":"</p>\n<h2 id=\"前端路由的两种模式\"><a href=\"#前端路由的两种模式\" class=\"headerlink\" title=\"前端路由的两种模式\"></a>前端路由的两种模式</h2><h3 id=\"Hash路由\"><a href=\"#Hash路由\" class=\"headerlink\" title=\"Hash路由\"></a>Hash路由</h3><p>hash就是指在 url 中看到 #， 以及其后面的字符。这个 # 有两种情况，一个是我们所谓的锚点，本身是用来做页面定位的，它可以使对应 id 的元素显示在可视区域内。而路由里的 # 不叫锚点，我们称之为 hash。hash满足以下几个特性，才使得其可以实现前端路由：</p>\n<ol>\n<li>url中hash值的变化并不会重新加载页面，因为hash是用来指导浏览器行为的，对服务端是无用的，所以不会包括在http请求中。</li>\n<li>hash值的改变，都会在浏览器的访问历史中增加一个记录，也就是能通过浏览器的回退、前进按钮控制hash的切换</li>\n<li>我们可以通过hashchange事件，监听到hash值的变化，从而响应不同路径的逻辑处理。</li>\n</ol>\n<p>触发hash值的变化有2种方法:</p>\n<ol>\n<li>一种是通过a标签，设置href属性，当标签点击之后，地址栏会改变，同时会触发hashchange事件</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#index\"</span>&gt;</span>to index<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>一种是通过js直接赋值给location.hash，也会改变url，触发hashchange事件。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.location.hash=<span class=\"string\">\"#index\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"History路由\"><a href=\"#History路由\" class=\"headerlink\" title=\"History路由\"></a>History路由</h3><p>HTML5的 History API 为浏览器的全局history对象增加了扩展方法。</p>\n<p>window对象提供了onpopstate事件来监听历史栈的改变,一旦历史栈信息发生改变,便会触发该事件。</p>\n<p><strong>特别注意的是,调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件。</strong></p>\n<p>history提供了两个操作历史栈的API:history.pushState 和 history.replaceState,这两个API都接收三个参数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.history.pushState(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"string\">\"http://www.google.com\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">window</span>.history.replaceState(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"string\">\"http://www.google.com\"</span>);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>状态对象（state object），一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，会触发popstate事件，并能在事件中使用该对象。</li>\n<li>标题（title） ：传入一个短标题给当前state。现在大多数浏览器不支持或者会忽略此参数，最好传入null代替；</li>\n<li>地址（URL）：新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。</li>\n</ul>\n<p>这两个API的相同之处是都会操作浏览器的历史记录，而不会引起页面的刷新。不同之处在于，pushState会增加一条新的历史记录，而replaceState则会替换当前的历史记录。这两个api，加上state改变触发的popstate事件，提供了单页应该的另一种路由方式。</p>\n<p><strong>当我们使用history模式时，如果服务器没有进行配置,刷新页面会出现404。</strong></p>\n<p>原因是因为history模式的url是真实的url,服务器会对url的文件路径进行资源查找,找不到资源就会返回404。</p>\n<p>解决方法就是对服务器进行配置，将所有向服务器请求的URL资源，都重定向到index.html返回给客户端。</p>\n<ul>\n<li>在nignx环境下：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /&#123;</span><br><span class=\"line\">    root   /data/nginx/html;</span><br><span class=\"line\">    index  index.html index.htm;</span><br><span class=\"line\">    error_page 404 /index.html;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>http-server下：</li>\n</ul>\n<p>安装npm包 spa-http-server，启动时增加 –push-state 参数<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-server --push-state</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>webpack开发环境下：</li>\n</ul>\n<p>使用webpack-dev-server的里的historyApiFallback属性来支持HTML5 History Mode。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    devServer: &#123;</span><br><span class=\"line\">        <span class=\"comment\">//在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html (解决histroy mode 404)</span></span><br><span class=\"line\">        historyApiFallback: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p>出现兼容性问题主要是在IE下面，hash路由在IE8及以上可用，而history路由在IE10及以上才可用。</p>\n<h2 id=\"实现一个简单的路由\"><a href=\"#实现一个简单的路由\" class=\"headerlink\" title=\"实现一个简单的路由\"></a>实现一个简单的路由</h2><p>先构造一个myRouter类，根据不同的mode参数，分别为这两种方式创建对应的类,并进行实例化,完成myRouter类的实现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">myRouter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(opts) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.router = opts.mode !== <span class=\"string\">'hash'</span> ? <span class=\"keyword\">new</span> HistoryRouter(opts) : <span class=\"keyword\">new</span> HashRouter(opts)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.router.init()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  push(path) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.router.push(path)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  replace(path) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.router.replace(path)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  go(num) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.router.go(num)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"hashRouter\"><a href=\"#hashRouter\" class=\"headerlink\" title=\"hashRouter\"></a>hashRouter</h3><ul>\n<li>初始化</li>\n</ul>\n<p>插件在被调用的时候进行初始化，作用是注册路由以及绑定对应的路由切换事件的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"comment\">// 注册路由</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.initRouter()</span><br><span class=\"line\">  <span class=\"comment\">// debugger</span></span><br><span class=\"line\">  <span class=\"comment\">// 页面加载匹配路由</span></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      that.urlChange()</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 路由切换</span></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'hashchange'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      that.urlChange()</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>路由注册</li>\n</ul>\n<p>将路由对象数组参数在初始化的时候就做好路由匹配。this.routers用来存储路由对象，执行每一个路由的callback函数就是加载对应的js文件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">initRouter() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// debugger</span></span><br><span class=\"line\">  (<span class=\"keyword\">this</span>.opts.routes || []).forEach(<span class=\"function\">(<span class=\"params\">item, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.map(item)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 单个路由注册</span></span><br><span class=\"line\">map(item) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> path = item.path.replace(<span class=\"regexp\">/\\s*/g</span>, <span class=\"string\">''</span>)<span class=\"comment\">// 过滤空格</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.routers[path] = &#123;</span><br><span class=\"line\">    callback: <span class=\"function\">(<span class=\"params\">state</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.asyncFun(item.url, state)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// 回调</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>asyncFun函数</li>\n</ul>\n<p>异步加载目标js文件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 路由异步懒加载js文件</span></span><br><span class=\"line\">asyncFun(file, transition) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> _body = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'body'</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> scriptEle = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>)</span><br><span class=\"line\">  scriptEle.type = <span class=\"string\">'text/javascript'</span></span><br><span class=\"line\">  scriptEle.src = file</span><br><span class=\"line\">  scriptEle.async = <span class=\"literal\">true</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  scriptEle.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    that.opts.afterFun &amp;&amp; that.opts.afterFun(transition)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _body.appendChild(scriptEle)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>render函数</li>\n</ul>\n<p>作用就是渲染页面，在这里也就是执行加载路由对应的js文件。如果存在beforeFun钩子的话，则由beforeFun钩子触发render函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 渲染视图(执行匹配到的js代码)</span></span><br><span class=\"line\">render(currentPath) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.currentPath = currentPath</span><br><span class=\"line\">  <span class=\"comment\">// 全局路由守护</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> pathObj = <span class=\"keyword\">this</span>.routers[currentPath.path]</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!pathObj) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'404'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.opts.beforeFun) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.opts.beforeFun(&#123;</span><br><span class=\"line\">      to: &#123;</span><br><span class=\"line\">        path: currentPath.path,</span><br><span class=\"line\">        query: currentPath.query</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      next() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行目标路由对应的js代码（相当于是组件渲染）</span></span><br><span class=\"line\">        pathObj.callback(currentPath)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    pathObj.callback(currentPath)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"historyRouter\"><a href=\"#historyRouter\" class=\"headerlink\" title=\"historyRouter\"></a>historyRouter</h3><p>historyRouter的实现与HashRouter的实现也是很类似的，下面只写下不同之处：</p>\n<ul>\n<li>路由监听</li>\n</ul>\n<ol>\n<li>historyRouter</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'popstate'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    that.urlChange()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>HashRouter</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'hashchange'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    that.urlChange()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取当前路由和参数</li>\n</ul>\n<ol>\n<li>historyRouter</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取当前hash</span></span><br><span class=\"line\">getPath() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> hash = <span class=\"built_in\">window</span>.location.pathname</span><br><span class=\"line\">  <span class=\"keyword\">return</span> hash </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//获取参数</span></span><br><span class=\"line\">getParams() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> paramsStr = <span class=\"built_in\">window</span>.location.search</span><br><span class=\"line\">  <span class=\"keyword\">var</span> index = paramsStr.indexOf(<span class=\"string\">'?'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> params = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(index !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = paramsStr.slice(<span class=\"number\">1</span>).split(<span class=\"string\">'&amp;'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> data = arr[i].split(<span class=\"string\">\"=\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(data.length == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">          params[data[<span class=\"number\">0</span>]] = data[<span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> params</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>HashRouter</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取当前hash</span></span><br><span class=\"line\">getHash() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> hash = <span class=\"built_in\">window</span>.location.hash.slice(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> index = hash.indexOf(<span class=\"string\">'?'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(hash === <span class=\"string\">''</span>) <span class=\"keyword\">return</span> <span class=\"string\">'/'</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(index !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hash.slice(<span class=\"number\">0</span>, index)</span><br><span class=\"line\">  &#125;   </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> hash </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//获取参数</span></span><br><span class=\"line\">getParams() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> hash = <span class=\"built_in\">window</span>.location.hash</span><br><span class=\"line\">  <span class=\"keyword\">var</span> index = hash.indexOf(<span class=\"string\">'?'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> params = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(index !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = hash.slice(index + <span class=\"number\">1</span>).split(<span class=\"string\">'&amp;'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> data = arr[i].split(<span class=\"string\">\"=\"</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(data.length == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">          params[data[<span class=\"number\">0</span>]] = data[<span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> params</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>push方法，压入history栈，进行路由跳转</li>\n</ul>\n<ol>\n<li>historyRouter</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push(path) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.history.pushState(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>, path)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.urlChange() <span class=\"comment\">//手动触发</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>HashRouter</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push(path) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.location.hash = path</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p><a href=\"https://github.com/60kmlh/router\" target=\"_blank\" rel=\"noopener\">router</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://juejin.im/post/5c380afde51d4552232fb077\" target=\"_blank\" rel=\"noopener\">[实践系列] 前端路由</a></li>\n<li><a href=\"https://github.com/kaola-fed/blog/issues/137\" target=\"_blank\" rel=\"noopener\">浅谈前端路由</a></li>\n<li><a href=\"https://juejin.im/post/5c4bbeaae51d453ba8104f39\" target=\"_blank\" rel=\"noopener\">JS 专题系列-前端路由</a></li>\n<li><a href=\"https://juejin.im/post/5b45c878f265da0f783c89a6\" target=\"_blank\" rel=\"noopener\">前端路由实现及 react-router v4 源码分析</a></li>\n<li><a href=\"http://web.jobbole.com/86407/\" target=\"_blank\" rel=\"noopener\">前端路由实现与 react-router 源码分析</a></li>\n<li><a href=\"https://www.npmjs.com/package/spa-http-server\" target=\"_blank\" rel=\"noopener\">spa-http-server</a></li>\n</ul>"},{"title":"基于vue-router的管理系统权限控制的实现","date":"2017-07-07T16:00:00.000Z","_content":"# 背景\n之前使用vue做的后台管理系统，具有账号体系和权限管理的功能，前端需要实现根据权限异步生成菜单，根据用户权限来控制页面和相关按钮的显示，以及路由控制，这里主要讨论解决路由的问题。\n<!--more-->\n# 解决思路\n## 思路一: 写出全部的路由配置，利用导航钩子控制无权限页面的跳转。\n\n登陆完之后，获取用户权限的相关信息存入vuex，相关按钮根据权限信息控制显示或隐藏。\n\n写死所有的路由配置，包括404页的跳转，输入不匹配的地址都跳到404页面。\n\n在路由的meta信息里存储权限信息，可以是一个权限码，具体看和后台的约定。\n````javascript\nimport Vue from 'vue'\nimport Router from 'vue-router'\n\nVue.use(Router)\n\nexport default new Router({\n  routes: [\n    {\n      path: '/hello',\n      name: 'Hello',\n      component: resolve => require(['@/components/FirstPage'], resolve),\n      meta: {\n      permission:'firstpage'\n      },\n      children: [\n        {\n          path:'child',\n          name: 'firstPageChild',\n          component: resolve => require(['@/components/Child'], resolve),\n          meta: {\n      permission:'firstpagechild'\n      } \n        }\n      ]\n    },\n    {\n\n      path:'*',\n      name:'notFound',\n      component: resolve => require(['@/components/NotFound'], resolve)\n    }//404路由\n  ]\n})\n\n````\n此时对于无权限的页面，隐藏按钮，用户无对应的入口按钮，是无法通过点击对应按钮进入的，但是直接在地址栏输入地址还可以进入。\n\n这里借助vue-router的beforeEach钩子，在进入页面之前，通过路由的meta信息进行权限判断，若无权限则跳到404页面，有权限则正常进行跳转。\n````javascript\nimport router from './router'\n\nrouter.beforeEach((to, from, next) => {\n  console.log(to.meta.permission);\n  if(to.matched.forEach(record => {return permissionCode.indexOf(record.meta.permission) == -1})){\n  next('/notFound')\n  }else{\n    next()\n  }\n})//permissionCode为后台传过来的拥有的权限列表，按具体项目判断方法不一样\n````\n这里如果是直接打印出to的meta信息，只能获取到当前路由嵌套最深的那一层路由meta信息。\n\nvue-router官方推荐使用matched属性，to.matched数组包含了匹配到的父路由记录以及子路由记录，遍历即可。\n\n如果没有权限则调用next('/notFound')跳转到404页面。有权限则继续调用next()，这里确保要调用next方法。\n\n这个方法的缺点是要将所有的路由和对应权限都写出来。\n\n<br>\n\n## 思路二: 借助addRoutes动态添加路由\n\nvue-router在2.2.0版本新增了router.addRoutes实例方法，用来动态添加路由。\n\n因此可借助这个方法，在用户登陆完之后，获取权限信息，动态生成对应的有权限的路由，之前先写好404路由。\n````javascript\nimport Vue from 'vue'\nimport Router from 'vue-router'\n\nVue.use(Router)\n\nexport default new Router({\n  routes: [\n    {\n      path:'*',\n      name:'notFound',\n      component: resolve => require(['@/components/NotFound'], resolve)\n    }//404路由\n  ]\n})\n````\n\n假设以下为和后台约定好的用来构造路由的权限信息，实际情况可能不一样。\n````javascript\n route:[{\n    route:'/a',//路由地址\n    name: 'A',//路由名称\n    component: 'pageA/Main',//组件名称\n    meta: {permission: 'A'},//meta信息\n    children: [{\n        route:'child1',\n        name: 'A_A',\n        component: 'pageA/ModuleA'\n    },{\n        route:'child2',\n        name: 'A_B',\n        component: 'pageA/ModuleB'\n    }]\n},\n{\n    route:'/b',\n    name: 'B',\n    component: 'pageB/Main',\n    meta: {permission: 'B'},\n    children: [{\n        route:'child1',\n        name: 'B_A',\n        component: 'pageB/ModuleA'\n    },{\n        route:'child2',\n        name: 'B_B',\n        component: 'pageB/ModuleB'\n    }]\n},\n{\n    route:'/c',\n    name: 'C',\n    component: 'pageC/Main',\n    meta: {permission: 'C'},\n    children: [{\n        route:'child1',\n        name: 'C_A',\n        component: 'pageC/ModuleA'\n    },{\n        route:'child2',\n        name: 'C_B',\n        component: 'pageC/ModuleB'\n    }]\n}]\n````\n将后台传过来的权限信息，配置成符合 routes 选项要求的数组。\n````javascript\ncreateRouter(){\n      var rootRoute = []\n      this.route.forEach((value1, index1) => {\n        let parentRoute = {\n          path: value1.route,\n          name: value1.name,\n          component: resolve => require(['./views/'+value1.component], resolve),\n          children: [],\n          meta: value1.meta\n        }\n\n        value1.children.forEach((value2, index2) => {\n          let childRoute = {\n            path: value2.route,\n            name: value2.name,\n            component: resolve => require(['./views/'+value2.component], resolve)\n          }\n          parentRoute.children.push(childRoute)\n        })\n\n        rootRoute.push(parentRoute)\n      })\n      this.$router.addRoutes(rootRoute)\n    }//页面级别的组件都放在views文件夹下，Main为主入口，子页面也在同一文件夹\n````\n\n这样输入的无权限地址都会不匹配，跳到404路由。\n\n这种方法存在缺点，使用webpack实现按需加载，打包只能打包到主页面级别，例如上面打包出来就是A.js，B.js，C.js，子级页面的代码也被打包进去了，不能再打包一层，这个问题待解决。\n","source":"_posts/基于vue-router的管理系统权限控制的实现.md","raw":"---\ntitle: 基于vue-router的管理系统权限控制的实现\ndate: 2017-07-08\ntags: ['vue','vue-router','管理系统','权限控制']\ncategories: ['工作总结']\n---\n# 背景\n之前使用vue做的后台管理系统，具有账号体系和权限管理的功能，前端需要实现根据权限异步生成菜单，根据用户权限来控制页面和相关按钮的显示，以及路由控制，这里主要讨论解决路由的问题。\n<!--more-->\n# 解决思路\n## 思路一: 写出全部的路由配置，利用导航钩子控制无权限页面的跳转。\n\n登陆完之后，获取用户权限的相关信息存入vuex，相关按钮根据权限信息控制显示或隐藏。\n\n写死所有的路由配置，包括404页的跳转，输入不匹配的地址都跳到404页面。\n\n在路由的meta信息里存储权限信息，可以是一个权限码，具体看和后台的约定。\n````javascript\nimport Vue from 'vue'\nimport Router from 'vue-router'\n\nVue.use(Router)\n\nexport default new Router({\n  routes: [\n    {\n      path: '/hello',\n      name: 'Hello',\n      component: resolve => require(['@/components/FirstPage'], resolve),\n      meta: {\n      permission:'firstpage'\n      },\n      children: [\n        {\n          path:'child',\n          name: 'firstPageChild',\n          component: resolve => require(['@/components/Child'], resolve),\n          meta: {\n      permission:'firstpagechild'\n      } \n        }\n      ]\n    },\n    {\n\n      path:'*',\n      name:'notFound',\n      component: resolve => require(['@/components/NotFound'], resolve)\n    }//404路由\n  ]\n})\n\n````\n此时对于无权限的页面，隐藏按钮，用户无对应的入口按钮，是无法通过点击对应按钮进入的，但是直接在地址栏输入地址还可以进入。\n\n这里借助vue-router的beforeEach钩子，在进入页面之前，通过路由的meta信息进行权限判断，若无权限则跳到404页面，有权限则正常进行跳转。\n````javascript\nimport router from './router'\n\nrouter.beforeEach((to, from, next) => {\n  console.log(to.meta.permission);\n  if(to.matched.forEach(record => {return permissionCode.indexOf(record.meta.permission) == -1})){\n  next('/notFound')\n  }else{\n    next()\n  }\n})//permissionCode为后台传过来的拥有的权限列表，按具体项目判断方法不一样\n````\n这里如果是直接打印出to的meta信息，只能获取到当前路由嵌套最深的那一层路由meta信息。\n\nvue-router官方推荐使用matched属性，to.matched数组包含了匹配到的父路由记录以及子路由记录，遍历即可。\n\n如果没有权限则调用next('/notFound')跳转到404页面。有权限则继续调用next()，这里确保要调用next方法。\n\n这个方法的缺点是要将所有的路由和对应权限都写出来。\n\n<br>\n\n## 思路二: 借助addRoutes动态添加路由\n\nvue-router在2.2.0版本新增了router.addRoutes实例方法，用来动态添加路由。\n\n因此可借助这个方法，在用户登陆完之后，获取权限信息，动态生成对应的有权限的路由，之前先写好404路由。\n````javascript\nimport Vue from 'vue'\nimport Router from 'vue-router'\n\nVue.use(Router)\n\nexport default new Router({\n  routes: [\n    {\n      path:'*',\n      name:'notFound',\n      component: resolve => require(['@/components/NotFound'], resolve)\n    }//404路由\n  ]\n})\n````\n\n假设以下为和后台约定好的用来构造路由的权限信息，实际情况可能不一样。\n````javascript\n route:[{\n    route:'/a',//路由地址\n    name: 'A',//路由名称\n    component: 'pageA/Main',//组件名称\n    meta: {permission: 'A'},//meta信息\n    children: [{\n        route:'child1',\n        name: 'A_A',\n        component: 'pageA/ModuleA'\n    },{\n        route:'child2',\n        name: 'A_B',\n        component: 'pageA/ModuleB'\n    }]\n},\n{\n    route:'/b',\n    name: 'B',\n    component: 'pageB/Main',\n    meta: {permission: 'B'},\n    children: [{\n        route:'child1',\n        name: 'B_A',\n        component: 'pageB/ModuleA'\n    },{\n        route:'child2',\n        name: 'B_B',\n        component: 'pageB/ModuleB'\n    }]\n},\n{\n    route:'/c',\n    name: 'C',\n    component: 'pageC/Main',\n    meta: {permission: 'C'},\n    children: [{\n        route:'child1',\n        name: 'C_A',\n        component: 'pageC/ModuleA'\n    },{\n        route:'child2',\n        name: 'C_B',\n        component: 'pageC/ModuleB'\n    }]\n}]\n````\n将后台传过来的权限信息，配置成符合 routes 选项要求的数组。\n````javascript\ncreateRouter(){\n      var rootRoute = []\n      this.route.forEach((value1, index1) => {\n        let parentRoute = {\n          path: value1.route,\n          name: value1.name,\n          component: resolve => require(['./views/'+value1.component], resolve),\n          children: [],\n          meta: value1.meta\n        }\n\n        value1.children.forEach((value2, index2) => {\n          let childRoute = {\n            path: value2.route,\n            name: value2.name,\n            component: resolve => require(['./views/'+value2.component], resolve)\n          }\n          parentRoute.children.push(childRoute)\n        })\n\n        rootRoute.push(parentRoute)\n      })\n      this.$router.addRoutes(rootRoute)\n    }//页面级别的组件都放在views文件夹下，Main为主入口，子页面也在同一文件夹\n````\n\n这样输入的无权限地址都会不匹配，跳到404路由。\n\n这种方法存在缺点，使用webpack实现按需加载，打包只能打包到主页面级别，例如上面打包出来就是A.js，B.js，C.js，子级页面的代码也被打包进去了，不能再打包一层，这个问题待解决。\n","slug":"基于vue-router的管理系统权限控制的实现","published":1,"updated":"2022-04-13T14:14:08.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfg2003ng3t8oo1s7ycr","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>之前使用vue做的后台管理系统，具有账号体系和权限管理的功能，前端需要实现根据权限异步生成菜单，根据用户权限来控制页面和相关按钮的显示，以及路由控制，这里主要讨论解决路由的问题。<br><a id=\"more\"></a></p>\n<h1 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h1><h2 id=\"思路一-写出全部的路由配置，利用导航钩子控制无权限页面的跳转。\"><a href=\"#思路一-写出全部的路由配置，利用导航钩子控制无权限页面的跳转。\" class=\"headerlink\" title=\"思路一: 写出全部的路由配置，利用导航钩子控制无权限页面的跳转。\"></a>思路一: 写出全部的路由配置，利用导航钩子控制无权限页面的跳转。</h2><p>登陆完之后，获取用户权限的相关信息存入vuex，相关按钮根据权限信息控制显示或隐藏。</p>\n<p>写死所有的路由配置，包括404页的跳转，输入不匹配的地址都跳到404页面。</p>\n<p>在路由的meta信息里存储权限信息，可以是一个权限码，具体看和后台的约定。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Router)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: <span class=\"string\">'/hello'</span>,</span><br><span class=\"line\">      name: <span class=\"string\">'Hello'</span>,</span><br><span class=\"line\">      component: <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> <span class=\"built_in\">require</span>([<span class=\"string\">'@/components/FirstPage'</span>], resolve),</span><br><span class=\"line\">      meta: &#123;</span><br><span class=\"line\">      permission:<span class=\"string\">'firstpage'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      children: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          path:<span class=\"string\">'child'</span>,</span><br><span class=\"line\">          name: <span class=\"string\">'firstPageChild'</span>,</span><br><span class=\"line\">          component: <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> <span class=\"built_in\">require</span>([<span class=\"string\">'@/components/Child'</span>], resolve),</span><br><span class=\"line\">          meta: &#123;</span><br><span class=\"line\">      permission:<span class=\"string\">'firstpagechild'</span></span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      path:<span class=\"string\">'*'</span>,</span><br><span class=\"line\">      name:<span class=\"string\">'notFound'</span>,</span><br><span class=\"line\">      component: <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> <span class=\"built_in\">require</span>([<span class=\"string\">'@/components/NotFound'</span>], resolve)</span><br><span class=\"line\">    &#125;<span class=\"comment\">//404路由</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>此时对于无权限的页面，隐藏按钮，用户无对应的入口按钮，是无法通过点击对应按钮进入的，但是直接在地址栏输入地址还可以进入。</p>\n<p>这里借助vue-router的beforeEach钩子，在进入页面之前，通过路由的meta信息进行权限判断，若无权限则跳到404页面，有权限则正常进行跳转。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./router'</span></span><br><span class=\"line\"></span><br><span class=\"line\">router.beforeEach(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(to.meta.permission);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(to.matched.forEach(<span class=\"function\"><span class=\"params\">record</span> =&gt;</span> &#123;<span class=\"keyword\">return</span> permissionCode.indexOf(record.meta.permission) == <span class=\"number\">-1</span>&#125;))&#123;</span><br><span class=\"line\">  next(<span class=\"string\">'/notFound'</span>)</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    next()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)<span class=\"comment\">//permissionCode为后台传过来的拥有的权限列表，按具体项目判断方法不一样</span></span><br></pre></td></tr></table></figure></p>\n<p>这里如果是直接打印出to的meta信息，只能获取到当前路由嵌套最深的那一层路由meta信息。</p>\n<p>vue-router官方推荐使用matched属性，to.matched数组包含了匹配到的父路由记录以及子路由记录，遍历即可。</p>\n<p>如果没有权限则调用next(‘/notFound’)跳转到404页面。有权限则继续调用next()，这里确保要调用next方法。</p>\n<p>这个方法的缺点是要将所有的路由和对应权限都写出来。</p>\n<p><br></p>\n<h2 id=\"思路二-借助addRoutes动态添加路由\"><a href=\"#思路二-借助addRoutes动态添加路由\" class=\"headerlink\" title=\"思路二: 借助addRoutes动态添加路由\"></a>思路二: 借助addRoutes动态添加路由</h2><p>vue-router在2.2.0版本新增了router.addRoutes实例方法，用来动态添加路由。</p>\n<p>因此可借助这个方法，在用户登陆完之后，获取权限信息，动态生成对应的有权限的路由，之前先写好404路由。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Router)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path:<span class=\"string\">'*'</span>,</span><br><span class=\"line\">      name:<span class=\"string\">'notFound'</span>,</span><br><span class=\"line\">      component: <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> <span class=\"built_in\">require</span>([<span class=\"string\">'@/components/NotFound'</span>], resolve)</span><br><span class=\"line\">    &#125;<span class=\"comment\">//404路由</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>假设以下为和后台约定好的用来构造路由的权限信息，实际情况可能不一样。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> route:[&#123;</span><br><span class=\"line\">    route:<span class=\"string\">'/a'</span>,<span class=\"comment\">//路由地址</span></span><br><span class=\"line\">    name: <span class=\"string\">'A'</span>,<span class=\"comment\">//路由名称</span></span><br><span class=\"line\">    component: <span class=\"string\">'pageA/Main'</span>,<span class=\"comment\">//组件名称</span></span><br><span class=\"line\">    meta: &#123;<span class=\"attr\">permission</span>: <span class=\"string\">'A'</span>&#125;,<span class=\"comment\">//meta信息</span></span><br><span class=\"line\">    children: [&#123;</span><br><span class=\"line\">        route:<span class=\"string\">'child1'</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'A_A'</span>,</span><br><span class=\"line\">        component: <span class=\"string\">'pageA/ModuleA'</span></span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">        route:<span class=\"string\">'child2'</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'A_B'</span>,</span><br><span class=\"line\">        component: <span class=\"string\">'pageA/ModuleB'</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    route:<span class=\"string\">'/b'</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'B'</span>,</span><br><span class=\"line\">    component: <span class=\"string\">'pageB/Main'</span>,</span><br><span class=\"line\">    meta: &#123;<span class=\"attr\">permission</span>: <span class=\"string\">'B'</span>&#125;,</span><br><span class=\"line\">    children: [&#123;</span><br><span class=\"line\">        route:<span class=\"string\">'child1'</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'B_A'</span>,</span><br><span class=\"line\">        component: <span class=\"string\">'pageB/ModuleA'</span></span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">        route:<span class=\"string\">'child2'</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'B_B'</span>,</span><br><span class=\"line\">        component: <span class=\"string\">'pageB/ModuleB'</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    route:<span class=\"string\">'/c'</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'C'</span>,</span><br><span class=\"line\">    component: <span class=\"string\">'pageC/Main'</span>,</span><br><span class=\"line\">    meta: &#123;<span class=\"attr\">permission</span>: <span class=\"string\">'C'</span>&#125;,</span><br><span class=\"line\">    children: [&#123;</span><br><span class=\"line\">        route:<span class=\"string\">'child1'</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'C_A'</span>,</span><br><span class=\"line\">        component: <span class=\"string\">'pageC/ModuleA'</span></span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">        route:<span class=\"string\">'child2'</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'C_B'</span>,</span><br><span class=\"line\">        component: <span class=\"string\">'pageC/ModuleB'</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>将后台传过来的权限信息，配置成符合 routes 选项要求的数组。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">createRouter()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> rootRoute = []</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.route.forEach(<span class=\"function\">(<span class=\"params\">value1, index1</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> parentRoute = &#123;</span><br><span class=\"line\">          path: value1.route,</span><br><span class=\"line\">          name: value1.name,</span><br><span class=\"line\">          component: <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> <span class=\"built_in\">require</span>([<span class=\"string\">'./views/'</span>+value1.component], resolve),</span><br><span class=\"line\">          children: [],</span><br><span class=\"line\">          meta: value1.meta</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        value1.children.forEach(<span class=\"function\">(<span class=\"params\">value2, index2</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> childRoute = &#123;</span><br><span class=\"line\">            path: value2.route,</span><br><span class=\"line\">            name: value2.name,</span><br><span class=\"line\">            component: <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> <span class=\"built_in\">require</span>([<span class=\"string\">'./views/'</span>+value2.component], resolve)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          parentRoute.children.push(childRoute)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        rootRoute.push(parentRoute)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$router.addRoutes(rootRoute)</span><br><span class=\"line\">    &#125;<span class=\"comment\">//页面级别的组件都放在views文件夹下，Main为主入口，子页面也在同一文件夹</span></span><br></pre></td></tr></table></figure></p>\n<p>这样输入的无权限地址都会不匹配，跳到404路由。</p>\n<p>这种方法存在缺点，使用webpack实现按需加载，打包只能打包到主页面级别，例如上面打包出来就是A.js，B.js，C.js，子级页面的代码也被打包进去了，不能再打包一层，这个问题待解决。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>之前使用vue做的后台管理系统，具有账号体系和权限管理的功能，前端需要实现根据权限异步生成菜单，根据用户权限来控制页面和相关按钮的显示，以及路由控制，这里主要讨论解决路由的问题。<br>","more":"</p>\n<h1 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h1><h2 id=\"思路一-写出全部的路由配置，利用导航钩子控制无权限页面的跳转。\"><a href=\"#思路一-写出全部的路由配置，利用导航钩子控制无权限页面的跳转。\" class=\"headerlink\" title=\"思路一: 写出全部的路由配置，利用导航钩子控制无权限页面的跳转。\"></a>思路一: 写出全部的路由配置，利用导航钩子控制无权限页面的跳转。</h2><p>登陆完之后，获取用户权限的相关信息存入vuex，相关按钮根据权限信息控制显示或隐藏。</p>\n<p>写死所有的路由配置，包括404页的跳转，输入不匹配的地址都跳到404页面。</p>\n<p>在路由的meta信息里存储权限信息，可以是一个权限码，具体看和后台的约定。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Router)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: <span class=\"string\">'/hello'</span>,</span><br><span class=\"line\">      name: <span class=\"string\">'Hello'</span>,</span><br><span class=\"line\">      component: <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> <span class=\"built_in\">require</span>([<span class=\"string\">'@/components/FirstPage'</span>], resolve),</span><br><span class=\"line\">      meta: &#123;</span><br><span class=\"line\">      permission:<span class=\"string\">'firstpage'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      children: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          path:<span class=\"string\">'child'</span>,</span><br><span class=\"line\">          name: <span class=\"string\">'firstPageChild'</span>,</span><br><span class=\"line\">          component: <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> <span class=\"built_in\">require</span>([<span class=\"string\">'@/components/Child'</span>], resolve),</span><br><span class=\"line\">          meta: &#123;</span><br><span class=\"line\">      permission:<span class=\"string\">'firstpagechild'</span></span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      path:<span class=\"string\">'*'</span>,</span><br><span class=\"line\">      name:<span class=\"string\">'notFound'</span>,</span><br><span class=\"line\">      component: <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> <span class=\"built_in\">require</span>([<span class=\"string\">'@/components/NotFound'</span>], resolve)</span><br><span class=\"line\">    &#125;<span class=\"comment\">//404路由</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>此时对于无权限的页面，隐藏按钮，用户无对应的入口按钮，是无法通过点击对应按钮进入的，但是直接在地址栏输入地址还可以进入。</p>\n<p>这里借助vue-router的beforeEach钩子，在进入页面之前，通过路由的meta信息进行权限判断，若无权限则跳到404页面，有权限则正常进行跳转。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./router'</span></span><br><span class=\"line\"></span><br><span class=\"line\">router.beforeEach(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(to.meta.permission);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(to.matched.forEach(<span class=\"function\"><span class=\"params\">record</span> =&gt;</span> &#123;<span class=\"keyword\">return</span> permissionCode.indexOf(record.meta.permission) == <span class=\"number\">-1</span>&#125;))&#123;</span><br><span class=\"line\">  next(<span class=\"string\">'/notFound'</span>)</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    next()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)<span class=\"comment\">//permissionCode为后台传过来的拥有的权限列表，按具体项目判断方法不一样</span></span><br></pre></td></tr></table></figure></p>\n<p>这里如果是直接打印出to的meta信息，只能获取到当前路由嵌套最深的那一层路由meta信息。</p>\n<p>vue-router官方推荐使用matched属性，to.matched数组包含了匹配到的父路由记录以及子路由记录，遍历即可。</p>\n<p>如果没有权限则调用next(‘/notFound’)跳转到404页面。有权限则继续调用next()，这里确保要调用next方法。</p>\n<p>这个方法的缺点是要将所有的路由和对应权限都写出来。</p>\n<p><br></p>\n<h2 id=\"思路二-借助addRoutes动态添加路由\"><a href=\"#思路二-借助addRoutes动态添加路由\" class=\"headerlink\" title=\"思路二: 借助addRoutes动态添加路由\"></a>思路二: 借助addRoutes动态添加路由</h2><p>vue-router在2.2.0版本新增了router.addRoutes实例方法，用来动态添加路由。</p>\n<p>因此可借助这个方法，在用户登陆完之后，获取权限信息，动态生成对应的有权限的路由，之前先写好404路由。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Router)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path:<span class=\"string\">'*'</span>,</span><br><span class=\"line\">      name:<span class=\"string\">'notFound'</span>,</span><br><span class=\"line\">      component: <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> <span class=\"built_in\">require</span>([<span class=\"string\">'@/components/NotFound'</span>], resolve)</span><br><span class=\"line\">    &#125;<span class=\"comment\">//404路由</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>假设以下为和后台约定好的用来构造路由的权限信息，实际情况可能不一样。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> route:[&#123;</span><br><span class=\"line\">    route:<span class=\"string\">'/a'</span>,<span class=\"comment\">//路由地址</span></span><br><span class=\"line\">    name: <span class=\"string\">'A'</span>,<span class=\"comment\">//路由名称</span></span><br><span class=\"line\">    component: <span class=\"string\">'pageA/Main'</span>,<span class=\"comment\">//组件名称</span></span><br><span class=\"line\">    meta: &#123;<span class=\"attr\">permission</span>: <span class=\"string\">'A'</span>&#125;,<span class=\"comment\">//meta信息</span></span><br><span class=\"line\">    children: [&#123;</span><br><span class=\"line\">        route:<span class=\"string\">'child1'</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'A_A'</span>,</span><br><span class=\"line\">        component: <span class=\"string\">'pageA/ModuleA'</span></span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">        route:<span class=\"string\">'child2'</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'A_B'</span>,</span><br><span class=\"line\">        component: <span class=\"string\">'pageA/ModuleB'</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    route:<span class=\"string\">'/b'</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'B'</span>,</span><br><span class=\"line\">    component: <span class=\"string\">'pageB/Main'</span>,</span><br><span class=\"line\">    meta: &#123;<span class=\"attr\">permission</span>: <span class=\"string\">'B'</span>&#125;,</span><br><span class=\"line\">    children: [&#123;</span><br><span class=\"line\">        route:<span class=\"string\">'child1'</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'B_A'</span>,</span><br><span class=\"line\">        component: <span class=\"string\">'pageB/ModuleA'</span></span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">        route:<span class=\"string\">'child2'</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'B_B'</span>,</span><br><span class=\"line\">        component: <span class=\"string\">'pageB/ModuleB'</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    route:<span class=\"string\">'/c'</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'C'</span>,</span><br><span class=\"line\">    component: <span class=\"string\">'pageC/Main'</span>,</span><br><span class=\"line\">    meta: &#123;<span class=\"attr\">permission</span>: <span class=\"string\">'C'</span>&#125;,</span><br><span class=\"line\">    children: [&#123;</span><br><span class=\"line\">        route:<span class=\"string\">'child1'</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'C_A'</span>,</span><br><span class=\"line\">        component: <span class=\"string\">'pageC/ModuleA'</span></span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">        route:<span class=\"string\">'child2'</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'C_B'</span>,</span><br><span class=\"line\">        component: <span class=\"string\">'pageC/ModuleB'</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>将后台传过来的权限信息，配置成符合 routes 选项要求的数组。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">createRouter()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> rootRoute = []</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.route.forEach(<span class=\"function\">(<span class=\"params\">value1, index1</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> parentRoute = &#123;</span><br><span class=\"line\">          path: value1.route,</span><br><span class=\"line\">          name: value1.name,</span><br><span class=\"line\">          component: <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> <span class=\"built_in\">require</span>([<span class=\"string\">'./views/'</span>+value1.component], resolve),</span><br><span class=\"line\">          children: [],</span><br><span class=\"line\">          meta: value1.meta</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        value1.children.forEach(<span class=\"function\">(<span class=\"params\">value2, index2</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> childRoute = &#123;</span><br><span class=\"line\">            path: value2.route,</span><br><span class=\"line\">            name: value2.name,</span><br><span class=\"line\">            component: <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> <span class=\"built_in\">require</span>([<span class=\"string\">'./views/'</span>+value2.component], resolve)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          parentRoute.children.push(childRoute)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        rootRoute.push(parentRoute)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$router.addRoutes(rootRoute)</span><br><span class=\"line\">    &#125;<span class=\"comment\">//页面级别的组件都放在views文件夹下，Main为主入口，子页面也在同一文件夹</span></span><br></pre></td></tr></table></figure></p>\n<p>这样输入的无权限地址都会不匹配，跳到404路由。</p>\n<p>这种方法存在缺点，使用webpack实现按需加载，打包只能打包到主页面级别，例如上面打包出来就是A.js，B.js，C.js，子级页面的代码也被打包进去了，不能再打包一层，这个问题待解决。</p>"},{"title":"实现开发静态页面的热更新","date":"2017-04-07T16:00:00.000Z","_content":"## 背景\n开发静态页面的时候，修改html结构或者样式，利用热更新可以实时保存刷新，这样就不用手动刷新，节省时间。\n<!--more-->\n## gulp\n使用gulp实现热更新，主要是借助gulp-livereload插件和(LiveReload)[https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei]chrome扩展。\n````javascript\nvar gulp = require('gulp')\nvar livereload = require('gulp-livereload')\n\ngulp.task('watch',function(){\n    gulp.task('watch',function () {\n        livereload.listen();    \n        gulp.watch('src/*.*',function(file){\n            livereload.changed(file.path);\n        });\n    });\n})\n\ngulp.task('default',['watch'])\n````\n运行gulp脚本之后，开启\nchrome扩展，将正在开发的静态资源放到服务器环境里，访问之。\n\n现在只要文件一保存，浏览器就会马上局部刷新了。","source":"_posts/实现开发静态页面的热更新.md","raw":"---\ntitle: 实现开发静态页面的热更新\ndate: 2017-04-08\ntags: ['gulp',‘效率’]\ncategories: ['工具']\n---\n## 背景\n开发静态页面的时候，修改html结构或者样式，利用热更新可以实时保存刷新，这样就不用手动刷新，节省时间。\n<!--more-->\n## gulp\n使用gulp实现热更新，主要是借助gulp-livereload插件和(LiveReload)[https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei]chrome扩展。\n````javascript\nvar gulp = require('gulp')\nvar livereload = require('gulp-livereload')\n\ngulp.task('watch',function(){\n    gulp.task('watch',function () {\n        livereload.listen();    \n        gulp.watch('src/*.*',function(file){\n            livereload.changed(file.path);\n        });\n    });\n})\n\ngulp.task('default',['watch'])\n````\n运行gulp脚本之后，开启\nchrome扩展，将正在开发的静态资源放到服务器环境里，访问之。\n\n现在只要文件一保存，浏览器就会马上局部刷新了。","slug":"实现开发静态页面的热更新","published":1,"updated":"2022-04-13T14:14:08.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfg3003qg3t8n5vxtm3x","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>开发静态页面的时候，修改html结构或者样式，利用热更新可以实时保存刷新，这样就不用手动刷新，节省时间。<br><a id=\"more\"></a></p>\n<h2 id=\"gulp\"><a href=\"#gulp\" class=\"headerlink\" title=\"gulp\"></a>gulp</h2><p>使用gulp实现热更新，主要是借助gulp-livereload插件和(LiveReload)[<a href=\"https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei]chrome扩展。\" target=\"_blank\" rel=\"noopener\">https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei]chrome扩展。</a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> livereload = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-livereload'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'watch'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    gulp.task(<span class=\"string\">'watch'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        livereload.listen();    </span><br><span class=\"line\">        gulp.watch(<span class=\"string\">'src/*.*'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">            livereload.changed(file.path);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'default'</span>,[<span class=\"string\">'watch'</span>])</span><br></pre></td></tr></table></figure></p>\n<p>运行gulp脚本之后，开启<br>chrome扩展，将正在开发的静态资源放到服务器环境里，访问之。</p>\n<p>现在只要文件一保存，浏览器就会马上局部刷新了。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>开发静态页面的时候，修改html结构或者样式，利用热更新可以实时保存刷新，这样就不用手动刷新，节省时间。<br>","more":"</p>\n<h2 id=\"gulp\"><a href=\"#gulp\" class=\"headerlink\" title=\"gulp\"></a>gulp</h2><p>使用gulp实现热更新，主要是借助gulp-livereload插件和(LiveReload)[<a href=\"https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei]chrome扩展。\" target=\"_blank\" rel=\"noopener\">https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei]chrome扩展。</a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> livereload = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-livereload'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'watch'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    gulp.task(<span class=\"string\">'watch'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        livereload.listen();    </span><br><span class=\"line\">        gulp.watch(<span class=\"string\">'src/*.*'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>)</span>&#123;</span><br><span class=\"line\">            livereload.changed(file.path);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'default'</span>,[<span class=\"string\">'watch'</span>])</span><br></pre></td></tr></table></figure></p>\n<p>运行gulp脚本之后，开启<br>chrome扩展，将正在开发的静态资源放到服务器环境里，访问之。</p>\n<p>现在只要文件一保存，浏览器就会马上局部刷新了。</p>"},{"title":"实现数组的Flat方法","date":"2018-02-27T16:00:00.000Z","_content":"## flat含义及要求\n\n> flat() 方法会递归到指定深度将所有子数组连接，并返回一个新数组。\n<!--more-->\n语法：\n\n````javascript\n/*\n* @param {number} depth 深度\n* @returns {array} array 处理完的数组\n*/\nvar newArray = arr.flat(depth)\n````\n特点：\n\n1. 将多维数组扁平化\n2. 移除数组中的空项\n\n## 实现\n\n### 方法一\n思路：\n\n* 借助数组的reduce方法，迭代数组的每一项，将每一项合并成新数组。\n* 同时记录递归次数，继续递归至次数已经达到传入的depth，操作结束。\n\n代码实现：\n\n````javascript\nfunction flat(arr, depth = 1) {\n  if(Number.isNaN(Number(depth))||Number(depth)<1) return arr\n\n  let timer = 1\n\n  function recursionFun(arr) {\n    return arr.reduce((res, item) => {\n      if(Array.isArray(item) && timer < depth) {\n        timer++\n        return res.concat(recursionFun(item))\n      }else {\n        return res.concat(item)\n      }\n    }, [])\n  }\n\n  return recursionFun(arr, depth)\n}\n````\n### 方法二(不考虑depth参数)\n\n思路：使用数组的toString方法\n\n````javascript\nfunction flat(arr) {\n  return arr.toString().split(',').map(item => +item);\n}\n````\n## 参考资料\n* [TC39规范](https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flat)\n* [Array.prototype.flat()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)","source":"_posts/实现数组的flat方法.md","raw":"---\ntitle: 实现数组的Flat方法\ndate: 2018-02-28\ntags: ['array', 'flat','js']\ncategories: ['array']\n---\n## flat含义及要求\n\n> flat() 方法会递归到指定深度将所有子数组连接，并返回一个新数组。\n<!--more-->\n语法：\n\n````javascript\n/*\n* @param {number} depth 深度\n* @returns {array} array 处理完的数组\n*/\nvar newArray = arr.flat(depth)\n````\n特点：\n\n1. 将多维数组扁平化\n2. 移除数组中的空项\n\n## 实现\n\n### 方法一\n思路：\n\n* 借助数组的reduce方法，迭代数组的每一项，将每一项合并成新数组。\n* 同时记录递归次数，继续递归至次数已经达到传入的depth，操作结束。\n\n代码实现：\n\n````javascript\nfunction flat(arr, depth = 1) {\n  if(Number.isNaN(Number(depth))||Number(depth)<1) return arr\n\n  let timer = 1\n\n  function recursionFun(arr) {\n    return arr.reduce((res, item) => {\n      if(Array.isArray(item) && timer < depth) {\n        timer++\n        return res.concat(recursionFun(item))\n      }else {\n        return res.concat(item)\n      }\n    }, [])\n  }\n\n  return recursionFun(arr, depth)\n}\n````\n### 方法二(不考虑depth参数)\n\n思路：使用数组的toString方法\n\n````javascript\nfunction flat(arr) {\n  return arr.toString().split(',').map(item => +item);\n}\n````\n## 参考资料\n* [TC39规范](https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flat)\n* [Array.prototype.flat()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)","slug":"实现数组的flat方法","published":1,"updated":"2022-04-13T14:14:08.066Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfg4003ug3t8tja1m4b2","content":"<h2 id=\"flat含义及要求\"><a href=\"#flat含义及要求\" class=\"headerlink\" title=\"flat含义及要求\"></a>flat含义及要求</h2><blockquote>\n<p>flat() 方法会递归到指定深度将所有子数组连接，并返回一个新数组。<br><a id=\"more\"></a><br>语法：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* @param &#123;number&#125; depth 深度</span></span><br><span class=\"line\"><span class=\"comment\">* @returns &#123;array&#125; array 处理完的数组</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newArray = arr.flat(depth)</span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li>将多维数组扁平化</li>\n<li>移除数组中的空项</li>\n</ol>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><h3 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h3><p>思路：</p>\n<ul>\n<li>借助数组的reduce方法，迭代数组的每一项，将每一项合并成新数组。</li>\n<li>同时记录递归次数，继续递归至次数已经达到传入的depth，操作结束。</li>\n</ul>\n<p>代码实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flat</span>(<span class=\"params\">arr, depth = <span class=\"number\">1</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">Number</span>.isNaN(<span class=\"built_in\">Number</span>(depth))||<span class=\"built_in\">Number</span>(depth)&lt;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> arr</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">recursionFun</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\">(<span class=\"params\">res, item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"built_in\">Array</span>.isArray(item) &amp;&amp; timer &lt; depth) &#123;</span><br><span class=\"line\">        timer++</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.concat(recursionFun(item))</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.concat(item)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, [])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> recursionFun(arr, depth)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法二-不考虑depth参数\"><a href=\"#方法二-不考虑depth参数\" class=\"headerlink\" title=\"方法二(不考虑depth参数)\"></a>方法二(不考虑depth参数)</h3><p>思路：使用数组的toString方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flat</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.toString().split(<span class=\"string\">','</span>).map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> +item);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flat\" target=\"_blank\" rel=\"noopener\">TC39规范</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat\" target=\"_blank\" rel=\"noopener\">Array.prototype.flat()</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"flat含义及要求\"><a href=\"#flat含义及要求\" class=\"headerlink\" title=\"flat含义及要求\"></a>flat含义及要求</h2><blockquote>\n<p>flat() 方法会递归到指定深度将所有子数组连接，并返回一个新数组。<br>","more":"<br>语法：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* @param &#123;number&#125; depth 深度</span></span><br><span class=\"line\"><span class=\"comment\">* @returns &#123;array&#125; array 处理完的数组</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newArray = arr.flat(depth)</span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li>将多维数组扁平化</li>\n<li>移除数组中的空项</li>\n</ol>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><h3 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h3><p>思路：</p>\n<ul>\n<li>借助数组的reduce方法，迭代数组的每一项，将每一项合并成新数组。</li>\n<li>同时记录递归次数，继续递归至次数已经达到传入的depth，操作结束。</li>\n</ul>\n<p>代码实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flat</span>(<span class=\"params\">arr, depth = <span class=\"number\">1</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">Number</span>.isNaN(<span class=\"built_in\">Number</span>(depth))||<span class=\"built_in\">Number</span>(depth)&lt;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> arr</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">recursionFun</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\">(<span class=\"params\">res, item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"built_in\">Array</span>.isArray(item) &amp;&amp; timer &lt; depth) &#123;</span><br><span class=\"line\">        timer++</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.concat(recursionFun(item))</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.concat(item)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, [])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> recursionFun(arr, depth)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法二-不考虑depth参数\"><a href=\"#方法二-不考虑depth参数\" class=\"headerlink\" title=\"方法二(不考虑depth参数)\"></a>方法二(不考虑depth参数)</h3><p>思路：使用数组的toString方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flat</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.toString().split(<span class=\"string\">','</span>).map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> +item);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flat\" target=\"_blank\" rel=\"noopener\">TC39规范</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat\" target=\"_blank\" rel=\"noopener\">Array.prototype.flat()</a></li>\n</ul>"},{"title":"《javascript权威指南》第八章读书笔记","date":"2017-03-17T16:00:00.000Z","_content":"## 8.1函数定义\n(1) 函数定义表达式\n\n声明的变量会提升，赋值操作不会提升。\n<!--more-->\n````javascript\nvar fn = function(){\n    //do somethings\n}\n````\n(2) 函数声明语句\n\n函数声明语句会被提升到作用域顶部。\n````javascript\nfunction fn(){\n    //do somethings\n}\n````\n## 8.2函数调用\n4种方式调用函数：\n\n1. 作为函数\n\n    ECMAScript 3和ECMAScript 5的非严格模式下规定，函数调用的调用上下文是全局对象。严格模式下，上下文对象是undefined。\n    ````javascript\n    'use strict';\n    function fn(){\n        console.log(this);\n    }\n    fn()//undefined\n    ````\n2. 作为方法\n\n    将函数保存在一个对象的属性里，作为该对象的方法进行调用。\n\n    任何函数作为方法调用都会传入一个隐式的实参，即调用该方法的对象。\n    ````javascript\n    var a=1;\n    function fn1(){\n        console.log(this.a);\n    }\n    var o={\n        a:2,\n        m:function(){\n            console.log(this.a);\n        }\n    }\n    console.log(fn1())//1\n    console.log(o.m())//2\n    ````\n3. 作为构造函数\n\n    通过new关键字进行构造函数调用。构造函数调用创建一个新的空对象，这个对象继承构造函数的prototype属性，构造函数将这个新对象用作其调用上下文，因此构造函数可以使用this关键字引用这个新对象。\n\n    不使用return关键字时，返回该新对象。\n\n\n4. 使用它们的call()或apply()方法间接调用\n\n    call()方法使用自有的实参列表作为函数的实参。\n\n    apply()则要求以数组的方式传入参数。\n\n## 8.3函数的实参和形参\njavascript函数调用不检查传入形参的个数。\n\n当调用函数时传入的实参个数少于函数声明是指定的形参个数时，剩下的形参将设置为undefined 。\n\n为了保持函数的适应性，应当给忽略的实参设置默认值。可使用||运算符。\n````javascript\nfunction fn(a){\n    a=a||[]\n}\n````\n当传入的实参个数大于指定的形参个数时，没有办法直接获得未命名值的引用。标示符arguments是指向实参对象的引用，可通过数字下标获得传入的实参值。\n````javascript\nfunction Max(){\n    var max = Number.NEGATIVE_INFINITY;\n    for(let i=0;i<arguments.length;i++){\n        max=arguments[i]>max?arguments[i]:max;\n    }\n    return max\n}\n````\n非严格模式下，arguments.callee指代当前正在执行的函数。arguments.caller指代调用当前正在执行的函数的函数。\n\n匿名函数中可通过arguments.callee调用自身实现递归。\n````javascript\nvar factorial = function(x){\n    if (x<1) return 1;\n    return x*arguments.callee(x-1)\n}\n````\njavascript方法的形参并未进行类型检查，应当添加实参类型检查逻辑。\n## 8.3作为值的函数\n````javascript\nvar operators = {\n    add:function(x,y){return x+y},\n    subtract:function(x,y){return x-y},\n    multiply:function(x,y){return x*y},\n    divide:function(x,y){return x/y}\n}\n\nfunction operate(operation,operand1,operand2){\n    if(typeof operators[operation] === 'function'){\n        return operators[operation](operand1,operand2)\n    }else{\n        throw 'unkown operator'\n    }\n}\nvar j = operate('add', 'hello', operate('add',' ','world'))\nconsole.log(j)//hello world\n````\n自定义函数属性\n````javascript\nfunction factorial(n){\n    if(isFinite(n)&&n>0&&n==Math.round(n)){\n        if(!(n in factorial)){\n            factorial[n]=n*factorial(n-1)\n        }\n        return factorial[n]\n    }else{\n        return NaN\n    }\n}\nfactorial[1]=1;\nconsole.log(factorial(4))//24\n````\n## 8.5作为命名空间的函数\n````javascript\nvar extend = (function(){\n    for(var i in {toString:null}){\n        return function extend(o){\n            for (var i=1;i<arguments.length;i++){\n                var source = arguments[i];\n                for(var prop in source){\n                    o[prop] = source[prop]\n                }\n            }\n        }\n    }\n    return function patched_extend(o){\n        for (var i=1;i<arguments.length;i++){\n            var source = arguments[i];\n            for(var prop in source){\n                o[prop] = source[prop]\n            }\n            for(var j=0;j<protoprops.length;j++){\n                prop=protoprops[j];\n                if(source.hasOwnProperty(prop)){\n                    o[prop] = source[prop]\n                }\n            }\n        }\n    }\n    var proptypes = ['toString','valueOf','constructor','hasOwnProperty']\n}())\n````\n## 8.6闭包\njavascript采用词法作用域，函数的执行依赖变量作用域，该作用域是在函数定义时决定的。函数定义时的作用域链，在函数执行时依然有效。\n\n为实现这种词法作用域，javascript函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。\n\n函数对象通过作用域链互相关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性称为闭包。\n````javascript\nvar scope = 'global scope';\nfunction checkScope(){\n    var scope = 'local scope';\n    function f(){return scope}\n    return f()\n}\ncheckScope()//'local scope'\n````\n````javascript\nvar scope = 'global scope';\nfunction checkScope(){\n    var scope = 'local scope';\n    function f(){return scope}\n    return f\n}\ncheckScope()()//'local scope'\n````\n利用闭包实现私有存取器方法\n````javascript\nfunction addPrivateProperty(o,name,predicate){\n    var value;\n    o['get'+name]=function(){return value};\n    o['set'+name]=function(v){\n        if(predicate&&!predicate(v)){\n            throw Error('set'+name+':invalid value'+v)\n        }else{\n            value=v\n        }\n    }\n}\nvar o = {};\naddPrivateProperty(o,'Name',function(x){return typeof x==='string'})\no.setName('Frank');\nconsole.log(o.getName());//'Frank'\no.setName(o) //Error: setName:invalid value[object Object]\n````\nthis是javascript关键字，而不是变量，如果闭包在外部函数里无法访问this，除非外部函数将this转存为一个变量。arguments同理。\n## 8.7函数属性、方法和构造函数\n1. length属性\n    在函数体里，arguments.length指向传入函数的实参长度，而函数的length属性指函数定义时给出的参数个数，即“形参”。\n    ````javascript\n    function check(args){\n        var actual = args.length;\n        var expected = args.callee.length;\n        if(actual!==expected){\n            throw Error('Expected'+expected+'args;got'+actual)\n        }\n    }\n    function f(x,y,z){\n        check(arguments);\n        return x+y+z\n    }\n    ````\n2. prototype\n    当函数用作构造函数的时候，新创建的对象会从原型对象上继承属性。\n3. call()和apply()方法\n    call()和apply()的第一个参数是要调用函数的母对象，它是调用的上下文，函数体内通过this获得对它引用。\n\n    ECMAScript 5的严格模式中，第一个实参会变成this的值。\n    ````javascript\n    'use strict'\n    var a=1;\n    var x={a:2}\n    function f(){console.log(a)}\n    f.call(x)//1\n    f.aplly(x)//1\n    ````\n    ECMAScript 3和非严格模式中，传入null和undefined会被全局对象所替代。\n\n    call()方法第一个调用上下文实参之后的所有实参就是要传入待调用函数的值。\n    ````javascript\n    f.call(o,1,2)\n    ````\n    apply()调用上下文实参之后的所有实参d都放入一个数组中。\n    ````javascript\n    f.apply(o,[1,2])\n    ````\n4. bind()方法\n    ECMAScript 5新增bind()方法，用来将函数绑定至某个对象。\n\n    在函数f()调用bind方法并传入一个对象o作为参数，将返回一个新的函数。调用这个新的函数，会把原始函数f()当做对象o的方法来调用。\n    ````javascript\n    function f(y){ return this.x+y }\n    var o = {x:1};\n    var g = f.bind(o);\n    g(2)//3\n    ````\n    除了第一个实参外，传入bind()的参数也会绑定至this。\n\n    bind()方法所返回的函数的length（形参数量）等于原函数的形参数量减去传入bind()方法中的实参数量（第一个参数以后的所有参数），因为传入bind中的实参都会绑定到原函数的形参\n    ````javascript\n    var sum = function(x,y){return x+y}//length为2\n    var succ = sum.bind(null,1)//length为1\n    succ(2)//3\n\n    //var sum = function(x,y){return x+y}//length为2\n    //var succ = sum.bind(null,1,2)//length为0\n    //succ()//3\n    ````\n    当bind()所返回的函数用作构造函数的时候， 传入bind()的this将被忽略，实参会全部传入原函数。\n\n    bind()方法返回的构造函数不包含prototype属性，将这些绑定的函数用作构造函数所创建的对象会从原始的未绑定的构造函数中继承prototype。\n    ````javascript\n    function original(x){\n        this.a = 1;\n        this.b = function(){return this.a + x}\n    }\n    var obj={\n        a = 10\n    }\n    var newObj = new(original.bind(obj, 2)); //传入了一个实参2\n    console.log(newObj.a);  //输出1, 说明返回的函数用作构造函数时obj(this的值)被忽略了\n    console.log(newObj.b()); //输出3 ，说明传入的实参2传入了原函数original\n    ````\n\n    ECMAScript 3版本的bind方法()\n    ````javascript\n    if(!Function.prototype.bind){\n        Function.prototype.bind(o,/*,arguments*/){\n            var self = this, boundArgs = arguments;\n            return function(){\n                var args = [], i;\n                for(i=1;i<boundArgs.length;i++){args.push(bonudArgs[i])}\n                for(i=0;i<arguments.length;i++){args.push(arguments[i])}\n                return self.apply(o,args)\n            }\n        }\n    }\n    ````\n5. toString()方法\n    大多数函数的toString()方法的实现都返回函数的完整源码。\n    \n    内置函数往往返回一个“[native code]”的字符串作为函数体。\n6. Function()构造函数\n    函数可通过Function()构造函数来定义。\n    ````javascript\n    var f = new Function('x','y','return x+y')\n    ````\n    Function()构造函数允许javascript运行时动态创建并编译函数。\n\n    每次调用Function()构造函数都回解析函数体，并创建新的函数对象。在循环中执行，会影响执行效率。\n\n    Function()构造函数创建的函数不使用词法作用域，函数体代码的编译综会在顶层函数执行。\n    ````javascript\n    var scope = 'global';\n    function constructFunciton(){\n        var scope = 'local';\n        return new Function('return scope')\n    }\n    constructFunciton()()//'global'\n    ````\n7. 可调用对象\n    截至目前为止，两个可调用对象在javascript中的实现不能算作函数。\n\n    ie8机之前的版本的客户端方法使用了可调用的宿主对象，而不是内置的函数对象。\n\n    另一个常见的可调用对象是RegExp对象，非javascript的标准特性。\n\n    检查对象是否为真正的函数对象。\n    ````javascript\n    function isFunction(x){\n        return Object.prototype.toString.call(x)==='[object Function]'\n    }\n    isFunction(window.alert)//IE8下为false\n    ````\n## 8.8函数式编程\n1. 使用函数处理数组\n    自定义map()函数\n    ````javascript\n    var map = Array.prototype.map?function(a,f){return a.map(f)}:function(a,f){\n        var results = [];\n        for(var i = 0,len = a.length;i<len;i++;){\n            if(i in a){\n                results[i] = f.call(null,a[i],i,a)\n            }\n        }\n        return results\n    }\n    自定义reduce()函数\n    ````javascript\n    var reduce = Array.prototype.reduce?function(a,f,initial){\n        if(arguments.length>2){\n            return a.reduce(f,initial)\n        }else{return a.reduce(f)}\n    }:function(a,f,initial){\n        var i = 0,len = a.length,accumulator;\n        if(arguments.length>2){accumulator=initial}\n        else{\n            if(len == 0){throw TypeError()}\n            while(i < len){\n                if(i in a){\n                    accumulator=a[i++];\n                    break;\n                }else{\n                    i++\n                }\n            }\n            if(i == len){throw TypeError()}\n        }\n        while(i < len){\n            if(i in a){\n                accumulator=f.call(undefined,accumulator,a[i],i,a);\n                i++\n            }\n        }\n        return accumulator\n    }\n    ````\n2. 高阶函数\n    高阶函数(higher-order function)即操作函数的函数，接收一个或者多个函数作为参数，返回一个新的函数。\n    ````javascript\n    function not(f){\n        return function(){\n            var result = f.apply(this,arguments)\n            return !return\n        }\n    }\n    function even(){\n        return x%2 === 0\n    }\n    var odd = not(even);\n    [1,3,5,7,9].every(odd)//true\n    ````\n3. 不完全函数\n    在JavaScript中，不完全函数是一种函数变换技巧，即把一次完整的函数调用拆成多次函数调用，每次传入的实参都是完整实参的一部分，每个拆分开的函数叫做不完全函数，每次函数调用叫做不完全调用，这种变换的特点是每次调用都返回一个函数，直到得到最终运行结果为止。\n    \n    举一个简单的例子，将对函数f(1,2,3,4,5)的调用修改为等价的f(1,2)(3,4)(5,6)，后者包含三次调用，和每次调用相关的函数就是“不完全函数”。\n    ````javascript\n    //实现一个工具函数，将类数组（或对象）转换为真正的数组\n    //在后面的示例代码中用到了这个方法将arguments对象转换为真正的数组\n    function array(a,n){\n        return Array.prototype.slice.call(a,n||0);\n    }\n\n    //这个函数的实参传递至左侧\n    function partialLeft(f){\n        var args = arguments;   //保存外部的实参数组\n        return function(){      //并返回这个函数\n            var a = array(args,1);  //从第一个元素开始处理args\n            a = a.concat(array(arguments)); //然后增加所有的内部实参\n            return f.apply(this,a); //然后基于这个实参列表调用f()\n        }\n    }\n\n    //这个函数的实参传递至右侧\n    function partialRight(f){\n        var args = arguments;   //保存外部的实参数组\n        return function(){      //并返回这个函数\n            var a = array(arguments);   //从内部参数开始\n            a = a.concat(array(args,1));    //从第一个元素开始处理args\n            return f.apply(this,a); //然后基于这个实参列表调用f()\n        }\n    }\n\n    //这个函数的实参传递至左侧\n    //如果参数为undefined,用后面的实参填充undefined\n    function partial(f){\n        var args = arguments;   //保存外部实参数组\n        return function(){\n            var a = array(args,1);  //从外部args开始\n            //遍历args，从内部实参填充undefined值\n            for(var i=0,j=0;i<a.length;i++){\n                if (a[i]===undefined) a[i] = arguments[j++];\n            }\n            //现在将剩下的内部实参都追加进去\n            a = a.concat(array(arguments,j));\n            return f.apply(this,a);\n        };\n    }\n\n    //这个函数带有三个实参\n    var f = function(x,y,z){return x*(y-z);};\n\n    //注意这三个不完全调用之间的区别\n    console.log(partialLeft(f,2)(3,4)); //-2，绑定第一个实参：2*(3-4)\n    console.log(partialRight(f,2)(3,4));    //6，绑定第一个实参：3*(4-2)\n    console.log(partial(f,2)(3,4));     //-2，绑定第一个实参：2*(3-4)\n    console.log(partial(f,undefined,2)(3,4));   //-6，绑定第一个实参：3*(2-4)\n    ````\n4. 记忆\n    在函数式编程中，将上次计算的结果缓存起来，这种缓存技巧叫“记忆”(memorization)。\n    ````javascript\n    //返回f()带有记忆功能的版本\n    function memorize(f){\n        var cache = {};\n        return function(){\n            //将实参转换为字符串形式，并将其用作缓存的键。\n            var key = arguments.length+Array.prototype.join.call(arguments,',');\n            if(key in cache){return cache[key]}\n            else{return cache[key] = f.apply(this,arguments)}\n        }\n    }\n    ````\n","source":"_posts/javascripts权威指南笔记-8.md","raw":"---\ntitle: 《javascript权威指南》第八章读书笔记\ndate: 2017-03-18\ntags: ['function']\ncategories: ['笔记']\n---\n## 8.1函数定义\n(1) 函数定义表达式\n\n声明的变量会提升，赋值操作不会提升。\n<!--more-->\n````javascript\nvar fn = function(){\n    //do somethings\n}\n````\n(2) 函数声明语句\n\n函数声明语句会被提升到作用域顶部。\n````javascript\nfunction fn(){\n    //do somethings\n}\n````\n## 8.2函数调用\n4种方式调用函数：\n\n1. 作为函数\n\n    ECMAScript 3和ECMAScript 5的非严格模式下规定，函数调用的调用上下文是全局对象。严格模式下，上下文对象是undefined。\n    ````javascript\n    'use strict';\n    function fn(){\n        console.log(this);\n    }\n    fn()//undefined\n    ````\n2. 作为方法\n\n    将函数保存在一个对象的属性里，作为该对象的方法进行调用。\n\n    任何函数作为方法调用都会传入一个隐式的实参，即调用该方法的对象。\n    ````javascript\n    var a=1;\n    function fn1(){\n        console.log(this.a);\n    }\n    var o={\n        a:2,\n        m:function(){\n            console.log(this.a);\n        }\n    }\n    console.log(fn1())//1\n    console.log(o.m())//2\n    ````\n3. 作为构造函数\n\n    通过new关键字进行构造函数调用。构造函数调用创建一个新的空对象，这个对象继承构造函数的prototype属性，构造函数将这个新对象用作其调用上下文，因此构造函数可以使用this关键字引用这个新对象。\n\n    不使用return关键字时，返回该新对象。\n\n\n4. 使用它们的call()或apply()方法间接调用\n\n    call()方法使用自有的实参列表作为函数的实参。\n\n    apply()则要求以数组的方式传入参数。\n\n## 8.3函数的实参和形参\njavascript函数调用不检查传入形参的个数。\n\n当调用函数时传入的实参个数少于函数声明是指定的形参个数时，剩下的形参将设置为undefined 。\n\n为了保持函数的适应性，应当给忽略的实参设置默认值。可使用||运算符。\n````javascript\nfunction fn(a){\n    a=a||[]\n}\n````\n当传入的实参个数大于指定的形参个数时，没有办法直接获得未命名值的引用。标示符arguments是指向实参对象的引用，可通过数字下标获得传入的实参值。\n````javascript\nfunction Max(){\n    var max = Number.NEGATIVE_INFINITY;\n    for(let i=0;i<arguments.length;i++){\n        max=arguments[i]>max?arguments[i]:max;\n    }\n    return max\n}\n````\n非严格模式下，arguments.callee指代当前正在执行的函数。arguments.caller指代调用当前正在执行的函数的函数。\n\n匿名函数中可通过arguments.callee调用自身实现递归。\n````javascript\nvar factorial = function(x){\n    if (x<1) return 1;\n    return x*arguments.callee(x-1)\n}\n````\njavascript方法的形参并未进行类型检查，应当添加实参类型检查逻辑。\n## 8.3作为值的函数\n````javascript\nvar operators = {\n    add:function(x,y){return x+y},\n    subtract:function(x,y){return x-y},\n    multiply:function(x,y){return x*y},\n    divide:function(x,y){return x/y}\n}\n\nfunction operate(operation,operand1,operand2){\n    if(typeof operators[operation] === 'function'){\n        return operators[operation](operand1,operand2)\n    }else{\n        throw 'unkown operator'\n    }\n}\nvar j = operate('add', 'hello', operate('add',' ','world'))\nconsole.log(j)//hello world\n````\n自定义函数属性\n````javascript\nfunction factorial(n){\n    if(isFinite(n)&&n>0&&n==Math.round(n)){\n        if(!(n in factorial)){\n            factorial[n]=n*factorial(n-1)\n        }\n        return factorial[n]\n    }else{\n        return NaN\n    }\n}\nfactorial[1]=1;\nconsole.log(factorial(4))//24\n````\n## 8.5作为命名空间的函数\n````javascript\nvar extend = (function(){\n    for(var i in {toString:null}){\n        return function extend(o){\n            for (var i=1;i<arguments.length;i++){\n                var source = arguments[i];\n                for(var prop in source){\n                    o[prop] = source[prop]\n                }\n            }\n        }\n    }\n    return function patched_extend(o){\n        for (var i=1;i<arguments.length;i++){\n            var source = arguments[i];\n            for(var prop in source){\n                o[prop] = source[prop]\n            }\n            for(var j=0;j<protoprops.length;j++){\n                prop=protoprops[j];\n                if(source.hasOwnProperty(prop)){\n                    o[prop] = source[prop]\n                }\n            }\n        }\n    }\n    var proptypes = ['toString','valueOf','constructor','hasOwnProperty']\n}())\n````\n## 8.6闭包\njavascript采用词法作用域，函数的执行依赖变量作用域，该作用域是在函数定义时决定的。函数定义时的作用域链，在函数执行时依然有效。\n\n为实现这种词法作用域，javascript函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。\n\n函数对象通过作用域链互相关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性称为闭包。\n````javascript\nvar scope = 'global scope';\nfunction checkScope(){\n    var scope = 'local scope';\n    function f(){return scope}\n    return f()\n}\ncheckScope()//'local scope'\n````\n````javascript\nvar scope = 'global scope';\nfunction checkScope(){\n    var scope = 'local scope';\n    function f(){return scope}\n    return f\n}\ncheckScope()()//'local scope'\n````\n利用闭包实现私有存取器方法\n````javascript\nfunction addPrivateProperty(o,name,predicate){\n    var value;\n    o['get'+name]=function(){return value};\n    o['set'+name]=function(v){\n        if(predicate&&!predicate(v)){\n            throw Error('set'+name+':invalid value'+v)\n        }else{\n            value=v\n        }\n    }\n}\nvar o = {};\naddPrivateProperty(o,'Name',function(x){return typeof x==='string'})\no.setName('Frank');\nconsole.log(o.getName());//'Frank'\no.setName(o) //Error: setName:invalid value[object Object]\n````\nthis是javascript关键字，而不是变量，如果闭包在外部函数里无法访问this，除非外部函数将this转存为一个变量。arguments同理。\n## 8.7函数属性、方法和构造函数\n1. length属性\n    在函数体里，arguments.length指向传入函数的实参长度，而函数的length属性指函数定义时给出的参数个数，即“形参”。\n    ````javascript\n    function check(args){\n        var actual = args.length;\n        var expected = args.callee.length;\n        if(actual!==expected){\n            throw Error('Expected'+expected+'args;got'+actual)\n        }\n    }\n    function f(x,y,z){\n        check(arguments);\n        return x+y+z\n    }\n    ````\n2. prototype\n    当函数用作构造函数的时候，新创建的对象会从原型对象上继承属性。\n3. call()和apply()方法\n    call()和apply()的第一个参数是要调用函数的母对象，它是调用的上下文，函数体内通过this获得对它引用。\n\n    ECMAScript 5的严格模式中，第一个实参会变成this的值。\n    ````javascript\n    'use strict'\n    var a=1;\n    var x={a:2}\n    function f(){console.log(a)}\n    f.call(x)//1\n    f.aplly(x)//1\n    ````\n    ECMAScript 3和非严格模式中，传入null和undefined会被全局对象所替代。\n\n    call()方法第一个调用上下文实参之后的所有实参就是要传入待调用函数的值。\n    ````javascript\n    f.call(o,1,2)\n    ````\n    apply()调用上下文实参之后的所有实参d都放入一个数组中。\n    ````javascript\n    f.apply(o,[1,2])\n    ````\n4. bind()方法\n    ECMAScript 5新增bind()方法，用来将函数绑定至某个对象。\n\n    在函数f()调用bind方法并传入一个对象o作为参数，将返回一个新的函数。调用这个新的函数，会把原始函数f()当做对象o的方法来调用。\n    ````javascript\n    function f(y){ return this.x+y }\n    var o = {x:1};\n    var g = f.bind(o);\n    g(2)//3\n    ````\n    除了第一个实参外，传入bind()的参数也会绑定至this。\n\n    bind()方法所返回的函数的length（形参数量）等于原函数的形参数量减去传入bind()方法中的实参数量（第一个参数以后的所有参数），因为传入bind中的实参都会绑定到原函数的形参\n    ````javascript\n    var sum = function(x,y){return x+y}//length为2\n    var succ = sum.bind(null,1)//length为1\n    succ(2)//3\n\n    //var sum = function(x,y){return x+y}//length为2\n    //var succ = sum.bind(null,1,2)//length为0\n    //succ()//3\n    ````\n    当bind()所返回的函数用作构造函数的时候， 传入bind()的this将被忽略，实参会全部传入原函数。\n\n    bind()方法返回的构造函数不包含prototype属性，将这些绑定的函数用作构造函数所创建的对象会从原始的未绑定的构造函数中继承prototype。\n    ````javascript\n    function original(x){\n        this.a = 1;\n        this.b = function(){return this.a + x}\n    }\n    var obj={\n        a = 10\n    }\n    var newObj = new(original.bind(obj, 2)); //传入了一个实参2\n    console.log(newObj.a);  //输出1, 说明返回的函数用作构造函数时obj(this的值)被忽略了\n    console.log(newObj.b()); //输出3 ，说明传入的实参2传入了原函数original\n    ````\n\n    ECMAScript 3版本的bind方法()\n    ````javascript\n    if(!Function.prototype.bind){\n        Function.prototype.bind(o,/*,arguments*/){\n            var self = this, boundArgs = arguments;\n            return function(){\n                var args = [], i;\n                for(i=1;i<boundArgs.length;i++){args.push(bonudArgs[i])}\n                for(i=0;i<arguments.length;i++){args.push(arguments[i])}\n                return self.apply(o,args)\n            }\n        }\n    }\n    ````\n5. toString()方法\n    大多数函数的toString()方法的实现都返回函数的完整源码。\n    \n    内置函数往往返回一个“[native code]”的字符串作为函数体。\n6. Function()构造函数\n    函数可通过Function()构造函数来定义。\n    ````javascript\n    var f = new Function('x','y','return x+y')\n    ````\n    Function()构造函数允许javascript运行时动态创建并编译函数。\n\n    每次调用Function()构造函数都回解析函数体，并创建新的函数对象。在循环中执行，会影响执行效率。\n\n    Function()构造函数创建的函数不使用词法作用域，函数体代码的编译综会在顶层函数执行。\n    ````javascript\n    var scope = 'global';\n    function constructFunciton(){\n        var scope = 'local';\n        return new Function('return scope')\n    }\n    constructFunciton()()//'global'\n    ````\n7. 可调用对象\n    截至目前为止，两个可调用对象在javascript中的实现不能算作函数。\n\n    ie8机之前的版本的客户端方法使用了可调用的宿主对象，而不是内置的函数对象。\n\n    另一个常见的可调用对象是RegExp对象，非javascript的标准特性。\n\n    检查对象是否为真正的函数对象。\n    ````javascript\n    function isFunction(x){\n        return Object.prototype.toString.call(x)==='[object Function]'\n    }\n    isFunction(window.alert)//IE8下为false\n    ````\n## 8.8函数式编程\n1. 使用函数处理数组\n    自定义map()函数\n    ````javascript\n    var map = Array.prototype.map?function(a,f){return a.map(f)}:function(a,f){\n        var results = [];\n        for(var i = 0,len = a.length;i<len;i++;){\n            if(i in a){\n                results[i] = f.call(null,a[i],i,a)\n            }\n        }\n        return results\n    }\n    自定义reduce()函数\n    ````javascript\n    var reduce = Array.prototype.reduce?function(a,f,initial){\n        if(arguments.length>2){\n            return a.reduce(f,initial)\n        }else{return a.reduce(f)}\n    }:function(a,f,initial){\n        var i = 0,len = a.length,accumulator;\n        if(arguments.length>2){accumulator=initial}\n        else{\n            if(len == 0){throw TypeError()}\n            while(i < len){\n                if(i in a){\n                    accumulator=a[i++];\n                    break;\n                }else{\n                    i++\n                }\n            }\n            if(i == len){throw TypeError()}\n        }\n        while(i < len){\n            if(i in a){\n                accumulator=f.call(undefined,accumulator,a[i],i,a);\n                i++\n            }\n        }\n        return accumulator\n    }\n    ````\n2. 高阶函数\n    高阶函数(higher-order function)即操作函数的函数，接收一个或者多个函数作为参数，返回一个新的函数。\n    ````javascript\n    function not(f){\n        return function(){\n            var result = f.apply(this,arguments)\n            return !return\n        }\n    }\n    function even(){\n        return x%2 === 0\n    }\n    var odd = not(even);\n    [1,3,5,7,9].every(odd)//true\n    ````\n3. 不完全函数\n    在JavaScript中，不完全函数是一种函数变换技巧，即把一次完整的函数调用拆成多次函数调用，每次传入的实参都是完整实参的一部分，每个拆分开的函数叫做不完全函数，每次函数调用叫做不完全调用，这种变换的特点是每次调用都返回一个函数，直到得到最终运行结果为止。\n    \n    举一个简单的例子，将对函数f(1,2,3,4,5)的调用修改为等价的f(1,2)(3,4)(5,6)，后者包含三次调用，和每次调用相关的函数就是“不完全函数”。\n    ````javascript\n    //实现一个工具函数，将类数组（或对象）转换为真正的数组\n    //在后面的示例代码中用到了这个方法将arguments对象转换为真正的数组\n    function array(a,n){\n        return Array.prototype.slice.call(a,n||0);\n    }\n\n    //这个函数的实参传递至左侧\n    function partialLeft(f){\n        var args = arguments;   //保存外部的实参数组\n        return function(){      //并返回这个函数\n            var a = array(args,1);  //从第一个元素开始处理args\n            a = a.concat(array(arguments)); //然后增加所有的内部实参\n            return f.apply(this,a); //然后基于这个实参列表调用f()\n        }\n    }\n\n    //这个函数的实参传递至右侧\n    function partialRight(f){\n        var args = arguments;   //保存外部的实参数组\n        return function(){      //并返回这个函数\n            var a = array(arguments);   //从内部参数开始\n            a = a.concat(array(args,1));    //从第一个元素开始处理args\n            return f.apply(this,a); //然后基于这个实参列表调用f()\n        }\n    }\n\n    //这个函数的实参传递至左侧\n    //如果参数为undefined,用后面的实参填充undefined\n    function partial(f){\n        var args = arguments;   //保存外部实参数组\n        return function(){\n            var a = array(args,1);  //从外部args开始\n            //遍历args，从内部实参填充undefined值\n            for(var i=0,j=0;i<a.length;i++){\n                if (a[i]===undefined) a[i] = arguments[j++];\n            }\n            //现在将剩下的内部实参都追加进去\n            a = a.concat(array(arguments,j));\n            return f.apply(this,a);\n        };\n    }\n\n    //这个函数带有三个实参\n    var f = function(x,y,z){return x*(y-z);};\n\n    //注意这三个不完全调用之间的区别\n    console.log(partialLeft(f,2)(3,4)); //-2，绑定第一个实参：2*(3-4)\n    console.log(partialRight(f,2)(3,4));    //6，绑定第一个实参：3*(4-2)\n    console.log(partial(f,2)(3,4));     //-2，绑定第一个实参：2*(3-4)\n    console.log(partial(f,undefined,2)(3,4));   //-6，绑定第一个实参：3*(2-4)\n    ````\n4. 记忆\n    在函数式编程中，将上次计算的结果缓存起来，这种缓存技巧叫“记忆”(memorization)。\n    ````javascript\n    //返回f()带有记忆功能的版本\n    function memorize(f){\n        var cache = {};\n        return function(){\n            //将实参转换为字符串形式，并将其用作缓存的键。\n            var key = arguments.length+Array.prototype.join.call(arguments,',');\n            if(key in cache){return cache[key]}\n            else{return cache[key] = f.apply(this,arguments)}\n        }\n    }\n    ````\n","slug":"javascripts权威指南笔记-8","published":1,"updated":"2022-04-13T14:14:07.801Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfg6003xg3t8kalqqhei","content":"<h2 id=\"8-1函数定义\"><a href=\"#8-1函数定义\" class=\"headerlink\" title=\"8.1函数定义\"></a>8.1函数定义</h2><p>(1) 函数定义表达式</p>\n<p>声明的变量会提升，赋值操作不会提升。<br><a id=\"more\"></a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do somethings</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>(2) 函数声明语句</p>\n<p>函数声明语句会被提升到作用域顶部。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do somethings</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"8-2函数调用\"><a href=\"#8-2函数调用\" class=\"headerlink\" title=\"8.2函数调用\"></a>8.2函数调用</h2><p>4种方式调用函数：</p>\n<ol>\n<li><p>作为函数</p>\n<p> ECMAScript 3和ECMAScript 5的非严格模式下规定，函数调用的调用上下文是全局对象。严格模式下，上下文对象是undefined。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn()<span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>作为方法</p>\n<p> 将函数保存在一个对象的属性里，作为该对象的方法进行调用。</p>\n<p> 任何函数作为方法调用都会传入一个隐式的实参，即调用该方法的对象。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o=&#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span>,</span><br><span class=\"line\">    m:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn1())<span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o.m())<span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>作为构造函数</p>\n<p> 通过new关键字进行构造函数调用。构造函数调用创建一个新的空对象，这个对象继承构造函数的prototype属性，构造函数将这个新对象用作其调用上下文，因此构造函数可以使用this关键字引用这个新对象。</p>\n<p> 不使用return关键字时，返回该新对象。</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>使用它们的call()或apply()方法间接调用</p>\n<p> call()方法使用自有的实参列表作为函数的实参。</p>\n<p> apply()则要求以数组的方式传入参数。</p>\n</li>\n</ol>\n<h2 id=\"8-3函数的实参和形参\"><a href=\"#8-3函数的实参和形参\" class=\"headerlink\" title=\"8.3函数的实参和形参\"></a>8.3函数的实参和形参</h2><p>javascript函数调用不检查传入形参的个数。</p>\n<p>当调用函数时传入的实参个数少于函数声明是指定的形参个数时，剩下的形参将设置为undefined 。</p>\n<p>为了保持函数的适应性，应当给忽略的实参设置默认值。可使用||运算符。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    a=a||[]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当传入的实参个数大于指定的形参个数时，没有办法直接获得未命名值的引用。标示符arguments是指向实参对象的引用，可通过数字下标获得传入的实参值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Max</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> max = <span class=\"built_in\">Number</span>.NEGATIVE_INFINITY;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"built_in\">arguments</span>.length;i++)&#123;</span><br><span class=\"line\">        max=<span class=\"built_in\">arguments</span>[i]&gt;max?<span class=\"built_in\">arguments</span>[i]:max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>非严格模式下，arguments.callee指代当前正在执行的函数。arguments.caller指代调用当前正在执行的函数的函数。</p>\n<p>匿名函数中可通过arguments.callee调用自身实现递归。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> factorial = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x&lt;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x*<span class=\"built_in\">arguments</span>.callee(x<span class=\"number\">-1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>javascript方法的形参并未进行类型检查，应当添加实参类型检查逻辑。</p>\n<h2 id=\"8-3作为值的函数\"><a href=\"#8-3作为值的函数\" class=\"headerlink\" title=\"8.3作为值的函数\"></a>8.3作为值的函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> operators = &#123;</span><br><span class=\"line\">    add:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>)</span>&#123;<span class=\"keyword\">return</span> x+y&#125;,</span><br><span class=\"line\">    subtract:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>)</span>&#123;<span class=\"keyword\">return</span> x-y&#125;,</span><br><span class=\"line\">    multiply:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>)</span>&#123;<span class=\"keyword\">return</span> x*y&#125;,</span><br><span class=\"line\">    divide:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>)</span>&#123;<span class=\"keyword\">return</span> x/y&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">operate</span>(<span class=\"params\">operation,operand1,operand2</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> operators[operation] === <span class=\"string\">'function'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> operators[operation](operand1,operand2)</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"string\">'unkown operator'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> j = operate(<span class=\"string\">'add'</span>, <span class=\"string\">'hello'</span>, operate(<span class=\"string\">'add'</span>,<span class=\"string\">' '</span>,<span class=\"string\">'world'</span>))</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(j)<span class=\"comment\">//hello world</span></span><br></pre></td></tr></table></figure>\n<p>自定义函数属性<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">isFinite</span>(n)&amp;&amp;n&gt;<span class=\"number\">0</span>&amp;&amp;n==<span class=\"built_in\">Math</span>.round(n))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(n <span class=\"keyword\">in</span> factorial))&#123;</span><br><span class=\"line\">            factorial[n]=n*factorial(n<span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> factorial[n]</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NaN</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factorial[<span class=\"number\">1</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(factorial(<span class=\"number\">4</span>))<span class=\"comment\">//24</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"8-5作为命名空间的函数\"><a href=\"#8-5作为命名空间的函数\" class=\"headerlink\" title=\"8.5作为命名空间的函数\"></a>8.5作为命名空间的函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> extend = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> &#123;<span class=\"attr\">toString</span>:<span class=\"literal\">null</span>&#125;)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"built_in\">arguments</span>.length;i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> source = <span class=\"built_in\">arguments</span>[i];</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> prop <span class=\"keyword\">in</span> source)&#123;</span><br><span class=\"line\">                    o[prop] = source[prop]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">patched_extend</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"built_in\">arguments</span>.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> source = <span class=\"built_in\">arguments</span>[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> prop <span class=\"keyword\">in</span> source)&#123;</span><br><span class=\"line\">                o[prop] = source[prop]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j=<span class=\"number\">0</span>;j&lt;protoprops.length;j++)&#123;</span><br><span class=\"line\">                prop=protoprops[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(source.hasOwnProperty(prop))&#123;</span><br><span class=\"line\">                    o[prop] = source[prop]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> proptypes = [<span class=\"string\">'toString'</span>,<span class=\"string\">'valueOf'</span>,<span class=\"string\">'constructor'</span>,<span class=\"string\">'hasOwnProperty'</span>]</span><br><span class=\"line\">&#125;())</span><br></pre></td></tr></table></figure>\n<h2 id=\"8-6闭包\"><a href=\"#8-6闭包\" class=\"headerlink\" title=\"8.6闭包\"></a>8.6闭包</h2><p>javascript采用词法作用域，函数的执行依赖变量作用域，该作用域是在函数定义时决定的。函数定义时的作用域链，在函数执行时依然有效。</p>\n<p>为实现这种词法作用域，javascript函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。</p>\n<p>函数对象通过作用域链互相关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性称为闭包。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">'global scope'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkScope</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> scope = <span class=\"string\">'local scope'</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> scope&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkScope()<span class=\"comment\">//'local scope'</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">'global scope'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkScope</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> scope = <span class=\"string\">'local scope'</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> scope&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkScope()()<span class=\"comment\">//'local scope'</span></span><br></pre></td></tr></table></figure>\n<p>利用闭包实现私有存取器方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addPrivateProperty</span>(<span class=\"params\">o,name,predicate</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">    o[<span class=\"string\">'get'</span>+name]=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> value&#125;;</span><br><span class=\"line\">    o[<span class=\"string\">'set'</span>+name]=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(predicate&amp;&amp;!predicate(v))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'set'</span>+name+<span class=\"string\">':invalid value'</span>+v)</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            value=v</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;&#125;;</span><br><span class=\"line\">addPrivateProperty(o,<span class=\"string\">'Name'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> x===<span class=\"string\">'string'</span>&#125;)</span><br><span class=\"line\">o.setName(<span class=\"string\">'Frank'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o.getName());<span class=\"comment\">//'Frank'</span></span><br><span class=\"line\">o.setName(o) <span class=\"comment\">//Error: setName:invalid value[object Object]</span></span><br></pre></td></tr></table></figure></p>\n<p>this是javascript关键字，而不是变量，如果闭包在外部函数里无法访问this，除非外部函数将this转存为一个变量。arguments同理。</p>\n<h2 id=\"8-7函数属性、方法和构造函数\"><a href=\"#8-7函数属性、方法和构造函数\" class=\"headerlink\" title=\"8.7函数属性、方法和构造函数\"></a>8.7函数属性、方法和构造函数</h2><ol>\n<li><p>length属性<br> 在函数体里，arguments.length指向传入函数的实参长度，而函数的length属性指函数定义时给出的参数个数，即“形参”。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">check</span>(<span class=\"params\">args</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> actual = args.length;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> expected = args.callee.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(actual!==expected)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected'</span>+expected+<span class=\"string\">'args;got'</span>+actual)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x,y,z</span>)</span>&#123;</span><br><span class=\"line\">    check(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x+y+z</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>prototype<br> 当函数用作构造函数的时候，新创建的对象会从原型对象上继承属性。</p>\n</li>\n<li><p>call()和apply()方法<br> call()和apply()的第一个参数是要调用函数的母对象，它是调用的上下文，函数体内通过this获得对它引用。</p>\n<p> ECMAScript 5的严格模式中，第一个实参会变成this的值。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> x=&#123;<span class=\"attr\">a</span>:<span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(a)&#125;</span><br><span class=\"line\">f.call(x)<span class=\"comment\">//1</span></span><br><span class=\"line\">f.aplly(x)<span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p> ECMAScript 3和非严格模式中，传入null和undefined会被全局对象所替代。</p>\n<p> call()方法第一个调用上下文实参之后的所有实参就是要传入待调用函数的值。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.call(o,<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p> apply()调用上下文实参之后的所有实参d都放入一个数组中。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.apply(o,[<span class=\"number\">1</span>,<span class=\"number\">2</span>])</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>bind()方法<br> ECMAScript 5新增bind()方法，用来将函数绑定至某个对象。</p>\n<p> 在函数f()调用bind方法并传入一个对象o作为参数，将返回一个新的函数。调用这个新的函数，会把原始函数f()当做对象o的方法来调用。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">y</span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x+y &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> g = f.bind(o);</span><br><span class=\"line\">g(<span class=\"number\">2</span>)<span class=\"comment\">//3</span></span><br></pre></td></tr></table></figure>\n<p> 除了第一个实参外，传入bind()的参数也会绑定至this。</p>\n<p> bind()方法所返回的函数的length（形参数量）等于原函数的形参数量减去传入bind()方法中的实参数量（第一个参数以后的所有参数），因为传入bind中的实参都会绑定到原函数的形参</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>)</span>&#123;<span class=\"keyword\">return</span> x+y&#125;<span class=\"comment\">//length为2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> succ = sum.bind(<span class=\"literal\">null</span>,<span class=\"number\">1</span>)<span class=\"comment\">//length为1</span></span><br><span class=\"line\">succ(<span class=\"number\">2</span>)<span class=\"comment\">//3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//var sum = function(x,y)&#123;return x+y&#125;//length为2</span></span><br><span class=\"line\"><span class=\"comment\">//var succ = sum.bind(null,1,2)//length为0</span></span><br><span class=\"line\"><span class=\"comment\">//succ()//3</span></span><br></pre></td></tr></table></figure>\n<p> 当bind()所返回的函数用作构造函数的时候， 传入bind()的this将被忽略，实参会全部传入原函数。</p>\n<p> bind()方法返回的构造函数不包含prototype属性，将这些绑定的函数用作构造函数所创建的对象会从原始的未绑定的构造函数中继承prototype。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">original</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.b = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + x&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">    a = <span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newObj = <span class=\"keyword\">new</span>(original.bind(obj, <span class=\"number\">2</span>)); <span class=\"comment\">//传入了一个实参2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.a);  <span class=\"comment\">//输出1, 说明返回的函数用作构造函数时obj(this的值)被忽略了</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.b()); <span class=\"comment\">//输出3 ，说明传入的实参2传入了原函数original</span></span><br></pre></td></tr></table></figure>\n<p> ECMAScript 3版本的bind方法()</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!<span class=\"built_in\">Function</span>.prototype.bind)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Function</span>.prototype.bind(o,<span class=\"comment\">/*,arguments*/</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>, boundArgs = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> args = [], i;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;boundArgs.length;i++)&#123;args.push(bonudArgs[i])&#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"built_in\">arguments</span>.length;i++)&#123;args.push(<span class=\"built_in\">arguments</span>[i])&#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.apply(o,args)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>toString()方法<br> 大多数函数的toString()方法的实现都返回函数的完整源码。</p>\n<p> 内置函数往往返回一个“[native code]”的字符串作为函数体。</p>\n</li>\n<li><p>Function()构造函数<br> 函数可通过Function()构造函数来定义。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">'x'</span>,<span class=\"string\">'y'</span>,<span class=\"string\">'return x+y'</span>)</span><br></pre></td></tr></table></figure>\n<p> Function()构造函数允许javascript运行时动态创建并编译函数。</p>\n<p> 每次调用Function()构造函数都回解析函数体，并创建新的函数对象。在循环中执行，会影响执行效率。</p>\n<p> Function()构造函数创建的函数不使用词法作用域，函数体代码的编译综会在顶层函数执行。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">'global'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">constructFunciton</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> scope = <span class=\"string\">'local'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">'return scope'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">constructFunciton()()<span class=\"comment\">//'global'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可调用对象<br> 截至目前为止，两个可调用对象在javascript中的实现不能算作函数。</p>\n<p> ie8机之前的版本的客户端方法使用了可调用的宿主对象，而不是内置的函数对象。</p>\n<p> 另一个常见的可调用对象是RegExp对象，非javascript的标准特性。</p>\n<p> 检查对象是否为真正的函数对象。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFunction</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(x)===<span class=\"string\">'[object Function]'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">isFunction(<span class=\"built_in\">window</span>.alert)<span class=\"comment\">//IE8下为false</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"8-8函数式编程\"><a href=\"#8-8函数式编程\" class=\"headerlink\" title=\"8.8函数式编程\"></a>8.8函数式编程</h2><ol>\n<li><p>使用函数处理数组<br> 自定义map()函数</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"built_in\">Array</span>.prototype.map?<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,f</span>)</span>&#123;<span class=\"keyword\">return</span> a.map(f)&#125;:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,f</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> results = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>,len = a.length;i&lt;len;i++;)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i <span class=\"keyword\">in</span> a)&#123;</span><br><span class=\"line\">            results[i] = f.call(<span class=\"literal\">null</span>,a[i],i,a)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> results</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">自定义reduce()函数</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\"><span class=\"keyword\">var</span> reduce = <span class=\"built_in\">Array</span>.prototype.reduce?<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,f,initial</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">arguments</span>.length&gt;<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.reduce(f,initial)</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;<span class=\"keyword\">return</span> a.reduce(f)&#125;</span><br><span class=\"line\">&#125;:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,f,initial</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>,len = a.length,accumulator;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">arguments</span>.length&gt;<span class=\"number\">2</span>)&#123;accumulator=initial&#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(len == <span class=\"number\">0</span>)&#123;<span class=\"keyword\">throw</span> <span class=\"built_in\">TypeError</span>()&#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; len)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i <span class=\"keyword\">in</span> a)&#123;</span><br><span class=\"line\">                accumulator=a[i++];</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                i++</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == len)&#123;<span class=\"keyword\">throw</span> <span class=\"built_in\">TypeError</span>()&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; len)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i <span class=\"keyword\">in</span> a)&#123;</span><br><span class=\"line\">            accumulator=f.call(<span class=\"literal\">undefined</span>,accumulator,a[i],i,a);</span><br><span class=\"line\">            i++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> accumulator</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>高阶函数<br> 高阶函数(higher-order function)即操作函数的函数，接收一个或者多个函数作为参数，返回一个新的函数。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">not</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = f.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> !<span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">even</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x%<span class=\"number\">2</span> === <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> odd = not(even);</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>].every(odd)<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>不完全函数<br> 在JavaScript中，不完全函数是一种函数变换技巧，即把一次完整的函数调用拆成多次函数调用，每次传入的实参都是完整实参的一部分，每个拆分开的函数叫做不完全函数，每次函数调用叫做不完全调用，这种变换的特点是每次调用都返回一个函数，直到得到最终运行结果为止。</p>\n<p> 举一个简单的例子，将对函数f(1,2,3,4,5)的调用修改为等价的f(1,2)(3,4)(5,6)，后者包含三次调用，和每次调用相关的函数就是“不完全函数”。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//实现一个工具函数，将类数组（或对象）转换为真正的数组</span></span><br><span class=\"line\"><span class=\"comment\">//在后面的示例代码中用到了这个方法将arguments对象转换为真正的数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">array</span>(<span class=\"params\">a,n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.slice.call(a,n||<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个函数的实参传递至左侧</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">partialLeft</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;   <span class=\"comment\">//保存外部的实参数组</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;      <span class=\"comment\">//并返回这个函数</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = array(args,<span class=\"number\">1</span>);  <span class=\"comment\">//从第一个元素开始处理args</span></span><br><span class=\"line\">        a = a.concat(array(<span class=\"built_in\">arguments</span>)); <span class=\"comment\">//然后增加所有的内部实参</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> f.apply(<span class=\"keyword\">this</span>,a); <span class=\"comment\">//然后基于这个实参列表调用f()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个函数的实参传递至右侧</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">partialRight</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;   <span class=\"comment\">//保存外部的实参数组</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;      <span class=\"comment\">//并返回这个函数</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = array(<span class=\"built_in\">arguments</span>);   <span class=\"comment\">//从内部参数开始</span></span><br><span class=\"line\">        a = a.concat(array(args,<span class=\"number\">1</span>));    <span class=\"comment\">//从第一个元素开始处理args</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> f.apply(<span class=\"keyword\">this</span>,a); <span class=\"comment\">//然后基于这个实参列表调用f()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个函数的实参传递至左侧</span></span><br><span class=\"line\"><span class=\"comment\">//如果参数为undefined,用后面的实参填充undefined</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">partial</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;   <span class=\"comment\">//保存外部实参数组</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = array(args,<span class=\"number\">1</span>);  <span class=\"comment\">//从外部args开始</span></span><br><span class=\"line\">        <span class=\"comment\">//遍历args，从内部实参填充undefined值</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>,j=<span class=\"number\">0</span>;i&lt;a.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[i]===<span class=\"literal\">undefined</span>) a[i] = <span class=\"built_in\">arguments</span>[j++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//现在将剩下的内部实参都追加进去</span></span><br><span class=\"line\">        a = a.concat(array(<span class=\"built_in\">arguments</span>,j));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f.apply(<span class=\"keyword\">this</span>,a);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个函数带有三个实参</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y,z</span>)</span>&#123;<span class=\"keyword\">return</span> x*(y-z);&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注意这三个不完全调用之间的区别</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(partialLeft(f,<span class=\"number\">2</span>)(<span class=\"number\">3</span>,<span class=\"number\">4</span>)); <span class=\"comment\">//-2，绑定第一个实参：2*(3-4)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(partialRight(f,<span class=\"number\">2</span>)(<span class=\"number\">3</span>,<span class=\"number\">4</span>));    <span class=\"comment\">//6，绑定第一个实参：3*(4-2)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(partial(f,<span class=\"number\">2</span>)(<span class=\"number\">3</span>,<span class=\"number\">4</span>));     <span class=\"comment\">//-2，绑定第一个实参：2*(3-4)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(partial(f,<span class=\"literal\">undefined</span>,<span class=\"number\">2</span>)(<span class=\"number\">3</span>,<span class=\"number\">4</span>));   <span class=\"comment\">//-6，绑定第一个实参：3*(2-4)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>记忆<br> 在函数式编程中，将上次计算的结果缓存起来，这种缓存技巧叫“记忆”(memorization)。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//返回f()带有记忆功能的版本</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">memorize</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cache = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//将实参转换为字符串形式，并将其用作缓存的键。</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> key = <span class=\"built_in\">arguments</span>.length+<span class=\"built_in\">Array</span>.prototype.join.call(<span class=\"built_in\">arguments</span>,<span class=\"string\">','</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(key <span class=\"keyword\">in</span> cache)&#123;<span class=\"keyword\">return</span> cache[key]&#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;<span class=\"keyword\">return</span> cache[key] = f.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>)&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"8-1函数定义\"><a href=\"#8-1函数定义\" class=\"headerlink\" title=\"8.1函数定义\"></a>8.1函数定义</h2><p>(1) 函数定义表达式</p>\n<p>声明的变量会提升，赋值操作不会提升。<br>","more":"<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do somethings</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>(2) 函数声明语句</p>\n<p>函数声明语句会被提升到作用域顶部。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do somethings</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"8-2函数调用\"><a href=\"#8-2函数调用\" class=\"headerlink\" title=\"8.2函数调用\"></a>8.2函数调用</h2><p>4种方式调用函数：</p>\n<ol>\n<li><p>作为函数</p>\n<p> ECMAScript 3和ECMAScript 5的非严格模式下规定，函数调用的调用上下文是全局对象。严格模式下，上下文对象是undefined。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn()<span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>作为方法</p>\n<p> 将函数保存在一个对象的属性里，作为该对象的方法进行调用。</p>\n<p> 任何函数作为方法调用都会传入一个隐式的实参，即调用该方法的对象。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o=&#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span>,</span><br><span class=\"line\">    m:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn1())<span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o.m())<span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>作为构造函数</p>\n<p> 通过new关键字进行构造函数调用。构造函数调用创建一个新的空对象，这个对象继承构造函数的prototype属性，构造函数将这个新对象用作其调用上下文，因此构造函数可以使用this关键字引用这个新对象。</p>\n<p> 不使用return关键字时，返回该新对象。</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>使用它们的call()或apply()方法间接调用</p>\n<p> call()方法使用自有的实参列表作为函数的实参。</p>\n<p> apply()则要求以数组的方式传入参数。</p>\n</li>\n</ol>\n<h2 id=\"8-3函数的实参和形参\"><a href=\"#8-3函数的实参和形参\" class=\"headerlink\" title=\"8.3函数的实参和形参\"></a>8.3函数的实参和形参</h2><p>javascript函数调用不检查传入形参的个数。</p>\n<p>当调用函数时传入的实参个数少于函数声明是指定的形参个数时，剩下的形参将设置为undefined 。</p>\n<p>为了保持函数的适应性，应当给忽略的实参设置默认值。可使用||运算符。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    a=a||[]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当传入的实参个数大于指定的形参个数时，没有办法直接获得未命名值的引用。标示符arguments是指向实参对象的引用，可通过数字下标获得传入的实参值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Max</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> max = <span class=\"built_in\">Number</span>.NEGATIVE_INFINITY;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"built_in\">arguments</span>.length;i++)&#123;</span><br><span class=\"line\">        max=<span class=\"built_in\">arguments</span>[i]&gt;max?<span class=\"built_in\">arguments</span>[i]:max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>非严格模式下，arguments.callee指代当前正在执行的函数。arguments.caller指代调用当前正在执行的函数的函数。</p>\n<p>匿名函数中可通过arguments.callee调用自身实现递归。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> factorial = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x&lt;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x*<span class=\"built_in\">arguments</span>.callee(x<span class=\"number\">-1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>javascript方法的形参并未进行类型检查，应当添加实参类型检查逻辑。</p>\n<h2 id=\"8-3作为值的函数\"><a href=\"#8-3作为值的函数\" class=\"headerlink\" title=\"8.3作为值的函数\"></a>8.3作为值的函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> operators = &#123;</span><br><span class=\"line\">    add:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>)</span>&#123;<span class=\"keyword\">return</span> x+y&#125;,</span><br><span class=\"line\">    subtract:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>)</span>&#123;<span class=\"keyword\">return</span> x-y&#125;,</span><br><span class=\"line\">    multiply:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>)</span>&#123;<span class=\"keyword\">return</span> x*y&#125;,</span><br><span class=\"line\">    divide:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>)</span>&#123;<span class=\"keyword\">return</span> x/y&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">operate</span>(<span class=\"params\">operation,operand1,operand2</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> operators[operation] === <span class=\"string\">'function'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> operators[operation](operand1,operand2)</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"string\">'unkown operator'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> j = operate(<span class=\"string\">'add'</span>, <span class=\"string\">'hello'</span>, operate(<span class=\"string\">'add'</span>,<span class=\"string\">' '</span>,<span class=\"string\">'world'</span>))</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(j)<span class=\"comment\">//hello world</span></span><br></pre></td></tr></table></figure>\n<p>自定义函数属性<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">isFinite</span>(n)&amp;&amp;n&gt;<span class=\"number\">0</span>&amp;&amp;n==<span class=\"built_in\">Math</span>.round(n))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(n <span class=\"keyword\">in</span> factorial))&#123;</span><br><span class=\"line\">            factorial[n]=n*factorial(n<span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> factorial[n]</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NaN</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factorial[<span class=\"number\">1</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(factorial(<span class=\"number\">4</span>))<span class=\"comment\">//24</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"8-5作为命名空间的函数\"><a href=\"#8-5作为命名空间的函数\" class=\"headerlink\" title=\"8.5作为命名空间的函数\"></a>8.5作为命名空间的函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> extend = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> &#123;<span class=\"attr\">toString</span>:<span class=\"literal\">null</span>&#125;)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"built_in\">arguments</span>.length;i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> source = <span class=\"built_in\">arguments</span>[i];</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> prop <span class=\"keyword\">in</span> source)&#123;</span><br><span class=\"line\">                    o[prop] = source[prop]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">patched_extend</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"built_in\">arguments</span>.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> source = <span class=\"built_in\">arguments</span>[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> prop <span class=\"keyword\">in</span> source)&#123;</span><br><span class=\"line\">                o[prop] = source[prop]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j=<span class=\"number\">0</span>;j&lt;protoprops.length;j++)&#123;</span><br><span class=\"line\">                prop=protoprops[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(source.hasOwnProperty(prop))&#123;</span><br><span class=\"line\">                    o[prop] = source[prop]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> proptypes = [<span class=\"string\">'toString'</span>,<span class=\"string\">'valueOf'</span>,<span class=\"string\">'constructor'</span>,<span class=\"string\">'hasOwnProperty'</span>]</span><br><span class=\"line\">&#125;())</span><br></pre></td></tr></table></figure>\n<h2 id=\"8-6闭包\"><a href=\"#8-6闭包\" class=\"headerlink\" title=\"8.6闭包\"></a>8.6闭包</h2><p>javascript采用词法作用域，函数的执行依赖变量作用域，该作用域是在函数定义时决定的。函数定义时的作用域链，在函数执行时依然有效。</p>\n<p>为实现这种词法作用域，javascript函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。</p>\n<p>函数对象通过作用域链互相关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性称为闭包。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">'global scope'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkScope</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> scope = <span class=\"string\">'local scope'</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> scope&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkScope()<span class=\"comment\">//'local scope'</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">'global scope'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkScope</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> scope = <span class=\"string\">'local scope'</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> scope&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkScope()()<span class=\"comment\">//'local scope'</span></span><br></pre></td></tr></table></figure>\n<p>利用闭包实现私有存取器方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addPrivateProperty</span>(<span class=\"params\">o,name,predicate</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value;</span><br><span class=\"line\">    o[<span class=\"string\">'get'</span>+name]=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> value&#125;;</span><br><span class=\"line\">    o[<span class=\"string\">'set'</span>+name]=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(predicate&amp;&amp;!predicate(v))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'set'</span>+name+<span class=\"string\">':invalid value'</span>+v)</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            value=v</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;&#125;;</span><br><span class=\"line\">addPrivateProperty(o,<span class=\"string\">'Name'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> x===<span class=\"string\">'string'</span>&#125;)</span><br><span class=\"line\">o.setName(<span class=\"string\">'Frank'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o.getName());<span class=\"comment\">//'Frank'</span></span><br><span class=\"line\">o.setName(o) <span class=\"comment\">//Error: setName:invalid value[object Object]</span></span><br></pre></td></tr></table></figure></p>\n<p>this是javascript关键字，而不是变量，如果闭包在外部函数里无法访问this，除非外部函数将this转存为一个变量。arguments同理。</p>\n<h2 id=\"8-7函数属性、方法和构造函数\"><a href=\"#8-7函数属性、方法和构造函数\" class=\"headerlink\" title=\"8.7函数属性、方法和构造函数\"></a>8.7函数属性、方法和构造函数</h2><ol>\n<li><p>length属性<br> 在函数体里，arguments.length指向传入函数的实参长度，而函数的length属性指函数定义时给出的参数个数，即“形参”。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">check</span>(<span class=\"params\">args</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> actual = args.length;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> expected = args.callee.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(actual!==expected)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected'</span>+expected+<span class=\"string\">'args;got'</span>+actual)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x,y,z</span>)</span>&#123;</span><br><span class=\"line\">    check(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x+y+z</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>prototype<br> 当函数用作构造函数的时候，新创建的对象会从原型对象上继承属性。</p>\n</li>\n<li><p>call()和apply()方法<br> call()和apply()的第一个参数是要调用函数的母对象，它是调用的上下文，函数体内通过this获得对它引用。</p>\n<p> ECMAScript 5的严格模式中，第一个实参会变成this的值。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> x=&#123;<span class=\"attr\">a</span>:<span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(a)&#125;</span><br><span class=\"line\">f.call(x)<span class=\"comment\">//1</span></span><br><span class=\"line\">f.aplly(x)<span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p> ECMAScript 3和非严格模式中，传入null和undefined会被全局对象所替代。</p>\n<p> call()方法第一个调用上下文实参之后的所有实参就是要传入待调用函数的值。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.call(o,<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p> apply()调用上下文实参之后的所有实参d都放入一个数组中。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f.apply(o,[<span class=\"number\">1</span>,<span class=\"number\">2</span>])</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>bind()方法<br> ECMAScript 5新增bind()方法，用来将函数绑定至某个对象。</p>\n<p> 在函数f()调用bind方法并传入一个对象o作为参数，将返回一个新的函数。调用这个新的函数，会把原始函数f()当做对象o的方法来调用。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">y</span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x+y &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> g = f.bind(o);</span><br><span class=\"line\">g(<span class=\"number\">2</span>)<span class=\"comment\">//3</span></span><br></pre></td></tr></table></figure>\n<p> 除了第一个实参外，传入bind()的参数也会绑定至this。</p>\n<p> bind()方法所返回的函数的length（形参数量）等于原函数的形参数量减去传入bind()方法中的实参数量（第一个参数以后的所有参数），因为传入bind中的实参都会绑定到原函数的形参</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>)</span>&#123;<span class=\"keyword\">return</span> x+y&#125;<span class=\"comment\">//length为2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> succ = sum.bind(<span class=\"literal\">null</span>,<span class=\"number\">1</span>)<span class=\"comment\">//length为1</span></span><br><span class=\"line\">succ(<span class=\"number\">2</span>)<span class=\"comment\">//3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//var sum = function(x,y)&#123;return x+y&#125;//length为2</span></span><br><span class=\"line\"><span class=\"comment\">//var succ = sum.bind(null,1,2)//length为0</span></span><br><span class=\"line\"><span class=\"comment\">//succ()//3</span></span><br></pre></td></tr></table></figure>\n<p> 当bind()所返回的函数用作构造函数的时候， 传入bind()的this将被忽略，实参会全部传入原函数。</p>\n<p> bind()方法返回的构造函数不包含prototype属性，将这些绑定的函数用作构造函数所创建的对象会从原始的未绑定的构造函数中继承prototype。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">original</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.b = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + x&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">    a = <span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newObj = <span class=\"keyword\">new</span>(original.bind(obj, <span class=\"number\">2</span>)); <span class=\"comment\">//传入了一个实参2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.a);  <span class=\"comment\">//输出1, 说明返回的函数用作构造函数时obj(this的值)被忽略了</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.b()); <span class=\"comment\">//输出3 ，说明传入的实参2传入了原函数original</span></span><br></pre></td></tr></table></figure>\n<p> ECMAScript 3版本的bind方法()</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!<span class=\"built_in\">Function</span>.prototype.bind)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Function</span>.prototype.bind(o,<span class=\"comment\">/*,arguments*/</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>, boundArgs = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> args = [], i;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;boundArgs.length;i++)&#123;args.push(bonudArgs[i])&#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"built_in\">arguments</span>.length;i++)&#123;args.push(<span class=\"built_in\">arguments</span>[i])&#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.apply(o,args)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>toString()方法<br> 大多数函数的toString()方法的实现都返回函数的完整源码。</p>\n<p> 内置函数往往返回一个“[native code]”的字符串作为函数体。</p>\n</li>\n<li><p>Function()构造函数<br> 函数可通过Function()构造函数来定义。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">'x'</span>,<span class=\"string\">'y'</span>,<span class=\"string\">'return x+y'</span>)</span><br></pre></td></tr></table></figure>\n<p> Function()构造函数允许javascript运行时动态创建并编译函数。</p>\n<p> 每次调用Function()构造函数都回解析函数体，并创建新的函数对象。在循环中执行，会影响执行效率。</p>\n<p> Function()构造函数创建的函数不使用词法作用域，函数体代码的编译综会在顶层函数执行。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">'global'</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">constructFunciton</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> scope = <span class=\"string\">'local'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">'return scope'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">constructFunciton()()<span class=\"comment\">//'global'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可调用对象<br> 截至目前为止，两个可调用对象在javascript中的实现不能算作函数。</p>\n<p> ie8机之前的版本的客户端方法使用了可调用的宿主对象，而不是内置的函数对象。</p>\n<p> 另一个常见的可调用对象是RegExp对象，非javascript的标准特性。</p>\n<p> 检查对象是否为真正的函数对象。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFunction</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(x)===<span class=\"string\">'[object Function]'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">isFunction(<span class=\"built_in\">window</span>.alert)<span class=\"comment\">//IE8下为false</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"8-8函数式编程\"><a href=\"#8-8函数式编程\" class=\"headerlink\" title=\"8.8函数式编程\"></a>8.8函数式编程</h2><ol>\n<li><p>使用函数处理数组<br> 自定义map()函数</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"built_in\">Array</span>.prototype.map?<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,f</span>)</span>&#123;<span class=\"keyword\">return</span> a.map(f)&#125;:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,f</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> results = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>,len = a.length;i&lt;len;i++;)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i <span class=\"keyword\">in</span> a)&#123;</span><br><span class=\"line\">            results[i] = f.call(<span class=\"literal\">null</span>,a[i],i,a)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> results</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">自定义reduce()函数</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\"><span class=\"keyword\">var</span> reduce = <span class=\"built_in\">Array</span>.prototype.reduce?<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,f,initial</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">arguments</span>.length&gt;<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.reduce(f,initial)</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;<span class=\"keyword\">return</span> a.reduce(f)&#125;</span><br><span class=\"line\">&#125;:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,f,initial</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>,len = a.length,accumulator;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">arguments</span>.length&gt;<span class=\"number\">2</span>)&#123;accumulator=initial&#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(len == <span class=\"number\">0</span>)&#123;<span class=\"keyword\">throw</span> <span class=\"built_in\">TypeError</span>()&#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; len)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i <span class=\"keyword\">in</span> a)&#123;</span><br><span class=\"line\">                accumulator=a[i++];</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                i++</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == len)&#123;<span class=\"keyword\">throw</span> <span class=\"built_in\">TypeError</span>()&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; len)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i <span class=\"keyword\">in</span> a)&#123;</span><br><span class=\"line\">            accumulator=f.call(<span class=\"literal\">undefined</span>,accumulator,a[i],i,a);</span><br><span class=\"line\">            i++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> accumulator</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>高阶函数<br> 高阶函数(higher-order function)即操作函数的函数，接收一个或者多个函数作为参数，返回一个新的函数。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">not</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = f.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> !<span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">even</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x%<span class=\"number\">2</span> === <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> odd = not(even);</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>].every(odd)<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>不完全函数<br> 在JavaScript中，不完全函数是一种函数变换技巧，即把一次完整的函数调用拆成多次函数调用，每次传入的实参都是完整实参的一部分，每个拆分开的函数叫做不完全函数，每次函数调用叫做不完全调用，这种变换的特点是每次调用都返回一个函数，直到得到最终运行结果为止。</p>\n<p> 举一个简单的例子，将对函数f(1,2,3,4,5)的调用修改为等价的f(1,2)(3,4)(5,6)，后者包含三次调用，和每次调用相关的函数就是“不完全函数”。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//实现一个工具函数，将类数组（或对象）转换为真正的数组</span></span><br><span class=\"line\"><span class=\"comment\">//在后面的示例代码中用到了这个方法将arguments对象转换为真正的数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">array</span>(<span class=\"params\">a,n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.slice.call(a,n||<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个函数的实参传递至左侧</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">partialLeft</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;   <span class=\"comment\">//保存外部的实参数组</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;      <span class=\"comment\">//并返回这个函数</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = array(args,<span class=\"number\">1</span>);  <span class=\"comment\">//从第一个元素开始处理args</span></span><br><span class=\"line\">        a = a.concat(array(<span class=\"built_in\">arguments</span>)); <span class=\"comment\">//然后增加所有的内部实参</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> f.apply(<span class=\"keyword\">this</span>,a); <span class=\"comment\">//然后基于这个实参列表调用f()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个函数的实参传递至右侧</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">partialRight</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;   <span class=\"comment\">//保存外部的实参数组</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;      <span class=\"comment\">//并返回这个函数</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = array(<span class=\"built_in\">arguments</span>);   <span class=\"comment\">//从内部参数开始</span></span><br><span class=\"line\">        a = a.concat(array(args,<span class=\"number\">1</span>));    <span class=\"comment\">//从第一个元素开始处理args</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> f.apply(<span class=\"keyword\">this</span>,a); <span class=\"comment\">//然后基于这个实参列表调用f()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个函数的实参传递至左侧</span></span><br><span class=\"line\"><span class=\"comment\">//如果参数为undefined,用后面的实参填充undefined</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">partial</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;   <span class=\"comment\">//保存外部实参数组</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = array(args,<span class=\"number\">1</span>);  <span class=\"comment\">//从外部args开始</span></span><br><span class=\"line\">        <span class=\"comment\">//遍历args，从内部实参填充undefined值</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>,j=<span class=\"number\">0</span>;i&lt;a.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[i]===<span class=\"literal\">undefined</span>) a[i] = <span class=\"built_in\">arguments</span>[j++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//现在将剩下的内部实参都追加进去</span></span><br><span class=\"line\">        a = a.concat(array(<span class=\"built_in\">arguments</span>,j));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f.apply(<span class=\"keyword\">this</span>,a);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个函数带有三个实参</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y,z</span>)</span>&#123;<span class=\"keyword\">return</span> x*(y-z);&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注意这三个不完全调用之间的区别</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(partialLeft(f,<span class=\"number\">2</span>)(<span class=\"number\">3</span>,<span class=\"number\">4</span>)); <span class=\"comment\">//-2，绑定第一个实参：2*(3-4)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(partialRight(f,<span class=\"number\">2</span>)(<span class=\"number\">3</span>,<span class=\"number\">4</span>));    <span class=\"comment\">//6，绑定第一个实参：3*(4-2)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(partial(f,<span class=\"number\">2</span>)(<span class=\"number\">3</span>,<span class=\"number\">4</span>));     <span class=\"comment\">//-2，绑定第一个实参：2*(3-4)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(partial(f,<span class=\"literal\">undefined</span>,<span class=\"number\">2</span>)(<span class=\"number\">3</span>,<span class=\"number\">4</span>));   <span class=\"comment\">//-6，绑定第一个实参：3*(2-4)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>记忆<br> 在函数式编程中，将上次计算的结果缓存起来，这种缓存技巧叫“记忆”(memorization)。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//返回f()带有记忆功能的版本</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">memorize</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cache = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//将实参转换为字符串形式，并将其用作缓存的键。</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> key = <span class=\"built_in\">arguments</span>.length+<span class=\"built_in\">Array</span>.prototype.join.call(<span class=\"built_in\">arguments</span>,<span class=\"string\">','</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(key <span class=\"keyword\">in</span> cache)&#123;<span class=\"keyword\">return</span> cache[key]&#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;<span class=\"keyword\">return</span> cache[key] = f.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>)&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>"},{"title":"打造属于自己的栅格系统（翻译）","date":"2017-10-04T16:00:00.000Z","_content":"原文地址：[http://j4n.co/blog/Creating-your-own-css-grid-system](http://j4n.co/blog/Creating-your-own-css-grid-system)\n译者：[60kmlh](https://github.com/60kmlh)\n译文：\n\nCSS栅格系统已经面世很久了，经常在一些CSS框架中可以看见它的身影，比如Boostrap。我不并讨厌Boostrap，但是有时候如果你只是需要一个栅格功能而去引入整个框架，就显得小题大做了。接下来，我将从零开始，教你一步步打造属于自己的CSS栅格系统。\n<!--more-->\n## CSS栅格系统的组成元素\n![](http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/grid-elements.png)\n\n正如我们所见，基本的栅格包含一下元素：\n* 一个容器\n* 行\n* 列\n* 列与列之间的间隔\n## 容器\n![](http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/container.png)\n\n容器的作用是为整个栅格设置宽度。一般将栅格的宽度设置为100%，但是在大屏幕下，也可为其设置一个max-width属性。\n````css\n.grid-container {\n  width: 100%;\n  max-width:1200px\n}\n````\n## 行\n![](http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/row.png)\n\n行的作用是保证自身里面的列不会溢出到其他的行。为了实现这一点，我们使用清除技巧来使行内的元素都会显示在行里面。\n````css\n.row:before,\n.row:after {\n  content: '';\n  display: table;\n  clear: both;\n}\n````\n## 列\n![](http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/column.png)\n\n列无疑是栅格系统里最复杂的部分了。首先，列在CSS里面有几种不同的定位方式，还要考虑到列的不同宽度，同时响应式设计也是要考虑到的因素。在这个教程里，我们主要解决列的定位和宽度问题。响应式我会留一部分到下次再讲。\n\n## 列的定位\nfloat布局，inline-blocks布局，display-table布局，display-flex布局，这些是用来定位列的不同方法。根据我的个人经验，这些方法里面最不容易出错和运用最广泛的是float布局。然而，当列的内容为空的时候，浮动的列将互相堆叠。为了避免这种情况，我们为列设置一个1px的min-height属性，同时设置float属性。\n````css\n[class*='col-'] {\n  foalt: left;\n  min-height: 1px;\n}\n````\n## 列的宽度\n为了找出列的宽度，我们要做的是将容器的总宽度按列的总数来切分。在我们的教程中，行的宽度是100%，我们将一行设置为包含6个列，这样列的宽度就是100%/6=16.66%。\n````css\n[class*='col-'] {\n  float: left;\n  min-height: 1px;\n  width: 16.66%;\n}\n````\n当然这只是第一步，如果我们想要一个2倍列宽的块，我们就需要一个2倍列宽的列。计算也不复杂，如下：\n````css\n.col-1{\n  width: 16.66%; \n}\n.col-2{\n  width: 33.33%; \n}\n.col-3{\n  width: 50%; \n}\n.col-4{\n  width: 66.664%;\n}\n.col-5{\n  width: 83.33%;\n}\n.col-6{\n  width: 100%;\n}\n````\n在使用这些列组合唯一点要注意的是，每一行的列数加起来要等于6（或者任何其他的列总数，根据你之前的切分数而定）。\n## 列与列之间的间隔\n![](http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/column-gutters.png)\n\n在设置box-sizing属性值为border-box之前，我们为一个宽度为百分比数值的元素设置一个具体的padding值，这个计算过程是很痛苦的。幸运的是，使用border-box模型之后，我们可以很容易地设置列与列之间的间隔。\n````css\n  /*-- 设置网格内的所有元素为border-box模型 --*/\n.grid-container *{\n  box-sizing: border-box; \n}\n\n[class*='col-'] {\n  float: left;\n  min-height: 1px; \n  width: 16.66%; \n  /*-- 列于列的间隔 --*/\n  padding: 12px;\n}\n````\n（就我自己而言，我会在我的CSS样式里使用* {box-sizing: border-box;} ，这样页面里所有的元素都是border-box模型了。）\n## 基本成型栅格系统\n````html\n<div class=\"grid-container outline\">\n  <div class=\"row\">\n    <div class=\"col-1\"><p>col-1</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n  </div> \n  <div class=\"row\">\n    <div class=\"col-2\"><p>col-2</p></div> \n    <div class=\"col-2\"><p>col-2</p></div> \n    <div class=\"col-2\"><p>col-2</p></div> \n  </div> \n  <div class=\"row\">\n    <div class=\"col-3\"><p>col-3</p></div> \n    <div class=\"col-3\"><p>col-3</p></div> \n  </div> \n</div>\n````\n````css\n.grid-container{\n  width: 100%; \n  max-width: 1200px;      \n}\n\n/*-- 清除浮动 -- */ \n.row:before, \n.row:after {\n  content:\"\";\n  display: table ;\n  clear:both;\n}\n\n[class*='col-'] {\n  float: left; \n  min-height: 1px; \n  width: 16.66%; \n  /*-- 间隔 -- */\n  padding: 12px; \n  background-color: #FFDCDC;\n}\n\n.col-1{ width: 16.66%; }\n.col-2{ width: 33.33%; }\n.col-3{ width: 50%;    }\n.col-4{ width: 66.66%; }\n.col-5{ width: 83.33%; }\n.col-6{ width: 100%;   }\n\n.outline, .outline *{\n  outline: 1px solid #F6A1A1; \n}\n\n/*-- 一些列的个性化样式 --*/\n[class*='col-'] > p {\n  background-color: #FFC2C2; \n  padding: 0;\n  margin: 0;\n  text-align: center; \n  color: white; \n}\n````\n## 为你的栅格加上响应式\n调整栅格系统以适应移动端布局并不困难，我们要做的只是调整列的宽度。\n\n为了简单起见，在屏幕宽度小于800px时，我将列的宽度进行放大为两倍。\n\n唯一需要注意的例外情况是，有些时候行的最后一列会超出列。比如当.clo-2的列和.col-1的列跟在.col-5的列旁边时，就会出现这种情况。\n\n为了应对这种情况，我们将处于列尾部的.col-1和.col-2的列的宽设置为100%。\n\n````css\n@media all and (max-width:800px){\n  .col-1{ width: 33.33%; }\n  .col-2{ width: 50%;    }\n  .col-3{ width: 83.33%; }\n  .col-4{ width: 100%;   }\n  .col-5{ width: 100%;   }\n  .col-6{ width: 100%;   }\n\n  .row .col-2:last-of-type{\n      width: 100%; \n }\n\n  .row .col-5 ~ .col-1{\n      width: 100%; \n }\n}\n````\n对于远小于800px宽度的屏幕，我们将除了最小列之外的其他列的宽度设置为100%。\n````css\n@media all and (max-width:650px){\n  .col-1{ width: 50%;  }\n  .col-2{ width: 100%; }\n  .col-3{ width: 100%; }\n  .col-4{ width: 100%; }\n  .col-5{ width: 100%; }\n  .col-6{ width: 100%; }\n  }\n````\n````html\n<div class=\"grid-container outline\">\n  <div class=\"row\">\n    <div class=\"col-1\"><p>col-1</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n  </div> \n  <div class=\"row\">\n    <div class=\"col-2\"><p>col-2</p></div> \n    <div class=\"col-2\"><p>col-2</p></div> \n    <div class=\"col-2\"><p>col-2</p></div> \n  </div> \n  <div class=\"row\">\n    <div class=\"col-3\"><p>col-3</p></div> \n    <div class=\"col-3\"><p>col-3</p></div> \n  </div> \n  <div class=\"row\">\n    <div class=\"col-4\"><p>col-4</p></div> \n    <div class=\"col-2\"><p>col-2</p></div> \n  </div> \n  <div class=\"row\">\n    <div class=\"col-5\"><p>col-5</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n  </div> \n  <div class=\"row\">\n    <div class=\"col-6\"><p>col-6</p></div> \n  </div> \n</div>\n````\n到此为止，我们已经脱离框架，打造了属于自己的响应式栅格系统。\n\n需要提醒的是，这份教程只是你创建栅格系统的起点，不是一个完整的框架，也不是一个完善的解决方案。但我希望通过这份教程，能为你揭秘CSS栅格系统的创建过程。\n\n\n\n## 译者补充\n\n这份教程简单易懂地介绍了如何一步一步建立CSS栅格系统。参照Boostrap，栅格系统的响应式功能可以进一步扩展。\n\n增加lg和md样式，利用媒体查询，在不同的浏览器尺寸下应用不同的CSS类。\n\n屏幕宽大于768px时，增加样式\n````css\n@media all and (min-width: 768px) {\n  .col-lg-1 {\n    width: 8.33%;\n  }\n  .col-lg-2 {\n    width: 16.66%;\n  }\n  .col-lg-3 {\n    width: 25%;\n  }\n  .col-lg-4 {\n    width: 33.33%;\n  }\n  .col-lg-5 {\n    width: 41.66%;\n  }\n  .col-lg-6 {\n    width: 50%;\n  }\n  .col-lg-7 {\n    width: 58.33%;\n  }\n  .col-lg-8 {\n    width: 66.66%;\n  }\n  .col-lg-9 {\n    width: 75%;\n  }\n  .col-lg-10 {\n    width: 83.33%;\n  }\n  .col-lg-11 {\n    width: 91.66%;\n  }\n  .col-lg-12 {\n    width: 100%;\n  }\n}\n````\n屏幕宽小于768px时\n````css\n@media all and (max-width: 768px) {\n  .col-md-1 {\n    width: 8.33%;\n  }\n  .col-md-2 {\n    width: 16.66%;\n  }\n  .col-md-3 {\n    width: 25%;\n  }\n  .col-md-4 {\n    width: 33.33%;\n  }\n  .col-md-5 {\n    width: 41.66%;\n  }\n  .col-md-6 {\n    width: 50%;\n  }\n  .col-md-7 {\n    width: 58.33%;\n  }\n  .col-md-8 {\n    width: 66.66%;\n  }\n  .col-md-9 {\n    width: 75%;\n  }\n  .col-md-10 {\n    width: 83.33%;\n  }\n  .col-md-11 {\n    width: 91.66%;\n  }\n  .col-md-12 {\n    width: 100%;\n  }\n}\n````\nhtml里面这样使用\n````html\n<body>\n<div class=\"wrap\">\n  <div class=\"row\">\n    <div class=\"col-lg-4 col-md-6\">\n      <div class=\"content\"></div>\n    </div>\n    <div class=\"col-lg-4 col-md-6\">\n      <div class=\"content\"></div>\n    </div>\n    <div class=\"col-lg-4 col-md-12\">\n      <div class=\"content\"></div>\n    </div>\n  </div>\n  <div class=\"row\">\n    <div class=\"col-lg-3 col-md-3\">\n      <div class=\"content\"></div>\n    </div>\n    <div class=\"col-lg-6 col-md-6\">\n      <div class=\"content\"></div>\n    </div>\n    <div class=\"col-lg-3 col-md-3\">\n      <div class=\"content\"></div>\n    </div>    \n  </div>\n  <div class=\"row\">\n    <div class=\"col-lg-1 col-md-2\">\n      <div class=\"content\"></div>\n    </div>\n    <div class=\"col-lg-1 col-md-2\">\n      <div class=\"content\"></div>\n    </div>\n    <div class=\"col-lg-2 col-md-8\">\n      <div class=\"content\"></div>\n    </div>\n    <div class=\"col-lg-2 col-md-3\">\n      <div class=\"content\"></div>\n    </div>\n    <div class=\"col-lg-6 col-md-3\">\n      <div class=\"content\"></div>\n    </div>\n  </div>\n</div>\n</body>\n````\n\n使用css预编译器编写上面的css更加方便\n````stylus\ngetGridWidth(n)\n  n/12*100%\n\n@media all and (min-width:768px)\n  for n in 1..12\n    .col-lg-{n}\n      width getGridWidth(n)\n\n@media all and (max-width:768px)\n  for n in 1..12\n    .col-md-{n}\n      width getGridWidth(n)\n\n````\n\n最终效果展示\n\n[http://60kmlh.ink/css-grid/](http://60kmlh.ink/css-grid/)","source":"_posts/打造属于自己的栅格系统（翻译）.md","raw":"---\ntitle: 打造属于自己的栅格系统（翻译）\ndate: 2017-10-05\ntags: ['css','grid','responsive']\ncategories: ['翻译']\n---\n原文地址：[http://j4n.co/blog/Creating-your-own-css-grid-system](http://j4n.co/blog/Creating-your-own-css-grid-system)\n译者：[60kmlh](https://github.com/60kmlh)\n译文：\n\nCSS栅格系统已经面世很久了，经常在一些CSS框架中可以看见它的身影，比如Boostrap。我不并讨厌Boostrap，但是有时候如果你只是需要一个栅格功能而去引入整个框架，就显得小题大做了。接下来，我将从零开始，教你一步步打造属于自己的CSS栅格系统。\n<!--more-->\n## CSS栅格系统的组成元素\n![](http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/grid-elements.png)\n\n正如我们所见，基本的栅格包含一下元素：\n* 一个容器\n* 行\n* 列\n* 列与列之间的间隔\n## 容器\n![](http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/container.png)\n\n容器的作用是为整个栅格设置宽度。一般将栅格的宽度设置为100%，但是在大屏幕下，也可为其设置一个max-width属性。\n````css\n.grid-container {\n  width: 100%;\n  max-width:1200px\n}\n````\n## 行\n![](http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/row.png)\n\n行的作用是保证自身里面的列不会溢出到其他的行。为了实现这一点，我们使用清除技巧来使行内的元素都会显示在行里面。\n````css\n.row:before,\n.row:after {\n  content: '';\n  display: table;\n  clear: both;\n}\n````\n## 列\n![](http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/column.png)\n\n列无疑是栅格系统里最复杂的部分了。首先，列在CSS里面有几种不同的定位方式，还要考虑到列的不同宽度，同时响应式设计也是要考虑到的因素。在这个教程里，我们主要解决列的定位和宽度问题。响应式我会留一部分到下次再讲。\n\n## 列的定位\nfloat布局，inline-blocks布局，display-table布局，display-flex布局，这些是用来定位列的不同方法。根据我的个人经验，这些方法里面最不容易出错和运用最广泛的是float布局。然而，当列的内容为空的时候，浮动的列将互相堆叠。为了避免这种情况，我们为列设置一个1px的min-height属性，同时设置float属性。\n````css\n[class*='col-'] {\n  foalt: left;\n  min-height: 1px;\n}\n````\n## 列的宽度\n为了找出列的宽度，我们要做的是将容器的总宽度按列的总数来切分。在我们的教程中，行的宽度是100%，我们将一行设置为包含6个列，这样列的宽度就是100%/6=16.66%。\n````css\n[class*='col-'] {\n  float: left;\n  min-height: 1px;\n  width: 16.66%;\n}\n````\n当然这只是第一步，如果我们想要一个2倍列宽的块，我们就需要一个2倍列宽的列。计算也不复杂，如下：\n````css\n.col-1{\n  width: 16.66%; \n}\n.col-2{\n  width: 33.33%; \n}\n.col-3{\n  width: 50%; \n}\n.col-4{\n  width: 66.664%;\n}\n.col-5{\n  width: 83.33%;\n}\n.col-6{\n  width: 100%;\n}\n````\n在使用这些列组合唯一点要注意的是，每一行的列数加起来要等于6（或者任何其他的列总数，根据你之前的切分数而定）。\n## 列与列之间的间隔\n![](http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/column-gutters.png)\n\n在设置box-sizing属性值为border-box之前，我们为一个宽度为百分比数值的元素设置一个具体的padding值，这个计算过程是很痛苦的。幸运的是，使用border-box模型之后，我们可以很容易地设置列与列之间的间隔。\n````css\n  /*-- 设置网格内的所有元素为border-box模型 --*/\n.grid-container *{\n  box-sizing: border-box; \n}\n\n[class*='col-'] {\n  float: left;\n  min-height: 1px; \n  width: 16.66%; \n  /*-- 列于列的间隔 --*/\n  padding: 12px;\n}\n````\n（就我自己而言，我会在我的CSS样式里使用* {box-sizing: border-box;} ，这样页面里所有的元素都是border-box模型了。）\n## 基本成型栅格系统\n````html\n<div class=\"grid-container outline\">\n  <div class=\"row\">\n    <div class=\"col-1\"><p>col-1</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n  </div> \n  <div class=\"row\">\n    <div class=\"col-2\"><p>col-2</p></div> \n    <div class=\"col-2\"><p>col-2</p></div> \n    <div class=\"col-2\"><p>col-2</p></div> \n  </div> \n  <div class=\"row\">\n    <div class=\"col-3\"><p>col-3</p></div> \n    <div class=\"col-3\"><p>col-3</p></div> \n  </div> \n</div>\n````\n````css\n.grid-container{\n  width: 100%; \n  max-width: 1200px;      \n}\n\n/*-- 清除浮动 -- */ \n.row:before, \n.row:after {\n  content:\"\";\n  display: table ;\n  clear:both;\n}\n\n[class*='col-'] {\n  float: left; \n  min-height: 1px; \n  width: 16.66%; \n  /*-- 间隔 -- */\n  padding: 12px; \n  background-color: #FFDCDC;\n}\n\n.col-1{ width: 16.66%; }\n.col-2{ width: 33.33%; }\n.col-3{ width: 50%;    }\n.col-4{ width: 66.66%; }\n.col-5{ width: 83.33%; }\n.col-6{ width: 100%;   }\n\n.outline, .outline *{\n  outline: 1px solid #F6A1A1; \n}\n\n/*-- 一些列的个性化样式 --*/\n[class*='col-'] > p {\n  background-color: #FFC2C2; \n  padding: 0;\n  margin: 0;\n  text-align: center; \n  color: white; \n}\n````\n## 为你的栅格加上响应式\n调整栅格系统以适应移动端布局并不困难，我们要做的只是调整列的宽度。\n\n为了简单起见，在屏幕宽度小于800px时，我将列的宽度进行放大为两倍。\n\n唯一需要注意的例外情况是，有些时候行的最后一列会超出列。比如当.clo-2的列和.col-1的列跟在.col-5的列旁边时，就会出现这种情况。\n\n为了应对这种情况，我们将处于列尾部的.col-1和.col-2的列的宽设置为100%。\n\n````css\n@media all and (max-width:800px){\n  .col-1{ width: 33.33%; }\n  .col-2{ width: 50%;    }\n  .col-3{ width: 83.33%; }\n  .col-4{ width: 100%;   }\n  .col-5{ width: 100%;   }\n  .col-6{ width: 100%;   }\n\n  .row .col-2:last-of-type{\n      width: 100%; \n }\n\n  .row .col-5 ~ .col-1{\n      width: 100%; \n }\n}\n````\n对于远小于800px宽度的屏幕，我们将除了最小列之外的其他列的宽度设置为100%。\n````css\n@media all and (max-width:650px){\n  .col-1{ width: 50%;  }\n  .col-2{ width: 100%; }\n  .col-3{ width: 100%; }\n  .col-4{ width: 100%; }\n  .col-5{ width: 100%; }\n  .col-6{ width: 100%; }\n  }\n````\n````html\n<div class=\"grid-container outline\">\n  <div class=\"row\">\n    <div class=\"col-1\"><p>col-1</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n  </div> \n  <div class=\"row\">\n    <div class=\"col-2\"><p>col-2</p></div> \n    <div class=\"col-2\"><p>col-2</p></div> \n    <div class=\"col-2\"><p>col-2</p></div> \n  </div> \n  <div class=\"row\">\n    <div class=\"col-3\"><p>col-3</p></div> \n    <div class=\"col-3\"><p>col-3</p></div> \n  </div> \n  <div class=\"row\">\n    <div class=\"col-4\"><p>col-4</p></div> \n    <div class=\"col-2\"><p>col-2</p></div> \n  </div> \n  <div class=\"row\">\n    <div class=\"col-5\"><p>col-5</p></div> \n    <div class=\"col-1\"><p>col-1</p></div> \n  </div> \n  <div class=\"row\">\n    <div class=\"col-6\"><p>col-6</p></div> \n  </div> \n</div>\n````\n到此为止，我们已经脱离框架，打造了属于自己的响应式栅格系统。\n\n需要提醒的是，这份教程只是你创建栅格系统的起点，不是一个完整的框架，也不是一个完善的解决方案。但我希望通过这份教程，能为你揭秘CSS栅格系统的创建过程。\n\n\n\n## 译者补充\n\n这份教程简单易懂地介绍了如何一步一步建立CSS栅格系统。参照Boostrap，栅格系统的响应式功能可以进一步扩展。\n\n增加lg和md样式，利用媒体查询，在不同的浏览器尺寸下应用不同的CSS类。\n\n屏幕宽大于768px时，增加样式\n````css\n@media all and (min-width: 768px) {\n  .col-lg-1 {\n    width: 8.33%;\n  }\n  .col-lg-2 {\n    width: 16.66%;\n  }\n  .col-lg-3 {\n    width: 25%;\n  }\n  .col-lg-4 {\n    width: 33.33%;\n  }\n  .col-lg-5 {\n    width: 41.66%;\n  }\n  .col-lg-6 {\n    width: 50%;\n  }\n  .col-lg-7 {\n    width: 58.33%;\n  }\n  .col-lg-8 {\n    width: 66.66%;\n  }\n  .col-lg-9 {\n    width: 75%;\n  }\n  .col-lg-10 {\n    width: 83.33%;\n  }\n  .col-lg-11 {\n    width: 91.66%;\n  }\n  .col-lg-12 {\n    width: 100%;\n  }\n}\n````\n屏幕宽小于768px时\n````css\n@media all and (max-width: 768px) {\n  .col-md-1 {\n    width: 8.33%;\n  }\n  .col-md-2 {\n    width: 16.66%;\n  }\n  .col-md-3 {\n    width: 25%;\n  }\n  .col-md-4 {\n    width: 33.33%;\n  }\n  .col-md-5 {\n    width: 41.66%;\n  }\n  .col-md-6 {\n    width: 50%;\n  }\n  .col-md-7 {\n    width: 58.33%;\n  }\n  .col-md-8 {\n    width: 66.66%;\n  }\n  .col-md-9 {\n    width: 75%;\n  }\n  .col-md-10 {\n    width: 83.33%;\n  }\n  .col-md-11 {\n    width: 91.66%;\n  }\n  .col-md-12 {\n    width: 100%;\n  }\n}\n````\nhtml里面这样使用\n````html\n<body>\n<div class=\"wrap\">\n  <div class=\"row\">\n    <div class=\"col-lg-4 col-md-6\">\n      <div class=\"content\"></div>\n    </div>\n    <div class=\"col-lg-4 col-md-6\">\n      <div class=\"content\"></div>\n    </div>\n    <div class=\"col-lg-4 col-md-12\">\n      <div class=\"content\"></div>\n    </div>\n  </div>\n  <div class=\"row\">\n    <div class=\"col-lg-3 col-md-3\">\n      <div class=\"content\"></div>\n    </div>\n    <div class=\"col-lg-6 col-md-6\">\n      <div class=\"content\"></div>\n    </div>\n    <div class=\"col-lg-3 col-md-3\">\n      <div class=\"content\"></div>\n    </div>    \n  </div>\n  <div class=\"row\">\n    <div class=\"col-lg-1 col-md-2\">\n      <div class=\"content\"></div>\n    </div>\n    <div class=\"col-lg-1 col-md-2\">\n      <div class=\"content\"></div>\n    </div>\n    <div class=\"col-lg-2 col-md-8\">\n      <div class=\"content\"></div>\n    </div>\n    <div class=\"col-lg-2 col-md-3\">\n      <div class=\"content\"></div>\n    </div>\n    <div class=\"col-lg-6 col-md-3\">\n      <div class=\"content\"></div>\n    </div>\n  </div>\n</div>\n</body>\n````\n\n使用css预编译器编写上面的css更加方便\n````stylus\ngetGridWidth(n)\n  n/12*100%\n\n@media all and (min-width:768px)\n  for n in 1..12\n    .col-lg-{n}\n      width getGridWidth(n)\n\n@media all and (max-width:768px)\n  for n in 1..12\n    .col-md-{n}\n      width getGridWidth(n)\n\n````\n\n最终效果展示\n\n[http://60kmlh.ink/css-grid/](http://60kmlh.ink/css-grid/)","slug":"打造属于自己的栅格系统（翻译）","published":1,"updated":"2022-04-13T14:14:08.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfg70041g3t8pk93wciz","content":"<p>原文地址：<a href=\"http://j4n.co/blog/Creating-your-own-css-grid-system\" target=\"_blank\" rel=\"noopener\">http://j4n.co/blog/Creating-your-own-css-grid-system</a><br>译者：<a href=\"https://github.com/60kmlh\" target=\"_blank\" rel=\"noopener\">60kmlh</a><br>译文：</p>\n<p>CSS栅格系统已经面世很久了，经常在一些CSS框架中可以看见它的身影，比如Boostrap。我不并讨厌Boostrap，但是有时候如果你只是需要一个栅格功能而去引入整个框架，就显得小题大做了。接下来，我将从零开始，教你一步步打造属于自己的CSS栅格系统。<br><a id=\"more\"></a></p>\n<h2 id=\"CSS栅格系统的组成元素\"><a href=\"#CSS栅格系统的组成元素\" class=\"headerlink\" title=\"CSS栅格系统的组成元素\"></a>CSS栅格系统的组成元素</h2><p><img src=\"http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/grid-elements.png\" alt></p>\n<p>正如我们所见，基本的栅格包含一下元素：</p>\n<ul>\n<li>一个容器</li>\n<li>行</li>\n<li>列</li>\n<li>列与列之间的间隔<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><img src=\"http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/container.png\" alt></li>\n</ul>\n<p>容器的作用是为整个栅格设置宽度。一般将栅格的宽度设置为100%，但是在大屏幕下，也可为其设置一个max-width属性。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.grid-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">max-width</span>:<span class=\"number\">1200px</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"行\"><a href=\"#行\" class=\"headerlink\" title=\"行\"></a>行</h2><p><img src=\"http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/row.png\" alt></p>\n<p>行的作用是保证自身里面的列不会溢出到其他的行。为了实现这一点，我们使用清除技巧来使行内的元素都会显示在行里面。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.row</span><span class=\"selector-pseudo\">:before</span>,</span><br><span class=\"line\"><span class=\"selector-class\">.row</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table;</span><br><span class=\"line\">  <span class=\"attribute\">clear</span>: both;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"列\"><a href=\"#列\" class=\"headerlink\" title=\"列\"></a>列</h2><p><img src=\"http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/column.png\" alt></p>\n<p>列无疑是栅格系统里最复杂的部分了。首先，列在CSS里面有几种不同的定位方式，还要考虑到列的不同宽度，同时响应式设计也是要考虑到的因素。在这个教程里，我们主要解决列的定位和宽度问题。响应式我会留一部分到下次再讲。</p>\n<h2 id=\"列的定位\"><a href=\"#列的定位\" class=\"headerlink\" title=\"列的定位\"></a>列的定位</h2><p>float布局，inline-blocks布局，display-table布局，display-flex布局，这些是用来定位列的不同方法。根据我的个人经验，这些方法里面最不容易出错和运用最广泛的是float布局。然而，当列的内容为空的时候，浮动的列将互相堆叠。为了避免这种情况，我们为列设置一个1px的min-height属性，同时设置float属性。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-attr\">[class*=<span class=\"string\">'col-'</span>]</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">foalt</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">min-height</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"列的宽度\"><a href=\"#列的宽度\" class=\"headerlink\" title=\"列的宽度\"></a>列的宽度</h2><p>为了找出列的宽度，我们要做的是将容器的总宽度按列的总数来切分。在我们的教程中，行的宽度是100%，我们将一行设置为包含6个列，这样列的宽度就是100%/6=16.66%。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-attr\">[class*=<span class=\"string\">'col-'</span>]</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">min-height</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">16.66%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然这只是第一步，如果我们想要一个2倍列宽的块，我们就需要一个2倍列宽的列。计算也不复杂，如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.col-1</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">16.66%</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-2</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">33.33%</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-3</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">50%</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-4</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">66.664%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-5</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">83.33%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-6</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在使用这些列组合唯一点要注意的是，每一行的列数加起来要等于6（或者任何其他的列总数，根据你之前的切分数而定）。</p>\n<h2 id=\"列与列之间的间隔\"><a href=\"#列与列之间的间隔\" class=\"headerlink\" title=\"列与列之间的间隔\"></a>列与列之间的间隔</h2><p><img src=\"http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/column-gutters.png\" alt></p>\n<p>在设置box-sizing属性值为border-box之前，我们为一个宽度为百分比数值的元素设置一个具体的padding值，这个计算过程是很痛苦的。幸运的是，使用border-box模型之后，我们可以很容易地设置列与列之间的间隔。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">/*-- 设置网格内的所有元素为border-box模型 --*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.grid-container</span> *&#123;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-attr\">[class*=<span class=\"string\">'col-'</span>]</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">min-height</span>: <span class=\"number\">1px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">16.66%</span>; </span><br><span class=\"line\">  <span class=\"comment\">/*-- 列于列的间隔 --*/</span></span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">12px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>（就我自己而言，我会在我的CSS样式里使用* {box-sizing: border-box;} ，这样页面里所有的元素都是border-box模型了。）</p>\n<h2 id=\"基本成型栅格系统\"><a href=\"#基本成型栅格系统\" class=\"headerlink\" title=\"基本成型栅格系统\"></a>基本成型栅格系统</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"grid-container outline\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-2\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-2\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-2\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-3\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-3<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-3\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-3<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.grid-container</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; </span><br><span class=\"line\">  <span class=\"attribute\">max-width</span>: <span class=\"number\">1200px</span>;      </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-- 清除浮动 -- */</span> </span><br><span class=\"line\"><span class=\"selector-class\">.row</span><span class=\"selector-pseudo\">:before</span>, </span><br><span class=\"line\"><span class=\"selector-class\">.row</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>:<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table ;</span><br><span class=\"line\">  <span class=\"attribute\">clear</span>:both;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-attr\">[class*=<span class=\"string\">'col-'</span>]</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left; </span><br><span class=\"line\">  <span class=\"attribute\">min-height</span>: <span class=\"number\">1px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">16.66%</span>; </span><br><span class=\"line\">  <span class=\"comment\">/*-- 间隔 -- */</span></span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">12px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#FFDCDC</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.col-1</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">16.66%</span>; &#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-2</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">33.33%</span>; &#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-3</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">50%</span>;    &#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-4</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">66.66%</span>; &#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-5</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">83.33%</span>; &#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-6</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.outline</span>, <span class=\"selector-class\">.outline</span> *&#123;</span><br><span class=\"line\">  <span class=\"attribute\">outline</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#F6A1A1</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-- 一些列的个性化样式 --*/</span></span><br><span class=\"line\"><span class=\"selector-attr\">[class*=<span class=\"string\">'col-'</span>]</span> &gt; <span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#FFC2C2</span>; </span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: center; </span><br><span class=\"line\">  <span class=\"attribute\">color</span>: white; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"为你的栅格加上响应式\"><a href=\"#为你的栅格加上响应式\" class=\"headerlink\" title=\"为你的栅格加上响应式\"></a>为你的栅格加上响应式</h2><p>调整栅格系统以适应移动端布局并不困难，我们要做的只是调整列的宽度。</p>\n<p>为了简单起见，在屏幕宽度小于800px时，我将列的宽度进行放大为两倍。</p>\n<p>唯一需要注意的例外情况是，有些时候行的最后一列会超出列。比如当.clo-2的列和.col-1的列跟在.col-5的列旁边时，就会出现这种情况。</p>\n<p>为了应对这种情况，我们将处于列尾部的.col-1和.col-2的列的宽设置为100%。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@media</span> all <span class=\"keyword\">and</span> (<span class=\"attribute\">max-width:</span><span class=\"number\">800px</span>)&#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-1</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">33.33%</span>; &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-2</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">50%</span>;    &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-3</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">83.33%</span>; &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-4</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;   &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-5</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;   &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-6</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-class\">.row</span> <span class=\"selector-class\">.col-2</span><span class=\"selector-pseudo\">:last-of-type</span>&#123;</span><br><span class=\"line\">      <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; </span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-class\">.row</span> <span class=\"selector-class\">.col-5</span> ~ <span class=\"selector-class\">.col-1</span>&#123;</span><br><span class=\"line\">      <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; </span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于远小于800px宽度的屏幕，我们将除了最小列之外的其他列的宽度设置为100%。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@media</span> all <span class=\"keyword\">and</span> (<span class=\"attribute\">max-width:</span><span class=\"number\">650px</span>)&#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-1</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">50%</span>;  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-2</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-3</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-4</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-5</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-6</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"grid-container outline\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-2\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-2\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-2\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-3\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-3<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-3\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-3<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-4\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-4<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-2\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-5\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-5<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-6\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-6<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>到此为止，我们已经脱离框架，打造了属于自己的响应式栅格系统。</p>\n<p>需要提醒的是，这份教程只是你创建栅格系统的起点，不是一个完整的框架，也不是一个完善的解决方案。但我希望通过这份教程，能为你揭秘CSS栅格系统的创建过程。</p>\n<h2 id=\"译者补充\"><a href=\"#译者补充\" class=\"headerlink\" title=\"译者补充\"></a>译者补充</h2><p>这份教程简单易懂地介绍了如何一步一步建立CSS栅格系统。参照Boostrap，栅格系统的响应式功能可以进一步扩展。</p>\n<p>增加lg和md样式，利用媒体查询，在不同的浏览器尺寸下应用不同的CSS类。</p>\n<p>屏幕宽大于768px时，增加样式<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@media</span> all <span class=\"keyword\">and</span> (<span class=\"attribute\">min-width:</span> <span class=\"number\">768px</span>) &#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">8.33%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-2</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">16.66%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-3</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">25%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-4</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">33.33%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-5</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">41.66%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-6</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-7</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">58.33%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-8</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">66.66%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-9</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">75%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-10</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">83.33%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-11</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">91.66%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-12</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>屏幕宽小于768px时<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@media</span> all <span class=\"keyword\">and</span> (<span class=\"attribute\">max-width:</span> <span class=\"number\">768px</span>) &#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">8.33%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-2</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">16.66%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-3</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">25%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-4</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">33.33%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-5</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">41.66%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-6</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-7</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">58.33%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-8</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">66.66%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-9</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">75%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-10</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">83.33%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-11</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">91.66%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-12</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>html里面这样使用<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-4 col-md-6\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-4 col-md-6\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-4 col-md-12\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-3 col-md-3\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-6 col-md-6\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-3 col-md-3\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>    </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-1 col-md-2\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-1 col-md-2\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-2 col-md-8\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-2 col-md-3\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-6 col-md-3\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>使用css预编译器编写上面的css更加方便<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">getGridWidth</span><span class=\"params\">(n)</span></span></span><br><span class=\"line\">  n/<span class=\"number\">12</span>*<span class=\"number\">100%</span></span><br><span class=\"line\"></span><br><span class=\"line\">@media all and (<span class=\"attribute\">min-width</span>:<span class=\"number\">768px</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">12</span></span><br><span class=\"line\">    .col-lg-&#123;n&#125;</span><br><span class=\"line\">      <span class=\"attribute\">width</span> getGridWidth(n)</span><br><span class=\"line\"></span><br><span class=\"line\">@media all and (<span class=\"attribute\">max-width</span>:<span class=\"number\">768px</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">12</span></span><br><span class=\"line\">    .col-md-&#123;n&#125;</span><br><span class=\"line\">      <span class=\"attribute\">width</span> getGridWidth(n)</span><br></pre></td></tr></table></figure></p>\n<p>最终效果展示</p>\n<p><a href=\"http://60kmlh.ink/css-grid/\" target=\"_blank\" rel=\"noopener\">http://60kmlh.ink/css-grid/</a></p>\n","site":{"data":{}},"excerpt":"<p>原文地址：<a href=\"http://j4n.co/blog/Creating-your-own-css-grid-system\" target=\"_blank\" rel=\"noopener\">http://j4n.co/blog/Creating-your-own-css-grid-system</a><br>译者：<a href=\"https://github.com/60kmlh\" target=\"_blank\" rel=\"noopener\">60kmlh</a><br>译文：</p>\n<p>CSS栅格系统已经面世很久了，经常在一些CSS框架中可以看见它的身影，比如Boostrap。我不并讨厌Boostrap，但是有时候如果你只是需要一个栅格功能而去引入整个框架，就显得小题大做了。接下来，我将从零开始，教你一步步打造属于自己的CSS栅格系统。<br>","more":"</p>\n<h2 id=\"CSS栅格系统的组成元素\"><a href=\"#CSS栅格系统的组成元素\" class=\"headerlink\" title=\"CSS栅格系统的组成元素\"></a>CSS栅格系统的组成元素</h2><p><img src=\"http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/grid-elements.png\" alt></p>\n<p>正如我们所见，基本的栅格包含一下元素：</p>\n<ul>\n<li>一个容器</li>\n<li>行</li>\n<li>列</li>\n<li>列与列之间的间隔<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><img src=\"http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/container.png\" alt></li>\n</ul>\n<p>容器的作用是为整个栅格设置宽度。一般将栅格的宽度设置为100%，但是在大屏幕下，也可为其设置一个max-width属性。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.grid-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">max-width</span>:<span class=\"number\">1200px</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"行\"><a href=\"#行\" class=\"headerlink\" title=\"行\"></a>行</h2><p><img src=\"http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/row.png\" alt></p>\n<p>行的作用是保证自身里面的列不会溢出到其他的行。为了实现这一点，我们使用清除技巧来使行内的元素都会显示在行里面。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.row</span><span class=\"selector-pseudo\">:before</span>,</span><br><span class=\"line\"><span class=\"selector-class\">.row</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table;</span><br><span class=\"line\">  <span class=\"attribute\">clear</span>: both;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"列\"><a href=\"#列\" class=\"headerlink\" title=\"列\"></a>列</h2><p><img src=\"http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/column.png\" alt></p>\n<p>列无疑是栅格系统里最复杂的部分了。首先，列在CSS里面有几种不同的定位方式，还要考虑到列的不同宽度，同时响应式设计也是要考虑到的因素。在这个教程里，我们主要解决列的定位和宽度问题。响应式我会留一部分到下次再讲。</p>\n<h2 id=\"列的定位\"><a href=\"#列的定位\" class=\"headerlink\" title=\"列的定位\"></a>列的定位</h2><p>float布局，inline-blocks布局，display-table布局，display-flex布局，这些是用来定位列的不同方法。根据我的个人经验，这些方法里面最不容易出错和运用最广泛的是float布局。然而，当列的内容为空的时候，浮动的列将互相堆叠。为了避免这种情况，我们为列设置一个1px的min-height属性，同时设置float属性。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-attr\">[class*=<span class=\"string\">'col-'</span>]</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">foalt</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">min-height</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"列的宽度\"><a href=\"#列的宽度\" class=\"headerlink\" title=\"列的宽度\"></a>列的宽度</h2><p>为了找出列的宽度，我们要做的是将容器的总宽度按列的总数来切分。在我们的教程中，行的宽度是100%，我们将一行设置为包含6个列，这样列的宽度就是100%/6=16.66%。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-attr\">[class*=<span class=\"string\">'col-'</span>]</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">min-height</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">16.66%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然这只是第一步，如果我们想要一个2倍列宽的块，我们就需要一个2倍列宽的列。计算也不复杂，如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.col-1</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">16.66%</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-2</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">33.33%</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-3</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">50%</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-4</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">66.664%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-5</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">83.33%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-6</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在使用这些列组合唯一点要注意的是，每一行的列数加起来要等于6（或者任何其他的列总数，根据你之前的切分数而定）。</p>\n<h2 id=\"列与列之间的间隔\"><a href=\"#列与列之间的间隔\" class=\"headerlink\" title=\"列与列之间的间隔\"></a>列与列之间的间隔</h2><p><img src=\"http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/column-gutters.png\" alt></p>\n<p>在设置box-sizing属性值为border-box之前，我们为一个宽度为百分比数值的元素设置一个具体的padding值，这个计算过程是很痛苦的。幸运的是，使用border-box模型之后，我们可以很容易地设置列与列之间的间隔。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">/*-- 设置网格内的所有元素为border-box模型 --*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.grid-container</span> *&#123;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-attr\">[class*=<span class=\"string\">'col-'</span>]</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">min-height</span>: <span class=\"number\">1px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">16.66%</span>; </span><br><span class=\"line\">  <span class=\"comment\">/*-- 列于列的间隔 --*/</span></span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">12px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>（就我自己而言，我会在我的CSS样式里使用* {box-sizing: border-box;} ，这样页面里所有的元素都是border-box模型了。）</p>\n<h2 id=\"基本成型栅格系统\"><a href=\"#基本成型栅格系统\" class=\"headerlink\" title=\"基本成型栅格系统\"></a>基本成型栅格系统</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"grid-container outline\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-2\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-2\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-2\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-3\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-3<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-3\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-3<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.grid-container</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; </span><br><span class=\"line\">  <span class=\"attribute\">max-width</span>: <span class=\"number\">1200px</span>;      </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-- 清除浮动 -- */</span> </span><br><span class=\"line\"><span class=\"selector-class\">.row</span><span class=\"selector-pseudo\">:before</span>, </span><br><span class=\"line\"><span class=\"selector-class\">.row</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>:<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table ;</span><br><span class=\"line\">  <span class=\"attribute\">clear</span>:both;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-attr\">[class*=<span class=\"string\">'col-'</span>]</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left; </span><br><span class=\"line\">  <span class=\"attribute\">min-height</span>: <span class=\"number\">1px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">16.66%</span>; </span><br><span class=\"line\">  <span class=\"comment\">/*-- 间隔 -- */</span></span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">12px</span>; </span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#FFDCDC</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.col-1</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">16.66%</span>; &#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-2</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">33.33%</span>; &#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-3</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">50%</span>;    &#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-4</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">66.66%</span>; &#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-5</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">83.33%</span>; &#125;</span><br><span class=\"line\"><span class=\"selector-class\">.col-6</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.outline</span>, <span class=\"selector-class\">.outline</span> *&#123;</span><br><span class=\"line\">  <span class=\"attribute\">outline</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#F6A1A1</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*-- 一些列的个性化样式 --*/</span></span><br><span class=\"line\"><span class=\"selector-attr\">[class*=<span class=\"string\">'col-'</span>]</span> &gt; <span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#FFC2C2</span>; </span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: center; </span><br><span class=\"line\">  <span class=\"attribute\">color</span>: white; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"为你的栅格加上响应式\"><a href=\"#为你的栅格加上响应式\" class=\"headerlink\" title=\"为你的栅格加上响应式\"></a>为你的栅格加上响应式</h2><p>调整栅格系统以适应移动端布局并不困难，我们要做的只是调整列的宽度。</p>\n<p>为了简单起见，在屏幕宽度小于800px时，我将列的宽度进行放大为两倍。</p>\n<p>唯一需要注意的例外情况是，有些时候行的最后一列会超出列。比如当.clo-2的列和.col-1的列跟在.col-5的列旁边时，就会出现这种情况。</p>\n<p>为了应对这种情况，我们将处于列尾部的.col-1和.col-2的列的宽设置为100%。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@media</span> all <span class=\"keyword\">and</span> (<span class=\"attribute\">max-width:</span><span class=\"number\">800px</span>)&#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-1</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">33.33%</span>; &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-2</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">50%</span>;    &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-3</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">83.33%</span>; &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-4</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;   &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-5</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;   &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-6</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-class\">.row</span> <span class=\"selector-class\">.col-2</span><span class=\"selector-pseudo\">:last-of-type</span>&#123;</span><br><span class=\"line\">      <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; </span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-class\">.row</span> <span class=\"selector-class\">.col-5</span> ~ <span class=\"selector-class\">.col-1</span>&#123;</span><br><span class=\"line\">      <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; </span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于远小于800px宽度的屏幕，我们将除了最小列之外的其他列的宽度设置为100%。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@media</span> all <span class=\"keyword\">and</span> (<span class=\"attribute\">max-width:</span><span class=\"number\">650px</span>)&#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-1</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">50%</span>;  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-2</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-3</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-4</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-5</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-6</span>&#123; <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"grid-container outline\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-2\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-2\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-2\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-3\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-3<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-3\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-3<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-4\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-4<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-2\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-5\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-5<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-1\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-1<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-6\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>col-6<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>到此为止，我们已经脱离框架，打造了属于自己的响应式栅格系统。</p>\n<p>需要提醒的是，这份教程只是你创建栅格系统的起点，不是一个完整的框架，也不是一个完善的解决方案。但我希望通过这份教程，能为你揭秘CSS栅格系统的创建过程。</p>\n<h2 id=\"译者补充\"><a href=\"#译者补充\" class=\"headerlink\" title=\"译者补充\"></a>译者补充</h2><p>这份教程简单易懂地介绍了如何一步一步建立CSS栅格系统。参照Boostrap，栅格系统的响应式功能可以进一步扩展。</p>\n<p>增加lg和md样式，利用媒体查询，在不同的浏览器尺寸下应用不同的CSS类。</p>\n<p>屏幕宽大于768px时，增加样式<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@media</span> all <span class=\"keyword\">and</span> (<span class=\"attribute\">min-width:</span> <span class=\"number\">768px</span>) &#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">8.33%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-2</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">16.66%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-3</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">25%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-4</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">33.33%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-5</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">41.66%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-6</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-7</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">58.33%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-8</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">66.66%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-9</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">75%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-10</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">83.33%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-11</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">91.66%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-lg-12</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>屏幕宽小于768px时<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@media</span> all <span class=\"keyword\">and</span> (<span class=\"attribute\">max-width:</span> <span class=\"number\">768px</span>) &#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">8.33%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-2</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">16.66%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-3</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">25%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-4</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">33.33%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-5</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">41.66%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-6</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-7</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">58.33%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-8</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">66.66%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-9</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">75%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-10</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">83.33%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-11</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">91.66%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.col-md-12</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>html里面这样使用<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-4 col-md-6\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-4 col-md-6\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-4 col-md-12\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-3 col-md-3\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-6 col-md-6\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-3 col-md-3\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>    </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"row\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-1 col-md-2\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-1 col-md-2\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-2 col-md-8\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-2 col-md-3\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"col-lg-6 col-md-3\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>使用css预编译器编写上面的css更加方便<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">getGridWidth</span><span class=\"params\">(n)</span></span></span><br><span class=\"line\">  n/<span class=\"number\">12</span>*<span class=\"number\">100%</span></span><br><span class=\"line\"></span><br><span class=\"line\">@media all and (<span class=\"attribute\">min-width</span>:<span class=\"number\">768px</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">12</span></span><br><span class=\"line\">    .col-lg-&#123;n&#125;</span><br><span class=\"line\">      <span class=\"attribute\">width</span> getGridWidth(n)</span><br><span class=\"line\"></span><br><span class=\"line\">@media all and (<span class=\"attribute\">max-width</span>:<span class=\"number\">768px</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">12</span></span><br><span class=\"line\">    .col-md-&#123;n&#125;</span><br><span class=\"line\">      <span class=\"attribute\">width</span> getGridWidth(n)</span><br></pre></td></tr></table></figure></p>\n<p>最终效果展示</p>\n<p><a href=\"http://60kmlh.ink/css-grid/\" target=\"_blank\" rel=\"noopener\">http://60kmlh.ink/css-grid/</a></p>"},{"title":"常见排序算法的JavaScript实现","date":"2018-06-08T16:00:00.000Z","_content":"## 冒泡排序\n\n冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n<!--more-->\n### 算法步骤\n\n1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n3. 针对所有的元素重复以上的步骤，除了最后一个。\n4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n### 动图演示\n\n![bubbleSotrt.gif](https://i.loli.net/2019/02/26/5c75078e5682c.gif)\n\n### 实现\n````javascript\nfunction bubble(array) {\n  for(let i = array.length - 1; i > 0; i--) {\n    for(let j = 0; j < i; j++) {\n      if(array[j] > array[j+1]) {\n        swap(array[j], array[j+1])\n      }\n    }\n  }\n}//(n-1)*(n-2)\n````\n## 插入排序\n\n插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 {\\displaystyle O(1)} {\\displaystyle O(1)}的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\n\n### 算法步骤\n\n1. 从第一个元素开始，该元素可以认为已经被排序\n2. 取出下一个元素，在已经排序的元素序列中从后向前扫描\n3. 如果该元素（已排序）大于新元素，将该元素移到下一位置\n4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置\n5. 将新元素插入到该位置后\n6. 重复步骤2~5\n\n### 动图演示\n![insertSort.gif](https://i.loli.net/2019/02/26/5c75078f47282.gif)\n\n### 实现\n````javascript\nfunction insertion(array) {\n  for(let i = 1; i < array.length; i++) {\n    for(let j = i - 1; j >= 0; j--) {\n      if(array[j] > array[j+1]) {\n        swap(array[j], array[j+1])\n      }\n    }\n  }\n}\n````\n\n## 选择排序\n\n选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n\n### 算法步骤\n\n1. 对比数组中前一个元素跟后一个元素的大小，如果后面的元素比前面的元素小则用一个变量k来记住他的位置。\n2. 接着第二次比较，前面“后一个元素”现变成了“前一个元素”，继续跟他的“后一个元素”进行比较如果后面的元素比他要小则用变量k记住它在数组中的位置(下标)，等到循环结束的时候，我们应该找到了最小的那个数的下标了。\n4. 然后进行判断，如果这个元素的下标不是第一个元素的下标，就让第一个元素跟他交换一下值，这样就找到整个数组中最小的数了。\n5. 然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推。\n### 动图演示\n\n![selectSort.gif](https://i.loli.net/2019/02/26/5c75078f6ad90.gif)\n\n### 实现\n````javascript\nfunction selection(array) {\n  for(let i = 0; i < array.length - 1; i++) {\n    let minIndex = i\n    for(let j = i + 1; j < array.length; j++) {\n      minIndex = array[j] < array[minIndex] ? j : minIndex\n    }\n    swap(array[minIndex], array[i])\n  }\n}\n````\n\n## 并归排序\n\n归并排序（英语：Merge sort，或mergesort），是创建在归并操作上的一种有效的排序算法，效率为 O(nlog n)（大O符号）。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。\n\n### 算法步骤\n\n* 递归法（Top-down）\n1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。\n2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置。\n3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。\n4. 重复步骤3直到某一指针到达序列尾。\n5. 将另一序列剩下的所有元素直接复制到合并序列尾。\n\n* 迭代法（Bottom-up）\n原理如下（假设序列共有 n 个元素）：\n\n1. 将序列每相邻两个数字进行归并操作，形成 ceil(n/2) 个序列，排序后每个序列包含两/一个元素。\n2. 若此时序列数不是1个则将上述序列再次归并，形成 ceil(n/4) 个序列，每个序列包含四/三个元素。\n3. 重复步骤2，直到所有元素排序完毕，即序列数为1。\n\n### 动图演示\n\n![mergeSort.gif](https://i.loli.net/2019/02/26/5c75078f45650.gif)\n\n### 实现\n\n* 递归法\n````javascript\nfunction merge(left, right) {\n  let result = []\n  while(left.length > 0 && right.length > 0) {\n    if(left[0] < right[0]) {\n      result.push(left.shift())\n    }else {\n      result.push(right.shift())\n    }\n  }\n\n  return result.concat(left, right)\n}\n\nfunction mergeSort(array) {\n  if(array.length < 2) return array\n\n  let middle = (array.length / 2)\n  let left = array.slice(0, middle)\n  let right = array.slice(middle)\n\n  return merge(mergeSort(left), mergeSort(right))\n}\n````\n* 迭代法\n````javascript\nfunction mergeSort(arr){\n  if(arr.length<2){\n    return;\n  }\n  //设置子序列的大小\n  var step=1; \n  var left,right;\n\n  while(step<arr.length){\n    left=0;\n    right=step;\n    while(right+step<=arr.length){\n      mergeArrays(arr,left,left+step,right,right+step);\n      left=right+step;\n      right=left+step;\n    }\n    if(right<arr.length){\n      mergeArrays(arr,left,left+step,right,arr.length);\n    }\n    step*=2;\n  }\n\n}\n//对左右序列进行排序\nfunction mergeArrays(arr,startLeft,stopLeft,startRight,stopRight){\n  // 建立一个左、右数组\n  var rightArr=new Array(stopRight-startRight+1);\n  var leftArr=new Array(stopLeft-startLeft+1);\n\n  // 给右数组赋值\n  k=startRight;\n  for(var i=0;i<(rightArr.length-1);++i){\n    rightArr[i]=arr[k];\n    ++k;\n  }\n   // 给左数组赋值\n  k=startLeft;\n  for(var i=0;i<(leftArr.length-1);++i){\n    leftArr[i]=arr[k];\n    ++k;\n  }\n  //设置哨兵值，当左子列或右子列读取到最后一位时，即Infinity，可以让另一个剩下的列中的值直接插入到数组中\n  rightArr[rightArr.length-1]=Infinity;\n  leftArr[leftArr.length-1]=Infinity;\n\n  var m=0;\n  var n=0;\n  // 比较左子列和右子列第一个值的大小，小的先填入数组，接着再进行比较\n  for(var k=startLeft;k<stopRight;++k){\n    if(leftArr[m]<=rightArr[n]){\n      arr[k]=leftArr[m];\n      m++; \n    }\n    else{\n      arr[k]=rightArr[n];\n      n++;\n    }\n  }\n  \n}\n````\n## 快速排序\n\n快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 n 个项目要 O(nlog n)（大O符号）次比较。在最坏状况下则需要 O(n^{2}) 次比较，但这种状况并不常见。事实上，快速排序 (n\\log n) 通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。\n\n### 算法步骤\n\n1. 从数列中挑出一个元素，称为“基准”（pivot），\n2. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。\n3. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n4. 递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。\n### 动图演示\n\n![quickSort.gif](https://i.loli.net/2019/02/26/5c75078e54e94.gif)\n\n### 实现\n````javascript\nfunction quickSort(array) {\n  let l = array.length\n  if(l < 2) return array\n\n  let basic = array[0]\n  let left = []\n  let right = []\n\n  for(let i = 1; i < l; i++) {\n    if(array[i] < basic) {\n      left.push(array[i])\n    }else {\n      right.push(array[i])\n    }\n  }\n\n  return quickSort(left).concat(basic, quickSort.concat(right))\n}\n````\n\n## 复杂度\n\n|算法|时间复杂度最好情况|时间复杂度平均情况|时间复杂度最坏情况|空间复杂度|稳定性|\n|---|---|---|---|---|---|\n|冒泡排序|O(n)|O(n^2)|O(n^2)|总共 O(n)，需要辅助空间 O(1)|是|\n|插入排序|O(n)|O(n^2)|O(n^2)|总共 O(n)，需要辅助空间 O(1)|是|\n|选择排序|O(n^2)|O(n^2)|O(n^2)|总共 O(n)，需要辅助空间 O(1)|否|\n|并归排序|O(nlogn)|O(nlogn)|O(nlogn)|总共 O(n)，需要辅助空间 O(1)|是|\n|快速排序|O(nlogn)|O(nlogn)|O(n^2)|O(n) 或者 O(nlogn)|是|\n\n## 参考资料\n\n* [排序算法](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)","source":"_posts/常见排序算法的JavaScript实现.md","raw":"---\ntitle: 常见排序算法的JavaScript实现\ndate: 2018-06-09\ntags: ['排序', 'js']\ncategories: ['算法']\n---\n## 冒泡排序\n\n冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n<!--more-->\n### 算法步骤\n\n1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n3. 针对所有的元素重复以上的步骤，除了最后一个。\n4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n### 动图演示\n\n![bubbleSotrt.gif](https://i.loli.net/2019/02/26/5c75078e5682c.gif)\n\n### 实现\n````javascript\nfunction bubble(array) {\n  for(let i = array.length - 1; i > 0; i--) {\n    for(let j = 0; j < i; j++) {\n      if(array[j] > array[j+1]) {\n        swap(array[j], array[j+1])\n      }\n    }\n  }\n}//(n-1)*(n-2)\n````\n## 插入排序\n\n插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 {\\displaystyle O(1)} {\\displaystyle O(1)}的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\n\n### 算法步骤\n\n1. 从第一个元素开始，该元素可以认为已经被排序\n2. 取出下一个元素，在已经排序的元素序列中从后向前扫描\n3. 如果该元素（已排序）大于新元素，将该元素移到下一位置\n4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置\n5. 将新元素插入到该位置后\n6. 重复步骤2~5\n\n### 动图演示\n![insertSort.gif](https://i.loli.net/2019/02/26/5c75078f47282.gif)\n\n### 实现\n````javascript\nfunction insertion(array) {\n  for(let i = 1; i < array.length; i++) {\n    for(let j = i - 1; j >= 0; j--) {\n      if(array[j] > array[j+1]) {\n        swap(array[j], array[j+1])\n      }\n    }\n  }\n}\n````\n\n## 选择排序\n\n选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n\n### 算法步骤\n\n1. 对比数组中前一个元素跟后一个元素的大小，如果后面的元素比前面的元素小则用一个变量k来记住他的位置。\n2. 接着第二次比较，前面“后一个元素”现变成了“前一个元素”，继续跟他的“后一个元素”进行比较如果后面的元素比他要小则用变量k记住它在数组中的位置(下标)，等到循环结束的时候，我们应该找到了最小的那个数的下标了。\n4. 然后进行判断，如果这个元素的下标不是第一个元素的下标，就让第一个元素跟他交换一下值，这样就找到整个数组中最小的数了。\n5. 然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推。\n### 动图演示\n\n![selectSort.gif](https://i.loli.net/2019/02/26/5c75078f6ad90.gif)\n\n### 实现\n````javascript\nfunction selection(array) {\n  for(let i = 0; i < array.length - 1; i++) {\n    let minIndex = i\n    for(let j = i + 1; j < array.length; j++) {\n      minIndex = array[j] < array[minIndex] ? j : minIndex\n    }\n    swap(array[minIndex], array[i])\n  }\n}\n````\n\n## 并归排序\n\n归并排序（英语：Merge sort，或mergesort），是创建在归并操作上的一种有效的排序算法，效率为 O(nlog n)（大O符号）。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。\n\n### 算法步骤\n\n* 递归法（Top-down）\n1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。\n2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置。\n3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。\n4. 重复步骤3直到某一指针到达序列尾。\n5. 将另一序列剩下的所有元素直接复制到合并序列尾。\n\n* 迭代法（Bottom-up）\n原理如下（假设序列共有 n 个元素）：\n\n1. 将序列每相邻两个数字进行归并操作，形成 ceil(n/2) 个序列，排序后每个序列包含两/一个元素。\n2. 若此时序列数不是1个则将上述序列再次归并，形成 ceil(n/4) 个序列，每个序列包含四/三个元素。\n3. 重复步骤2，直到所有元素排序完毕，即序列数为1。\n\n### 动图演示\n\n![mergeSort.gif](https://i.loli.net/2019/02/26/5c75078f45650.gif)\n\n### 实现\n\n* 递归法\n````javascript\nfunction merge(left, right) {\n  let result = []\n  while(left.length > 0 && right.length > 0) {\n    if(left[0] < right[0]) {\n      result.push(left.shift())\n    }else {\n      result.push(right.shift())\n    }\n  }\n\n  return result.concat(left, right)\n}\n\nfunction mergeSort(array) {\n  if(array.length < 2) return array\n\n  let middle = (array.length / 2)\n  let left = array.slice(0, middle)\n  let right = array.slice(middle)\n\n  return merge(mergeSort(left), mergeSort(right))\n}\n````\n* 迭代法\n````javascript\nfunction mergeSort(arr){\n  if(arr.length<2){\n    return;\n  }\n  //设置子序列的大小\n  var step=1; \n  var left,right;\n\n  while(step<arr.length){\n    left=0;\n    right=step;\n    while(right+step<=arr.length){\n      mergeArrays(arr,left,left+step,right,right+step);\n      left=right+step;\n      right=left+step;\n    }\n    if(right<arr.length){\n      mergeArrays(arr,left,left+step,right,arr.length);\n    }\n    step*=2;\n  }\n\n}\n//对左右序列进行排序\nfunction mergeArrays(arr,startLeft,stopLeft,startRight,stopRight){\n  // 建立一个左、右数组\n  var rightArr=new Array(stopRight-startRight+1);\n  var leftArr=new Array(stopLeft-startLeft+1);\n\n  // 给右数组赋值\n  k=startRight;\n  for(var i=0;i<(rightArr.length-1);++i){\n    rightArr[i]=arr[k];\n    ++k;\n  }\n   // 给左数组赋值\n  k=startLeft;\n  for(var i=0;i<(leftArr.length-1);++i){\n    leftArr[i]=arr[k];\n    ++k;\n  }\n  //设置哨兵值，当左子列或右子列读取到最后一位时，即Infinity，可以让另一个剩下的列中的值直接插入到数组中\n  rightArr[rightArr.length-1]=Infinity;\n  leftArr[leftArr.length-1]=Infinity;\n\n  var m=0;\n  var n=0;\n  // 比较左子列和右子列第一个值的大小，小的先填入数组，接着再进行比较\n  for(var k=startLeft;k<stopRight;++k){\n    if(leftArr[m]<=rightArr[n]){\n      arr[k]=leftArr[m];\n      m++; \n    }\n    else{\n      arr[k]=rightArr[n];\n      n++;\n    }\n  }\n  \n}\n````\n## 快速排序\n\n快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 n 个项目要 O(nlog n)（大O符号）次比较。在最坏状况下则需要 O(n^{2}) 次比较，但这种状况并不常见。事实上，快速排序 (n\\log n) 通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。\n\n### 算法步骤\n\n1. 从数列中挑出一个元素，称为“基准”（pivot），\n2. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。\n3. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n4. 递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。\n### 动图演示\n\n![quickSort.gif](https://i.loli.net/2019/02/26/5c75078e54e94.gif)\n\n### 实现\n````javascript\nfunction quickSort(array) {\n  let l = array.length\n  if(l < 2) return array\n\n  let basic = array[0]\n  let left = []\n  let right = []\n\n  for(let i = 1; i < l; i++) {\n    if(array[i] < basic) {\n      left.push(array[i])\n    }else {\n      right.push(array[i])\n    }\n  }\n\n  return quickSort(left).concat(basic, quickSort.concat(right))\n}\n````\n\n## 复杂度\n\n|算法|时间复杂度最好情况|时间复杂度平均情况|时间复杂度最坏情况|空间复杂度|稳定性|\n|---|---|---|---|---|---|\n|冒泡排序|O(n)|O(n^2)|O(n^2)|总共 O(n)，需要辅助空间 O(1)|是|\n|插入排序|O(n)|O(n^2)|O(n^2)|总共 O(n)，需要辅助空间 O(1)|是|\n|选择排序|O(n^2)|O(n^2)|O(n^2)|总共 O(n)，需要辅助空间 O(1)|否|\n|并归排序|O(nlogn)|O(nlogn)|O(nlogn)|总共 O(n)，需要辅助空间 O(1)|是|\n|快速排序|O(nlogn)|O(nlogn)|O(n^2)|O(n) 或者 O(nlogn)|是|\n\n## 参考资料\n\n* [排序算法](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)","slug":"常见排序算法的JavaScript实现","published":1,"updated":"2022-04-13T14:14:08.075Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfg80043g3t8jee6zkxu","content":"<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<br><a id=\"more\"></a></p>\n<h3 id=\"算法步骤\"><a href=\"#算法步骤\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h3><ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个。</li>\n<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>\n</ol>\n<h3 id=\"动图演示\"><a href=\"#动图演示\" class=\"headerlink\" title=\"动图演示\"></a>动图演示</h3><p><img src=\"https://i.loli.net/2019/02/26/5c75078e5682c.gif\" alt=\"bubbleSotrt.gif\"></p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubble</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = array.length - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(array[j] &gt; array[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        swap(array[j], array[j+<span class=\"number\">1</span>])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;<span class=\"comment\">//(n-1)*(n-2)</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 {\\displaystyle O(1)} {\\displaystyle O(1)}的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>\n<h3 id=\"算法步骤-1\"><a href=\"#算法步骤-1\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h3><ol>\n<li>从第一个元素开始，该元素可以认为已经被排序</li>\n<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>\n<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>\n<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>\n<li>将新元素插入到该位置后</li>\n<li>重复步骤2~5</li>\n</ol>\n<h3 id=\"动图演示-1\"><a href=\"#动图演示-1\" class=\"headerlink\" title=\"动图演示\"></a>动图演示</h3><p><img src=\"https://i.loli.net/2019/02/26/5c75078f47282.gif\" alt=\"insertSort.gif\"></p>\n<h3 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertion</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = i - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(array[j] &gt; array[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        swap(array[j], array[j+<span class=\"number\">1</span>])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>\n<h3 id=\"算法步骤-2\"><a href=\"#算法步骤-2\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h3><ol>\n<li>对比数组中前一个元素跟后一个元素的大小，如果后面的元素比前面的元素小则用一个变量k来记住他的位置。</li>\n<li>接着第二次比较，前面“后一个元素”现变成了“前一个元素”，继续跟他的“后一个元素”进行比较如果后面的元素比他要小则用变量k记住它在数组中的位置(下标)，等到循环结束的时候，我们应该找到了最小的那个数的下标了。</li>\n<li>然后进行判断，如果这个元素的下标不是第一个元素的下标，就让第一个元素跟他交换一下值，这样就找到整个数组中最小的数了。</li>\n<li>然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推。<h3 id=\"动图演示-2\"><a href=\"#动图演示-2\" class=\"headerlink\" title=\"动图演示\"></a>动图演示</h3></li>\n</ol>\n<p><img src=\"https://i.loli.net/2019/02/26/5c75078f6ad90.gif\" alt=\"selectSort.gif\"></p>\n<h3 id=\"实现-2\"><a href=\"#实现-2\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selection</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> minIndex = i</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; array.length; j++) &#123;</span><br><span class=\"line\">      minIndex = array[j] &lt; array[minIndex] ? j : minIndex</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    swap(array[minIndex], array[i])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"并归排序\"><a href=\"#并归排序\" class=\"headerlink\" title=\"并归排序\"></a>并归排序</h2><p>归并排序（英语：Merge sort，或mergesort），是创建在归并操作上的一种有效的排序算法，效率为 O(nlog n)（大O符号）。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>\n<h3 id=\"算法步骤-3\"><a href=\"#算法步骤-3\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h3><ul>\n<li>递归法（Top-down）</li>\n</ul>\n<ol>\n<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。</li>\n<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置。</li>\n<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。</li>\n<li>重复步骤3直到某一指针到达序列尾。</li>\n<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>\n</ol>\n<ul>\n<li>迭代法（Bottom-up）<br>原理如下（假设序列共有 n 个元素）：</li>\n</ul>\n<ol>\n<li>将序列每相邻两个数字进行归并操作，形成 ceil(n/2) 个序列，排序后每个序列包含两/一个元素。</li>\n<li>若此时序列数不是1个则将上述序列再次归并，形成 ceil(n/4) 个序列，每个序列包含四/三个元素。</li>\n<li>重复步骤2，直到所有元素排序完毕，即序列数为1。</li>\n</ol>\n<h3 id=\"动图演示-3\"><a href=\"#动图演示-3\" class=\"headerlink\" title=\"动图演示\"></a>动图演示</h3><p><img src=\"https://i.loli.net/2019/02/26/5c75078f45650.gif\" alt=\"mergeSort.gif\"></p>\n<h3 id=\"实现-3\"><a href=\"#实现-3\" class=\"headerlink\" title=\"实现\"></a>实现</h3><ul>\n<li><p>递归法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">left, right</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = []</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(left.length &gt; <span class=\"number\">0</span> &amp;&amp; right.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(left[<span class=\"number\">0</span>] &lt; right[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">      result.push(left.shift())</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      result.push(right.shift())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result.concat(left, right)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(array.length &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> array</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> middle = (array.length / <span class=\"number\">2</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = array.slice(<span class=\"number\">0</span>, middle)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> right = array.slice(middle)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>迭代法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeSort</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(arr.length&lt;<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//设置子序列的大小</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> step=<span class=\"number\">1</span>; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> left,right;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(step&lt;arr.length)&#123;</span><br><span class=\"line\">    left=<span class=\"number\">0</span>;</span><br><span class=\"line\">    right=step;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(right+step&lt;=arr.length)&#123;</span><br><span class=\"line\">      mergeArrays(arr,left,left+step,right,right+step);</span><br><span class=\"line\">      left=right+step;</span><br><span class=\"line\">      right=left+step;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(right&lt;arr.length)&#123;</span><br><span class=\"line\">      mergeArrays(arr,left,left+step,right,arr.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    step*=<span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//对左右序列进行排序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeArrays</span>(<span class=\"params\">arr,startLeft,stopLeft,startRight,stopRight</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 建立一个左、右数组</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> rightArr=<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(stopRight-startRight+<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> leftArr=<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(stopLeft-startLeft+<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 给右数组赋值</span></span><br><span class=\"line\">  k=startRight;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;(rightArr.length<span class=\"number\">-1</span>);++i)&#123;</span><br><span class=\"line\">    rightArr[i]=arr[k];</span><br><span class=\"line\">    ++k;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 给左数组赋值</span></span><br><span class=\"line\">  k=startLeft;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;(leftArr.length<span class=\"number\">-1</span>);++i)&#123;</span><br><span class=\"line\">    leftArr[i]=arr[k];</span><br><span class=\"line\">    ++k;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//设置哨兵值，当左子列或右子列读取到最后一位时，即Infinity，可以让另一个剩下的列中的值直接插入到数组中</span></span><br><span class=\"line\">  rightArr[rightArr.length<span class=\"number\">-1</span>]=<span class=\"literal\">Infinity</span>;</span><br><span class=\"line\">  leftArr[leftArr.length<span class=\"number\">-1</span>]=<span class=\"literal\">Infinity</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> m=<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n=<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 比较左子列和右子列第一个值的大小，小的先填入数组，接着再进行比较</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> k=startLeft;k&lt;stopRight;++k)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(leftArr[m]&lt;=rightArr[n])&#123;</span><br><span class=\"line\">      arr[k]=leftArr[m];</span><br><span class=\"line\">      m++; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      arr[k]=rightArr[n];</span><br><span class=\"line\">      n++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 n 个项目要 O(nlog n)（大O符号）次比较。在最坏状况下则需要 O(n^{2}) 次比较，但这种状况并不常见。事实上，快速排序 (n\\log n) 通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。</p>\n<h3 id=\"算法步骤-4\"><a href=\"#算法步骤-4\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h3><ol>\n<li>从数列中挑出一个元素，称为“基准”（pivot），</li>\n<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。</li>\n<li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>\n<li>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。<h3 id=\"动图演示-4\"><a href=\"#动图演示-4\" class=\"headerlink\" title=\"动图演示\"></a>动图演示</h3></li>\n</ol>\n<p><img src=\"https://i.loli.net/2019/02/26/5c75078e54e94.gif\" alt=\"quickSort.gif\"></p>\n<h3 id=\"实现-4\"><a href=\"#实现-4\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = array.length</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(l &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> array</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> basic = array[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = []</span><br><span class=\"line\">  <span class=\"keyword\">let</span> right = []</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; l; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(array[i] &lt; basic) &#123;</span><br><span class=\"line\">      left.push(array[i])</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      right.push(array[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> quickSort(left).concat(basic, quickSort.concat(right))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h2><table>\n<thead>\n<tr>\n<th>算法</th>\n<th>时间复杂度最好情况</th>\n<th>时间复杂度平均情况</th>\n<th>时间复杂度最坏情况</th>\n<th>空间复杂度</th>\n<th>稳定性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>冒泡排序</td>\n<td>O(n)</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>总共 O(n)，需要辅助空间 O(1)</td>\n<td>是</td>\n</tr>\n<tr>\n<td>插入排序</td>\n<td>O(n)</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>总共 O(n)，需要辅助空间 O(1)</td>\n<td>是</td>\n</tr>\n<tr>\n<td>选择排序</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>总共 O(n)，需要辅助空间 O(1)</td>\n<td>否</td>\n</tr>\n<tr>\n<td>并归排序</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>总共 O(n)，需要辅助空间 O(1)</td>\n<td>是</td>\n</tr>\n<tr>\n<td>快速排序</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(n^2)</td>\n<td>O(n) 或者 O(nlogn)</td>\n<td>是</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\">排序算法</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<br>","more":"</p>\n<h3 id=\"算法步骤\"><a href=\"#算法步骤\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h3><ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个。</li>\n<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>\n</ol>\n<h3 id=\"动图演示\"><a href=\"#动图演示\" class=\"headerlink\" title=\"动图演示\"></a>动图演示</h3><p><img src=\"https://i.loli.net/2019/02/26/5c75078e5682c.gif\" alt=\"bubbleSotrt.gif\"></p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubble</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = array.length - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(array[j] &gt; array[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        swap(array[j], array[j+<span class=\"number\">1</span>])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;<span class=\"comment\">//(n-1)*(n-2)</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 {\\displaystyle O(1)} {\\displaystyle O(1)}的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>\n<h3 id=\"算法步骤-1\"><a href=\"#算法步骤-1\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h3><ol>\n<li>从第一个元素开始，该元素可以认为已经被排序</li>\n<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>\n<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>\n<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>\n<li>将新元素插入到该位置后</li>\n<li>重复步骤2~5</li>\n</ol>\n<h3 id=\"动图演示-1\"><a href=\"#动图演示-1\" class=\"headerlink\" title=\"动图演示\"></a>动图演示</h3><p><img src=\"https://i.loli.net/2019/02/26/5c75078f47282.gif\" alt=\"insertSort.gif\"></p>\n<h3 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertion</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = i - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(array[j] &gt; array[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        swap(array[j], array[j+<span class=\"number\">1</span>])</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>\n<h3 id=\"算法步骤-2\"><a href=\"#算法步骤-2\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h3><ol>\n<li>对比数组中前一个元素跟后一个元素的大小，如果后面的元素比前面的元素小则用一个变量k来记住他的位置。</li>\n<li>接着第二次比较，前面“后一个元素”现变成了“前一个元素”，继续跟他的“后一个元素”进行比较如果后面的元素比他要小则用变量k记住它在数组中的位置(下标)，等到循环结束的时候，我们应该找到了最小的那个数的下标了。</li>\n<li>然后进行判断，如果这个元素的下标不是第一个元素的下标，就让第一个元素跟他交换一下值，这样就找到整个数组中最小的数了。</li>\n<li>然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推。<h3 id=\"动图演示-2\"><a href=\"#动图演示-2\" class=\"headerlink\" title=\"动图演示\"></a>动图演示</h3></li>\n</ol>\n<p><img src=\"https://i.loli.net/2019/02/26/5c75078f6ad90.gif\" alt=\"selectSort.gif\"></p>\n<h3 id=\"实现-2\"><a href=\"#实现-2\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selection</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> minIndex = i</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; array.length; j++) &#123;</span><br><span class=\"line\">      minIndex = array[j] &lt; array[minIndex] ? j : minIndex</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    swap(array[minIndex], array[i])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"并归排序\"><a href=\"#并归排序\" class=\"headerlink\" title=\"并归排序\"></a>并归排序</h2><p>归并排序（英语：Merge sort，或mergesort），是创建在归并操作上的一种有效的排序算法，效率为 O(nlog n)（大O符号）。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>\n<h3 id=\"算法步骤-3\"><a href=\"#算法步骤-3\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h3><ul>\n<li>递归法（Top-down）</li>\n</ul>\n<ol>\n<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。</li>\n<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置。</li>\n<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。</li>\n<li>重复步骤3直到某一指针到达序列尾。</li>\n<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>\n</ol>\n<ul>\n<li>迭代法（Bottom-up）<br>原理如下（假设序列共有 n 个元素）：</li>\n</ul>\n<ol>\n<li>将序列每相邻两个数字进行归并操作，形成 ceil(n/2) 个序列，排序后每个序列包含两/一个元素。</li>\n<li>若此时序列数不是1个则将上述序列再次归并，形成 ceil(n/4) 个序列，每个序列包含四/三个元素。</li>\n<li>重复步骤2，直到所有元素排序完毕，即序列数为1。</li>\n</ol>\n<h3 id=\"动图演示-3\"><a href=\"#动图演示-3\" class=\"headerlink\" title=\"动图演示\"></a>动图演示</h3><p><img src=\"https://i.loli.net/2019/02/26/5c75078f45650.gif\" alt=\"mergeSort.gif\"></p>\n<h3 id=\"实现-3\"><a href=\"#实现-3\" class=\"headerlink\" title=\"实现\"></a>实现</h3><ul>\n<li><p>递归法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">left, right</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = []</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(left.length &gt; <span class=\"number\">0</span> &amp;&amp; right.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(left[<span class=\"number\">0</span>] &lt; right[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">      result.push(left.shift())</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      result.push(right.shift())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result.concat(left, right)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(array.length &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> array</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> middle = (array.length / <span class=\"number\">2</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = array.slice(<span class=\"number\">0</span>, middle)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> right = array.slice(middle)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>迭代法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeSort</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(arr.length&lt;<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//设置子序列的大小</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> step=<span class=\"number\">1</span>; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> left,right;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(step&lt;arr.length)&#123;</span><br><span class=\"line\">    left=<span class=\"number\">0</span>;</span><br><span class=\"line\">    right=step;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(right+step&lt;=arr.length)&#123;</span><br><span class=\"line\">      mergeArrays(arr,left,left+step,right,right+step);</span><br><span class=\"line\">      left=right+step;</span><br><span class=\"line\">      right=left+step;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(right&lt;arr.length)&#123;</span><br><span class=\"line\">      mergeArrays(arr,left,left+step,right,arr.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    step*=<span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//对左右序列进行排序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeArrays</span>(<span class=\"params\">arr,startLeft,stopLeft,startRight,stopRight</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 建立一个左、右数组</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> rightArr=<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(stopRight-startRight+<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> leftArr=<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(stopLeft-startLeft+<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 给右数组赋值</span></span><br><span class=\"line\">  k=startRight;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;(rightArr.length<span class=\"number\">-1</span>);++i)&#123;</span><br><span class=\"line\">    rightArr[i]=arr[k];</span><br><span class=\"line\">    ++k;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 给左数组赋值</span></span><br><span class=\"line\">  k=startLeft;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;(leftArr.length<span class=\"number\">-1</span>);++i)&#123;</span><br><span class=\"line\">    leftArr[i]=arr[k];</span><br><span class=\"line\">    ++k;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//设置哨兵值，当左子列或右子列读取到最后一位时，即Infinity，可以让另一个剩下的列中的值直接插入到数组中</span></span><br><span class=\"line\">  rightArr[rightArr.length<span class=\"number\">-1</span>]=<span class=\"literal\">Infinity</span>;</span><br><span class=\"line\">  leftArr[leftArr.length<span class=\"number\">-1</span>]=<span class=\"literal\">Infinity</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> m=<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n=<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 比较左子列和右子列第一个值的大小，小的先填入数组，接着再进行比较</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> k=startLeft;k&lt;stopRight;++k)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(leftArr[m]&lt;=rightArr[n])&#123;</span><br><span class=\"line\">      arr[k]=leftArr[m];</span><br><span class=\"line\">      m++; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      arr[k]=rightArr[n];</span><br><span class=\"line\">      n++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 n 个项目要 O(nlog n)（大O符号）次比较。在最坏状况下则需要 O(n^{2}) 次比较，但这种状况并不常见。事实上，快速排序 (n\\log n) 通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。</p>\n<h3 id=\"算法步骤-4\"><a href=\"#算法步骤-4\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h3><ol>\n<li>从数列中挑出一个元素，称为“基准”（pivot），</li>\n<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。</li>\n<li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>\n<li>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。<h3 id=\"动图演示-4\"><a href=\"#动图演示-4\" class=\"headerlink\" title=\"动图演示\"></a>动图演示</h3></li>\n</ol>\n<p><img src=\"https://i.loli.net/2019/02/26/5c75078e54e94.gif\" alt=\"quickSort.gif\"></p>\n<h3 id=\"实现-4\"><a href=\"#实现-4\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = array.length</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(l &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> array</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> basic = array[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = []</span><br><span class=\"line\">  <span class=\"keyword\">let</span> right = []</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; l; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(array[i] &lt; basic) &#123;</span><br><span class=\"line\">      left.push(array[i])</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      right.push(array[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> quickSort(left).concat(basic, quickSort.concat(right))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h2><table>\n<thead>\n<tr>\n<th>算法</th>\n<th>时间复杂度最好情况</th>\n<th>时间复杂度平均情况</th>\n<th>时间复杂度最坏情况</th>\n<th>空间复杂度</th>\n<th>稳定性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>冒泡排序</td>\n<td>O(n)</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>总共 O(n)，需要辅助空间 O(1)</td>\n<td>是</td>\n</tr>\n<tr>\n<td>插入排序</td>\n<td>O(n)</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>总共 O(n)，需要辅助空间 O(1)</td>\n<td>是</td>\n</tr>\n<tr>\n<td>选择排序</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>总共 O(n)，需要辅助空间 O(1)</td>\n<td>否</td>\n</tr>\n<tr>\n<td>并归排序</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>总共 O(n)，需要辅助空间 O(1)</td>\n<td>是</td>\n</tr>\n<tr>\n<td>快速排序</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(n^2)</td>\n<td>O(n) 或者 O(nlogn)</td>\n<td>是</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\">排序算法</a></li>\n</ul>"},{"title":"浏览器的Event Loop机制","date":"2018-07-20T16:00:00.000Z","_content":"## 单线程的JavaScript\n\n> JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？\n>\n> 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。\n<!--more-->\n## 任务队列 (Task Queue)\n\n>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。\n>\n>所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入\"任务队列\"（task queue）的任务，只有\"任务队列\"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。\n\n## Event Loop机制\n\n### 执行栈与事件队列\n\n当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。\n\n当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。\n````javascript\nfunction foo(b) {\n  var a = 10;\n  return a + b + 11;\n}\n\nfunction bar(x) {\n  var y = 3;\n  return foo(x * y);\n}\n\nconsole.log(bar(7)); // 返回 42\n````\n\n函数调用形成了一个栈帧。\n\n当调用 bar 时，创建了第一个帧 ，帧中包含了 bar 的参数和局部变量。当 bar 调用 foo 时，第二个帧就被创建，并被压到第一个帧之上，帧中包含了 foo 的参数和局部变量。当 foo 返回时，最上层的帧就被弹出栈（剩下 bar 函数的调用帧 ）。当 bar 返回的时候，栈就空了。\n\njs引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。\n### 同步任务和异步任务\n\nJavascript单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。\n\n### 事件循环\n\n不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。\n\n以下事件属于宏任务：\n* script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。\n以下事件属于微任务：\n* Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver。\n\n\n**事件循环的进程模型**\n\n* 选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即null，则执行跳转到微任务（MicroTask）的执行步骤。\n* 将事件循环中的任务设置为已选择任务。\n* 执行任务。\n* 将事件循环中当前运行任务设置为null。\n* 将已经运行完成的任务从任务队列中删除。\n* microtasks步骤：进入microtask检查点。\n* 更新界面渲染。\n* 返回第一步。\n\n执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空，就会去检查微任务(microTask)队列是否为空，如果为空的话，就执行Task（宏任务），否则就一次性执行完所有微任务。\n\n每次单个宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务(microTask)后，设置微任务(microTask)队列为null，然后再执行宏任务，如此循环。\n\n**总结：当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。**\n## 例子\n\n````javascript\nconsole.log('script start');\n\nsetTimeout(function() {\n  console.log('setTimeout');\n}, 0);\n\nPromise.resolve().then(function() {\n  console.log('promise1');\n}).then(function() {\n  console.log('promise2');\n});\nconsole.log('script end');\n````\n执行分析：\n1. 执行同步代码，将宏任务（Tasks）和微任务(Microtasks)划分到各自队列中。\n2. 执行宏任务后，检测到微任务(Microtasks)队列中不为空，执行Promise1，执行完成Promise1后，调用Promise2.then，放入微任务(Microtasks)队列中，再执行Promise2.then。\n3. 当微任务(Microtasks)队列中为空时，执行宏任务（Tasks），执行setTimeout callback，打印日志。\n4. 清空Tasks队列和JS stack。\n\n|事件顺序|宏任务|微任务|执行栈|输出\n|---|---|---|---|---|\n|第一次|run script、 setTimeout callback|Promise then|script|script start、script end|\n|第二次|run script、 setTimeout callback|Promise2 then|Promise2 callback|start、script end、promise1|\n|第三次|etTimeout callback|空|setTimeout callback|script start、script end、promise1、promise2|\n|第四次|etTimeout callback|空|空|script start、script end、promise1、promise2、setTimeout|\n\n执行帧动画：[Tasks, microtasks, queues and schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)\n\n### setTimeout\n\n函数 setTimeout 接受两个参数：待加入队列的消息和一个延迟（可选，默认为 0）。这个延迟代表了消息被实际加入到队列的最小延迟时间。如果队列中没有其它消息，在这段延迟时间过去之后，消息会被马上处理。但是，如果有其它消息，setTimeout 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少延迟时间，而非确切的等待时间。\n\n````javaScript\nconst s = new Date().getSeconds();\n\nsetTimeout(function() {\n  // 输出 \"2\"，表示回调函数并没有在 500 毫秒之后立即执行\n  console.log(\"Run after \" + (new Date().getSeconds() - s) + \" seconds\");\n}, 500);\n\nwhile(true) {\n  if(new Date().getSeconds() - s >= 2) {\n    console.log(\"Good, looped for 2 seconds\");\n    break;\n  }\n}\n//输出：Good, looped for 2 seconds\n//      Run after 2 seconds\n````\n\n> HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。\n\n再看看这段代码\n````javaScript\nsetTimeout(() => {\n\tconsole.log(2)\n}, 2)\n\nsetTimeout(() => {\n\tconsole.log(1)\n}, 1)\n\nsetTimeout(() => {\n\tconsole.log(0)\n}, 0)\n````\n\n按照上面的规范，低于4毫秒的自动变为4毫秒，因此三个setTimeout进入异步队列的顺序的依次从上到下的，即打印出 2 1 0 。\n\n然而在FireFox 64.0.2 (32 位) 环境下，setTimeout的时间是可以设置小于4毫秒的，因此输出是 0 1 2 。\n\n在Chrome 72.0.3626.121(正式版本)(32 位) 环境下，打印的是 1 0 2 。\n\n从测试结果可以看出，0ms和1ms的延时效果是一致的。原因是Blink内核对于传入时间有这样一行判断：\n\n````c++\n// https://chromium.googlesource.com/chromium/blink/+/master/Source/core/frame/DOMTimer.cpp#93\n\ndouble intervalMilliseconds = std::max(oneMillisecond, interval * oneMillisecond); \n````\n**可以看出传入0和传入1结果都是oneMillisecond，即1ms。**\n### setInterval\n\n对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。\n\n````javaScript\nconst s = new Date().getSeconds();\n\nsetInterval(function() {\n  let _s = new Date().getSeconds();\n  while(true) {\n    if(new Date().getSeconds() - _s >= 2) {\n      break;\n    }\n  }\n  console.log(\"Run after \" + (new Date().getSeconds() - s) + \" seconds\");\n}, 500);\n//每隔2秒打印一次，而不是500毫秒\n````\n\n### async/await\n\nasync/await 在底层转换成了 promise 和 then 回调函数。也就是说，这是 promise 的语法糖。\n\n每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。\n\n然而对于下面这段代码，不同的浏览器，执行结果是不一致的。\n````javaScript\nasync function async1() {\n  console.log(\"a\");\n  await async2();\n  console.log(\"b\");\n}\nasync function async2() {\n  console.log('c');\n}\nasync1();\nnew Promise(function (resolve) {\n  console.log(\"d\");\n  resolve();\n}).then(function () {\n  console.log(\"e\");\n});\n````\n而在 FireFox 64.0.2 (32 位) 环境下，输出 a c d e b 。\n\n在 Chrome 72.0.3626.121(正式版本)(32 位) 环境下，输出 a c d b e 。\n\n原因是由于ECMAScript规范的更新（ [ TC39 新决议](https://github.com/tc39/ecma262/pull/1250) ），决定await将直接使用Promise.resolve()相同语义，导致不同版本的浏览器对于async的实现是不一样的。\n\n在旧的规范中，await p 近似等于 return new Promise(resolve => resolve(p))。\n\n在新的规范中，await p 近似等于 return Promise.resolve(p)。\n\n如果传递给 await 的值已经是一个 Promise，则返回Promise.resolve(p)，那么这种优化避免了再次创建 Promise 包装器。\n\n> 如果 RESOLVE(p) 严格按照标准，应该是产生一个新的 promise，尽管该 promise 确定会 resolve 为 p，但这个过程本身是异步的，也就是现在进入 job 队列的是新 promise 的 resolve 过程，所以该 promise 的 then 不会被立即调用，而要等到当前 job 队列执行到前述 resolve 过程才会被调用，然后其回调（也就是继续 await 之后的语句）才加入 job 队列，所以时序上就晚了。\n\n对于以上代码，在不同规范下转化为Promise之后如下：\n\n**旧规范：**\n````javaScript\nasync function async1 () {\n  console.log('a')\n  new Promise(resolve => {\n    resolve(async2())\n  }).then(res => {\n    console.log('b')\n  })\n}\nasync function async2 () {\n  console.log('c')\n}\nasync1()\nnew Promise(function (resolve) {\n  console.log('d')\n  resolve()\n}).then(function () {\n  console.log('e')\n})\n````\n因为 async2() 返回 promise, 所以进一步转化就是：\n````javaScript\nasync function async1 () {\n  console.log('a')\n  new Promise(resolve => {\n    Promise.resolve().then(() => {\n      async2().then(resolve)\n    })\n  }).then(res => {\n    console.log('b')\n  })\n}\nasync function async2 () {\n  console.log('c')\n}\nasync1()\nnew Promise(function (resolve) {\n  console.log('d')\n  resolve()\n}).then(function () {\n  console.log('e')\n})\n````\n输出：a c d e b\n\n**新规范：**\n````javaScript\nasync function async1 () {\n  console.log('a')\n  Promise.resolve(async2()).then(res => {\n    console.log('b')\n  })\n}\nasync function async2 () {\n  console.log('c')\n}\nasync1()\nnew Promise(function (resolve) {\n  console.log('d')\n  resolve()\n}).then(function () {\n  console.log('e')\n})\n````\n输出：a c d b e\n\n## 参考资料\n* [并发模型与事件循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop)\n* [JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)\n* [Tasks, microtasks, queues and schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)\n* [一次弄懂Event Loop](https://juejin.im/post/5c3d8956e51d4511dc72c200)\n* [async/await 在chrome 环境和 node 环境的 执行结果不一致，求解？](https://www.zhihu.com/question/268007969)\n* [这一次，彻底弄懂 JavaScript 执行机制](https://juejin.im/post/59e85eebf265da430d571f89)\n* [Event Loop的规范和实现](https://zhuanlan.zhihu.com/p/33087629)\n* [window.setTimeout](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout)","source":"_posts/浏览器的Event Loop机制.md","raw":"---\ntitle: 浏览器的Event Loop机制\ndate: 2018-07-21\ntags: ['浏览器', 'eventloop']\ncategories: ['浏览器']\n---\n## 单线程的JavaScript\n\n> JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？\n>\n> 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。\n<!--more-->\n## 任务队列 (Task Queue)\n\n>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。\n>\n>所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入\"任务队列\"（task queue）的任务，只有\"任务队列\"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。\n\n## Event Loop机制\n\n### 执行栈与事件队列\n\n当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。\n\n当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。\n````javascript\nfunction foo(b) {\n  var a = 10;\n  return a + b + 11;\n}\n\nfunction bar(x) {\n  var y = 3;\n  return foo(x * y);\n}\n\nconsole.log(bar(7)); // 返回 42\n````\n\n函数调用形成了一个栈帧。\n\n当调用 bar 时，创建了第一个帧 ，帧中包含了 bar 的参数和局部变量。当 bar 调用 foo 时，第二个帧就被创建，并被压到第一个帧之上，帧中包含了 foo 的参数和局部变量。当 foo 返回时，最上层的帧就被弹出栈（剩下 bar 函数的调用帧 ）。当 bar 返回的时候，栈就空了。\n\njs引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。\n### 同步任务和异步任务\n\nJavascript单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。\n\n### 事件循环\n\n不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。\n\n以下事件属于宏任务：\n* script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。\n以下事件属于微任务：\n* Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver。\n\n\n**事件循环的进程模型**\n\n* 选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即null，则执行跳转到微任务（MicroTask）的执行步骤。\n* 将事件循环中的任务设置为已选择任务。\n* 执行任务。\n* 将事件循环中当前运行任务设置为null。\n* 将已经运行完成的任务从任务队列中删除。\n* microtasks步骤：进入microtask检查点。\n* 更新界面渲染。\n* 返回第一步。\n\n执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空，就会去检查微任务(microTask)队列是否为空，如果为空的话，就执行Task（宏任务），否则就一次性执行完所有微任务。\n\n每次单个宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务(microTask)后，设置微任务(microTask)队列为null，然后再执行宏任务，如此循环。\n\n**总结：当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。**\n## 例子\n\n````javascript\nconsole.log('script start');\n\nsetTimeout(function() {\n  console.log('setTimeout');\n}, 0);\n\nPromise.resolve().then(function() {\n  console.log('promise1');\n}).then(function() {\n  console.log('promise2');\n});\nconsole.log('script end');\n````\n执行分析：\n1. 执行同步代码，将宏任务（Tasks）和微任务(Microtasks)划分到各自队列中。\n2. 执行宏任务后，检测到微任务(Microtasks)队列中不为空，执行Promise1，执行完成Promise1后，调用Promise2.then，放入微任务(Microtasks)队列中，再执行Promise2.then。\n3. 当微任务(Microtasks)队列中为空时，执行宏任务（Tasks），执行setTimeout callback，打印日志。\n4. 清空Tasks队列和JS stack。\n\n|事件顺序|宏任务|微任务|执行栈|输出\n|---|---|---|---|---|\n|第一次|run script、 setTimeout callback|Promise then|script|script start、script end|\n|第二次|run script、 setTimeout callback|Promise2 then|Promise2 callback|start、script end、promise1|\n|第三次|etTimeout callback|空|setTimeout callback|script start、script end、promise1、promise2|\n|第四次|etTimeout callback|空|空|script start、script end、promise1、promise2、setTimeout|\n\n执行帧动画：[Tasks, microtasks, queues and schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)\n\n### setTimeout\n\n函数 setTimeout 接受两个参数：待加入队列的消息和一个延迟（可选，默认为 0）。这个延迟代表了消息被实际加入到队列的最小延迟时间。如果队列中没有其它消息，在这段延迟时间过去之后，消息会被马上处理。但是，如果有其它消息，setTimeout 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少延迟时间，而非确切的等待时间。\n\n````javaScript\nconst s = new Date().getSeconds();\n\nsetTimeout(function() {\n  // 输出 \"2\"，表示回调函数并没有在 500 毫秒之后立即执行\n  console.log(\"Run after \" + (new Date().getSeconds() - s) + \" seconds\");\n}, 500);\n\nwhile(true) {\n  if(new Date().getSeconds() - s >= 2) {\n    console.log(\"Good, looped for 2 seconds\");\n    break;\n  }\n}\n//输出：Good, looped for 2 seconds\n//      Run after 2 seconds\n````\n\n> HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。\n\n再看看这段代码\n````javaScript\nsetTimeout(() => {\n\tconsole.log(2)\n}, 2)\n\nsetTimeout(() => {\n\tconsole.log(1)\n}, 1)\n\nsetTimeout(() => {\n\tconsole.log(0)\n}, 0)\n````\n\n按照上面的规范，低于4毫秒的自动变为4毫秒，因此三个setTimeout进入异步队列的顺序的依次从上到下的，即打印出 2 1 0 。\n\n然而在FireFox 64.0.2 (32 位) 环境下，setTimeout的时间是可以设置小于4毫秒的，因此输出是 0 1 2 。\n\n在Chrome 72.0.3626.121(正式版本)(32 位) 环境下，打印的是 1 0 2 。\n\n从测试结果可以看出，0ms和1ms的延时效果是一致的。原因是Blink内核对于传入时间有这样一行判断：\n\n````c++\n// https://chromium.googlesource.com/chromium/blink/+/master/Source/core/frame/DOMTimer.cpp#93\n\ndouble intervalMilliseconds = std::max(oneMillisecond, interval * oneMillisecond); \n````\n**可以看出传入0和传入1结果都是oneMillisecond，即1ms。**\n### setInterval\n\n对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。\n\n````javaScript\nconst s = new Date().getSeconds();\n\nsetInterval(function() {\n  let _s = new Date().getSeconds();\n  while(true) {\n    if(new Date().getSeconds() - _s >= 2) {\n      break;\n    }\n  }\n  console.log(\"Run after \" + (new Date().getSeconds() - s) + \" seconds\");\n}, 500);\n//每隔2秒打印一次，而不是500毫秒\n````\n\n### async/await\n\nasync/await 在底层转换成了 promise 和 then 回调函数。也就是说，这是 promise 的语法糖。\n\n每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。\n\n然而对于下面这段代码，不同的浏览器，执行结果是不一致的。\n````javaScript\nasync function async1() {\n  console.log(\"a\");\n  await async2();\n  console.log(\"b\");\n}\nasync function async2() {\n  console.log('c');\n}\nasync1();\nnew Promise(function (resolve) {\n  console.log(\"d\");\n  resolve();\n}).then(function () {\n  console.log(\"e\");\n});\n````\n而在 FireFox 64.0.2 (32 位) 环境下，输出 a c d e b 。\n\n在 Chrome 72.0.3626.121(正式版本)(32 位) 环境下，输出 a c d b e 。\n\n原因是由于ECMAScript规范的更新（ [ TC39 新决议](https://github.com/tc39/ecma262/pull/1250) ），决定await将直接使用Promise.resolve()相同语义，导致不同版本的浏览器对于async的实现是不一样的。\n\n在旧的规范中，await p 近似等于 return new Promise(resolve => resolve(p))。\n\n在新的规范中，await p 近似等于 return Promise.resolve(p)。\n\n如果传递给 await 的值已经是一个 Promise，则返回Promise.resolve(p)，那么这种优化避免了再次创建 Promise 包装器。\n\n> 如果 RESOLVE(p) 严格按照标准，应该是产生一个新的 promise，尽管该 promise 确定会 resolve 为 p，但这个过程本身是异步的，也就是现在进入 job 队列的是新 promise 的 resolve 过程，所以该 promise 的 then 不会被立即调用，而要等到当前 job 队列执行到前述 resolve 过程才会被调用，然后其回调（也就是继续 await 之后的语句）才加入 job 队列，所以时序上就晚了。\n\n对于以上代码，在不同规范下转化为Promise之后如下：\n\n**旧规范：**\n````javaScript\nasync function async1 () {\n  console.log('a')\n  new Promise(resolve => {\n    resolve(async2())\n  }).then(res => {\n    console.log('b')\n  })\n}\nasync function async2 () {\n  console.log('c')\n}\nasync1()\nnew Promise(function (resolve) {\n  console.log('d')\n  resolve()\n}).then(function () {\n  console.log('e')\n})\n````\n因为 async2() 返回 promise, 所以进一步转化就是：\n````javaScript\nasync function async1 () {\n  console.log('a')\n  new Promise(resolve => {\n    Promise.resolve().then(() => {\n      async2().then(resolve)\n    })\n  }).then(res => {\n    console.log('b')\n  })\n}\nasync function async2 () {\n  console.log('c')\n}\nasync1()\nnew Promise(function (resolve) {\n  console.log('d')\n  resolve()\n}).then(function () {\n  console.log('e')\n})\n````\n输出：a c d e b\n\n**新规范：**\n````javaScript\nasync function async1 () {\n  console.log('a')\n  Promise.resolve(async2()).then(res => {\n    console.log('b')\n  })\n}\nasync function async2 () {\n  console.log('c')\n}\nasync1()\nnew Promise(function (resolve) {\n  console.log('d')\n  resolve()\n}).then(function () {\n  console.log('e')\n})\n````\n输出：a c d b e\n\n## 参考资料\n* [并发模型与事件循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop)\n* [JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)\n* [Tasks, microtasks, queues and schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)\n* [一次弄懂Event Loop](https://juejin.im/post/5c3d8956e51d4511dc72c200)\n* [async/await 在chrome 环境和 node 环境的 执行结果不一致，求解？](https://www.zhihu.com/question/268007969)\n* [这一次，彻底弄懂 JavaScript 执行机制](https://juejin.im/post/59e85eebf265da430d571f89)\n* [Event Loop的规范和实现](https://zhuanlan.zhihu.com/p/33087629)\n* [window.setTimeout](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout)","slug":"浏览器的Event Loop机制","published":1,"updated":"2022-04-13T14:14:08.092Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfg90047g3t8gabai8c4","content":"<h2 id=\"单线程的JavaScript\"><a href=\"#单线程的JavaScript\" class=\"headerlink\" title=\"单线程的JavaScript\"></a>单线程的JavaScript</h2><blockquote>\n<p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>\n<p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。<br><a id=\"more\"></a></p>\n</blockquote>\n<h2 id=\"任务队列-Task-Queue\"><a href=\"#任务队列-Task-Queue\" class=\"headerlink\" title=\"任务队列 (Task Queue)\"></a>任务队列 (Task Queue)</h2><blockquote>\n<p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</p>\n<p>所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>\n</blockquote>\n<h2 id=\"Event-Loop机制\"><a href=\"#Event-Loop机制\" class=\"headerlink\" title=\"Event Loop机制\"></a>Event Loop机制</h2><h3 id=\"执行栈与事件队列\"><a href=\"#执行栈与事件队列\" class=\"headerlink\" title=\"执行栈与事件队列\"></a>执行栈与事件队列</h3><p>当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。</p>\n<p>当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b + <span class=\"number\">11</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> y = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> foo(x * y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar(<span class=\"number\">7</span>)); <span class=\"comment\">// 返回 42</span></span><br></pre></td></tr></table></figure></p>\n<p>函数调用形成了一个栈帧。</p>\n<p>当调用 bar 时，创建了第一个帧 ，帧中包含了 bar 的参数和局部变量。当 bar 调用 foo 时，第二个帧就被创建，并被压到第一个帧之上，帧中包含了 foo 的参数和局部变量。当 foo 返回时，最上层的帧就被弹出栈（剩下 bar 函数的调用帧 ）。当 bar 返回的时候，栈就空了。</p>\n<p>js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。</p>\n<h3 id=\"同步任务和异步任务\"><a href=\"#同步任务和异步任务\" class=\"headerlink\" title=\"同步任务和异步任务\"></a>同步任务和异步任务</h3><p>Javascript单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。</p>\n<h3 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h3><p>不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。</p>\n<p>以下事件属于宏任务：</p>\n<ul>\n<li>script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。<br>以下事件属于微任务：</li>\n<li>Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver。</li>\n</ul>\n<p><strong>事件循环的进程模型</strong></p>\n<ul>\n<li>选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即null，则执行跳转到微任务（MicroTask）的执行步骤。</li>\n<li>将事件循环中的任务设置为已选择任务。</li>\n<li>执行任务。</li>\n<li>将事件循环中当前运行任务设置为null。</li>\n<li>将已经运行完成的任务从任务队列中删除。</li>\n<li>microtasks步骤：进入microtask检查点。</li>\n<li>更新界面渲染。</li>\n<li>返回第一步。</li>\n</ul>\n<p>执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空，就会去检查微任务(microTask)队列是否为空，如果为空的话，就执行Task（宏任务），否则就一次性执行完所有微任务。</p>\n<p>每次单个宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务(microTask)后，设置微任务(microTask)队列为null，然后再执行宏任务，如此循环。</p>\n<p><strong>总结：当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。</strong></p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script start'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'setTimeout'</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise1'</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise2'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script end'</span>);</span><br></pre></td></tr></table></figure>\n<p>执行分析：</p>\n<ol>\n<li>执行同步代码，将宏任务（Tasks）和微任务(Microtasks)划分到各自队列中。</li>\n<li>执行宏任务后，检测到微任务(Microtasks)队列中不为空，执行Promise1，执行完成Promise1后，调用Promise2.then，放入微任务(Microtasks)队列中，再执行Promise2.then。</li>\n<li>当微任务(Microtasks)队列中为空时，执行宏任务（Tasks），执行setTimeout callback，打印日志。</li>\n<li>清空Tasks队列和JS stack。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>事件顺序</th>\n<th>宏任务</th>\n<th>微任务</th>\n<th>执行栈</th>\n<th>输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>第一次</td>\n<td>run script、 setTimeout callback</td>\n<td>Promise then</td>\n<td>script</td>\n<td>script start、script end</td>\n</tr>\n<tr>\n<td>第二次</td>\n<td>run script、 setTimeout callback</td>\n<td>Promise2 then</td>\n<td>Promise2 callback</td>\n<td>start、script end、promise1</td>\n</tr>\n<tr>\n<td>第三次</td>\n<td>etTimeout callback</td>\n<td>空</td>\n<td>setTimeout callback</td>\n<td>script start、script end、promise1、promise2</td>\n</tr>\n<tr>\n<td>第四次</td>\n<td>etTimeout callback</td>\n<td>空</td>\n<td>空</td>\n<td>script start、script end、promise1、promise2、setTimeout</td>\n</tr>\n</tbody>\n</table>\n<p>执行帧动画：<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\" target=\"_blank\" rel=\"noopener\">Tasks, microtasks, queues and schedules</a></p>\n<h3 id=\"setTimeout\"><a href=\"#setTimeout\" class=\"headerlink\" title=\"setTimeout\"></a>setTimeout</h3><p>函数 setTimeout 接受两个参数：待加入队列的消息和一个延迟（可选，默认为 0）。这个延迟代表了消息被实际加入到队列的最小延迟时间。如果队列中没有其它消息，在这段延迟时间过去之后，消息会被马上处理。但是，如果有其它消息，setTimeout 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少延迟时间，而非确切的等待时间。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getSeconds();</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 输出 \"2\"，表示回调函数并没有在 500 毫秒之后立即执行</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Run after \"</span> + (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getSeconds() - s) + <span class=\"string\">\" seconds\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getSeconds() - s &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Good, looped for 2 seconds\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//输出：Good, looped for 2 seconds</span></span><br><span class=\"line\"><span class=\"comment\">//      Run after 2 seconds</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。</p>\n</blockquote>\n<p>再看看这段代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure></p>\n<p>按照上面的规范，低于4毫秒的自动变为4毫秒，因此三个setTimeout进入异步队列的顺序的依次从上到下的，即打印出 2 1 0 。</p>\n<p>然而在FireFox 64.0.2 (32 位) 环境下，setTimeout的时间是可以设置小于4毫秒的，因此输出是 0 1 2 。</p>\n<p>在Chrome 72.0.3626.121(正式版本)(32 位) 环境下，打印的是 1 0 2 。</p>\n<p>从测试结果可以看出，0ms和1ms的延时效果是一致的。原因是Blink内核对于传入时间有这样一行判断：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// https://chromium.googlesource.com/chromium/blink/+/master/Source/core/frame/DOMTimer.cpp#93</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> intervalMilliseconds = <span class=\"built_in\">std</span>::max(oneMillisecond, interval * oneMillisecond);</span><br></pre></td></tr></table></figure>\n<p><strong>可以看出传入0和传入1结果都是oneMillisecond，即1ms。</strong></p>\n<h3 id=\"setInterval\"><a href=\"#setInterval\" class=\"headerlink\" title=\"setInterval\"></a>setInterval</h3><p>对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getSeconds();</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> _s = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getSeconds();</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getSeconds() - _s &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Run after \"</span> + (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getSeconds() - s) + <span class=\"string\">\" seconds\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\"><span class=\"comment\">//每隔2秒打印一次，而不是500毫秒</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async/await\"></a>async/await</h3><p>async/await 在底层转换成了 promise 和 then 回调函数。也就是说，这是 promise 的语法糖。</p>\n<p>每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。</p>\n<p>然而对于下面这段代码，不同的浏览器，执行结果是不一致的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"a\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> async2();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"b\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'c'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async1();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"d\"</span>);</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"e\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>而在 FireFox 64.0.2 (32 位) 环境下，输出 a c d e b 。</p>\n<p>在 Chrome 72.0.3626.121(正式版本)(32 位) 环境下，输出 a c d b e 。</p>\n<p>原因是由于ECMAScript规范的更新（ <a href=\"https://github.com/tc39/ecma262/pull/1250\" target=\"_blank\" rel=\"noopener\"> TC39 新决议</a> ），决定await将直接使用Promise.resolve()相同语义，导致不同版本的浏览器对于async的实现是不一样的。</p>\n<p>在旧的规范中，await p 近似等于 return new Promise(resolve =&gt; resolve(p))。</p>\n<p>在新的规范中，await p 近似等于 return Promise.resolve(p)。</p>\n<p>如果传递给 await 的值已经是一个 Promise，则返回Promise.resolve(p)，那么这种优化避免了再次创建 Promise 包装器。</p>\n<blockquote>\n<p>如果 RESOLVE(p) 严格按照标准，应该是产生一个新的 promise，尽管该 promise 确定会 resolve 为 p，但这个过程本身是异步的，也就是现在进入 job 队列的是新 promise 的 resolve 过程，所以该 promise 的 then 不会被立即调用，而要等到当前 job 队列执行到前述 resolve 过程才会被调用，然后其回调（也就是继续 await 之后的语句）才加入 job 队列，所以时序上就晚了。</p>\n</blockquote>\n<p>对于以上代码，在不同规范下转化为Promise之后如下：</p>\n<p><strong>旧规范：</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(async2())</span><br><span class=\"line\">  &#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async2</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'c'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async1()</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'d'</span>)</span><br><span class=\"line\">  resolve()</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'e'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>因为 async2() 返回 promise, 所以进一步转化就是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      async2().then(resolve)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async2</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'c'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async1()</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'d'</span>)</span><br><span class=\"line\">  resolve()</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'e'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>输出：a c d e b</p>\n<p><strong>新规范：</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve(async2()).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async2</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'c'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async1()</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'d'</span>)</span><br><span class=\"line\">  resolve()</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'e'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>输出：a c d b e</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop\" target=\"_blank\" rel=\"noopener\">并发模型与事件循环</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"noopener\">JavaScript 运行机制详解：再谈Event Loop</a></li>\n<li><a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\" target=\"_blank\" rel=\"noopener\">Tasks, microtasks, queues and schedules</a></li>\n<li><a href=\"https://juejin.im/post/5c3d8956e51d4511dc72c200\" target=\"_blank\" rel=\"noopener\">一次弄懂Event Loop</a></li>\n<li><a href=\"https://www.zhihu.com/question/268007969\" target=\"_blank\" rel=\"noopener\">async/await 在chrome 环境和 node 环境的 执行结果不一致，求解？</a></li>\n<li><a href=\"https://juejin.im/post/59e85eebf265da430d571f89\" target=\"_blank\" rel=\"noopener\">这一次，彻底弄懂 JavaScript 执行机制</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/33087629\" target=\"_blank\" rel=\"noopener\">Event Loop的规范和实现</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout\" target=\"_blank\" rel=\"noopener\">window.setTimeout</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"单线程的JavaScript\"><a href=\"#单线程的JavaScript\" class=\"headerlink\" title=\"单线程的JavaScript\"></a>单线程的JavaScript</h2><blockquote>\n<p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>\n<p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。<br>","more":"</p>\n</blockquote>\n<h2 id=\"任务队列-Task-Queue\"><a href=\"#任务队列-Task-Queue\" class=\"headerlink\" title=\"任务队列 (Task Queue)\"></a>任务队列 (Task Queue)</h2><blockquote>\n<p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</p>\n<p>所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>\n</blockquote>\n<h2 id=\"Event-Loop机制\"><a href=\"#Event-Loop机制\" class=\"headerlink\" title=\"Event Loop机制\"></a>Event Loop机制</h2><h3 id=\"执行栈与事件队列\"><a href=\"#执行栈与事件队列\" class=\"headerlink\" title=\"执行栈与事件队列\"></a>执行栈与事件队列</h3><p>当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。</p>\n<p>当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b + <span class=\"number\">11</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> y = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> foo(x * y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar(<span class=\"number\">7</span>)); <span class=\"comment\">// 返回 42</span></span><br></pre></td></tr></table></figure></p>\n<p>函数调用形成了一个栈帧。</p>\n<p>当调用 bar 时，创建了第一个帧 ，帧中包含了 bar 的参数和局部变量。当 bar 调用 foo 时，第二个帧就被创建，并被压到第一个帧之上，帧中包含了 foo 的参数和局部变量。当 foo 返回时，最上层的帧就被弹出栈（剩下 bar 函数的调用帧 ）。当 bar 返回的时候，栈就空了。</p>\n<p>js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。</p>\n<h3 id=\"同步任务和异步任务\"><a href=\"#同步任务和异步任务\" class=\"headerlink\" title=\"同步任务和异步任务\"></a>同步任务和异步任务</h3><p>Javascript单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。</p>\n<h3 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h3><p>不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。</p>\n<p>以下事件属于宏任务：</p>\n<ul>\n<li>script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。<br>以下事件属于微任务：</li>\n<li>Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver。</li>\n</ul>\n<p><strong>事件循环的进程模型</strong></p>\n<ul>\n<li>选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即null，则执行跳转到微任务（MicroTask）的执行步骤。</li>\n<li>将事件循环中的任务设置为已选择任务。</li>\n<li>执行任务。</li>\n<li>将事件循环中当前运行任务设置为null。</li>\n<li>将已经运行完成的任务从任务队列中删除。</li>\n<li>microtasks步骤：进入microtask检查点。</li>\n<li>更新界面渲染。</li>\n<li>返回第一步。</li>\n</ul>\n<p>执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空，就会去检查微任务(microTask)队列是否为空，如果为空的话，就执行Task（宏任务），否则就一次性执行完所有微任务。</p>\n<p>每次单个宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务(microTask)后，设置微任务(microTask)队列为null，然后再执行宏任务，如此循环。</p>\n<p><strong>总结：当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。</strong></p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script start'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'setTimeout'</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise1'</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise2'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script end'</span>);</span><br></pre></td></tr></table></figure>\n<p>执行分析：</p>\n<ol>\n<li>执行同步代码，将宏任务（Tasks）和微任务(Microtasks)划分到各自队列中。</li>\n<li>执行宏任务后，检测到微任务(Microtasks)队列中不为空，执行Promise1，执行完成Promise1后，调用Promise2.then，放入微任务(Microtasks)队列中，再执行Promise2.then。</li>\n<li>当微任务(Microtasks)队列中为空时，执行宏任务（Tasks），执行setTimeout callback，打印日志。</li>\n<li>清空Tasks队列和JS stack。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>事件顺序</th>\n<th>宏任务</th>\n<th>微任务</th>\n<th>执行栈</th>\n<th>输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>第一次</td>\n<td>run script、 setTimeout callback</td>\n<td>Promise then</td>\n<td>script</td>\n<td>script start、script end</td>\n</tr>\n<tr>\n<td>第二次</td>\n<td>run script、 setTimeout callback</td>\n<td>Promise2 then</td>\n<td>Promise2 callback</td>\n<td>start、script end、promise1</td>\n</tr>\n<tr>\n<td>第三次</td>\n<td>etTimeout callback</td>\n<td>空</td>\n<td>setTimeout callback</td>\n<td>script start、script end、promise1、promise2</td>\n</tr>\n<tr>\n<td>第四次</td>\n<td>etTimeout callback</td>\n<td>空</td>\n<td>空</td>\n<td>script start、script end、promise1、promise2、setTimeout</td>\n</tr>\n</tbody>\n</table>\n<p>执行帧动画：<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\" target=\"_blank\" rel=\"noopener\">Tasks, microtasks, queues and schedules</a></p>\n<h3 id=\"setTimeout\"><a href=\"#setTimeout\" class=\"headerlink\" title=\"setTimeout\"></a>setTimeout</h3><p>函数 setTimeout 接受两个参数：待加入队列的消息和一个延迟（可选，默认为 0）。这个延迟代表了消息被实际加入到队列的最小延迟时间。如果队列中没有其它消息，在这段延迟时间过去之后，消息会被马上处理。但是，如果有其它消息，setTimeout 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少延迟时间，而非确切的等待时间。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getSeconds();</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 输出 \"2\"，表示回调函数并没有在 500 毫秒之后立即执行</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Run after \"</span> + (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getSeconds() - s) + <span class=\"string\">\" seconds\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getSeconds() - s &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Good, looped for 2 seconds\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//输出：Good, looped for 2 seconds</span></span><br><span class=\"line\"><span class=\"comment\">//      Run after 2 seconds</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。</p>\n</blockquote>\n<p>再看看这段代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure></p>\n<p>按照上面的规范，低于4毫秒的自动变为4毫秒，因此三个setTimeout进入异步队列的顺序的依次从上到下的，即打印出 2 1 0 。</p>\n<p>然而在FireFox 64.0.2 (32 位) 环境下，setTimeout的时间是可以设置小于4毫秒的，因此输出是 0 1 2 。</p>\n<p>在Chrome 72.0.3626.121(正式版本)(32 位) 环境下，打印的是 1 0 2 。</p>\n<p>从测试结果可以看出，0ms和1ms的延时效果是一致的。原因是Blink内核对于传入时间有这样一行判断：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// https://chromium.googlesource.com/chromium/blink/+/master/Source/core/frame/DOMTimer.cpp#93</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> intervalMilliseconds = <span class=\"built_in\">std</span>::max(oneMillisecond, interval * oneMillisecond);</span><br></pre></td></tr></table></figure>\n<p><strong>可以看出传入0和传入1结果都是oneMillisecond，即1ms。</strong></p>\n<h3 id=\"setInterval\"><a href=\"#setInterval\" class=\"headerlink\" title=\"setInterval\"></a>setInterval</h3><p>对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getSeconds();</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> _s = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getSeconds();</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getSeconds() - _s &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Run after \"</span> + (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getSeconds() - s) + <span class=\"string\">\" seconds\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\"><span class=\"comment\">//每隔2秒打印一次，而不是500毫秒</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async/await\"></a>async/await</h3><p>async/await 在底层转换成了 promise 和 then 回调函数。也就是说，这是 promise 的语法糖。</p>\n<p>每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。</p>\n<p>然而对于下面这段代码，不同的浏览器，执行结果是不一致的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"a\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> async2();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"b\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'c'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async1();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"d\"</span>);</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"e\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>而在 FireFox 64.0.2 (32 位) 环境下，输出 a c d e b 。</p>\n<p>在 Chrome 72.0.3626.121(正式版本)(32 位) 环境下，输出 a c d b e 。</p>\n<p>原因是由于ECMAScript规范的更新（ <a href=\"https://github.com/tc39/ecma262/pull/1250\" target=\"_blank\" rel=\"noopener\"> TC39 新决议</a> ），决定await将直接使用Promise.resolve()相同语义，导致不同版本的浏览器对于async的实现是不一样的。</p>\n<p>在旧的规范中，await p 近似等于 return new Promise(resolve =&gt; resolve(p))。</p>\n<p>在新的规范中，await p 近似等于 return Promise.resolve(p)。</p>\n<p>如果传递给 await 的值已经是一个 Promise，则返回Promise.resolve(p)，那么这种优化避免了再次创建 Promise 包装器。</p>\n<blockquote>\n<p>如果 RESOLVE(p) 严格按照标准，应该是产生一个新的 promise，尽管该 promise 确定会 resolve 为 p，但这个过程本身是异步的，也就是现在进入 job 队列的是新 promise 的 resolve 过程，所以该 promise 的 then 不会被立即调用，而要等到当前 job 队列执行到前述 resolve 过程才会被调用，然后其回调（也就是继续 await 之后的语句）才加入 job 队列，所以时序上就晚了。</p>\n</blockquote>\n<p>对于以上代码，在不同规范下转化为Promise之后如下：</p>\n<p><strong>旧规范：</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(async2())</span><br><span class=\"line\">  &#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async2</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'c'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async1()</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'d'</span>)</span><br><span class=\"line\">  resolve()</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'e'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>因为 async2() 返回 promise, 所以进一步转化就是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      async2().then(resolve)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async2</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'c'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async1()</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'d'</span>)</span><br><span class=\"line\">  resolve()</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'e'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>输出：a c d e b</p>\n<p><strong>新规范：</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve(async2()).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async2</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'c'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async1()</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'d'</span>)</span><br><span class=\"line\">  resolve()</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'e'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>输出：a c d b e</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop\" target=\"_blank\" rel=\"noopener\">并发模型与事件循环</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"noopener\">JavaScript 运行机制详解：再谈Event Loop</a></li>\n<li><a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\" target=\"_blank\" rel=\"noopener\">Tasks, microtasks, queues and schedules</a></li>\n<li><a href=\"https://juejin.im/post/5c3d8956e51d4511dc72c200\" target=\"_blank\" rel=\"noopener\">一次弄懂Event Loop</a></li>\n<li><a href=\"https://www.zhihu.com/question/268007969\" target=\"_blank\" rel=\"noopener\">async/await 在chrome 环境和 node 环境的 执行结果不一致，求解？</a></li>\n<li><a href=\"https://juejin.im/post/59e85eebf265da430d571f89\" target=\"_blank\" rel=\"noopener\">这一次，彻底弄懂 JavaScript 执行机制</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/33087629\" target=\"_blank\" rel=\"noopener\">Event Loop的规范和实现</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout\" target=\"_blank\" rel=\"noopener\">window.setTimeout</a></li>\n</ul>"},{"title":"防抖与节流","date":"2017-11-17T16:00:00.000Z","_content":"## 背景\n在处理诸如 resize、scroll、mousemove 和 keydown/keyup/keypress 等事件的时候，通常我们不希望这些事件太过频繁地触发，尤其是监听程序中涉及到大量的计算或者有非常耗费资源的操作。\n<!--more-->\n为了解决这个问题，一般有两种解决方案：\n1. debounce 防抖\n2. throttle 节流\n\nthrottle 和 debounce 是解决请求和响应速度不匹配问题的两个方案。二者的差异在于选择不同的策略。\n\n### 电梯超时\n想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应。假设电梯有两种运行策略 throttle 和 debounce ，超时设定为15秒，不考虑容量限制。\n* throttle 策略的电梯。保证如果电梯第一个人进来后，15秒后准时运送一次，不等待。如果没有人，则待机。\n* debounce 策略的电梯。如果电梯里有人进来，等待15秒。如果又人进来，15秒等待重新计时，直到15秒超时，开始运送。\n\n\n## 防抖(debounce)\n### 原理\n在 debounce 函数没有再被调用的情况下经过 delay 毫秒后才执行回调函数。\n* 由 debounce 的功能可知防抖函数至少接收两个参数（流行类库中都是 3 个参数）\n  * 回调函数fn\n  * 延时时间delay\n* debounce 函数返回一个闭包，闭包被频繁的调用\n  * debounce 函数只调用一次，之后调用的都是它返回的闭包函数\n  * 在闭包内部限制了回调函数fn的执行，强制只有连续操作停止后执行一次\n* 使用闭包是为了使指向定时器的变量不被gc回收\n  * 实现在延时时间delay内的连续触发都不执行回调函数fn，使用的是在闭包内设置定时器setTimeOut\n  * 频繁调用这个闭包，在每次调用时都要将上次调用的定时器清除\n  * 被闭包保存的变量就是指向上一次设置的定时器\n### 实现\n* 基本实现\n\n````javascript\nfunction debounce(fn, wait) {\n  var timer\n  return function () {\n    clearTimeout(timer)\n    timer = setTimeout(fn, wait)\n  }\n}\n\n````\n以上实现的缺点:\n1. this指向问题。debounce 函数在定时器中调用回调函数fn，所以fn执行的时候this指向全局对象（浏览器中window），需要在外层用变量将this保存下来，使用apply进行显式绑定\n2. event对象。JavaScript 的事件处理函数中会提供事件对象event，在闭包中调用时需要将这个事件对象传入\n* 完整实现\n1. 增加第三个参数, 是否立刻执行。\n2. 增加 debounce 函数的返回值。\n3. 取消 debounce 函数。\n\n````javascript\n/**\n * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行\n *\n * @param  {function} func        传入函数\n * @param  {number}   wait        表示时间窗口的间隔\n * @param  {boolean}  immediate   设置为ture时，调用触发于开始边界而不是结束边界\n * @return {function}             返回客户调用函数\n */\nfunction debounce(fn, wait, immediate) {\n  var timer, result\n\n  var debounced = function() {\n    var context = this\n    var args = arguments\n    //清除计时器，清除上次未到延迟时间的任务\n    if(timer) {clearTimeout(timer)}\n\n    if(immediate) {\n      //是否执行完成\n      let callNow = !timer\n      //设置timer，执行完成之后清除timer，以便下次还能执行\n      timer = setTimeout(function() {\n        timer = null;\n      }, wait);\n      //如果上次已经执行完成， 则可以立即执行\n      if(callNow) {result = fn.apply(context, args)}\n    }else {\n      //非立即执行的，设置wait时间之后执行\n      timer = setTimeout(function() {\n        fn.apply(context, args)\n      }, wait)\n    }\n    return result\n  }\n  \n  debounced.cancel = function() {\n    clearTimeout(timer)\n    timer = null\n  }\n\n  return debounced\n}\n````\n\n## 节流(throttle)\nthrottle 的概念就是固定函数执行的速率，即所谓的“节流”。正常情况下，mousemove 的监听函数可能会每 20ms（假设）执行一次，如果设置 200ms 的“节流”，那么它就会每 200ms 执行一次。比如在 1s 的时间段内，正常的监听函数可能会执行 50（1000/20） 次，“节流” 200ms 后则会执行 5（1000/200） 次。\n### 原理\n* 有两种主流实现方式\n  * 使用时间戳\n  * 设置定时器\n* 节流函数 throttle 调用后返回一个闭包\n  * 闭包用来保存之前的时间戳或者定时器变量（因为变量被返回的函数引用，所以无法被垃圾回收机制回收）\n* 时间戳方式\n  * 当触发事件的时候，取出当前的时间戳，然后减去之前的时间戳（初始设置为 0）\n  * 结果大于设置的时间周期，则执行函数，然后更新时间戳为当前时间戳\n  * 结果小于设置的时间周期，则不执行函数\n* 定时器方式\n  * 当触发事件的时候，设置一个定时器\n  * 再次触发事件的时候，如果定时器存在，就不执行，知道定时器执行，然后执行函数，清空定时器\n  * 设置下个定时器\n* 将两种方式结合，可以实现兼并立刻执行和停止触发后依然执行一次的效果\n### 实现\n* 时间戳实现\n\n````javascript\nfunction throttle(fn, wait) {\n  var args;\n  // 前一次执行的时间戳\n  var previous = 0;\n  return function() {\n    // 将时间转为时间戳\n    var now = +new Date();\n    args = arguments;\n    // 时间间隔大于延迟时间才执行\n    if (now - previous > wait) {\n      fn.apply(this, args);\n      previous = now;\n    }\n  };\n}\n````\n* 定时器实现\n\n````javascript\nfunction throttle(fn, wait) {\n  var timer, context, args;\n  return function() {\n    context = this;\n    args = arguments;\n    // 如果定时器存在，则不执行\n    if (!timer) {\n      timer = setTimeout(function() {\n        // 执行后释放定时器变量\n        timer = null;\n        fn.apply(context, args);\n      }, wait);\n    }\n  };\n}\n````\n\n* 完整实现\n1. 增加第三个参数，让用户可以自己选择模式\n  * 忽略开始边界上的调用，传入{ leading: false }\n  * 忽略结尾边界上的调用，传入{ trailing: false }\n  * 增加返回值功能\n2. 增加取消功能\n3. leading: false 和 trailing: false 不能同时设置\n\n````javascript\n/**\n * 频率控制 返回函数连续调用时，func 执行频率限定为 次 / wait\n * \n * @param  {function}   func      传入函数\n * @param  {number}     wait      表示时间窗口的间隔\n * @param  {object}     options   如果想忽略开始边界上的调用，传入{leading: false}。\n *                                如果想忽略结尾边界上的调用，传入{trailing: false}\n * @return {function}             返回客户调用函数   \n */\nfunction throttle(fn, wait, options) {\n  var timer, result, args, context\n  var previous = 0\n  if(!options) {options = {}}\n\n  // 延迟执行函数\n  var later = function() {\n    // 更新上次执行时间\n    // 若上边界不执行，则上次执行时间始终为0\n    previous = options.leading === false ? 0 : +new Date()\n    result = fn.apply(context, args)\n    // 本次执行结束后 清除上下文环境和参数\n    if(!timer) context = args = null\n  }\n\n  var throttled = function() {\n    var now = +new Date()\n    // 首次执行时，如果设定了开始边界不执行选项，将上次执行时间设定为当前时间。\n    if(!previous && options.leading === false) {\n      previous = now\n    }\n    // 延迟执行时间间隔\n    var remaining = wait - (now - previous)\n    context = this\n    args = arguments\n\n    // 执行函数的两种情况\n    // remaining小于0，说明次执行至此所间隔时间已经超过一个时间窗口\n    // remaining大于时间窗口wait，表示客户端系统时间被调整过\n    if(remaining <= 0 || remaining < wait) {\n      if (timer) {\n        clearTimeout(timer);\n        timer = null;\n      }\n      previous = now\n      result = fn.apply(context, args)\n      //本次执行结束后 清除上下文环境和参数\n      if(!timer) context = args = null\n    }else if(!timer && options.trailing !== false) {\n      timer = setTimeout(later, remaining)\n    }\n  }\n  return throttled \n}\n````\n\n## demo\n<iframe width=\"100%\" height=\"300\" src=\"https://jsrun.net/e6XKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n## 参考资料\n* [Debounce 和 Throttle 的原理及实现](http://hackll.com/2015/11/19/debounce-and-throttle)\n* [节流与防抖](https://juejin.im/post/5c2eb031f265da61343889bb)\n* [underscore](https://github.com/jashkenas/underscore/blob/master/underscore.js#L887)","source":"_posts/防抖与节流.md","raw":"---\ntitle: 防抖与节流\ndate: 2017-11-18\ntags: ['debounce']\ncategories: ['性能']\n---\n## 背景\n在处理诸如 resize、scroll、mousemove 和 keydown/keyup/keypress 等事件的时候，通常我们不希望这些事件太过频繁地触发，尤其是监听程序中涉及到大量的计算或者有非常耗费资源的操作。\n<!--more-->\n为了解决这个问题，一般有两种解决方案：\n1. debounce 防抖\n2. throttle 节流\n\nthrottle 和 debounce 是解决请求和响应速度不匹配问题的两个方案。二者的差异在于选择不同的策略。\n\n### 电梯超时\n想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应。假设电梯有两种运行策略 throttle 和 debounce ，超时设定为15秒，不考虑容量限制。\n* throttle 策略的电梯。保证如果电梯第一个人进来后，15秒后准时运送一次，不等待。如果没有人，则待机。\n* debounce 策略的电梯。如果电梯里有人进来，等待15秒。如果又人进来，15秒等待重新计时，直到15秒超时，开始运送。\n\n\n## 防抖(debounce)\n### 原理\n在 debounce 函数没有再被调用的情况下经过 delay 毫秒后才执行回调函数。\n* 由 debounce 的功能可知防抖函数至少接收两个参数（流行类库中都是 3 个参数）\n  * 回调函数fn\n  * 延时时间delay\n* debounce 函数返回一个闭包，闭包被频繁的调用\n  * debounce 函数只调用一次，之后调用的都是它返回的闭包函数\n  * 在闭包内部限制了回调函数fn的执行，强制只有连续操作停止后执行一次\n* 使用闭包是为了使指向定时器的变量不被gc回收\n  * 实现在延时时间delay内的连续触发都不执行回调函数fn，使用的是在闭包内设置定时器setTimeOut\n  * 频繁调用这个闭包，在每次调用时都要将上次调用的定时器清除\n  * 被闭包保存的变量就是指向上一次设置的定时器\n### 实现\n* 基本实现\n\n````javascript\nfunction debounce(fn, wait) {\n  var timer\n  return function () {\n    clearTimeout(timer)\n    timer = setTimeout(fn, wait)\n  }\n}\n\n````\n以上实现的缺点:\n1. this指向问题。debounce 函数在定时器中调用回调函数fn，所以fn执行的时候this指向全局对象（浏览器中window），需要在外层用变量将this保存下来，使用apply进行显式绑定\n2. event对象。JavaScript 的事件处理函数中会提供事件对象event，在闭包中调用时需要将这个事件对象传入\n* 完整实现\n1. 增加第三个参数, 是否立刻执行。\n2. 增加 debounce 函数的返回值。\n3. 取消 debounce 函数。\n\n````javascript\n/**\n * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行\n *\n * @param  {function} func        传入函数\n * @param  {number}   wait        表示时间窗口的间隔\n * @param  {boolean}  immediate   设置为ture时，调用触发于开始边界而不是结束边界\n * @return {function}             返回客户调用函数\n */\nfunction debounce(fn, wait, immediate) {\n  var timer, result\n\n  var debounced = function() {\n    var context = this\n    var args = arguments\n    //清除计时器，清除上次未到延迟时间的任务\n    if(timer) {clearTimeout(timer)}\n\n    if(immediate) {\n      //是否执行完成\n      let callNow = !timer\n      //设置timer，执行完成之后清除timer，以便下次还能执行\n      timer = setTimeout(function() {\n        timer = null;\n      }, wait);\n      //如果上次已经执行完成， 则可以立即执行\n      if(callNow) {result = fn.apply(context, args)}\n    }else {\n      //非立即执行的，设置wait时间之后执行\n      timer = setTimeout(function() {\n        fn.apply(context, args)\n      }, wait)\n    }\n    return result\n  }\n  \n  debounced.cancel = function() {\n    clearTimeout(timer)\n    timer = null\n  }\n\n  return debounced\n}\n````\n\n## 节流(throttle)\nthrottle 的概念就是固定函数执行的速率，即所谓的“节流”。正常情况下，mousemove 的监听函数可能会每 20ms（假设）执行一次，如果设置 200ms 的“节流”，那么它就会每 200ms 执行一次。比如在 1s 的时间段内，正常的监听函数可能会执行 50（1000/20） 次，“节流” 200ms 后则会执行 5（1000/200） 次。\n### 原理\n* 有两种主流实现方式\n  * 使用时间戳\n  * 设置定时器\n* 节流函数 throttle 调用后返回一个闭包\n  * 闭包用来保存之前的时间戳或者定时器变量（因为变量被返回的函数引用，所以无法被垃圾回收机制回收）\n* 时间戳方式\n  * 当触发事件的时候，取出当前的时间戳，然后减去之前的时间戳（初始设置为 0）\n  * 结果大于设置的时间周期，则执行函数，然后更新时间戳为当前时间戳\n  * 结果小于设置的时间周期，则不执行函数\n* 定时器方式\n  * 当触发事件的时候，设置一个定时器\n  * 再次触发事件的时候，如果定时器存在，就不执行，知道定时器执行，然后执行函数，清空定时器\n  * 设置下个定时器\n* 将两种方式结合，可以实现兼并立刻执行和停止触发后依然执行一次的效果\n### 实现\n* 时间戳实现\n\n````javascript\nfunction throttle(fn, wait) {\n  var args;\n  // 前一次执行的时间戳\n  var previous = 0;\n  return function() {\n    // 将时间转为时间戳\n    var now = +new Date();\n    args = arguments;\n    // 时间间隔大于延迟时间才执行\n    if (now - previous > wait) {\n      fn.apply(this, args);\n      previous = now;\n    }\n  };\n}\n````\n* 定时器实现\n\n````javascript\nfunction throttle(fn, wait) {\n  var timer, context, args;\n  return function() {\n    context = this;\n    args = arguments;\n    // 如果定时器存在，则不执行\n    if (!timer) {\n      timer = setTimeout(function() {\n        // 执行后释放定时器变量\n        timer = null;\n        fn.apply(context, args);\n      }, wait);\n    }\n  };\n}\n````\n\n* 完整实现\n1. 增加第三个参数，让用户可以自己选择模式\n  * 忽略开始边界上的调用，传入{ leading: false }\n  * 忽略结尾边界上的调用，传入{ trailing: false }\n  * 增加返回值功能\n2. 增加取消功能\n3. leading: false 和 trailing: false 不能同时设置\n\n````javascript\n/**\n * 频率控制 返回函数连续调用时，func 执行频率限定为 次 / wait\n * \n * @param  {function}   func      传入函数\n * @param  {number}     wait      表示时间窗口的间隔\n * @param  {object}     options   如果想忽略开始边界上的调用，传入{leading: false}。\n *                                如果想忽略结尾边界上的调用，传入{trailing: false}\n * @return {function}             返回客户调用函数   \n */\nfunction throttle(fn, wait, options) {\n  var timer, result, args, context\n  var previous = 0\n  if(!options) {options = {}}\n\n  // 延迟执行函数\n  var later = function() {\n    // 更新上次执行时间\n    // 若上边界不执行，则上次执行时间始终为0\n    previous = options.leading === false ? 0 : +new Date()\n    result = fn.apply(context, args)\n    // 本次执行结束后 清除上下文环境和参数\n    if(!timer) context = args = null\n  }\n\n  var throttled = function() {\n    var now = +new Date()\n    // 首次执行时，如果设定了开始边界不执行选项，将上次执行时间设定为当前时间。\n    if(!previous && options.leading === false) {\n      previous = now\n    }\n    // 延迟执行时间间隔\n    var remaining = wait - (now - previous)\n    context = this\n    args = arguments\n\n    // 执行函数的两种情况\n    // remaining小于0，说明次执行至此所间隔时间已经超过一个时间窗口\n    // remaining大于时间窗口wait，表示客户端系统时间被调整过\n    if(remaining <= 0 || remaining < wait) {\n      if (timer) {\n        clearTimeout(timer);\n        timer = null;\n      }\n      previous = now\n      result = fn.apply(context, args)\n      //本次执行结束后 清除上下文环境和参数\n      if(!timer) context = args = null\n    }else if(!timer && options.trailing !== false) {\n      timer = setTimeout(later, remaining)\n    }\n  }\n  return throttled \n}\n````\n\n## demo\n<iframe width=\"100%\" height=\"300\" src=\"https://jsrun.net/e6XKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n## 参考资料\n* [Debounce 和 Throttle 的原理及实现](http://hackll.com/2015/11/19/debounce-and-throttle)\n* [节流与防抖](https://juejin.im/post/5c2eb031f265da61343889bb)\n* [underscore](https://github.com/jashkenas/underscore/blob/master/underscore.js#L887)","slug":"防抖与节流","published":1,"updated":"2022-04-13T14:14:08.123Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfga004ag3t88b960uyg","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>在处理诸如 resize、scroll、mousemove 和 keydown/keyup/keypress 等事件的时候，通常我们不希望这些事件太过频繁地触发，尤其是监听程序中涉及到大量的计算或者有非常耗费资源的操作。<br><a id=\"more\"></a><br>为了解决这个问题，一般有两种解决方案：</p>\n<ol>\n<li>debounce 防抖</li>\n<li>throttle 节流</li>\n</ol>\n<p>throttle 和 debounce 是解决请求和响应速度不匹配问题的两个方案。二者的差异在于选择不同的策略。</p>\n<h3 id=\"电梯超时\"><a href=\"#电梯超时\" class=\"headerlink\" title=\"电梯超时\"></a>电梯超时</h3><p>想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应。假设电梯有两种运行策略 throttle 和 debounce ，超时设定为15秒，不考虑容量限制。</p>\n<ul>\n<li>throttle 策略的电梯。保证如果电梯第一个人进来后，15秒后准时运送一次，不等待。如果没有人，则待机。</li>\n<li>debounce 策略的电梯。如果电梯里有人进来，等待15秒。如果又人进来，15秒等待重新计时，直到15秒超时，开始运送。</li>\n</ul>\n<h2 id=\"防抖-debounce\"><a href=\"#防抖-debounce\" class=\"headerlink\" title=\"防抖(debounce)\"></a>防抖(debounce)</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>在 debounce 函数没有再被调用的情况下经过 delay 毫秒后才执行回调函数。</p>\n<ul>\n<li>由 debounce 的功能可知防抖函数至少接收两个参数（流行类库中都是 3 个参数）<ul>\n<li>回调函数fn</li>\n<li>延时时间delay</li>\n</ul>\n</li>\n<li>debounce 函数返回一个闭包，闭包被频繁的调用<ul>\n<li>debounce 函数只调用一次，之后调用的都是它返回的闭包函数</li>\n<li>在闭包内部限制了回调函数fn的执行，强制只有连续操作停止后执行一次</li>\n</ul>\n</li>\n<li>使用闭包是为了使指向定时器的变量不被gc回收<ul>\n<li>实现在延时时间delay内的连续触发都不执行回调函数fn，使用的是在闭包内设置定时器setTimeOut</li>\n<li>频繁调用这个闭包，在每次调用时都要将上次调用的定时器清除</li>\n<li>被闭包保存的变量就是指向上一次设置的定时器<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3></li>\n</ul>\n</li>\n<li>基本实现</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, wait</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    clearTimeout(timer)</span><br><span class=\"line\">    timer = setTimeout(fn, wait)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上实现的缺点:</p>\n<ol>\n<li>this指向问题。debounce 函数在定时器中调用回调函数fn，所以fn执行的时候this指向全局对象（浏览器中window），需要在外层用变量将this保存下来，使用apply进行显式绑定</li>\n<li>event对象。JavaScript 的事件处理函数中会提供事件对象event，在闭包中调用时需要将这个事件对象传入</li>\n</ol>\n<ul>\n<li>完整实现</li>\n</ul>\n<ol>\n<li>增加第三个参数, 是否立刻执行。</li>\n<li>增加 debounce 函数的返回值。</li>\n<li>取消 debounce 函数。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param  <span class=\"type\">&#123;function&#125;</span> </span>func        传入函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param  <span class=\"type\">&#123;number&#125;</span>   </span>wait        表示时间窗口的间隔</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param  <span class=\"type\">&#123;boolean&#125;</span>  </span>immediate   设置为ture时，调用触发于开始边界而不是结束边界</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;function&#125;</span>             </span>返回客户调用函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, wait, immediate</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer, result</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> debounced = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span></span><br><span class=\"line\">    <span class=\"comment\">//清除计时器，清除上次未到延迟时间的任务</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(timer) &#123;clearTimeout(timer)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(immediate) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//是否执行完成</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> callNow = !timer</span><br><span class=\"line\">      <span class=\"comment\">//设置timer，执行完成之后清除timer，以便下次还能执行</span></span><br><span class=\"line\">      timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">      <span class=\"comment\">//如果上次已经执行完成， 则可以立即执行</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(callNow) &#123;result = fn.apply(context, args)&#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//非立即执行的，设置wait时间之后执行</span></span><br><span class=\"line\">      timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        fn.apply(context, args)</span><br><span class=\"line\">      &#125;, wait)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  debounced.cancel = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    clearTimeout(timer)</span><br><span class=\"line\">    timer = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> debounced</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"节流-throttle\"><a href=\"#节流-throttle\" class=\"headerlink\" title=\"节流(throttle)\"></a>节流(throttle)</h2><p>throttle 的概念就是固定函数执行的速率，即所谓的“节流”。正常情况下，mousemove 的监听函数可能会每 20ms（假设）执行一次，如果设置 200ms 的“节流”，那么它就会每 200ms 执行一次。比如在 1s 的时间段内，正常的监听函数可能会执行 50（1000/20） 次，“节流” 200ms 后则会执行 5（1000/200） 次。</p>\n<h3 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h3><ul>\n<li>有两种主流实现方式<ul>\n<li>使用时间戳</li>\n<li>设置定时器</li>\n</ul>\n</li>\n<li>节流函数 throttle 调用后返回一个闭包<ul>\n<li>闭包用来保存之前的时间戳或者定时器变量（因为变量被返回的函数引用，所以无法被垃圾回收机制回收）</li>\n</ul>\n</li>\n<li>时间戳方式<ul>\n<li>当触发事件的时候，取出当前的时间戳，然后减去之前的时间戳（初始设置为 0）</li>\n<li>结果大于设置的时间周期，则执行函数，然后更新时间戳为当前时间戳</li>\n<li>结果小于设置的时间周期，则不执行函数</li>\n</ul>\n</li>\n<li>定时器方式<ul>\n<li>当触发事件的时候，设置一个定时器</li>\n<li>再次触发事件的时候，如果定时器存在，就不执行，知道定时器执行，然后执行函数，清空定时器</li>\n<li>设置下个定时器</li>\n</ul>\n</li>\n<li>将两种方式结合，可以实现兼并立刻执行和停止触发后依然执行一次的效果<h3 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h3></li>\n<li>时间戳实现</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">fn, wait</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args;</span><br><span class=\"line\">  <span class=\"comment\">// 前一次执行的时间戳</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> previous = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将时间转为时间戳</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">    args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 时间间隔大于延迟时间才执行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (now - previous &gt; wait) &#123;</span><br><span class=\"line\">      fn.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">      previous = now;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>定时器实现</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">fn, wait</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer, context, args;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果定时器存在，则不执行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!timer) &#123;</span><br><span class=\"line\">      timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行后释放定时器变量</span></span><br><span class=\"line\">        timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        fn.apply(context, args);</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>完整实现</li>\n</ul>\n<ol>\n<li>增加第三个参数，让用户可以自己选择模式<ul>\n<li>忽略开始边界上的调用，传入{ leading: false }</li>\n<li>忽略结尾边界上的调用，传入{ trailing: false }</li>\n<li>增加返回值功能</li>\n</ul>\n</li>\n<li>增加取消功能</li>\n<li>leading: false 和 trailing: false 不能同时设置</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 频率控制 返回函数连续调用时，func 执行频率限定为 次 / wait</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param  <span class=\"type\">&#123;function&#125;</span>   </span>func      传入函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param  <span class=\"type\">&#123;number&#125;</span>     </span>wait      表示时间窗口的间隔</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param  <span class=\"type\">&#123;object&#125;</span>     </span>options   如果想忽略开始边界上的调用，传入&#123;leading: false&#125;。</span></span><br><span class=\"line\"><span class=\"comment\"> *                                如果想忽略结尾边界上的调用，传入&#123;trailing: false&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;function&#125;</span>             </span>返回客户调用函数   </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">fn, wait, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer, result, args, context</span><br><span class=\"line\">  <span class=\"keyword\">var</span> previous = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!options) &#123;options = &#123;&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 延迟执行函数</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 更新上次执行时间</span></span><br><span class=\"line\">    <span class=\"comment\">// 若上边界不执行，则上次执行时间始终为0</span></span><br><span class=\"line\">    previous = options.leading === <span class=\"literal\">false</span> ? <span class=\"number\">0</span> : +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">    result = fn.apply(context, args)</span><br><span class=\"line\">    <span class=\"comment\">// 本次执行结束后 清除上下文环境和参数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!timer) context = args = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> throttled = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">    <span class=\"comment\">// 首次执行时，如果设定了开始边界不执行选项，将上次执行时间设定为当前时间。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!previous &amp;&amp; options.leading === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">      previous = now</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 延迟执行时间间隔</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> remaining = wait - (now - previous)</span><br><span class=\"line\">    context = <span class=\"keyword\">this</span></span><br><span class=\"line\">    args = <span class=\"built_in\">arguments</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行函数的两种情况</span></span><br><span class=\"line\">    <span class=\"comment\">// remaining小于0，说明次执行至此所间隔时间已经超过一个时间窗口</span></span><br><span class=\"line\">    <span class=\"comment\">// remaining大于时间窗口wait，表示客户端系统时间被调整过</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(remaining &lt;= <span class=\"number\">0</span> || remaining &lt; wait) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (timer) &#123;</span><br><span class=\"line\">        clearTimeout(timer);</span><br><span class=\"line\">        timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      previous = now</span><br><span class=\"line\">      result = fn.apply(context, args)</span><br><span class=\"line\">      <span class=\"comment\">//本次执行结束后 清除上下文环境和参数</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(!timer) context = args = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!timer &amp;&amp; options.trailing !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">      timer = setTimeout(later, remaining)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> throttled </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h2><iframe width=\"100%\" height=\"300\" src=\"https://jsrun.net/e6XKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"http://hackll.com/2015/11/19/debounce-and-throttle\" target=\"_blank\" rel=\"noopener\">Debounce 和 Throttle 的原理及实现</a></li>\n<li><a href=\"https://juejin.im/post/5c2eb031f265da61343889bb\" target=\"_blank\" rel=\"noopener\">节流与防抖</a></li>\n<li><a href=\"https://github.com/jashkenas/underscore/blob/master/underscore.js#L887\" target=\"_blank\" rel=\"noopener\">underscore</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>在处理诸如 resize、scroll、mousemove 和 keydown/keyup/keypress 等事件的时候，通常我们不希望这些事件太过频繁地触发，尤其是监听程序中涉及到大量的计算或者有非常耗费资源的操作。<br>","more":"<br>为了解决这个问题，一般有两种解决方案：</p>\n<ol>\n<li>debounce 防抖</li>\n<li>throttle 节流</li>\n</ol>\n<p>throttle 和 debounce 是解决请求和响应速度不匹配问题的两个方案。二者的差异在于选择不同的策略。</p>\n<h3 id=\"电梯超时\"><a href=\"#电梯超时\" class=\"headerlink\" title=\"电梯超时\"></a>电梯超时</h3><p>想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应。假设电梯有两种运行策略 throttle 和 debounce ，超时设定为15秒，不考虑容量限制。</p>\n<ul>\n<li>throttle 策略的电梯。保证如果电梯第一个人进来后，15秒后准时运送一次，不等待。如果没有人，则待机。</li>\n<li>debounce 策略的电梯。如果电梯里有人进来，等待15秒。如果又人进来，15秒等待重新计时，直到15秒超时，开始运送。</li>\n</ul>\n<h2 id=\"防抖-debounce\"><a href=\"#防抖-debounce\" class=\"headerlink\" title=\"防抖(debounce)\"></a>防抖(debounce)</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>在 debounce 函数没有再被调用的情况下经过 delay 毫秒后才执行回调函数。</p>\n<ul>\n<li>由 debounce 的功能可知防抖函数至少接收两个参数（流行类库中都是 3 个参数）<ul>\n<li>回调函数fn</li>\n<li>延时时间delay</li>\n</ul>\n</li>\n<li>debounce 函数返回一个闭包，闭包被频繁的调用<ul>\n<li>debounce 函数只调用一次，之后调用的都是它返回的闭包函数</li>\n<li>在闭包内部限制了回调函数fn的执行，强制只有连续操作停止后执行一次</li>\n</ul>\n</li>\n<li>使用闭包是为了使指向定时器的变量不被gc回收<ul>\n<li>实现在延时时间delay内的连续触发都不执行回调函数fn，使用的是在闭包内设置定时器setTimeOut</li>\n<li>频繁调用这个闭包，在每次调用时都要将上次调用的定时器清除</li>\n<li>被闭包保存的变量就是指向上一次设置的定时器<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3></li>\n</ul>\n</li>\n<li>基本实现</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, wait</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    clearTimeout(timer)</span><br><span class=\"line\">    timer = setTimeout(fn, wait)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上实现的缺点:</p>\n<ol>\n<li>this指向问题。debounce 函数在定时器中调用回调函数fn，所以fn执行的时候this指向全局对象（浏览器中window），需要在外层用变量将this保存下来，使用apply进行显式绑定</li>\n<li>event对象。JavaScript 的事件处理函数中会提供事件对象event，在闭包中调用时需要将这个事件对象传入</li>\n</ol>\n<ul>\n<li>完整实现</li>\n</ul>\n<ol>\n<li>增加第三个参数, 是否立刻执行。</li>\n<li>增加 debounce 函数的返回值。</li>\n<li>取消 debounce 函数。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param  <span class=\"type\">&#123;function&#125;</span> </span>func        传入函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param  <span class=\"type\">&#123;number&#125;</span>   </span>wait        表示时间窗口的间隔</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param  <span class=\"type\">&#123;boolean&#125;</span>  </span>immediate   设置为ture时，调用触发于开始边界而不是结束边界</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;function&#125;</span>             </span>返回客户调用函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, wait, immediate</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer, result</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> debounced = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span></span><br><span class=\"line\">    <span class=\"comment\">//清除计时器，清除上次未到延迟时间的任务</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(timer) &#123;clearTimeout(timer)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(immediate) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//是否执行完成</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> callNow = !timer</span><br><span class=\"line\">      <span class=\"comment\">//设置timer，执行完成之后清除timer，以便下次还能执行</span></span><br><span class=\"line\">      timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">      <span class=\"comment\">//如果上次已经执行完成， 则可以立即执行</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(callNow) &#123;result = fn.apply(context, args)&#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//非立即执行的，设置wait时间之后执行</span></span><br><span class=\"line\">      timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        fn.apply(context, args)</span><br><span class=\"line\">      &#125;, wait)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  debounced.cancel = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    clearTimeout(timer)</span><br><span class=\"line\">    timer = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> debounced</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"节流-throttle\"><a href=\"#节流-throttle\" class=\"headerlink\" title=\"节流(throttle)\"></a>节流(throttle)</h2><p>throttle 的概念就是固定函数执行的速率，即所谓的“节流”。正常情况下，mousemove 的监听函数可能会每 20ms（假设）执行一次，如果设置 200ms 的“节流”，那么它就会每 200ms 执行一次。比如在 1s 的时间段内，正常的监听函数可能会执行 50（1000/20） 次，“节流” 200ms 后则会执行 5（1000/200） 次。</p>\n<h3 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h3><ul>\n<li>有两种主流实现方式<ul>\n<li>使用时间戳</li>\n<li>设置定时器</li>\n</ul>\n</li>\n<li>节流函数 throttle 调用后返回一个闭包<ul>\n<li>闭包用来保存之前的时间戳或者定时器变量（因为变量被返回的函数引用，所以无法被垃圾回收机制回收）</li>\n</ul>\n</li>\n<li>时间戳方式<ul>\n<li>当触发事件的时候，取出当前的时间戳，然后减去之前的时间戳（初始设置为 0）</li>\n<li>结果大于设置的时间周期，则执行函数，然后更新时间戳为当前时间戳</li>\n<li>结果小于设置的时间周期，则不执行函数</li>\n</ul>\n</li>\n<li>定时器方式<ul>\n<li>当触发事件的时候，设置一个定时器</li>\n<li>再次触发事件的时候，如果定时器存在，就不执行，知道定时器执行，然后执行函数，清空定时器</li>\n<li>设置下个定时器</li>\n</ul>\n</li>\n<li>将两种方式结合，可以实现兼并立刻执行和停止触发后依然执行一次的效果<h3 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h3></li>\n<li>时间戳实现</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">fn, wait</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args;</span><br><span class=\"line\">  <span class=\"comment\">// 前一次执行的时间戳</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> previous = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将时间转为时间戳</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">    args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 时间间隔大于延迟时间才执行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (now - previous &gt; wait) &#123;</span><br><span class=\"line\">      fn.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">      previous = now;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>定时器实现</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">fn, wait</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer, context, args;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果定时器存在，则不执行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!timer) &#123;</span><br><span class=\"line\">      timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行后释放定时器变量</span></span><br><span class=\"line\">        timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        fn.apply(context, args);</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>完整实现</li>\n</ul>\n<ol>\n<li>增加第三个参数，让用户可以自己选择模式<ul>\n<li>忽略开始边界上的调用，传入{ leading: false }</li>\n<li>忽略结尾边界上的调用，传入{ trailing: false }</li>\n<li>增加返回值功能</li>\n</ul>\n</li>\n<li>增加取消功能</li>\n<li>leading: false 和 trailing: false 不能同时设置</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 频率控制 返回函数连续调用时，func 执行频率限定为 次 / wait</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param  <span class=\"type\">&#123;function&#125;</span>   </span>func      传入函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param  <span class=\"type\">&#123;number&#125;</span>     </span>wait      表示时间窗口的间隔</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param  <span class=\"type\">&#123;object&#125;</span>     </span>options   如果想忽略开始边界上的调用，传入&#123;leading: false&#125;。</span></span><br><span class=\"line\"><span class=\"comment\"> *                                如果想忽略结尾边界上的调用，传入&#123;trailing: false&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;function&#125;</span>             </span>返回客户调用函数   </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">fn, wait, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer, result, args, context</span><br><span class=\"line\">  <span class=\"keyword\">var</span> previous = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!options) &#123;options = &#123;&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 延迟执行函数</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 更新上次执行时间</span></span><br><span class=\"line\">    <span class=\"comment\">// 若上边界不执行，则上次执行时间始终为0</span></span><br><span class=\"line\">    previous = options.leading === <span class=\"literal\">false</span> ? <span class=\"number\">0</span> : +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">    result = fn.apply(context, args)</span><br><span class=\"line\">    <span class=\"comment\">// 本次执行结束后 清除上下文环境和参数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!timer) context = args = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> throttled = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">    <span class=\"comment\">// 首次执行时，如果设定了开始边界不执行选项，将上次执行时间设定为当前时间。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!previous &amp;&amp; options.leading === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">      previous = now</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 延迟执行时间间隔</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> remaining = wait - (now - previous)</span><br><span class=\"line\">    context = <span class=\"keyword\">this</span></span><br><span class=\"line\">    args = <span class=\"built_in\">arguments</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行函数的两种情况</span></span><br><span class=\"line\">    <span class=\"comment\">// remaining小于0，说明次执行至此所间隔时间已经超过一个时间窗口</span></span><br><span class=\"line\">    <span class=\"comment\">// remaining大于时间窗口wait，表示客户端系统时间被调整过</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(remaining &lt;= <span class=\"number\">0</span> || remaining &lt; wait) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (timer) &#123;</span><br><span class=\"line\">        clearTimeout(timer);</span><br><span class=\"line\">        timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      previous = now</span><br><span class=\"line\">      result = fn.apply(context, args)</span><br><span class=\"line\">      <span class=\"comment\">//本次执行结束后 清除上下文环境和参数</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(!timer) context = args = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!timer &amp;&amp; options.trailing !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">      timer = setTimeout(later, remaining)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> throttled </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h2><iframe width=\"100%\" height=\"300\" src=\"https://jsrun.net/e6XKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"http://hackll.com/2015/11/19/debounce-and-throttle\" target=\"_blank\" rel=\"noopener\">Debounce 和 Throttle 的原理及实现</a></li>\n<li><a href=\"https://juejin.im/post/5c2eb031f265da61343889bb\" target=\"_blank\" rel=\"noopener\">节流与防抖</a></li>\n<li><a href=\"https://github.com/jashkenas/underscore/blob/master/underscore.js#L887\" target=\"_blank\" rel=\"noopener\">underscore</a></li>\n</ul>"},{"title":"iOS的iframe宽度bug","date":"2017-09-29T16:00:00.000Z","_content":"## 问题背景\n最近做一个项目里，有一个使用了[slick](https://github.com/kenwheeler/slick)插件做轮播效果的页面，本身打开一切正常。后面这个页面被嵌在另一个页面的iframe下时，iframe的宽度设置为100%，在iOS里打开，页面就变得不正常了，轮播部分好像被放得很大，把其他元素挤出屏幕外，轮播来回切换，页面来回闪烁。\n<!--more-->\n## 产生原因\niOS下的safari是按照iframe里面页面元素的全尺寸来调整iframe的大小的。\n\n轮播效果的实现原理是将所有的幻灯片都放到一个块里面，然后设置溢出隐藏，在iOS的iframe下，结合上面第一条原因，就会将iframe撑得很大。\n## 解决方案\n### 方案一\n在包含轮播组件的元素上设置以下样式：\n````css\n{\n  width: 1px;\n  min-width: 100%;\n}\n````\n或者设置\n````css\n{\n  width: 100vw;\n}\n````\n### 方案二\n在iframe上设置以下样式\n````css\niframe {\n  width: 1px;\n  min-width: 100%;\n  *width: 100%;\n}\n````\n同时设置scrolling属性为'no'。\n````html\n<iframe height=\"950\" width=\"100%\" scrolling=\"no\" src=\"Content.html\"></iframe>\n````\n## 参考资料\n* [https://www.spacevatican.org/2015/4/7/on-mobile-safari-and-iframes/](https://www.spacevatican.org/2015/4/7/on-mobile-safari-and-iframes/)\n* [https://stackoverflow.com/questions/20123960/how-to-get-iframe-width-100-in-iphone-portrait-view](https://stackoverflow.com/questions/20123960/how-to-get-iframe-width-100-in-iphone-portrait-view)\n* [https://stackoverflow.com/questions/23083462/how-to-get-an-iframe-to-be-responsive-in-ios-safari](https://stackoverflow.com/questions/23083462/how-to-get-an-iframe-to-be-responsive-in-ios-safari)\n* [https://github.com/kenwheeler/slick/issues/1470](https://github.com/kenwheeler/slick/issues/1470)\n","source":"_posts/iOS的iframe宽度bug.md","raw":"---\ntitle: iOS的iframe宽度bug\ndate: 2017-09-30\ntags: ['iOS','iframe','bug']\ncategories: ['工作总结']\n---\n## 问题背景\n最近做一个项目里，有一个使用了[slick](https://github.com/kenwheeler/slick)插件做轮播效果的页面，本身打开一切正常。后面这个页面被嵌在另一个页面的iframe下时，iframe的宽度设置为100%，在iOS里打开，页面就变得不正常了，轮播部分好像被放得很大，把其他元素挤出屏幕外，轮播来回切换，页面来回闪烁。\n<!--more-->\n## 产生原因\niOS下的safari是按照iframe里面页面元素的全尺寸来调整iframe的大小的。\n\n轮播效果的实现原理是将所有的幻灯片都放到一个块里面，然后设置溢出隐藏，在iOS的iframe下，结合上面第一条原因，就会将iframe撑得很大。\n## 解决方案\n### 方案一\n在包含轮播组件的元素上设置以下样式：\n````css\n{\n  width: 1px;\n  min-width: 100%;\n}\n````\n或者设置\n````css\n{\n  width: 100vw;\n}\n````\n### 方案二\n在iframe上设置以下样式\n````css\niframe {\n  width: 1px;\n  min-width: 100%;\n  *width: 100%;\n}\n````\n同时设置scrolling属性为'no'。\n````html\n<iframe height=\"950\" width=\"100%\" scrolling=\"no\" src=\"Content.html\"></iframe>\n````\n## 参考资料\n* [https://www.spacevatican.org/2015/4/7/on-mobile-safari-and-iframes/](https://www.spacevatican.org/2015/4/7/on-mobile-safari-and-iframes/)\n* [https://stackoverflow.com/questions/20123960/how-to-get-iframe-width-100-in-iphone-portrait-view](https://stackoverflow.com/questions/20123960/how-to-get-iframe-width-100-in-iphone-portrait-view)\n* [https://stackoverflow.com/questions/23083462/how-to-get-an-iframe-to-be-responsive-in-ios-safari](https://stackoverflow.com/questions/23083462/how-to-get-an-iframe-to-be-responsive-in-ios-safari)\n* [https://github.com/kenwheeler/slick/issues/1470](https://github.com/kenwheeler/slick/issues/1470)\n","slug":"iOS的iframe宽度bug","published":1,"updated":"2022-04-13T14:14:07.778Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfgc004eg3t8wttlb6xl","content":"<h2 id=\"问题背景\"><a href=\"#问题背景\" class=\"headerlink\" title=\"问题背景\"></a>问题背景</h2><p>最近做一个项目里，有一个使用了<a href=\"https://github.com/kenwheeler/slick\" target=\"_blank\" rel=\"noopener\">slick</a>插件做轮播效果的页面，本身打开一切正常。后面这个页面被嵌在另一个页面的iframe下时，iframe的宽度设置为100%，在iOS里打开，页面就变得不正常了，轮播部分好像被放得很大，把其他元素挤出屏幕外，轮播来回切换，页面来回闪烁。<br><a id=\"more\"></a></p>\n<h2 id=\"产生原因\"><a href=\"#产生原因\" class=\"headerlink\" title=\"产生原因\"></a>产生原因</h2><p>iOS下的safari是按照iframe里面页面元素的全尺寸来调整iframe的大小的。</p>\n<p>轮播效果的实现原理是将所有的幻灯片都放到一个块里面，然后设置溢出隐藏，在iOS的iframe下，结合上面第一条原因，就会将iframe撑得很大。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><h3 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h3><p>在包含轮播组件的元素上设置以下样式：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">min-width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>或者设置<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100vw</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h3><p>在iframe上设置以下样式<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">iframe</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">min-width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  *width: 100%;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同时设置scrolling属性为’no’。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">height</span>=<span class=\"string\">\"950\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"100%\"</span> <span class=\"attr\">scrolling</span>=<span class=\"string\">\"no\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Content.html\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://www.spacevatican.org/2015/4/7/on-mobile-safari-and-iframes/\" target=\"_blank\" rel=\"noopener\">https://www.spacevatican.org/2015/4/7/on-mobile-safari-and-iframes/</a></li>\n<li><a href=\"https://stackoverflow.com/questions/20123960/how-to-get-iframe-width-100-in-iphone-portrait-view\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/20123960/how-to-get-iframe-width-100-in-iphone-portrait-view</a></li>\n<li><a href=\"https://stackoverflow.com/questions/23083462/how-to-get-an-iframe-to-be-responsive-in-ios-safari\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/23083462/how-to-get-an-iframe-to-be-responsive-in-ios-safari</a></li>\n<li><a href=\"https://github.com/kenwheeler/slick/issues/1470\" target=\"_blank\" rel=\"noopener\">https://github.com/kenwheeler/slick/issues/1470</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"问题背景\"><a href=\"#问题背景\" class=\"headerlink\" title=\"问题背景\"></a>问题背景</h2><p>最近做一个项目里，有一个使用了<a href=\"https://github.com/kenwheeler/slick\" target=\"_blank\" rel=\"noopener\">slick</a>插件做轮播效果的页面，本身打开一切正常。后面这个页面被嵌在另一个页面的iframe下时，iframe的宽度设置为100%，在iOS里打开，页面就变得不正常了，轮播部分好像被放得很大，把其他元素挤出屏幕外，轮播来回切换，页面来回闪烁。<br>","more":"</p>\n<h2 id=\"产生原因\"><a href=\"#产生原因\" class=\"headerlink\" title=\"产生原因\"></a>产生原因</h2><p>iOS下的safari是按照iframe里面页面元素的全尺寸来调整iframe的大小的。</p>\n<p>轮播效果的实现原理是将所有的幻灯片都放到一个块里面，然后设置溢出隐藏，在iOS的iframe下，结合上面第一条原因，就会将iframe撑得很大。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><h3 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h3><p>在包含轮播组件的元素上设置以下样式：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">min-width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>或者设置<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100vw</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h3><p>在iframe上设置以下样式<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">iframe</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">min-width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  *width: 100%;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同时设置scrolling属性为’no’。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">height</span>=<span class=\"string\">\"950\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"100%\"</span> <span class=\"attr\">scrolling</span>=<span class=\"string\">\"no\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"Content.html\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://www.spacevatican.org/2015/4/7/on-mobile-safari-and-iframes/\" target=\"_blank\" rel=\"noopener\">https://www.spacevatican.org/2015/4/7/on-mobile-safari-and-iframes/</a></li>\n<li><a href=\"https://stackoverflow.com/questions/20123960/how-to-get-iframe-width-100-in-iphone-portrait-view\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/20123960/how-to-get-iframe-width-100-in-iphone-portrait-view</a></li>\n<li><a href=\"https://stackoverflow.com/questions/23083462/how-to-get-an-iframe-to-be-responsive-in-ios-safari\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/23083462/how-to-get-an-iframe-to-be-responsive-in-ios-safari</a></li>\n<li><a href=\"https://github.com/kenwheeler/slick/issues/1470\" target=\"_blank\" rel=\"noopener\">https://github.com/kenwheeler/slick/issues/1470</a></li>\n</ul>"},{"title":"浏览器缓存原理","date":"2018-11-09T16:00:00.000Z","_content":"## 浏览器缓存\n当浏览器请求一个网站的时候，会加载各种各样的资源，比如：HTML文档、图片、CSS和JS等文件。对于一些不经常变的内容，浏览器会将他们保存在本地的文件中，下次访问相同网站的时候，直接加载这些资源，加速访问。\n<!--more-->\n所以缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。那么浏览器缓存就是浏览器请求网站留下的资源副本。\n### 缓存的好处\n* 缓解服务器压力(不用每次去请求资源)；\n* 提升性能(打开本地资源速度当然比请求回来再打开要快得多)；\n* 减少带宽消耗； \n\n\n## 浏览器的缓存策略\n\n### 强缓存\n\n强缓存策略就是给浏览器缓存设置过期时间，超过这个时间之后缓存就是过期,浏览器需要重新请求。\n\n**强缓存主要是通过http请求头中的Cache-Control和Expires两个字段控制。**\n\n* expires\n\nexpires是一个HTTP/1.0的字段,它给浏览器设置了一个绝对时间，当浏览器时间超过这个绝对时间之后，重新向服务器发送请求。\n\n用法：它描述的是一个绝对时间,用GMT格式的字符串表示\n````javascript\nExpires: Wed Feb 20 2019 11:25:41 GMT\n````\n也可在html文件的meta标签里面使用\n````html\n<meta http-equiv=\"expires\" content=\"Wed Feb 20 2019 11:25:41 GMT\">\n````\n缺点：Expires返回的是服务器的时间，但判断的时候用的却是客户端的时间，这就导致Expires很被动，因为客户端时间和服务器端时间可能有误差，或者用户有可能改变客户端的时间，导致缓存时间判断出错，这也是引入Cache-Control:max-age指令的原因之一。\n\n* cache-control: max-age\n\n为了解决expires存在的问题，Http1.1版本中提出了cache-control:max-age，该字段与expires的缓存思路相同，都是设置了一个过期时间，不同的是max-age设置的是相对缓存时间开始往后的多少秒，因此不再受日期不准确情况的影响。\n\n\n用法：传入秒数\n````javascript\nCache-control: max-age=666\n````\n表示资源会在第一次加载之后的 666 秒后过期，需要再次请求。\n\n* 优先级\n\nmax-age>Expires。当两者同时出现在响应头时,Expires将被max-age覆盖。\n\n* 强缓存在浏览器上的表现\n\nFirefox浏览器对强缓存表现为一个灰色的200状态码。\nChrome浏览器状态码表现为:200 (from disk cache)或是200 OK (from memory cache)\n\n关于缓存是从磁盘中获取还是从内存中获取：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，磁盘的使用率很高会暂时放在内存里面。这就可以比较合理的解释了为什么同一个资源有时是from memory cache有时是from disk cache的问题了。\n\n强制缓存的处理策略较为简单粗暴，如果在过期时间内缓存的资源在服务器上更新了，客服端不能及时获取最新的资源。这时怎么办?于是就有了协商缓存。\n### 协商缓存\n协商缓存解决了无法及时获取更新资源的问题。它利用http首部的两组字段,对资源做标识.然后由服务器做分析，如果资源未更新，则返回304状态码.那么浏览器则会从缓存中读取资源，否则重新请求资源。\n\n**协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。**\n\n* Last-Modified与If-Modified-Since\n\n通过告知客户端上次修改资源的时间来控制缓存。\n\n策略步骤：\n\n1. 浏览器第一次向服务器请求资源，服务器会在返回这个资源的同时，在response的header加上Last-Modified的header,这个header表示这个资源在服务器上的最后修改时间：Last-Modified: Wed Feb 20 2019 14:08:32 GMT\n2. 浏览器之后再向服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值：Last-Modified: Wed Feb 20 2019 14:08:32 GMT\n3. 服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化,返回200，就正常返回资源内容。\n\n    当服务器返回304 Not Modified的响应时，response的header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header.\n\n4. 浏览器收到304的响应后，就会从缓存中加载资源。\n5. 浏览器收到200的响应后，则从服务器加载新资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。\n\n一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来。又或者因为这对首部字段是以秒为单位进行更新，如果浏览器资源以小于该单位进行高频更新的话，则不适合采用该方法。\n\n而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是 ETag 和 If-None-Match。\n\n* ETag与If-None-Match\n\n通过对资源的进行特殊标识，来判断资源是否过期。\n\nETag服务器默认采用SHA256算法生成。\n\n策略步骤：\n\n1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，ETag: shotcat-66666只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题。\n2. 浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值If-None-Match: shotcat-66666。\n3. 服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，则返回200,并正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。\n4. 浏览器收到304的响应后，就会从缓存中加载资源。\n5. 浏览器收到200的响应后，则从服务器加载新资源时，ETag在重新加载的时候会被更新，下次请求时，If-None-Match会启用上次返回的ETag值。\n\n* 优先级\n\nETag与If-None-Match > Last-Modified与If-Modified-Since, 同时存在时, 前者覆盖后者。\n\n有一种场景需要注意：\n\n分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败。\n\n分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）。\n\n### 强缓存和协商缓存的区别\n协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。\n\n### 启发式缓存\n\n当请求头中确定缓存过期时间的字段一个都没有，此时则会默认触发浏览器启发式缓存:\n\n**浏览器会根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。**\n### 缓存的优先级\n在缓存策略上:强缓存>协商缓存>启发式缓存\n\nCache-Control > Expires > ETag > Last-Modified\n\n如果Cache-Control为no-store.则浏览器 所有内容都不会缓存，强制缓存，协商缓存统统都不会触发。\n## 浏览器缓存判断流程\n![http文件缓存判断机制流程](https://i.loli.net/2019/03/05/5c7e7bced3174.jpg)\n## HTTP中和缓存相关的首部字段\n\nHTTP报文,主要由以下两部分构成：\n1. 首部(header)：包含了很多字段，比如：cookie、缓存、报文大小、报文格式等等）。\n2. 主体(body)：HTTP请求真正要传输的部分，比如：一个HTML文档，一个js文件。\n\n1. 通用首部字段\n\n|字段名称|说明|\n|----|----|\n|Cache-Control|控制缓存具体的行为|\n|Pragma|HTTP1.0时的遗留字段，当值为\"no-cache\"时强制验证缓存|\n|Date|创建报文的日期时间(启发式缓存阶段会用到这个字段)|\n\n2. 响应首部字段\n\n|字段名称|说明|\n|----|----|\n|ETag|服务器生成资源的唯一标识|\n|Vary|代理服务器缓存的管理信息|\n|Age|资源在缓存代理中存贮的时长(取决于max-age和s-maxage的大小)|\n\n3. 请求首部字段\n\n|字段名称|说明|\n|----|----|\n|If-Match|条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断文件是否有新的修改|\n|If-None-Match|和If-Match作用相反，服务器根据这个字段判断文件是否有新的修改|\n|If-Modified-Since|比较资源前后两次访问最后的修改时间是否一致|\n|If-Unmodified-Since|比较资源前后两次访问最后的修改时间是否一致|\n\n4. 实体首部字段\n\n|字段名称|说明|\n|----|----|\n|Expires|告知客户端资源缓存失效的绝对时间\n|Last-Modified|资源最后一次修改的时间|\n## 用户操作行为对缓存的影响\n\n|操作|说明|\n|----|----|\n|打开新窗口|如果指定cache-control的值为private、no-cache、must-revalidate,那么打开新窗口访问时都会重新访问服务器。而如果指定了max-age值,那么在此值内的时间里就不会重新访问服务器,例如：Cache-control: max-age=5 表示当访问此网页后的5秒内不会去再次访问服务器.|\n|在地址栏回车|如果值为private或must-revalidate,则只有第一次访问时会访问服务器,以后就不再访问。如果值为no-cache,那么每次都会访问。如果值为max-age,则在过期之前不会重复访问。|\n|按后退按扭|如果值为private、must-revalidate、max-age,则不会重访问,而如果为no-cache,则每次都重复访问.|\n|按刷新按扭|无论为何值,都会重复访问.（可能返回状态码：200、304，这个不同浏览器处理是不一样的，FireFox正常，Chrome则会启用缓存(200 from cache)）|\n|按强制刷新按钮|当做首次进入重新请求(返回状态码200)|\n\n## 合理应用缓存\n于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略\n\n* 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存\n* 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。\n* 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。\n\n\n## 参考资料\n* [缓存详解](https://juejin.im/post/5a6c87c46fb9a01ca560b4d7)\n* [浏览器缓存](https://juejin.im/post/5c6c9c99f265da2d896326ae)","source":"_posts/浏览器缓存原理.md","raw":"---\ntitle: 浏览器缓存原理\ndate: 2018-11-10\ntags: ['cache', '浏览器']\ncategories: ['浏览器']\n---\n## 浏览器缓存\n当浏览器请求一个网站的时候，会加载各种各样的资源，比如：HTML文档、图片、CSS和JS等文件。对于一些不经常变的内容，浏览器会将他们保存在本地的文件中，下次访问相同网站的时候，直接加载这些资源，加速访问。\n<!--more-->\n所以缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。那么浏览器缓存就是浏览器请求网站留下的资源副本。\n### 缓存的好处\n* 缓解服务器压力(不用每次去请求资源)；\n* 提升性能(打开本地资源速度当然比请求回来再打开要快得多)；\n* 减少带宽消耗； \n\n\n## 浏览器的缓存策略\n\n### 强缓存\n\n强缓存策略就是给浏览器缓存设置过期时间，超过这个时间之后缓存就是过期,浏览器需要重新请求。\n\n**强缓存主要是通过http请求头中的Cache-Control和Expires两个字段控制。**\n\n* expires\n\nexpires是一个HTTP/1.0的字段,它给浏览器设置了一个绝对时间，当浏览器时间超过这个绝对时间之后，重新向服务器发送请求。\n\n用法：它描述的是一个绝对时间,用GMT格式的字符串表示\n````javascript\nExpires: Wed Feb 20 2019 11:25:41 GMT\n````\n也可在html文件的meta标签里面使用\n````html\n<meta http-equiv=\"expires\" content=\"Wed Feb 20 2019 11:25:41 GMT\">\n````\n缺点：Expires返回的是服务器的时间，但判断的时候用的却是客户端的时间，这就导致Expires很被动，因为客户端时间和服务器端时间可能有误差，或者用户有可能改变客户端的时间，导致缓存时间判断出错，这也是引入Cache-Control:max-age指令的原因之一。\n\n* cache-control: max-age\n\n为了解决expires存在的问题，Http1.1版本中提出了cache-control:max-age，该字段与expires的缓存思路相同，都是设置了一个过期时间，不同的是max-age设置的是相对缓存时间开始往后的多少秒，因此不再受日期不准确情况的影响。\n\n\n用法：传入秒数\n````javascript\nCache-control: max-age=666\n````\n表示资源会在第一次加载之后的 666 秒后过期，需要再次请求。\n\n* 优先级\n\nmax-age>Expires。当两者同时出现在响应头时,Expires将被max-age覆盖。\n\n* 强缓存在浏览器上的表现\n\nFirefox浏览器对强缓存表现为一个灰色的200状态码。\nChrome浏览器状态码表现为:200 (from disk cache)或是200 OK (from memory cache)\n\n关于缓存是从磁盘中获取还是从内存中获取：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，磁盘的使用率很高会暂时放在内存里面。这就可以比较合理的解释了为什么同一个资源有时是from memory cache有时是from disk cache的问题了。\n\n强制缓存的处理策略较为简单粗暴，如果在过期时间内缓存的资源在服务器上更新了，客服端不能及时获取最新的资源。这时怎么办?于是就有了协商缓存。\n### 协商缓存\n协商缓存解决了无法及时获取更新资源的问题。它利用http首部的两组字段,对资源做标识.然后由服务器做分析，如果资源未更新，则返回304状态码.那么浏览器则会从缓存中读取资源，否则重新请求资源。\n\n**协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。**\n\n* Last-Modified与If-Modified-Since\n\n通过告知客户端上次修改资源的时间来控制缓存。\n\n策略步骤：\n\n1. 浏览器第一次向服务器请求资源，服务器会在返回这个资源的同时，在response的header加上Last-Modified的header,这个header表示这个资源在服务器上的最后修改时间：Last-Modified: Wed Feb 20 2019 14:08:32 GMT\n2. 浏览器之后再向服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值：Last-Modified: Wed Feb 20 2019 14:08:32 GMT\n3. 服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化,返回200，就正常返回资源内容。\n\n    当服务器返回304 Not Modified的响应时，response的header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header.\n\n4. 浏览器收到304的响应后，就会从缓存中加载资源。\n5. 浏览器收到200的响应后，则从服务器加载新资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。\n\n一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来。又或者因为这对首部字段是以秒为单位进行更新，如果浏览器资源以小于该单位进行高频更新的话，则不适合采用该方法。\n\n而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是 ETag 和 If-None-Match。\n\n* ETag与If-None-Match\n\n通过对资源的进行特殊标识，来判断资源是否过期。\n\nETag服务器默认采用SHA256算法生成。\n\n策略步骤：\n\n1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，ETag: shotcat-66666只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题。\n2. 浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值If-None-Match: shotcat-66666。\n3. 服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，则返回200,并正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。\n4. 浏览器收到304的响应后，就会从缓存中加载资源。\n5. 浏览器收到200的响应后，则从服务器加载新资源时，ETag在重新加载的时候会被更新，下次请求时，If-None-Match会启用上次返回的ETag值。\n\n* 优先级\n\nETag与If-None-Match > Last-Modified与If-Modified-Since, 同时存在时, 前者覆盖后者。\n\n有一种场景需要注意：\n\n分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败。\n\n分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）。\n\n### 强缓存和协商缓存的区别\n协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。\n\n### 启发式缓存\n\n当请求头中确定缓存过期时间的字段一个都没有，此时则会默认触发浏览器启发式缓存:\n\n**浏览器会根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。**\n### 缓存的优先级\n在缓存策略上:强缓存>协商缓存>启发式缓存\n\nCache-Control > Expires > ETag > Last-Modified\n\n如果Cache-Control为no-store.则浏览器 所有内容都不会缓存，强制缓存，协商缓存统统都不会触发。\n## 浏览器缓存判断流程\n![http文件缓存判断机制流程](https://i.loli.net/2019/03/05/5c7e7bced3174.jpg)\n## HTTP中和缓存相关的首部字段\n\nHTTP报文,主要由以下两部分构成：\n1. 首部(header)：包含了很多字段，比如：cookie、缓存、报文大小、报文格式等等）。\n2. 主体(body)：HTTP请求真正要传输的部分，比如：一个HTML文档，一个js文件。\n\n1. 通用首部字段\n\n|字段名称|说明|\n|----|----|\n|Cache-Control|控制缓存具体的行为|\n|Pragma|HTTP1.0时的遗留字段，当值为\"no-cache\"时强制验证缓存|\n|Date|创建报文的日期时间(启发式缓存阶段会用到这个字段)|\n\n2. 响应首部字段\n\n|字段名称|说明|\n|----|----|\n|ETag|服务器生成资源的唯一标识|\n|Vary|代理服务器缓存的管理信息|\n|Age|资源在缓存代理中存贮的时长(取决于max-age和s-maxage的大小)|\n\n3. 请求首部字段\n\n|字段名称|说明|\n|----|----|\n|If-Match|条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断文件是否有新的修改|\n|If-None-Match|和If-Match作用相反，服务器根据这个字段判断文件是否有新的修改|\n|If-Modified-Since|比较资源前后两次访问最后的修改时间是否一致|\n|If-Unmodified-Since|比较资源前后两次访问最后的修改时间是否一致|\n\n4. 实体首部字段\n\n|字段名称|说明|\n|----|----|\n|Expires|告知客户端资源缓存失效的绝对时间\n|Last-Modified|资源最后一次修改的时间|\n## 用户操作行为对缓存的影响\n\n|操作|说明|\n|----|----|\n|打开新窗口|如果指定cache-control的值为private、no-cache、must-revalidate,那么打开新窗口访问时都会重新访问服务器。而如果指定了max-age值,那么在此值内的时间里就不会重新访问服务器,例如：Cache-control: max-age=5 表示当访问此网页后的5秒内不会去再次访问服务器.|\n|在地址栏回车|如果值为private或must-revalidate,则只有第一次访问时会访问服务器,以后就不再访问。如果值为no-cache,那么每次都会访问。如果值为max-age,则在过期之前不会重复访问。|\n|按后退按扭|如果值为private、must-revalidate、max-age,则不会重访问,而如果为no-cache,则每次都重复访问.|\n|按刷新按扭|无论为何值,都会重复访问.（可能返回状态码：200、304，这个不同浏览器处理是不一样的，FireFox正常，Chrome则会启用缓存(200 from cache)）|\n|按强制刷新按钮|当做首次进入重新请求(返回状态码200)|\n\n## 合理应用缓存\n于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略\n\n* 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存\n* 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。\n* 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。\n\n\n## 参考资料\n* [缓存详解](https://juejin.im/post/5a6c87c46fb9a01ca560b4d7)\n* [浏览器缓存](https://juejin.im/post/5c6c9c99f265da2d896326ae)","slug":"浏览器缓存原理","published":1,"updated":"2022-04-13T14:14:08.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfgd004hg3t8uxal5ej7","content":"<h2 id=\"浏览器缓存\"><a href=\"#浏览器缓存\" class=\"headerlink\" title=\"浏览器缓存\"></a>浏览器缓存</h2><p>当浏览器请求一个网站的时候，会加载各种各样的资源，比如：HTML文档、图片、CSS和JS等文件。对于一些不经常变的内容，浏览器会将他们保存在本地的文件中，下次访问相同网站的时候，直接加载这些资源，加速访问。<br><a id=\"more\"></a><br>所以缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。那么浏览器缓存就是浏览器请求网站留下的资源副本。</p>\n<h3 id=\"缓存的好处\"><a href=\"#缓存的好处\" class=\"headerlink\" title=\"缓存的好处\"></a>缓存的好处</h3><ul>\n<li>缓解服务器压力(不用每次去请求资源)；</li>\n<li>提升性能(打开本地资源速度当然比请求回来再打开要快得多)；</li>\n<li>减少带宽消耗； </li>\n</ul>\n<h2 id=\"浏览器的缓存策略\"><a href=\"#浏览器的缓存策略\" class=\"headerlink\" title=\"浏览器的缓存策略\"></a>浏览器的缓存策略</h2><h3 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h3><p>强缓存策略就是给浏览器缓存设置过期时间，超过这个时间之后缓存就是过期,浏览器需要重新请求。</p>\n<p><strong>强缓存主要是通过http请求头中的Cache-Control和Expires两个字段控制。</strong></p>\n<ul>\n<li>expires</li>\n</ul>\n<p>expires是一个HTTP/1.0的字段,它给浏览器设置了一个绝对时间，当浏览器时间超过这个绝对时间之后，重新向服务器发送请求。</p>\n<p>用法：它描述的是一个绝对时间,用GMT格式的字符串表示<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Expires: Wed Feb <span class=\"number\">20</span> <span class=\"number\">2019</span> <span class=\"number\">11</span>:<span class=\"number\">25</span>:<span class=\"number\">41</span> GMT</span><br></pre></td></tr></table></figure></p>\n<p>也可在html文件的meta标签里面使用<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"expires\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"Wed Feb 20 2019 11:25:41 GMT\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>缺点：Expires返回的是服务器的时间，但判断的时候用的却是客户端的时间，这就导致Expires很被动，因为客户端时间和服务器端时间可能有误差，或者用户有可能改变客户端的时间，导致缓存时间判断出错，这也是引入Cache-Control:max-age指令的原因之一。</p>\n<ul>\n<li>cache-control: max-age</li>\n</ul>\n<p>为了解决expires存在的问题，Http1.1版本中提出了cache-control:max-age，该字段与expires的缓存思路相同，都是设置了一个过期时间，不同的是max-age设置的是相对缓存时间开始往后的多少秒，因此不再受日期不准确情况的影响。</p>\n<p>用法：传入秒数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-control: max-age=<span class=\"number\">666</span></span><br></pre></td></tr></table></figure></p>\n<p>表示资源会在第一次加载之后的 666 秒后过期，需要再次请求。</p>\n<ul>\n<li>优先级</li>\n</ul>\n<p>max-age&gt;Expires。当两者同时出现在响应头时,Expires将被max-age覆盖。</p>\n<ul>\n<li>强缓存在浏览器上的表现</li>\n</ul>\n<p>Firefox浏览器对强缓存表现为一个灰色的200状态码。<br>Chrome浏览器状态码表现为:200 (from disk cache)或是200 OK (from memory cache)</p>\n<p>关于缓存是从磁盘中获取还是从内存中获取：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，磁盘的使用率很高会暂时放在内存里面。这就可以比较合理的解释了为什么同一个资源有时是from memory cache有时是from disk cache的问题了。</p>\n<p>强制缓存的处理策略较为简单粗暴，如果在过期时间内缓存的资源在服务器上更新了，客服端不能及时获取最新的资源。这时怎么办?于是就有了协商缓存。</p>\n<h3 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h3><p>协商缓存解决了无法及时获取更新资源的问题。它利用http首部的两组字段,对资源做标识.然后由服务器做分析，如果资源未更新，则返回304状态码.那么浏览器则会从缓存中读取资源，否则重新请求资源。</p>\n<p><strong>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。</strong></p>\n<ul>\n<li>Last-Modified与If-Modified-Since</li>\n</ul>\n<p>通过告知客户端上次修改资源的时间来控制缓存。</p>\n<p>策略步骤：</p>\n<ol>\n<li>浏览器第一次向服务器请求资源，服务器会在返回这个资源的同时，在response的header加上Last-Modified的header,这个header表示这个资源在服务器上的最后修改时间：Last-Modified: Wed Feb 20 2019 14:08:32 GMT</li>\n<li>浏览器之后再向服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值：Last-Modified: Wed Feb 20 2019 14:08:32 GMT</li>\n<li><p>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化,返回200，就正常返回资源内容。</p>\n<p> 当服务器返回304 Not Modified的响应时，response的header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header.</p>\n</li>\n<li><p>浏览器收到304的响应后，就会从缓存中加载资源。</p>\n</li>\n<li>浏览器收到200的响应后，则从服务器加载新资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。</li>\n</ol>\n<p>一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来。又或者因为这对首部字段是以秒为单位进行更新，如果浏览器资源以小于该单位进行高频更新的话，则不适合采用该方法。</p>\n<p>而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是 ETag 和 If-None-Match。</p>\n<ul>\n<li>ETag与If-None-Match</li>\n</ul>\n<p>通过对资源的进行特殊标识，来判断资源是否过期。</p>\n<p>ETag服务器默认采用SHA256算法生成。</p>\n<p>策略步骤：</p>\n<ol>\n<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，ETag: shotcat-66666只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题。</li>\n<li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值If-None-Match: shotcat-66666。</li>\n<li>服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，则返回200,并正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。</li>\n<li>浏览器收到304的响应后，就会从缓存中加载资源。</li>\n<li>浏览器收到200的响应后，则从服务器加载新资源时，ETag在重新加载的时候会被更新，下次请求时，If-None-Match会启用上次返回的ETag值。</li>\n</ol>\n<ul>\n<li>优先级</li>\n</ul>\n<p>ETag与If-None-Match &gt; Last-Modified与If-Modified-Since, 同时存在时, 前者覆盖后者。</p>\n<p>有一种场景需要注意：</p>\n<p>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败。</p>\n<p>分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）。</p>\n<h3 id=\"强缓存和协商缓存的区别\"><a href=\"#强缓存和协商缓存的区别\" class=\"headerlink\" title=\"强缓存和协商缓存的区别\"></a>强缓存和协商缓存的区别</h3><p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。</p>\n<h3 id=\"启发式缓存\"><a href=\"#启发式缓存\" class=\"headerlink\" title=\"启发式缓存\"></a>启发式缓存</h3><p>当请求头中确定缓存过期时间的字段一个都没有，此时则会默认触发浏览器启发式缓存:</p>\n<p><strong>浏览器会根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。</strong></p>\n<h3 id=\"缓存的优先级\"><a href=\"#缓存的优先级\" class=\"headerlink\" title=\"缓存的优先级\"></a>缓存的优先级</h3><p>在缓存策略上:强缓存&gt;协商缓存&gt;启发式缓存</p>\n<p>Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified</p>\n<p>如果Cache-Control为no-store.则浏览器 所有内容都不会缓存，强制缓存，协商缓存统统都不会触发。</p>\n<h2 id=\"浏览器缓存判断流程\"><a href=\"#浏览器缓存判断流程\" class=\"headerlink\" title=\"浏览器缓存判断流程\"></a>浏览器缓存判断流程</h2><p><img src=\"https://i.loli.net/2019/03/05/5c7e7bced3174.jpg\" alt=\"http文件缓存判断机制流程\"></p>\n<h2 id=\"HTTP中和缓存相关的首部字段\"><a href=\"#HTTP中和缓存相关的首部字段\" class=\"headerlink\" title=\"HTTP中和缓存相关的首部字段\"></a>HTTP中和缓存相关的首部字段</h2><p>HTTP报文,主要由以下两部分构成：</p>\n<ol>\n<li>首部(header)：包含了很多字段，比如：cookie、缓存、报文大小、报文格式等等）。</li>\n<li><p>主体(body)：HTTP请求真正要传输的部分，比如：一个HTML文档，一个js文件。</p>\n</li>\n<li><p>通用首部字段</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>字段名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Cache-Control</td>\n<td>控制缓存具体的行为</td>\n</tr>\n<tr>\n<td>Pragma</td>\n<td>HTTP1.0时的遗留字段，当值为”no-cache”时强制验证缓存</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>创建报文的日期时间(启发式缓存阶段会用到这个字段)</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"2\">\n<li>响应首部字段</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>字段名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ETag</td>\n<td>服务器生成资源的唯一标识</td>\n</tr>\n<tr>\n<td>Vary</td>\n<td>代理服务器缓存的管理信息</td>\n</tr>\n<tr>\n<td>Age</td>\n<td>资源在缓存代理中存贮的时长(取决于max-age和s-maxage的大小)</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"3\">\n<li>请求首部字段</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>字段名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>If-Match</td>\n<td>条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断文件是否有新的修改</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>和If-Match作用相反，服务器根据这个字段判断文件是否有新的修改</td>\n</tr>\n<tr>\n<td>If-Modified-Since</td>\n<td>比较资源前后两次访问最后的修改时间是否一致</td>\n</tr>\n<tr>\n<td>If-Unmodified-Since</td>\n<td>比较资源前后两次访问最后的修改时间是否一致</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"4\">\n<li>实体首部字段</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>字段名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Expires</td>\n<td>告知客户端资源缓存失效的绝对时间</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>资源最后一次修改的时间</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"用户操作行为对缓存的影响\"><a href=\"#用户操作行为对缓存的影响\" class=\"headerlink\" title=\"用户操作行为对缓存的影响\"></a>用户操作行为对缓存的影响</h2><table>\n<thead>\n<tr>\n<th>操作</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>打开新窗口</td>\n<td>如果指定cache-control的值为private、no-cache、must-revalidate,那么打开新窗口访问时都会重新访问服务器。而如果指定了max-age值,那么在此值内的时间里就不会重新访问服务器,例如：Cache-control: max-age=5 表示当访问此网页后的5秒内不会去再次访问服务器.</td>\n</tr>\n<tr>\n<td>在地址栏回车</td>\n<td>如果值为private或must-revalidate,则只有第一次访问时会访问服务器,以后就不再访问。如果值为no-cache,那么每次都会访问。如果值为max-age,则在过期之前不会重复访问。</td>\n</tr>\n<tr>\n<td>按后退按扭</td>\n<td>如果值为private、must-revalidate、max-age,则不会重访问,而如果为no-cache,则每次都重复访问.</td>\n</tr>\n<tr>\n<td>按刷新按扭</td>\n<td>无论为何值,都会重复访问.（可能返回状态码：200、304，这个不同浏览器处理是不一样的，FireFox正常，Chrome则会启用缓存(200 from cache)）</td>\n</tr>\n<tr>\n<td>按强制刷新按钮</td>\n<td>当做首次进入重新请求(返回状态码200)</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"合理应用缓存\"><a href=\"#合理应用缓存\" class=\"headerlink\" title=\"合理应用缓存\"></a>合理应用缓存</h2><p>于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p>\n<ul>\n<li>对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存</li>\n<li>对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li>\n<li>对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://juejin.im/post/5a6c87c46fb9a01ca560b4d7\" target=\"_blank\" rel=\"noopener\">缓存详解</a></li>\n<li><a href=\"https://juejin.im/post/5c6c9c99f265da2d896326ae\" target=\"_blank\" rel=\"noopener\">浏览器缓存</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"浏览器缓存\"><a href=\"#浏览器缓存\" class=\"headerlink\" title=\"浏览器缓存\"></a>浏览器缓存</h2><p>当浏览器请求一个网站的时候，会加载各种各样的资源，比如：HTML文档、图片、CSS和JS等文件。对于一些不经常变的内容，浏览器会将他们保存在本地的文件中，下次访问相同网站的时候，直接加载这些资源，加速访问。<br>","more":"<br>所以缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。那么浏览器缓存就是浏览器请求网站留下的资源副本。</p>\n<h3 id=\"缓存的好处\"><a href=\"#缓存的好处\" class=\"headerlink\" title=\"缓存的好处\"></a>缓存的好处</h3><ul>\n<li>缓解服务器压力(不用每次去请求资源)；</li>\n<li>提升性能(打开本地资源速度当然比请求回来再打开要快得多)；</li>\n<li>减少带宽消耗； </li>\n</ul>\n<h2 id=\"浏览器的缓存策略\"><a href=\"#浏览器的缓存策略\" class=\"headerlink\" title=\"浏览器的缓存策略\"></a>浏览器的缓存策略</h2><h3 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h3><p>强缓存策略就是给浏览器缓存设置过期时间，超过这个时间之后缓存就是过期,浏览器需要重新请求。</p>\n<p><strong>强缓存主要是通过http请求头中的Cache-Control和Expires两个字段控制。</strong></p>\n<ul>\n<li>expires</li>\n</ul>\n<p>expires是一个HTTP/1.0的字段,它给浏览器设置了一个绝对时间，当浏览器时间超过这个绝对时间之后，重新向服务器发送请求。</p>\n<p>用法：它描述的是一个绝对时间,用GMT格式的字符串表示<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Expires: Wed Feb <span class=\"number\">20</span> <span class=\"number\">2019</span> <span class=\"number\">11</span>:<span class=\"number\">25</span>:<span class=\"number\">41</span> GMT</span><br></pre></td></tr></table></figure></p>\n<p>也可在html文件的meta标签里面使用<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"expires\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"Wed Feb 20 2019 11:25:41 GMT\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>缺点：Expires返回的是服务器的时间，但判断的时候用的却是客户端的时间，这就导致Expires很被动，因为客户端时间和服务器端时间可能有误差，或者用户有可能改变客户端的时间，导致缓存时间判断出错，这也是引入Cache-Control:max-age指令的原因之一。</p>\n<ul>\n<li>cache-control: max-age</li>\n</ul>\n<p>为了解决expires存在的问题，Http1.1版本中提出了cache-control:max-age，该字段与expires的缓存思路相同，都是设置了一个过期时间，不同的是max-age设置的是相对缓存时间开始往后的多少秒，因此不再受日期不准确情况的影响。</p>\n<p>用法：传入秒数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-control: max-age=<span class=\"number\">666</span></span><br></pre></td></tr></table></figure></p>\n<p>表示资源会在第一次加载之后的 666 秒后过期，需要再次请求。</p>\n<ul>\n<li>优先级</li>\n</ul>\n<p>max-age&gt;Expires。当两者同时出现在响应头时,Expires将被max-age覆盖。</p>\n<ul>\n<li>强缓存在浏览器上的表现</li>\n</ul>\n<p>Firefox浏览器对强缓存表现为一个灰色的200状态码。<br>Chrome浏览器状态码表现为:200 (from disk cache)或是200 OK (from memory cache)</p>\n<p>关于缓存是从磁盘中获取还是从内存中获取：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，磁盘的使用率很高会暂时放在内存里面。这就可以比较合理的解释了为什么同一个资源有时是from memory cache有时是from disk cache的问题了。</p>\n<p>强制缓存的处理策略较为简单粗暴，如果在过期时间内缓存的资源在服务器上更新了，客服端不能及时获取最新的资源。这时怎么办?于是就有了协商缓存。</p>\n<h3 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h3><p>协商缓存解决了无法及时获取更新资源的问题。它利用http首部的两组字段,对资源做标识.然后由服务器做分析，如果资源未更新，则返回304状态码.那么浏览器则会从缓存中读取资源，否则重新请求资源。</p>\n<p><strong>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。</strong></p>\n<ul>\n<li>Last-Modified与If-Modified-Since</li>\n</ul>\n<p>通过告知客户端上次修改资源的时间来控制缓存。</p>\n<p>策略步骤：</p>\n<ol>\n<li>浏览器第一次向服务器请求资源，服务器会在返回这个资源的同时，在response的header加上Last-Modified的header,这个header表示这个资源在服务器上的最后修改时间：Last-Modified: Wed Feb 20 2019 14:08:32 GMT</li>\n<li>浏览器之后再向服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值：Last-Modified: Wed Feb 20 2019 14:08:32 GMT</li>\n<li><p>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化,返回200，就正常返回资源内容。</p>\n<p> 当服务器返回304 Not Modified的响应时，response的header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header.</p>\n</li>\n<li><p>浏览器收到304的响应后，就会从缓存中加载资源。</p>\n</li>\n<li>浏览器收到200的响应后，则从服务器加载新资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。</li>\n</ol>\n<p>一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来。又或者因为这对首部字段是以秒为单位进行更新，如果浏览器资源以小于该单位进行高频更新的话，则不适合采用该方法。</p>\n<p>而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是 ETag 和 If-None-Match。</p>\n<ul>\n<li>ETag与If-None-Match</li>\n</ul>\n<p>通过对资源的进行特殊标识，来判断资源是否过期。</p>\n<p>ETag服务器默认采用SHA256算法生成。</p>\n<p>策略步骤：</p>\n<ol>\n<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，ETag: shotcat-66666只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题。</li>\n<li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值If-None-Match: shotcat-66666。</li>\n<li>服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，则返回200,并正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。</li>\n<li>浏览器收到304的响应后，就会从缓存中加载资源。</li>\n<li>浏览器收到200的响应后，则从服务器加载新资源时，ETag在重新加载的时候会被更新，下次请求时，If-None-Match会启用上次返回的ETag值。</li>\n</ol>\n<ul>\n<li>优先级</li>\n</ul>\n<p>ETag与If-None-Match &gt; Last-Modified与If-Modified-Since, 同时存在时, 前者覆盖后者。</p>\n<p>有一种场景需要注意：</p>\n<p>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败。</p>\n<p>分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）。</p>\n<h3 id=\"强缓存和协商缓存的区别\"><a href=\"#强缓存和协商缓存的区别\" class=\"headerlink\" title=\"强缓存和协商缓存的区别\"></a>强缓存和协商缓存的区别</h3><p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。</p>\n<h3 id=\"启发式缓存\"><a href=\"#启发式缓存\" class=\"headerlink\" title=\"启发式缓存\"></a>启发式缓存</h3><p>当请求头中确定缓存过期时间的字段一个都没有，此时则会默认触发浏览器启发式缓存:</p>\n<p><strong>浏览器会根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。</strong></p>\n<h3 id=\"缓存的优先级\"><a href=\"#缓存的优先级\" class=\"headerlink\" title=\"缓存的优先级\"></a>缓存的优先级</h3><p>在缓存策略上:强缓存&gt;协商缓存&gt;启发式缓存</p>\n<p>Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified</p>\n<p>如果Cache-Control为no-store.则浏览器 所有内容都不会缓存，强制缓存，协商缓存统统都不会触发。</p>\n<h2 id=\"浏览器缓存判断流程\"><a href=\"#浏览器缓存判断流程\" class=\"headerlink\" title=\"浏览器缓存判断流程\"></a>浏览器缓存判断流程</h2><p><img src=\"https://i.loli.net/2019/03/05/5c7e7bced3174.jpg\" alt=\"http文件缓存判断机制流程\"></p>\n<h2 id=\"HTTP中和缓存相关的首部字段\"><a href=\"#HTTP中和缓存相关的首部字段\" class=\"headerlink\" title=\"HTTP中和缓存相关的首部字段\"></a>HTTP中和缓存相关的首部字段</h2><p>HTTP报文,主要由以下两部分构成：</p>\n<ol>\n<li>首部(header)：包含了很多字段，比如：cookie、缓存、报文大小、报文格式等等）。</li>\n<li><p>主体(body)：HTTP请求真正要传输的部分，比如：一个HTML文档，一个js文件。</p>\n</li>\n<li><p>通用首部字段</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>字段名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Cache-Control</td>\n<td>控制缓存具体的行为</td>\n</tr>\n<tr>\n<td>Pragma</td>\n<td>HTTP1.0时的遗留字段，当值为”no-cache”时强制验证缓存</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>创建报文的日期时间(启发式缓存阶段会用到这个字段)</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"2\">\n<li>响应首部字段</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>字段名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ETag</td>\n<td>服务器生成资源的唯一标识</td>\n</tr>\n<tr>\n<td>Vary</td>\n<td>代理服务器缓存的管理信息</td>\n</tr>\n<tr>\n<td>Age</td>\n<td>资源在缓存代理中存贮的时长(取决于max-age和s-maxage的大小)</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"3\">\n<li>请求首部字段</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>字段名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>If-Match</td>\n<td>条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断文件是否有新的修改</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>和If-Match作用相反，服务器根据这个字段判断文件是否有新的修改</td>\n</tr>\n<tr>\n<td>If-Modified-Since</td>\n<td>比较资源前后两次访问最后的修改时间是否一致</td>\n</tr>\n<tr>\n<td>If-Unmodified-Since</td>\n<td>比较资源前后两次访问最后的修改时间是否一致</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"4\">\n<li>实体首部字段</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>字段名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Expires</td>\n<td>告知客户端资源缓存失效的绝对时间</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>资源最后一次修改的时间</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"用户操作行为对缓存的影响\"><a href=\"#用户操作行为对缓存的影响\" class=\"headerlink\" title=\"用户操作行为对缓存的影响\"></a>用户操作行为对缓存的影响</h2><table>\n<thead>\n<tr>\n<th>操作</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>打开新窗口</td>\n<td>如果指定cache-control的值为private、no-cache、must-revalidate,那么打开新窗口访问时都会重新访问服务器。而如果指定了max-age值,那么在此值内的时间里就不会重新访问服务器,例如：Cache-control: max-age=5 表示当访问此网页后的5秒内不会去再次访问服务器.</td>\n</tr>\n<tr>\n<td>在地址栏回车</td>\n<td>如果值为private或must-revalidate,则只有第一次访问时会访问服务器,以后就不再访问。如果值为no-cache,那么每次都会访问。如果值为max-age,则在过期之前不会重复访问。</td>\n</tr>\n<tr>\n<td>按后退按扭</td>\n<td>如果值为private、must-revalidate、max-age,则不会重访问,而如果为no-cache,则每次都重复访问.</td>\n</tr>\n<tr>\n<td>按刷新按扭</td>\n<td>无论为何值,都会重复访问.（可能返回状态码：200、304，这个不同浏览器处理是不一样的，FireFox正常，Chrome则会启用缓存(200 from cache)）</td>\n</tr>\n<tr>\n<td>按强制刷新按钮</td>\n<td>当做首次进入重新请求(返回状态码200)</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"合理应用缓存\"><a href=\"#合理应用缓存\" class=\"headerlink\" title=\"合理应用缓存\"></a>合理应用缓存</h2><p>于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p>\n<ul>\n<li>对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存</li>\n<li>对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li>\n<li>对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://juejin.im/post/5a6c87c46fb9a01ca560b4d7\" target=\"_blank\" rel=\"noopener\">缓存详解</a></li>\n<li><a href=\"https://juejin.im/post/5c6c9c99f265da2d896326ae\" target=\"_blank\" rel=\"noopener\">浏览器缓存</a></li>\n</ul>"},{"title":"视网膜屏下的canvas清晰度处理","date":"2017-08-31T16:00:00.000Z","_content":"## 背景\n最近使用图表插件在移动端绘制canvas图表的时候，发现画出来的图很模糊。经过排查和查询相关资料，发现和视网膜屏设备的设备像素比有关。\n<!--more-->\n## 相关知识\n### canvas的width 和 canvas的style.width\nstyle.width是用来设定canvas元素在浏览器中被渲染的宽度（高度同理）\n````html\n<canvas style=\"border:1px solid;width:100px;height:100px;\"></canvas>\n````\n<canvas style=\"border:1px solid;width:100px;height:100px;\"></canvas>\n\nwidth属性是用来设置canvas元素里面画布的宽度\n````html\n<canvas style=\"border:1px solid;\" width=\"100px\" height=\"100px\"></canvas>\n````\n<canvas style=\"border:1px solid;\" width=\"100px\" height=\"100px\"></canvas>\n\n最终绘制出来的宽度 = 需要绘制的宽度 / 画布宽 * 画框宽\n\n可以看到在不同元素宽，画布宽下绘制出来的（0，0）到（100，100）效果是不一样的。\n<canvas id=\"diagonal1\" style=\"border:1px solid;display:inline-block;margin-right:35px\" width=\"100px\" height=\"100px\"></canvas><canvas id=\"diagonal2\" style=\"border:1px solid;width:200px;height:200px;display:inline-block;margin-right:35px\" width=\"100px\" height=\"100px\"></canvas><canvas id=\"diagonal3\" style=\"border:1px solid;width:200px;height:200px;display:inline-block\"></canvas>\n\n### 视网膜屏幕\n* 物理像素(physical pixel)\n\n物理像素又被称为设备像素，他是显示设备中一个最微小的物理部件。每个像素可以根据操作系统设置自己的颜色和亮度。\n\n* 设备独立像素(density-independent pixel)\n\n设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说CSS像素)，然后由相关系统转换为物理像素。\n\n* CSS像素\n\nCSS像素是一个抽像的单位，主要使用在浏览器上，用来精确度量Web页面上的内容。一般情况之下，CSS像素称为与设备无关的像素(device-independent pixel)，简称DIPs\n\n* 设备像素比(device pixel ratio)\n\n设备像素比简称为dpr，其定义了物理像素和设备独立像素的对应关系。它的值可以按下面的公式计算得到：\n\n    设备像素比 ＝ 物理像素 / 设备独立像素\n\n视网膜屏幕的dpr是大于1的，比如iphone6为2。\n\n以iphone6为例，在上面绘制canvas，绘制1px x 1px时，实际上是使用了2物理像素 x 2物理像素，所以看起来会有模糊的效果。\n## 解决思路\n将画布先放大dpr倍，画框维持不变，根据公式：最终绘制出来的宽度 = 需要绘制的宽度 / 画布宽 * 画框宽，可知，此时绘制出来的图像会缩小dpr * dpr倍，因为图像缩小了来显示，这样看就是清晰的，但是图像被缩小了。\n\n再调用canvas.scale(dpr, dpr),将canvas的绘图的值放大dpr * dpr倍，重新绘制,这样呈现出来的图像大小就是和原来一样，而且清晰的。此处理和视网膜屏幕下的1px处理是类似的。\n## 代码\n````javascript\nvar scaleFn = function(canvas, context, customWidth, customHeight) {\n  if(!canvas || !context) { throw new Error('Must pass in `canvas` and `context`.'); }\n\n  var width = customWidth ||\n              canvas.width ||\n              canvas.clientWidth;\n  var height = customHeight ||\n               canvas.height ||\n               canvas.clientHeight;\n  var deviceRatio = window.devicePixelRatio || 1;\n  var ratio = deviceRatio;\n\n  if (ratio !== 1) {\n    canvas.width = Math.round(width * ratio);\n    canvas.height = Math.round(height * ratio);\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n    context.scale(ratio, ratio);\n  }\n  return ratio;\n};\n````\n## 参考资料\n\n[https://www.html5rocks.com/en/tutorials/canvas/hidpi/](https://www.html5rocks.com/en/tutorials/canvas/hidpi/)\n[https://www.npmjs.com/package/canvas-dpi-scaler](https://www.npmjs.com/package/canvas-dpi-scaler)\n[https://bugs.chromium.org/p/chromium/issues/detail?id=277205](https://bugs.chromium.org/p/chromium/issues/detail?id=277205)\n\n<script type=\"text/javascript\">function drawDiagonal(id){var canvas=document.getElementById(id);\n    var context=canvas.getContext(\"2d\");\n    context.beginPath();\n    context.moveTo(0,0);\n    context.lineTo(100,100);\n    context.stroke();\n}\n\n    drawDiagonal(\"diagonal1\");\n    drawDiagonal(\"diagonal2\");\n    drawDiagonal(\"diagonal3\");\n</script>\n","source":"_posts/视网膜屏下的canvas清晰度处理.md","raw":"---\ntitle: 视网膜屏下的canvas清晰度处理\ndate: 2017-09-01\ntags: ['canvas','dpr']\ncategories: ['工作总结']\n---\n## 背景\n最近使用图表插件在移动端绘制canvas图表的时候，发现画出来的图很模糊。经过排查和查询相关资料，发现和视网膜屏设备的设备像素比有关。\n<!--more-->\n## 相关知识\n### canvas的width 和 canvas的style.width\nstyle.width是用来设定canvas元素在浏览器中被渲染的宽度（高度同理）\n````html\n<canvas style=\"border:1px solid;width:100px;height:100px;\"></canvas>\n````\n<canvas style=\"border:1px solid;width:100px;height:100px;\"></canvas>\n\nwidth属性是用来设置canvas元素里面画布的宽度\n````html\n<canvas style=\"border:1px solid;\" width=\"100px\" height=\"100px\"></canvas>\n````\n<canvas style=\"border:1px solid;\" width=\"100px\" height=\"100px\"></canvas>\n\n最终绘制出来的宽度 = 需要绘制的宽度 / 画布宽 * 画框宽\n\n可以看到在不同元素宽，画布宽下绘制出来的（0，0）到（100，100）效果是不一样的。\n<canvas id=\"diagonal1\" style=\"border:1px solid;display:inline-block;margin-right:35px\" width=\"100px\" height=\"100px\"></canvas><canvas id=\"diagonal2\" style=\"border:1px solid;width:200px;height:200px;display:inline-block;margin-right:35px\" width=\"100px\" height=\"100px\"></canvas><canvas id=\"diagonal3\" style=\"border:1px solid;width:200px;height:200px;display:inline-block\"></canvas>\n\n### 视网膜屏幕\n* 物理像素(physical pixel)\n\n物理像素又被称为设备像素，他是显示设备中一个最微小的物理部件。每个像素可以根据操作系统设置自己的颜色和亮度。\n\n* 设备独立像素(density-independent pixel)\n\n设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说CSS像素)，然后由相关系统转换为物理像素。\n\n* CSS像素\n\nCSS像素是一个抽像的单位，主要使用在浏览器上，用来精确度量Web页面上的内容。一般情况之下，CSS像素称为与设备无关的像素(device-independent pixel)，简称DIPs\n\n* 设备像素比(device pixel ratio)\n\n设备像素比简称为dpr，其定义了物理像素和设备独立像素的对应关系。它的值可以按下面的公式计算得到：\n\n    设备像素比 ＝ 物理像素 / 设备独立像素\n\n视网膜屏幕的dpr是大于1的，比如iphone6为2。\n\n以iphone6为例，在上面绘制canvas，绘制1px x 1px时，实际上是使用了2物理像素 x 2物理像素，所以看起来会有模糊的效果。\n## 解决思路\n将画布先放大dpr倍，画框维持不变，根据公式：最终绘制出来的宽度 = 需要绘制的宽度 / 画布宽 * 画框宽，可知，此时绘制出来的图像会缩小dpr * dpr倍，因为图像缩小了来显示，这样看就是清晰的，但是图像被缩小了。\n\n再调用canvas.scale(dpr, dpr),将canvas的绘图的值放大dpr * dpr倍，重新绘制,这样呈现出来的图像大小就是和原来一样，而且清晰的。此处理和视网膜屏幕下的1px处理是类似的。\n## 代码\n````javascript\nvar scaleFn = function(canvas, context, customWidth, customHeight) {\n  if(!canvas || !context) { throw new Error('Must pass in `canvas` and `context`.'); }\n\n  var width = customWidth ||\n              canvas.width ||\n              canvas.clientWidth;\n  var height = customHeight ||\n               canvas.height ||\n               canvas.clientHeight;\n  var deviceRatio = window.devicePixelRatio || 1;\n  var ratio = deviceRatio;\n\n  if (ratio !== 1) {\n    canvas.width = Math.round(width * ratio);\n    canvas.height = Math.round(height * ratio);\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n    context.scale(ratio, ratio);\n  }\n  return ratio;\n};\n````\n## 参考资料\n\n[https://www.html5rocks.com/en/tutorials/canvas/hidpi/](https://www.html5rocks.com/en/tutorials/canvas/hidpi/)\n[https://www.npmjs.com/package/canvas-dpi-scaler](https://www.npmjs.com/package/canvas-dpi-scaler)\n[https://bugs.chromium.org/p/chromium/issues/detail?id=277205](https://bugs.chromium.org/p/chromium/issues/detail?id=277205)\n\n<script type=\"text/javascript\">function drawDiagonal(id){var canvas=document.getElementById(id);\n    var context=canvas.getContext(\"2d\");\n    context.beginPath();\n    context.moveTo(0,0);\n    context.lineTo(100,100);\n    context.stroke();\n}\n\n    drawDiagonal(\"diagonal1\");\n    drawDiagonal(\"diagonal2\");\n    drawDiagonal(\"diagonal3\");\n</script>\n","slug":"视网膜屏下的canvas清晰度处理","published":1,"updated":"2022-04-13T14:14:08.109Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1ydvfqm007eg3t8znzjtr0c","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最近使用图表插件在移动端绘制canvas图表的时候，发现画出来的图很模糊。经过排查和查询相关资料，发现和视网膜屏设备的设备像素比有关。<br><a id=\"more\"></a></p>\n<h2 id=\"相关知识\"><a href=\"#相关知识\" class=\"headerlink\" title=\"相关知识\"></a>相关知识</h2><h3 id=\"canvas的width-和-canvas的style-width\"><a href=\"#canvas的width-和-canvas的style-width\" class=\"headerlink\" title=\"canvas的width 和 canvas的style.width\"></a>canvas的width 和 canvas的style.width</h3><p>style.width是用来设定canvas元素在浏览器中被渲染的宽度（高度同理）<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">style</span>=<span class=\"string\">\"border:1px solid;width:100px;height:100px;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<canvas style=\"border:1px solid;width:100px;height:100px;\"></canvas>\n\n<p>width属性是用来设置canvas元素里面画布的宽度<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">style</span>=<span class=\"string\">\"border:1px solid;\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"100px\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"100px\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<canvas style=\"border:1px solid;\" width=\"100px\" height=\"100px\"></canvas>\n\n<p>最终绘制出来的宽度 = 需要绘制的宽度 / 画布宽 * 画框宽</p>\n<p>可以看到在不同元素宽，画布宽下绘制出来的（0，0）到（100，100）效果是不一样的。</p>\n<canvas id=\"diagonal1\" style=\"border:1px solid;display:inline-block;margin-right:35px\" width=\"100px\" height=\"100px\"></canvas><canvas id=\"diagonal2\" style=\"border:1px solid;width:200px;height:200px;display:inline-block;margin-right:35px\" width=\"100px\" height=\"100px\"></canvas><canvas id=\"diagonal3\" style=\"border:1px solid;width:200px;height:200px;display:inline-block\"></canvas>\n\n<h3 id=\"视网膜屏幕\"><a href=\"#视网膜屏幕\" class=\"headerlink\" title=\"视网膜屏幕\"></a>视网膜屏幕</h3><ul>\n<li>物理像素(physical pixel)</li>\n</ul>\n<p>物理像素又被称为设备像素，他是显示设备中一个最微小的物理部件。每个像素可以根据操作系统设置自己的颜色和亮度。</p>\n<ul>\n<li>设备独立像素(density-independent pixel)</li>\n</ul>\n<p>设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说CSS像素)，然后由相关系统转换为物理像素。</p>\n<ul>\n<li>CSS像素</li>\n</ul>\n<p>CSS像素是一个抽像的单位，主要使用在浏览器上，用来精确度量Web页面上的内容。一般情况之下，CSS像素称为与设备无关的像素(device-independent pixel)，简称DIPs</p>\n<ul>\n<li>设备像素比(device pixel ratio)</li>\n</ul>\n<p>设备像素比简称为dpr，其定义了物理像素和设备独立像素的对应关系。它的值可以按下面的公式计算得到：</p>\n<pre><code>设备像素比 ＝ 物理像素 / 设备独立像素\n</code></pre><p>视网膜屏幕的dpr是大于1的，比如iphone6为2。</p>\n<p>以iphone6为例，在上面绘制canvas，绘制1px x 1px时，实际上是使用了2物理像素 x 2物理像素，所以看起来会有模糊的效果。</p>\n<h2 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h2><p>将画布先放大dpr倍，画框维持不变，根据公式：最终绘制出来的宽度 = 需要绘制的宽度 / 画布宽 <em> 画框宽，可知，此时绘制出来的图像会缩小dpr </em> dpr倍，因为图像缩小了来显示，这样看就是清晰的，但是图像被缩小了。</p>\n<p>再调用canvas.scale(dpr, dpr),将canvas的绘图的值放大dpr * dpr倍，重新绘制,这样呈现出来的图像大小就是和原来一样，而且清晰的。此处理和视网膜屏幕下的1px处理是类似的。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scaleFn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">canvas, context, customWidth, customHeight</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!canvas || !context) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Must pass in `canvas` and `context`.'</span>); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> width = customWidth ||</span><br><span class=\"line\">              canvas.width ||</span><br><span class=\"line\">              canvas.clientWidth;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> height = customHeight ||</span><br><span class=\"line\">               canvas.height ||</span><br><span class=\"line\">               canvas.clientHeight;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> deviceRatio = <span class=\"built_in\">window</span>.devicePixelRatio || <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ratio = deviceRatio;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ratio !== <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    canvas.width = <span class=\"built_in\">Math</span>.round(width * ratio);</span><br><span class=\"line\">    canvas.height = <span class=\"built_in\">Math</span>.round(height * ratio);</span><br><span class=\"line\">    canvas.style.width = width + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">    canvas.style.height = height + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">    context.scale(ratio, ratio);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ratio;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://www.html5rocks.com/en/tutorials/canvas/hidpi/\" target=\"_blank\" rel=\"noopener\">https://www.html5rocks.com/en/tutorials/canvas/hidpi/</a><br><a href=\"https://www.npmjs.com/package/canvas-dpi-scaler\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/canvas-dpi-scaler</a><br><a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=277205\" target=\"_blank\" rel=\"noopener\">https://bugs.chromium.org/p/chromium/issues/detail?id=277205</a></p>\n<script type=\"text/javascript\">function drawDiagonal(id){var canvas=document.getElementById(id);\n    var context=canvas.getContext(\"2d\");\n    context.beginPath();\n    context.moveTo(0,0);\n    context.lineTo(100,100);\n    context.stroke();\n}\n\n    drawDiagonal(\"diagonal1\");\n    drawDiagonal(\"diagonal2\");\n    drawDiagonal(\"diagonal3\");\n</script>\n","site":{"data":{}},"excerpt":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最近使用图表插件在移动端绘制canvas图表的时候，发现画出来的图很模糊。经过排查和查询相关资料，发现和视网膜屏设备的设备像素比有关。<br>","more":"</p>\n<h2 id=\"相关知识\"><a href=\"#相关知识\" class=\"headerlink\" title=\"相关知识\"></a>相关知识</h2><h3 id=\"canvas的width-和-canvas的style-width\"><a href=\"#canvas的width-和-canvas的style-width\" class=\"headerlink\" title=\"canvas的width 和 canvas的style.width\"></a>canvas的width 和 canvas的style.width</h3><p>style.width是用来设定canvas元素在浏览器中被渲染的宽度（高度同理）<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">style</span>=<span class=\"string\">\"border:1px solid;width:100px;height:100px;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<canvas style=\"border:1px solid;width:100px;height:100px;\"></canvas>\n\n<p>width属性是用来设置canvas元素里面画布的宽度<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">style</span>=<span class=\"string\">\"border:1px solid;\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"100px\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"100px\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<canvas style=\"border:1px solid;\" width=\"100px\" height=\"100px\"></canvas>\n\n<p>最终绘制出来的宽度 = 需要绘制的宽度 / 画布宽 * 画框宽</p>\n<p>可以看到在不同元素宽，画布宽下绘制出来的（0，0）到（100，100）效果是不一样的。</p>\n<canvas id=\"diagonal1\" style=\"border:1px solid;display:inline-block;margin-right:35px\" width=\"100px\" height=\"100px\"></canvas><canvas id=\"diagonal2\" style=\"border:1px solid;width:200px;height:200px;display:inline-block;margin-right:35px\" width=\"100px\" height=\"100px\"></canvas><canvas id=\"diagonal3\" style=\"border:1px solid;width:200px;height:200px;display:inline-block\"></canvas>\n\n<h3 id=\"视网膜屏幕\"><a href=\"#视网膜屏幕\" class=\"headerlink\" title=\"视网膜屏幕\"></a>视网膜屏幕</h3><ul>\n<li>物理像素(physical pixel)</li>\n</ul>\n<p>物理像素又被称为设备像素，他是显示设备中一个最微小的物理部件。每个像素可以根据操作系统设置自己的颜色和亮度。</p>\n<ul>\n<li>设备独立像素(density-independent pixel)</li>\n</ul>\n<p>设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说CSS像素)，然后由相关系统转换为物理像素。</p>\n<ul>\n<li>CSS像素</li>\n</ul>\n<p>CSS像素是一个抽像的单位，主要使用在浏览器上，用来精确度量Web页面上的内容。一般情况之下，CSS像素称为与设备无关的像素(device-independent pixel)，简称DIPs</p>\n<ul>\n<li>设备像素比(device pixel ratio)</li>\n</ul>\n<p>设备像素比简称为dpr，其定义了物理像素和设备独立像素的对应关系。它的值可以按下面的公式计算得到：</p>\n<pre><code>设备像素比 ＝ 物理像素 / 设备独立像素\n</code></pre><p>视网膜屏幕的dpr是大于1的，比如iphone6为2。</p>\n<p>以iphone6为例，在上面绘制canvas，绘制1px x 1px时，实际上是使用了2物理像素 x 2物理像素，所以看起来会有模糊的效果。</p>\n<h2 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h2><p>将画布先放大dpr倍，画框维持不变，根据公式：最终绘制出来的宽度 = 需要绘制的宽度 / 画布宽 <em> 画框宽，可知，此时绘制出来的图像会缩小dpr </em> dpr倍，因为图像缩小了来显示，这样看就是清晰的，但是图像被缩小了。</p>\n<p>再调用canvas.scale(dpr, dpr),将canvas的绘图的值放大dpr * dpr倍，重新绘制,这样呈现出来的图像大小就是和原来一样，而且清晰的。此处理和视网膜屏幕下的1px处理是类似的。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scaleFn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">canvas, context, customWidth, customHeight</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!canvas || !context) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Must pass in `canvas` and `context`.'</span>); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> width = customWidth ||</span><br><span class=\"line\">              canvas.width ||</span><br><span class=\"line\">              canvas.clientWidth;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> height = customHeight ||</span><br><span class=\"line\">               canvas.height ||</span><br><span class=\"line\">               canvas.clientHeight;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> deviceRatio = <span class=\"built_in\">window</span>.devicePixelRatio || <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ratio = deviceRatio;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ratio !== <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    canvas.width = <span class=\"built_in\">Math</span>.round(width * ratio);</span><br><span class=\"line\">    canvas.height = <span class=\"built_in\">Math</span>.round(height * ratio);</span><br><span class=\"line\">    canvas.style.width = width + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">    canvas.style.height = height + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">    context.scale(ratio, ratio);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ratio;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://www.html5rocks.com/en/tutorials/canvas/hidpi/\" target=\"_blank\" rel=\"noopener\">https://www.html5rocks.com/en/tutorials/canvas/hidpi/</a><br><a href=\"https://www.npmjs.com/package/canvas-dpi-scaler\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/canvas-dpi-scaler</a><br><a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=277205\" target=\"_blank\" rel=\"noopener\">https://bugs.chromium.org/p/chromium/issues/detail?id=277205</a></p>\n<script type=\"text/javascript\">function drawDiagonal(id){var canvas=document.getElementById(id);\n    var context=canvas.getContext(\"2d\");\n    context.beginPath();\n    context.moveTo(0,0);\n    context.lineTo(100,100);\n    context.stroke();\n}\n\n    drawDiagonal(\"diagonal1\");\n    drawDiagonal(\"diagonal2\");\n    drawDiagonal(\"diagonal3\");\n</script>"}],"PostAsset":[],"PostCategory":[{"post_id":"cl1ydvfeh0005g3t8e1zesr51","category_id":"cl1ydvfee0002g3t8203bw6bp","_id":"cl1ydvfem000bg3t8xyex4zlh"},{"post_id":"cl1ydvfe80000g3t8i6dumvua","category_id":"cl1ydvfee0002g3t8203bw6bp","_id":"cl1ydvfeo000fg3t8nx6qhy6j"},{"post_id":"cl1ydvfef0004g3t8bdvsy7ii","category_id":"cl1ydvfej0007g3t8br07s6p0","_id":"cl1ydvfeo000ig3t8r5w0trmj"},{"post_id":"cl1ydvfen000eg3t8w0b4ync6","category_id":"cl1ydvfej0007g3t8br07s6p0","_id":"cl1ydvfeq000mg3t8f9d2t6vv"},{"post_id":"cl1ydvfei0006g3t8ddga11rv","category_id":"cl1ydvfem000cg3t87vtph4nl","_id":"cl1ydvfer000og3t8a6i9e6ft"},{"post_id":"cl1ydvfek0009g3t8omdj43pr","category_id":"cl1ydvfep000jg3t8zzrvrtig","_id":"cl1ydvfes000pg3t839w0zcwp"},{"post_id":"cl1ydvff40014g3t8o88y6nzt","category_id":"cl1ydvfej0007g3t8br07s6p0","_id":"cl1ydvff8001bg3t8zgyspu6y"},{"post_id":"cl1ydvff9001cg3t80cx4jw2l","category_id":"cl1ydvfej0007g3t8br07s6p0","_id":"cl1ydvffe001lg3t85w6bvjjs"},{"post_id":"cl1ydvff50016g3t8hqrtefkr","category_id":"cl1ydvff70019g3t8yg0ysypw","_id":"cl1ydvfff001og3t81w028rig"},{"post_id":"cl1ydvff60018g3t8h1mokknt","category_id":"cl1ydvffb001gg3t8d2gph7pf","_id":"cl1ydvffg001sg3t87ajk3g61"},{"post_id":"cl1ydvffd001kg3t8yg4v907c","category_id":"cl1ydvfej0007g3t8br07s6p0","_id":"cl1ydvffh001vg3t8dco3quek"},{"post_id":"cl1ydvff7001ag3t859em7e60","category_id":"cl1ydvffb001gg3t8d2gph7pf","_id":"cl1ydvffi001zg3t800rw0pru"},{"post_id":"cl1ydvfff001qg3t8mst5lp9x","category_id":"cl1ydvfep000jg3t8zzrvrtig","_id":"cl1ydvffj0022g3t8mcon5zep"},{"post_id":"cl1ydvffg001ug3t8gw5uk4ds","category_id":"cl1ydvfej0007g3t8br07s6p0","_id":"cl1ydvffk0025g3t8f6scu06s"},{"post_id":"cl1ydvffc001hg3t8i7wcjyds","category_id":"cl1ydvffg001rg3t8tgk3tgx0","_id":"cl1ydvffl0028g3t8hxtcydsc"},{"post_id":"cl1ydvffh001yg3t8ymav3mcx","category_id":"cl1ydvfej0007g3t8br07s6p0","_id":"cl1ydvffm002cg3t809rcwpmo"},{"post_id":"cl1ydvffj0021g3t89be1m2tj","category_id":"cl1ydvfej0007g3t8br07s6p0","_id":"cl1ydvffn002fg3t8ya4fcuwr"},{"post_id":"cl1ydvffe001ng3t8zu4q4yol","category_id":"cl1ydvffi0020g3t8kiv5ke3n","_id":"cl1ydvffo002hg3t8810kpyif"},{"post_id":"cl1ydvffj0023g3t83il70khv","category_id":"cl1ydvfej0007g3t8br07s6p0","_id":"cl1ydvffp002lg3t8bbsdfw48"},{"post_id":"cl1ydvffl0027g3t8oqwn09m6","category_id":"cl1ydvfej0007g3t8br07s6p0","_id":"cl1ydvffq002og3t8aj8kfgjw"},{"post_id":"cl1ydvffm002ag3t84c0qbsf4","category_id":"cl1ydvfej0007g3t8br07s6p0","_id":"cl1ydvffs002sg3t8ns41vm0z"},{"post_id":"cl1ydvffn002eg3t81s5jlprr","category_id":"cl1ydvfej0007g3t8br07s6p0","_id":"cl1ydvfft002vg3t8vqn0h8vd"},{"post_id":"cl1ydvffo002gg3t88n0m9ypf","category_id":"cl1ydvfej0007g3t8br07s6p0","_id":"cl1ydvffu002yg3t8gzpwnsd3"},{"post_id":"cl1ydvffp002jg3t8y0nisj8h","category_id":"cl1ydvfej0007g3t8br07s6p0","_id":"cl1ydvffv0032g3t85z2nzpcs"},{"post_id":"cl1ydvffq002mg3t8h1r60lqg","category_id":"cl1ydvffs002tg3t86robo40z","_id":"cl1ydvffx0038g3t88wozyeni"},{"post_id":"cl1ydvffr002qg3t8xyp7ve83","category_id":"cl1ydvffv0031g3t8p765w95o","_id":"cl1ydvffz003eg3t85ckshp9b"},{"post_id":"cl1ydvffw0037g3t8lyvwse5r","category_id":"cl1ydvffs002tg3t86robo40z","_id":"cl1ydvfg0003hg3t8y537yu26"},{"post_id":"cl1ydvffx003ag3t85q8elvov","category_id":"cl1ydvffi0020g3t8kiv5ke3n","_id":"cl1ydvfg2003lg3t80166gl9e"},{"post_id":"cl1ydvffs002ug3t88o5r92la","category_id":"cl1ydvffx0039g3t8zk4wjbeo","_id":"cl1ydvfg3003og3t8yqf4ed70"},{"post_id":"cl1ydvfg0003gg3t8s8ih1v8l","category_id":"cl1ydvffx0039g3t8zk4wjbeo","_id":"cl1ydvfg4003rg3t8ywp0rbck"},{"post_id":"cl1ydvfft002xg3t8yezbgiba","category_id":"cl1ydvfg0003fg3t8yb3trpym","_id":"cl1ydvfg5003vg3t8gidp462f"},{"post_id":"cl1ydvfg2003ng3t8oo1s7ycr","category_id":"cl1ydvffi0020g3t8kiv5ke3n","_id":"cl1ydvfg7003yg3t8hcbgjrll"},{"post_id":"cl1ydvffu0030g3t8vxfnik15","category_id":"cl1ydvffx0039g3t8zk4wjbeo","_id":"cl1ydvfg80042g3t81g6234wg"},{"post_id":"cl1ydvfg3003qg3t8n5vxtm3x","category_id":"cl1ydvffx0039g3t8zk4wjbeo","_id":"cl1ydvfg90045g3t8s9yd4avx"},{"post_id":"cl1ydvffv0034g3t8dp5b1hzl","category_id":"cl1ydvffx0039g3t8zk4wjbeo","_id":"cl1ydvfga0049g3t84q9qo3qa"},{"post_id":"cl1ydvfg6003xg3t8kalqqhei","category_id":"cl1ydvfej0007g3t8br07s6p0","_id":"cl1ydvfgb004cg3t8aw2kra71"},{"post_id":"cl1ydvfg80043g3t8jee6zkxu","category_id":"cl1ydvffs002tg3t86robo40z","_id":"cl1ydvfgd004gg3t84m01tt67"},{"post_id":"cl1ydvffz003cg3t83l00j09n","category_id":"cl1ydvfg70040g3t8t2j033um","_id":"cl1ydvfge004jg3t830fs7vs2"},{"post_id":"cl1ydvfg1003jg3t8qw7f5pit","category_id":"cl1ydvfga0048g3t8mal0wyd2","_id":"cl1ydvfgf004lg3t8ykiv30so"},{"post_id":"cl1ydvfgc004eg3t8wttlb6xl","category_id":"cl1ydvffi0020g3t8kiv5ke3n","_id":"cl1ydvfgf004og3t8h1h60ixg"},{"post_id":"cl1ydvfg4003ug3t8tja1m4b2","category_id":"cl1ydvfgd004fg3t8e0zu75mq","_id":"cl1ydvfgg004qg3t89cqv2zeb"},{"post_id":"cl1ydvfg70041g3t8pk93wciz","category_id":"cl1ydvfgf004mg3t8qq545z4q","_id":"cl1ydvfgh004ug3t8tqrcvel1"},{"post_id":"cl1ydvfg90047g3t8gabai8c4","category_id":"cl1ydvfgg004rg3t83mpwcrk3","_id":"cl1ydvfgi004yg3t8evrtk8gi"},{"post_id":"cl1ydvfga004ag3t88b960uyg","category_id":"cl1ydvfgi004vg3t86fist92s","_id":"cl1ydvfgq0052g3t8w9j9lrsr"},{"post_id":"cl1ydvfgd004hg3t8uxal5ej7","category_id":"cl1ydvfgg004rg3t83mpwcrk3","_id":"cl1ydvfgq0055g3t85pl29p8t"},{"post_id":"cl1ydvfqm007eg3t8znzjtr0c","category_id":"cl1ydvffi0020g3t8kiv5ke3n","_id":"cl1ydvfqn007gg3t8luekjc6v"}],"PostTag":[{"post_id":"cl1ydvfe80000g3t8i6dumvua","tag_id":"cl1ydvfef0003g3t8cl0b87mr","_id":"cl1ydvfeo000gg3t8qhpo0fsw"},{"post_id":"cl1ydvfe80000g3t8i6dumvua","tag_id":"cl1ydvfej0008g3t8i4ae0q7p","_id":"cl1ydvfeo000hg3t82g1qffqz"},{"post_id":"cl1ydvfec0001g3t83veewh0i","tag_id":"cl1ydvfem000dg3t827brwlfk","_id":"cl1ydvfeq000lg3t8rh538gzm"},{"post_id":"cl1ydvfef0004g3t8bdvsy7ii","tag_id":"cl1ydvfeq000kg3t85y4naild","_id":"cl1ydvfes000rg3t8043ntohb"},{"post_id":"cl1ydvfef0004g3t8bdvsy7ii","tag_id":"cl1ydvfej0008g3t8i4ae0q7p","_id":"cl1ydvfes000sg3t8k1s07s5o"},{"post_id":"cl1ydvfeh0005g3t8e1zesr51","tag_id":"cl1ydvfes000qg3t8yf60yc7c","_id":"cl1ydvfet000vg3t8awuq2hp1"},{"post_id":"cl1ydvfeh0005g3t8e1zesr51","tag_id":"cl1ydvfet000tg3t85gzaxqxf","_id":"cl1ydvfet000wg3t8i1g2qbjv"},{"post_id":"cl1ydvfei0006g3t8ddga11rv","tag_id":"cl1ydvfet000ug3t87p6z0vld","_id":"cl1ydvfeu000yg3t8rk7xcrjc"},{"post_id":"cl1ydvfek0009g3t8omdj43pr","tag_id":"cl1ydvfet000tg3t85gzaxqxf","_id":"cl1ydvfeu0010g3t8s2vqf329"},{"post_id":"cl1ydvfel000ag3t8puqk0v3o","tag_id":"cl1ydvfeu000zg3t8crnmhwe9","_id":"cl1ydvfeu0012g3t8dpks43ip"},{"post_id":"cl1ydvfen000eg3t8w0b4ync6","tag_id":"cl1ydvfeu0011g3t8nnfc8net","_id":"cl1ydvfev0013g3t8j5f4lx4l"},{"post_id":"cl1ydvff40014g3t8o88y6nzt","tag_id":"cl1ydvff60017g3t8mrc4fpq9","_id":"cl1ydvffa001eg3t8j4akwh1d"},{"post_id":"cl1ydvffa001fg3t8mgyshaoe","tag_id":"cl1ydvfet000ug3t87p6z0vld","_id":"cl1ydvffd001jg3t8q34uuq7l"},{"post_id":"cl1ydvff50016g3t8hqrtefkr","tag_id":"cl1ydvffa001dg3t8l0bfwgyw","_id":"cl1ydvffg001tg3t848yibyw1"},{"post_id":"cl1ydvff50016g3t8hqrtefkr","tag_id":"cl1ydvffc001ig3t83pd8lev2","_id":"cl1ydvffh001wg3t843w43t3a"},{"post_id":"cl1ydvff60018g3t8h1mokknt","tag_id":"cl1ydvfff001pg3t81nr2mimm","_id":"cl1ydvffl0026g3t874k38hiv"},{"post_id":"cl1ydvff60018g3t8h1mokknt","tag_id":"cl1ydvffh001xg3t8e8i210ag","_id":"cl1ydvffm0029g3t8j11j9snz"},{"post_id":"cl1ydvffj0023g3t83il70khv","tag_id":"cl1ydvfes000qg3t8yf60yc7c","_id":"cl1ydvffn002dg3t85vi08myn"},{"post_id":"cl1ydvff7001ag3t859em7e60","tag_id":"cl1ydvfff001pg3t81nr2mimm","_id":"cl1ydvffp002kg3t81xcpozhe"},{"post_id":"cl1ydvff7001ag3t859em7e60","tag_id":"cl1ydvfej0008g3t8i4ae0q7p","_id":"cl1ydvffq002ng3t8xj5iz11n"},{"post_id":"cl1ydvff7001ag3t859em7e60","tag_id":"cl1ydvffm002bg3t8uhdqtrcg","_id":"cl1ydvffs002rg3t8g3vwhfvw"},{"post_id":"cl1ydvff9001cg3t80cx4jw2l","tag_id":"cl1ydvffo002ig3t8ly8ddjhg","_id":"cl1ydvffu002zg3t8fsh6upp4"},{"post_id":"cl1ydvff9001cg3t80cx4jw2l","tag_id":"cl1ydvffr002pg3t8j5gbyn93","_id":"cl1ydvffv0033g3t83c9fljbp"},{"post_id":"cl1ydvffc001hg3t8i7wcjyds","tag_id":"cl1ydvfft002wg3t8qhcivr5q","_id":"cl1ydvffw0036g3t8vyboof5h"},{"post_id":"cl1ydvffd001kg3t8yg4v907c","tag_id":"cl1ydvffw0035g3t8n6f50hb5","_id":"cl1ydvffz003dg3t8afvsycgb"},{"post_id":"cl1ydvffe001ng3t8zu4q4yol","tag_id":"cl1ydvffw0035g3t8n6f50hb5","_id":"cl1ydvfg1003kg3t86u6bkkbl"},{"post_id":"cl1ydvfff001qg3t8mst5lp9x","tag_id":"cl1ydvfg0003ig3t8f30o9mrg","_id":"cl1ydvfg4003sg3t8yghnx8hm"},{"post_id":"cl1ydvffg001ug3t8gw5uk4ds","tag_id":"cl1ydvfg3003pg3t86vf0hmaw","_id":"cl1ydvfg7003zg3t8je9r1cff"},{"post_id":"cl1ydvffh001yg3t8ymav3mcx","tag_id":"cl1ydvfg6003wg3t83fow52av","_id":"cl1ydvfg90046g3t8cu4tkfxj"},{"post_id":"cl1ydvffj0021g3t89be1m2tj","tag_id":"cl1ydvfg3003pg3t86vf0hmaw","_id":"cl1ydvfgc004dg3t8qbnxw4b8"},{"post_id":"cl1ydvffl0027g3t8oqwn09m6","tag_id":"cl1ydvfg3003pg3t86vf0hmaw","_id":"cl1ydvfge004kg3t8ojlnqwnc"},{"post_id":"cl1ydvffm002ag3t84c0qbsf4","tag_id":"cl1ydvfg3003pg3t86vf0hmaw","_id":"cl1ydvfgf004pg3t8vtwt3fkp"},{"post_id":"cl1ydvffn002eg3t81s5jlprr","tag_id":"cl1ydvfg3003pg3t86vf0hmaw","_id":"cl1ydvfgh004tg3t8zvuts420"},{"post_id":"cl1ydvffo002gg3t88n0m9ypf","tag_id":"cl1ydvfgh004sg3t8o6vzplxm","_id":"cl1ydvfgi004xg3t87kumaphl"},{"post_id":"cl1ydvffp002jg3t8y0nisj8h","tag_id":"cl1ydvfg3003pg3t86vf0hmaw","_id":"cl1ydvfgl0051g3t8ovbsj269"},{"post_id":"cl1ydvffq002mg3t8h1r60lqg","tag_id":"cl1ydvfgj0050g3t8rc6mrbmn","_id":"cl1ydvfgq0054g3t8e68nqbko"},{"post_id":"cl1ydvffq002mg3t8h1r60lqg","tag_id":"cl1ydvfej0008g3t8i4ae0q7p","_id":"cl1ydvfgr0056g3t8fq5a3pfg"},{"post_id":"cl1ydvffr002qg3t8xyp7ve83","tag_id":"cl1ydvffw0035g3t8n6f50hb5","_id":"cl1ydvfgt005bg3t816o1ieli"},{"post_id":"cl1ydvffr002qg3t8xyp7ve83","tag_id":"cl1ydvfgr0057g3t820rob5hc","_id":"cl1ydvfgt005cg3t8jqmsz79q"},{"post_id":"cl1ydvffr002qg3t8xyp7ve83","tag_id":"cl1ydvfgs0058g3t88k6y3ag1","_id":"cl1ydvfgt005eg3t89sfuhvnu"},{"post_id":"cl1ydvffr002qg3t8xyp7ve83","tag_id":"cl1ydvfgs0059g3t80klyeahu","_id":"cl1ydvfgt005fg3t8wgkipviq"},{"post_id":"cl1ydvffs002ug3t88o5r92la","tag_id":"cl1ydvfgs005ag3t8a609lp0s","_id":"cl1ydvfgu005hg3t8d27a23ql"},{"post_id":"cl1ydvffs002ug3t88o5r92la","tag_id":"cl1ydvfgt005dg3t8zbcavh97","_id":"cl1ydvfgu005ig3t8e0bj78cq"},{"post_id":"cl1ydvfft002xg3t8yezbgiba","tag_id":"cl1ydvfff001pg3t81nr2mimm","_id":"cl1ydvfgu005kg3t85ims70cq"},{"post_id":"cl1ydvfft002xg3t8yezbgiba","tag_id":"cl1ydvffw0035g3t8n6f50hb5","_id":"cl1ydvfgu005lg3t80xc7wzir"},{"post_id":"cl1ydvffu0030g3t8vxfnik15","tag_id":"cl1ydvfgu005jg3t89g9nmcjo","_id":"cl1ydvfgv005og3t8dxtlagzd"},{"post_id":"cl1ydvffu0030g3t8vxfnik15","tag_id":"cl1ydvfgv005mg3t8sxpk1eu3","_id":"cl1ydvfgv005pg3t8dufsr9zk"},{"post_id":"cl1ydvffv0034g3t8dp5b1hzl","tag_id":"cl1ydvfgv005ng3t8uxfib8jh","_id":"cl1ydvfgw005sg3t83z6xd88z"},{"post_id":"cl1ydvffv0034g3t8dp5b1hzl","tag_id":"cl1ydvfgv005qg3t8yd4hw2go","_id":"cl1ydvfgw005tg3t8tsw46c9m"},{"post_id":"cl1ydvffw0037g3t8lyvwse5r","tag_id":"cl1ydvfgv005rg3t8x8o4k1qw","_id":"cl1ydvfgw005vg3t85o7gl95c"},{"post_id":"cl1ydvffw0037g3t8lyvwse5r","tag_id":"cl1ydvfej0008g3t8i4ae0q7p","_id":"cl1ydvfgw005wg3t8ctizja09"},{"post_id":"cl1ydvffx003ag3t85q8elvov","tag_id":"cl1ydvfgw005ug3t8t9p2ycpu","_id":"cl1ydvfgx005zg3t84l7rf86m"},{"post_id":"cl1ydvffx003ag3t85q8elvov","tag_id":"cl1ydvfgw005xg3t8qbr62t65","_id":"cl1ydvfgx0060g3t8i7kiq7ps"},{"post_id":"cl1ydvffz003cg3t83l00j09n","tag_id":"cl1ydvfgw005yg3t803whw4nd","_id":"cl1ydvfgx0062g3t8aimg2rwo"},{"post_id":"cl1ydvfg0003gg3t8s8ih1v8l","tag_id":"cl1ydvfgs005ag3t8a609lp0s","_id":"cl1ydvfgy0065g3t888hwc20d"},{"post_id":"cl1ydvfg0003gg3t8s8ih1v8l","tag_id":"cl1ydvfgt005dg3t8zbcavh97","_id":"cl1ydvfgy0066g3t8519vu5ez"},{"post_id":"cl1ydvfg1003jg3t8qw7f5pit","tag_id":"cl1ydvfgy0064g3t8dloi0ea2","_id":"cl1ydvfgy0068g3t8i2pd26cg"},{"post_id":"cl1ydvfg2003ng3t8oo1s7ycr","tag_id":"cl1ydvffw0035g3t8n6f50hb5","_id":"cl1ydvfgz006cg3t8jg8udx4o"},{"post_id":"cl1ydvfg2003ng3t8oo1s7ycr","tag_id":"cl1ydvfgy0067g3t8bcbhlkax","_id":"cl1ydvfh0006dg3t8onwci1zr"},{"post_id":"cl1ydvfg2003ng3t8oo1s7ycr","tag_id":"cl1ydvfgy0069g3t8x8q3k6ee","_id":"cl1ydvfh1006fg3t8t4sqeg25"},{"post_id":"cl1ydvfg2003ng3t8oo1s7ycr","tag_id":"cl1ydvfgy006ag3t89l2ne5z3","_id":"cl1ydvfh1006gg3t8sqxqunzw"},{"post_id":"cl1ydvfg3003qg3t8n5vxtm3x","tag_id":"cl1ydvfgs005ag3t8a609lp0s","_id":"cl1ydvfh1006ig3t8n02yfp0u"},{"post_id":"cl1ydvfg3003qg3t8n5vxtm3x","tag_id":"cl1ydvfh0006eg3t8tr17j98c","_id":"cl1ydvfh1006jg3t8jo58b52c"},{"post_id":"cl1ydvfg4003ug3t8tja1m4b2","tag_id":"cl1ydvfh1006hg3t8y7qbk0zl","_id":"cl1ydvfh1006mg3t8u3784x2b"},{"post_id":"cl1ydvfg4003ug3t8tja1m4b2","tag_id":"cl1ydvfh1006kg3t8in030i1u","_id":"cl1ydvfh2006ng3t811idhmr7"},{"post_id":"cl1ydvfg4003ug3t8tja1m4b2","tag_id":"cl1ydvfej0008g3t8i4ae0q7p","_id":"cl1ydvfh2006pg3t801wj2xa0"},{"post_id":"cl1ydvfg6003xg3t8kalqqhei","tag_id":"cl1ydvfh1006lg3t8eer7v4a7","_id":"cl1ydvfh2006qg3t8m7eo2hb3"},{"post_id":"cl1ydvfg70041g3t8pk93wciz","tag_id":"cl1ydvfft002wg3t8qhcivr5q","_id":"cl1ydvfh3006tg3t8h1z64nd9"},{"post_id":"cl1ydvfg70041g3t8pk93wciz","tag_id":"cl1ydvfh2006og3t8inqmnxab","_id":"cl1ydvfh3006ug3t86x4v678v"},{"post_id":"cl1ydvfg70041g3t8pk93wciz","tag_id":"cl1ydvfh2006rg3t858v1dbel","_id":"cl1ydvfh3006wg3t8uwtv77n8"},{"post_id":"cl1ydvfg80043g3t8jee6zkxu","tag_id":"cl1ydvfh3006sg3t84jwtfj8v","_id":"cl1ydvfh3006xg3t8yyaa6gk4"},{"post_id":"cl1ydvfg80043g3t8jee6zkxu","tag_id":"cl1ydvfej0008g3t8i4ae0q7p","_id":"cl1ydvfh4006zg3t8efjnvnoi"},{"post_id":"cl1ydvfg90047g3t8gabai8c4","tag_id":"cl1ydvfh3006vg3t8c6pu11oy","_id":"cl1ydvfh50071g3t8z28847zk"},{"post_id":"cl1ydvfg90047g3t8gabai8c4","tag_id":"cl1ydvfh4006yg3t8smhi1shr","_id":"cl1ydvfh50072g3t88l9z057t"},{"post_id":"cl1ydvfga004ag3t88b960uyg","tag_id":"cl1ydvfh40070g3t8rrigfqst","_id":"cl1ydvfh50074g3t8apx6hr87"},{"post_id":"cl1ydvfgc004eg3t8wttlb6xl","tag_id":"cl1ydvfh50073g3t8vcjwwq8x","_id":"cl1ydvfh60078g3t8ephlhcqh"},{"post_id":"cl1ydvfgc004eg3t8wttlb6xl","tag_id":"cl1ydvfh50075g3t81ple6ugk","_id":"cl1ydvfh60079g3t8s39yfje2"},{"post_id":"cl1ydvfgc004eg3t8wttlb6xl","tag_id":"cl1ydvfh50076g3t83go9pa05","_id":"cl1ydvfh7007bg3t8ryhg6svs"},{"post_id":"cl1ydvfgd004hg3t8uxal5ej7","tag_id":"cl1ydvfh60077g3t8733hiobg","_id":"cl1ydvfh8007cg3t8rxezu4nd"},{"post_id":"cl1ydvfgd004hg3t8uxal5ej7","tag_id":"cl1ydvfh3006vg3t8c6pu11oy","_id":"cl1ydvfh8007dg3t88rvlx715"},{"post_id":"cl1ydvfqm007eg3t8znzjtr0c","tag_id":"cl1ydvfqn007fg3t8tetwo3o4","_id":"cl1ydvfqn007ig3t8b2jus6gi"},{"post_id":"cl1ydvfqm007eg3t8znzjtr0c","tag_id":"cl1ydvfqn007hg3t8w1dpsem9","_id":"cl1ydvfqn007jg3t8zbr9ys5l"}],"Tag":[{"name":"模块化","_id":"cl1ydvfef0003g3t8cl0b87mr"},{"name":"js","_id":"cl1ydvfej0008g3t8i4ae0q7p"},{"name":"google drive","_id":"cl1ydvfem000dg3t827brwlfk"},{"name":"inherit","_id":"cl1ydvfeq000kg3t85y4naild"},{"name":"promise","_id":"cl1ydvfes000qg3t8yf60yc7c"},{"name":"es6","_id":"cl1ydvfet000tg3t85gzaxqxf"},{"name":"typescript","_id":"cl1ydvfet000ug3t87p6z0vld"},{"name":"吸顶","_id":"cl1ydvfeu000zg3t8crnmhwe9"},{"name":"FormData","_id":"cl1ydvfeu0011g3t8nnfc8net"},{"name":"babel","_id":"cl1ydvff60017g3t8mrc4fpq9"},{"name":"git","_id":"cl1ydvffa001dg3t8l0bfwgyw"},{"name":"proxy","_id":"cl1ydvffc001ig3t83pd8lev2"},{"name":"react","_id":"cl1ydvfff001pg3t81nr2mimm"},{"name":"hoc","_id":"cl1ydvffh001xg3t8e8i210ag"},{"name":"ssr","_id":"cl1ydvffm002bg3t8uhdqtrcg"},{"name":"html","_id":"cl1ydvffo002ig3t8ly8ddjhg"},{"name":"语意化","_id":"cl1ydvffr002pg3t8j5gbyn93"},{"name":"css","_id":"cl1ydvfft002wg3t8qhcivr5q"},{"name":"vue","_id":"cl1ydvffw0035g3t8n6f50hb5"},{"name":"switch/case","_id":"cl1ydvfg0003ig3t8f30o9mrg"},{"name":"http","_id":"cl1ydvfg3003pg3t86vf0hmaw"},{"name":"object","_id":"cl1ydvfg6003wg3t83fow52av"},{"name":"正则表达式","_id":"cl1ydvfgh004sg3t8o6vzplxm"},{"name":"tree","_id":"cl1ydvfgj0050g3t8rc6mrbmn"},{"name":"karma","_id":"cl1ydvfgr0057g3t820rob5hc"},{"name":"mocha","_id":"cl1ydvfgs0058g3t88k6y3ag1"},{"name":"chai","_id":"cl1ydvfgs0059g3t80klyeahu"},{"name":"gulp","_id":"cl1ydvfgs005ag3t8a609lp0s"},{"name":"效率","_id":"cl1ydvfgt005dg3t8zbcavh97"},{"name":"npm","_id":"cl1ydvfgu005jg3t89g9nmcjo"},{"name":"版本","_id":"cl1ydvfgv005mg3t8sxpk1eu3"},{"name":"webpack","_id":"cl1ydvfgv005ng3t8uxfib8jh"},{"name":"性能优化","_id":"cl1ydvfgv005qg3t8yd4hw2go"},{"name":"queue","_id":"cl1ydvfgv005rg3t8x8o4k1qw"},{"name":"audio","_id":"cl1ydvfgw005ug3t8t9p2ycpu"},{"name":"用户体验","_id":"cl1ydvfgw005xg3t8qbr62t65"},{"name":"animation","_id":"cl1ydvfgw005yg3t803whw4nd"},{"name":"路由","_id":"cl1ydvfgy0064g3t8dloi0ea2"},{"name":"vue-router","_id":"cl1ydvfgy0067g3t8bcbhlkax"},{"name":"管理系统","_id":"cl1ydvfgy0069g3t8x8q3k6ee"},{"name":"权限控制","_id":"cl1ydvfgy006ag3t89l2ne5z3"},{"name":"‘效率’","_id":"cl1ydvfh0006eg3t8tr17j98c"},{"name":"array","_id":"cl1ydvfh1006hg3t8y7qbk0zl"},{"name":"flat","_id":"cl1ydvfh1006kg3t8in030i1u"},{"name":"function","_id":"cl1ydvfh1006lg3t8eer7v4a7"},{"name":"grid","_id":"cl1ydvfh2006og3t8inqmnxab"},{"name":"responsive","_id":"cl1ydvfh2006rg3t858v1dbel"},{"name":"排序","_id":"cl1ydvfh3006sg3t84jwtfj8v"},{"name":"浏览器","_id":"cl1ydvfh3006vg3t8c6pu11oy"},{"name":"eventloop","_id":"cl1ydvfh4006yg3t8smhi1shr"},{"name":"debounce","_id":"cl1ydvfh40070g3t8rrigfqst"},{"name":"iOS","_id":"cl1ydvfh50073g3t8vcjwwq8x"},{"name":"iframe","_id":"cl1ydvfh50075g3t81ple6ugk"},{"name":"bug","_id":"cl1ydvfh50076g3t83go9pa05"},{"name":"cache","_id":"cl1ydvfh60077g3t8733hiobg"},{"name":"canvas","_id":"cl1ydvfqn007fg3t8tetwo3o4"},{"name":"dpr","_id":"cl1ydvfqn007hg3t8w1dpsem9"}]}}