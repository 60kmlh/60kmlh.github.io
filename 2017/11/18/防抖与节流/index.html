<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>防抖与节流 · 60km/h</title><meta name="description" content="防抖与节流 - 60kmlh"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/gandalfr.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/monokai.min.css"><link rel="search" type="application/opensearchdescription+xml" href="http://60kmlh.github.io/atom.xml" title="60km/h"></head><body><div class="wrap"><header><div class="title_wrap"><p>60km/h</p><span class="subtitle typing">好记性不如烂笔头</span></div><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">防抖与节流</h1><div class="tags"><a href="/tags/debounce/" class="tag-title">#debounce</a></div><div class="post-info">2017年11月18日</div><div class="post-content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在处理诸如 resize、scroll、mousemove 和 keydown/keyup/keypress 等事件的时候，通常我们不希望这些事件太过频繁地触发，尤其是监听程序中涉及到大量的计算或者有非常耗费资源的操作。<br><a id="more"></a><br>为了解决这个问题，一般有两种解决方案：</p>
<ol>
<li>debounce 防抖</li>
<li>throttle 节流</li>
</ol>
<p>throttle 和 debounce 是解决请求和响应速度不匹配问题的两个方案。二者的差异在于选择不同的策略。</p>
<h3 id="电梯超时"><a href="#电梯超时" class="headerlink" title="电梯超时"></a>电梯超时</h3><p>想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应。假设电梯有两种运行策略 throttle 和 debounce ，超时设定为15秒，不考虑容量限制。</p>
<ul>
<li>throttle 策略的电梯。保证如果电梯第一个人进来后，15秒后准时运送一次，不等待。如果没有人，则待机。</li>
<li>debounce 策略的电梯。如果电梯里有人进来，等待15秒。如果又人进来，15秒等待重新计时，直到15秒超时，开始运送。</li>
</ul>
<h2 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在 debounce 函数没有再被调用的情况下经过 delay 毫秒后才执行回调函数。</p>
<ul>
<li>由 debounce 的功能可知防抖函数至少接收两个参数（流行类库中都是 3 个参数）<ul>
<li>回调函数fn</li>
<li>延时时间delay</li>
</ul>
</li>
<li>debounce 函数返回一个闭包，闭包被频繁的调用<ul>
<li>debounce 函数只调用一次，之后调用的都是它返回的闭包函数</li>
<li>在闭包内部限制了回调函数fn的执行，强制只有连续操作停止后执行一次</li>
</ul>
</li>
<li>使用闭包是为了使指向定时器的变量不被gc回收<ul>
<li>实现在延时时间delay内的连续触发都不执行回调函数fn，使用的是在闭包内设置定时器setTimeOut</li>
<li>频繁调用这个闭包，在每次调用时都要将上次调用的定时器清除</li>
<li>被闭包保存的变量就是指向上一次设置的定时器<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3></li>
</ul>
</li>
<li>基本实现</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    timer = setTimeout(fn, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实现的缺点:</p>
<ol>
<li>this指向问题。debounce 函数在定时器中调用回调函数fn，所以fn执行的时候this指向全局对象（浏览器中window），需要在外层用变量将this保存下来，使用apply进行显式绑定</li>
<li>event对象。JavaScript 的事件处理函数中会提供事件对象event，在闭包中调用时需要将这个事件对象传入</li>
</ol>
<ul>
<li>完整实现</li>
</ul>
<ol>
<li>增加第三个参数, 是否立刻执行。</li>
<li>增加 debounce 函数的返回值。</li>
<li>取消 debounce 函数。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param  &#123;function&#125; func        传入函数</span></span><br><span class="line"><span class="comment"> * @param  &#123;number&#125;   wait        表示时间窗口的间隔</span></span><br><span class="line"><span class="comment"> * @param  &#123;boolean&#125;  immediate   设置为ture时，调用触发于开始边界而不是结束边界</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125;             返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer, result</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> debounced = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="comment">//清除计时器，清除上次未到延迟时间的任务</span></span><br><span class="line">    <span class="keyword">if</span>(timer) &#123;clearTimeout(timer)&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(immediate) &#123;</span><br><span class="line">      <span class="comment">//是否执行完成</span></span><br><span class="line">      <span class="keyword">let</span> callNow = !timer</span><br><span class="line">      <span class="comment">//设置timer，执行完成之后清除timer，以便下次还能执行</span></span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, wait);</span><br><span class="line">      <span class="comment">//如果上次已经执行完成， 则可以立即执行</span></span><br><span class="line">      <span class="keyword">if</span>(callNow) &#123;result = fn.apply(context, args)&#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//非立即执行的，设置wait时间之后执行</span></span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        fn.apply(context, args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  debounced.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> debounced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流(throttle)"></a>节流(throttle)</h2><p>throttle 的概念就是固定函数执行的速率，即所谓的“节流”。正常情况下，mousemove 的监听函数可能会每 20ms（假设）执行一次，如果设置 200ms 的“节流”，那么它就会每 200ms 执行一次。比如在 1s 的时间段内，正常的监听函数可能会执行 50（1000/20） 次，“节流” 200ms 后则会执行 5（1000/200） 次。</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul>
<li>有两种主流实现方式<ul>
<li>使用时间戳</li>
<li>设置定时器</li>
</ul>
</li>
<li>节流函数 throttle 调用后返回一个闭包<ul>
<li>闭包用来保存之前的时间戳或者定时器变量（因为变量被返回的函数引用，所以无法被垃圾回收机制回收）</li>
</ul>
</li>
<li>时间戳方式<ul>
<li>当触发事件的时候，取出当前的时间戳，然后减去之前的时间戳（初始设置为 0）</li>
<li>结果大于设置的时间周期，则执行函数，然后更新时间戳为当前时间戳</li>
<li>结果小于设置的时间周期，则不执行函数</li>
</ul>
</li>
<li>定时器方式<ul>
<li>当触发事件的时候，设置一个定时器</li>
<li>再次触发事件的时候，如果定时器存在，就不执行，知道定时器执行，然后执行函数，清空定时器</li>
<li>设置下个定时器</li>
</ul>
</li>
<li>将两种方式结合，可以实现兼并立刻执行和停止触发后依然执行一次的效果<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3></li>
<li>时间戳实现</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args;</span><br><span class="line">  <span class="comment">// 前一次执行的时间戳</span></span><br><span class="line">  <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将时间转为时间戳</span></span><br><span class="line">    <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="comment">// 时间间隔大于延迟时间才执行</span></span><br><span class="line">    <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">      previous = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定时器实现</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer, context, args;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    context = <span class="keyword">this</span>;</span><br><span class="line">    args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="comment">// 如果定时器存在，则不执行</span></span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 执行后释放定时器变量</span></span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">        fn.apply(context, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>完整实现</li>
</ul>
<ol>
<li>增加第三个参数，让用户可以自己选择模式<ul>
<li>忽略开始边界上的调用，传入{ leading: false }</li>
<li>忽略结尾边界上的调用，传入{ trailing: false }</li>
<li>增加返回值功能</li>
</ul>
</li>
<li>增加取消功能</li>
<li>leading: false 和 trailing: false 不能同时设置</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 频率控制 返回函数连续调用时，func 执行频率限定为 次 / wait</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param  &#123;function&#125;   func      传入函数</span></span><br><span class="line"><span class="comment"> * @param  &#123;number&#125;     wait      表示时间窗口的间隔</span></span><br><span class="line"><span class="comment"> * @param  &#123;object&#125;     options   如果想忽略开始边界上的调用，传入&#123;leading: false&#125;。</span></span><br><span class="line"><span class="comment"> *                                如果想忽略结尾边界上的调用，传入&#123;trailing: false&#125;</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125;             返回客户调用函数   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer, result, args, context</span><br><span class="line">  <span class="keyword">var</span> previous = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span>(!options) &#123;options = &#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 延迟执行函数</span></span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 更新上次执行时间</span></span><br><span class="line">    <span class="comment">// 若上边界不执行，则上次执行时间始终为0</span></span><br><span class="line">    previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    result = fn.apply(context, args)</span><br><span class="line">    <span class="comment">// 本次执行结束后 清除上下文环境和参数</span></span><br><span class="line">    <span class="keyword">if</span>(!timer) context = args = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="comment">// 首次执行时，如果设定了开始边界不执行选项，将上次执行时间设定为当前时间。</span></span><br><span class="line">    <span class="keyword">if</span>(!previous &amp;&amp; options.leading === <span class="literal">false</span>) &#123;</span><br><span class="line">      previous = now</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 延迟执行时间间隔</span></span><br><span class="line">    <span class="keyword">var</span> remaining = wait - (now - previous)</span><br><span class="line">    context = <span class="keyword">this</span></span><br><span class="line">    args = <span class="built_in">arguments</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行函数的两种情况</span></span><br><span class="line">    <span class="comment">// remaining小于0，说明次执行至此所间隔时间已经超过一个时间窗口</span></span><br><span class="line">    <span class="comment">// remaining大于时间窗口wait，表示客户端系统时间被调整过</span></span><br><span class="line">    <span class="keyword">if</span>(remaining &lt;= <span class="number">0</span> || remaining &lt; wait) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      previous = now</span><br><span class="line">      result = fn.apply(context, args)</span><br><span class="line">      <span class="comment">//本次执行结束后 清除上下文环境和参数</span></span><br><span class="line">      <span class="keyword">if</span>(!timer) context = args = <span class="literal">null</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!timer &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">      timer = setTimeout(later, remaining)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> throttled </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><iframe width="100%" height="300" src="https://jsrun.net/e6XKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://hackll.com/2015/11/19/debounce-and-throttle" target="_blank" rel="noopener">Debounce 和 Throttle 的原理及实现</a></li>
<li><a href="https://juejin.im/post/5c2eb031f265da61343889bb" target="_blank" rel="noopener">节流与防抖</a></li>
<li><a href="https://github.com/jashkenas/underscore/blob/master/underscore.js#L887" target="_blank" rel="noopener">underscore</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2017/12/16/JavaScript的继承/" class="prev">上一篇</a><a href="/2017/11/05/inline-block元素间距问题/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 - 2019 <a href="http://60kmlh.github.io">60kmlh</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/MikeCoder/hexo-theme-gandalfr" target="_blank">hexo-theme-gandalfr</a>.</p></div></footer></div><script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js" crossorigin="anonymous"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.js" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-147983033-1",'auto');ga('send','pageview');</script><script>$(document).ready(function() { hljs.configure({useBR: true}); $('pre').each(function(i, block) { hljs.highlightBlock(block); }); });</script></body></html>