<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>《javascript权威指南》第八章读书笔记 · 60km/h</title><meta name="description" content="《javascript权威指南》第八章读书笔记 - 60kmlh"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/gandalfr.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/monokai.min.css"><link rel="search" type="application/opensearchdescription+xml" href="http://60kmlh.github.io/atom.xml" title="60km/h"></head><body><div class="wrap"><header><div class="title_wrap"><p>60km/h</p><span class="subtitle typing">好记性不如烂笔头</span></div><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">《javascript权威指南》第八章读书笔记</h1><div class="tags"><a href="/tags/function/" class="tag-title">#function</a></div><div class="post-info">2017年3月18日</div><div class="post-content"><h2 id="8-1函数定义"><a href="#8-1函数定义" class="headerlink" title="8.1函数定义"></a>8.1函数定义</h2><p>(1) 函数定义表达式</p>
<p>声明的变量会提升，赋值操作不会提升。<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//do somethings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(2) 函数声明语句</p>
<p>函数声明语句会被提升到作用域顶部。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//do somethings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="8-2函数调用"><a href="#8-2函数调用" class="headerlink" title="8.2函数调用"></a>8.2函数调用</h2><p>4种方式调用函数：</p>
<ol>
<li><p>作为函数</p>
<p> ECMAScript 3和ECMAScript 5的非严格模式下规定，函数调用的调用上下文是全局对象。严格模式下，上下文对象是undefined。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn()<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>作为方法</p>
<p> 将函数保存在一个对象的属性里，作为该对象的方法进行调用。</p>
<p> 任何函数作为方法调用都会传入一个隐式的实参，即调用该方法的对象。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o=&#123;</span><br><span class="line">    a:<span class="number">2</span>,</span><br><span class="line">    m:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn1())<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(o.m())<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>作为构造函数</p>
<p> 通过new关键字进行构造函数调用。构造函数调用创建一个新的空对象，这个对象继承构造函数的prototype属性，构造函数将这个新对象用作其调用上下文，因此构造函数可以使用this关键字引用这个新对象。</p>
<p> 不使用return关键字时，返回该新对象。</p>
</li>
</ol>
<ol start="4">
<li><p>使用它们的call()或apply()方法间接调用</p>
<p> call()方法使用自有的实参列表作为函数的实参。</p>
<p> apply()则要求以数组的方式传入参数。</p>
</li>
</ol>
<h2 id="8-3函数的实参和形参"><a href="#8-3函数的实参和形参" class="headerlink" title="8.3函数的实参和形参"></a>8.3函数的实参和形参</h2><p>javascript函数调用不检查传入形参的个数。</p>
<p>当调用函数时传入的实参个数少于函数声明是指定的形参个数时，剩下的形参将设置为undefined 。</p>
<p>为了保持函数的适应性，应当给忽略的实参设置默认值。可使用||运算符。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    a=a||[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当传入的实参个数大于指定的形参个数时，没有办法直接获得未命名值的引用。标示符arguments是指向实参对象的引用，可通过数字下标获得传入的实参值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Max</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="built_in">Number</span>.NEGATIVE_INFINITY;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line">        max=<span class="built_in">arguments</span>[i]&gt;max?<span class="built_in">arguments</span>[i]:max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>非严格模式下，arguments.callee指代当前正在执行的函数。arguments.caller指代调用当前正在执行的函数的函数。</p>
<p>匿名函数中可通过arguments.callee调用自身实现递归。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x*<span class="built_in">arguments</span>.callee(x<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>javascript方法的形参并未进行类型检查，应当添加实参类型检查逻辑。</p>
<h2 id="8-3作为值的函数"><a href="#8-3作为值的函数" class="headerlink" title="8.3作为值的函数"></a>8.3作为值的函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> operators = &#123;</span><br><span class="line">    add:<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x+y&#125;,</span><br><span class="line">    subtract:<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x-y&#125;,</span><br><span class="line">    multiply:<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x*y&#125;,</span><br><span class="line">    divide:<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x/y&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">operate</span>(<span class="params">operation,operand1,operand2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> operators[operation] === <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> operators[operation](operand1,operand2)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'unkown operator'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> j = operate(<span class="string">'add'</span>, <span class="string">'hello'</span>, operate(<span class="string">'add'</span>,<span class="string">' '</span>,<span class="string">'world'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(j)<span class="comment">//hello world</span></span><br></pre></td></tr></table></figure>
<p>自定义函数属性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isFinite</span>(n)&amp;&amp;n&gt;<span class="number">0</span>&amp;&amp;n==<span class="built_in">Math</span>.round(n))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(n <span class="keyword">in</span> factorial))&#123;</span><br><span class="line">            factorial[n]=n*factorial(n<span class="number">-1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> factorial[n]</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NaN</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">factorial[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">4</span>))<span class="comment">//24</span></span><br></pre></td></tr></table></figure></p>
<h2 id="8-5作为命名空间的函数"><a href="#8-5作为命名空间的函数" class="headerlink" title="8.5作为命名空间的函数"></a>8.5作为命名空间的函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extend = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> &#123;<span class="attr">toString</span>:<span class="literal">null</span>&#125;)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line">                <span class="keyword">var</span> source = <span class="built_in">arguments</span>[i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> source)&#123;</span><br><span class="line">                    o[prop] = source[prop]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patched_extend</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line">            <span class="keyword">var</span> source = <span class="built_in">arguments</span>[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> source)&#123;</span><br><span class="line">                o[prop] = source[prop]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;protoprops.length;j++)&#123;</span><br><span class="line">                prop=protoprops[j];</span><br><span class="line">                <span class="keyword">if</span>(source.hasOwnProperty(prop))&#123;</span><br><span class="line">                    o[prop] = source[prop]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> proptypes = [<span class="string">'toString'</span>,<span class="string">'valueOf'</span>,<span class="string">'constructor'</span>,<span class="string">'hasOwnProperty'</span>]</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<h2 id="8-6闭包"><a href="#8-6闭包" class="headerlink" title="8.6闭包"></a>8.6闭包</h2><p>javascript采用词法作用域，函数的执行依赖变量作用域，该作用域是在函数定义时决定的。函数定义时的作用域链，在函数执行时依然有效。</p>
<p>为实现这种词法作用域，javascript函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。</p>
<p>函数对象通过作用域链互相关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性称为闭包。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">'global scope'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkScope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">'local scope'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> scope&#125;</span><br><span class="line">    <span class="keyword">return</span> f()</span><br><span class="line">&#125;</span><br><span class="line">checkScope()<span class="comment">//'local scope'</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">'global scope'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkScope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">'local scope'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> scope&#125;</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line">checkScope()()<span class="comment">//'local scope'</span></span><br></pre></td></tr></table></figure>
<p>利用闭包实现私有存取器方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addPrivateProperty</span>(<span class="params">o,name,predicate</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line">    o[<span class="string">'get'</span>+name]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> value&#125;;</span><br><span class="line">    o[<span class="string">'set'</span>+name]=<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(predicate&amp;&amp;!predicate(v))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'set'</span>+name+<span class="string">':invalid value'</span>+v)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            value=v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">addPrivateProperty(o,<span class="string">'Name'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">typeof</span> x===<span class="string">'string'</span>&#125;)</span><br><span class="line">o.setName(<span class="string">'Frank'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o.getName());<span class="comment">//'Frank'</span></span><br><span class="line">o.setName(o) <span class="comment">//Error: setName:invalid value[object Object]</span></span><br></pre></td></tr></table></figure></p>
<p>this是javascript关键字，而不是变量，如果闭包在外部函数里无法访问this，除非外部函数将this转存为一个变量。arguments同理。</p>
<h2 id="8-7函数属性、方法和构造函数"><a href="#8-7函数属性、方法和构造函数" class="headerlink" title="8.7函数属性、方法和构造函数"></a>8.7函数属性、方法和构造函数</h2><ol>
<li><p>length属性<br> 在函数体里，arguments.length指向传入函数的实参长度，而函数的length属性指函数定义时给出的参数个数，即“形参”。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> actual = args.length;</span><br><span class="line">    <span class="keyword">var</span> expected = args.callee.length;</span><br><span class="line">    <span class="keyword">if</span>(actual!==expected)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Expected'</span>+expected+<span class="string">'args;got'</span>+actual)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y,z</span>)</span>&#123;</span><br><span class="line">    check(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> x+y+z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>prototype<br> 当函数用作构造函数的时候，新创建的对象会从原型对象上继承属性。</p>
</li>
<li><p>call()和apply()方法<br> call()和apply()的第一个参数是要调用函数的母对象，它是调用的上下文，函数体内通过this获得对它引用。</p>
<p> ECMAScript 5的严格模式中，第一个实参会变成this的值。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x=&#123;<span class="attr">a</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(a)&#125;</span><br><span class="line">f.call(x)<span class="comment">//1</span></span><br><span class="line">f.aplly(x)<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p> ECMAScript 3和非严格模式中，传入null和undefined会被全局对象所替代。</p>
<p> call()方法第一个调用上下文实参之后的所有实参就是要传入待调用函数的值。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.call(o,<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p> apply()调用上下文实参之后的所有实参d都放入一个数组中。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.apply(o,[<span class="number">1</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>bind()方法<br> ECMAScript 5新增bind()方法，用来将函数绑定至某个对象。</p>
<p> 在函数f()调用bind方法并传入一个对象o作为参数，将返回一个新的函数。调用这个新的函数，会把原始函数f()当做对象o的方法来调用。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y</span>)</span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.x+y &#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> g = f.bind(o);</span><br><span class="line">g(<span class="number">2</span>)<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p> 除了第一个实参外，传入bind()的参数也会绑定至this。</p>
<p> bind()方法所返回的函数的length（形参数量）等于原函数的形参数量减去传入bind()方法中的实参数量（第一个参数以后的所有参数），因为传入bind中的实参都会绑定到原函数的形参</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x+y&#125;<span class="comment">//length为2</span></span><br><span class="line"><span class="keyword">var</span> succ = sum.bind(<span class="literal">null</span>,<span class="number">1</span>)<span class="comment">//length为1</span></span><br><span class="line">succ(<span class="number">2</span>)<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//var sum = function(x,y)&#123;return x+y&#125;//length为2</span></span><br><span class="line"><span class="comment">//var succ = sum.bind(null,1,2)//length为0</span></span><br><span class="line"><span class="comment">//succ()//3</span></span><br></pre></td></tr></table></figure>
<p> 当bind()所返回的函数用作构造函数的时候， 传入bind()的this将被忽略，实参会全部传入原函数。</p>
<p> bind()方法返回的构造函数不包含prototype属性，将这些绑定的函数用作构造函数所创建的对象会从原始的未绑定的构造函数中继承prototype。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">original</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.a + x&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="keyword">new</span>(original.bind(obj, <span class="number">2</span>)); <span class="comment">//传入了一个实参2</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.a);  <span class="comment">//输出1, 说明返回的函数用作构造函数时obj(this的值)被忽略了</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.b()); <span class="comment">//输出3 ，说明传入的实参2传入了原函数original</span></span><br></pre></td></tr></table></figure>
<p> ECMAScript 3版本的bind方法()</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">Function</span>.prototype.bind)&#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind(o,<span class="comment">/*,arguments*/</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>, boundArgs = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> args = [], i;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;boundArgs.length;i++)&#123;args.push(bonudArgs[i])&#125;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;args.push(<span class="built_in">arguments</span>[i])&#125;</span><br><span class="line">            <span class="keyword">return</span> self.apply(o,args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>toString()方法<br> 大多数函数的toString()方法的实现都返回函数的完整源码。</p>
<p> 内置函数往往返回一个“[native code]”的字符串作为函数体。</p>
</li>
<li><p>Function()构造函数<br> 函数可通过Function()构造函数来定义。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'return x+y'</span>)</span><br></pre></td></tr></table></figure>
<p> Function()构造函数允许javascript运行时动态创建并编译函数。</p>
<p> 每次调用Function()构造函数都回解析函数体，并创建新的函数对象。在循环中执行，会影响执行效率。</p>
<p> Function()构造函数创建的函数不使用词法作用域，函数体代码的编译综会在顶层函数执行。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructFunciton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">'local'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'return scope'</span>)</span><br><span class="line">&#125;</span><br><span class="line">constructFunciton()()<span class="comment">//'global'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可调用对象<br> 截至目前为止，两个可调用对象在javascript中的实现不能算作函数。</p>
<p> ie8机之前的版本的客户端方法使用了可调用的宿主对象，而不是内置的函数对象。</p>
<p> 另一个常见的可调用对象是RegExp对象，非javascript的标准特性。</p>
<p> 检查对象是否为真正的函数对象。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(x)===<span class="string">'[object Function]'</span></span><br><span class="line">&#125;</span><br><span class="line">isFunction(<span class="built_in">window</span>.alert)<span class="comment">//IE8下为false</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="8-8函数式编程"><a href="#8-8函数式编程" class="headerlink" title="8.8函数式编程"></a>8.8函数式编程</h2><ol>
<li><p>使用函数处理数组<br> 自定义map()函数</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="built_in">Array</span>.prototype.map?<span class="function"><span class="keyword">function</span>(<span class="params">a,f</span>)</span>&#123;<span class="keyword">return</span> a.map(f)&#125;:<span class="function"><span class="keyword">function</span>(<span class="params">a,f</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> results = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = a.length;i&lt;len;i++;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i <span class="keyword">in</span> a)&#123;</span><br><span class="line">            results[i] = f.call(<span class="literal">null</span>,a[i],i,a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line">自定义reduce()函数</span><br><span class="line"><span class="string">``</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">var</span> reduce = <span class="built_in">Array</span>.prototype.reduce?<span class="function"><span class="keyword">function</span>(<span class="params">a,f,initial</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.reduce(f,initial)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="keyword">return</span> a.reduce(f)&#125;</span><br><span class="line">&#125;:<span class="function"><span class="keyword">function</span>(<span class="params">a,f,initial</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>,len = a.length,accumulator;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length&gt;<span class="number">2</span>)&#123;accumulator=initial&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;<span class="keyword">throw</span> <span class="built_in">TypeError</span>()&#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i <span class="keyword">in</span> a)&#123;</span><br><span class="line">                accumulator=a[i++];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == len)&#123;<span class="keyword">throw</span> <span class="built_in">TypeError</span>()&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i <span class="keyword">in</span> a)&#123;</span><br><span class="line">            accumulator=f.call(<span class="literal">undefined</span>,accumulator,a[i],i,a);</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> accumulator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>高阶函数<br> 高阶函数(higher-order function)即操作函数的函数，接收一个或者多个函数作为参数，返回一个新的函数。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">not</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = f.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">even</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x%<span class="number">2</span> === <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> odd = not(even);</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>].every(odd)<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不完全函数<br> 在JavaScript中，不完全函数是一种函数变换技巧，即把一次完整的函数调用拆成多次函数调用，每次传入的实参都是完整实参的一部分，每个拆分开的函数叫做不完全函数，每次函数调用叫做不完全调用，这种变换的特点是每次调用都返回一个函数，直到得到最终运行结果为止。</p>
<p> 举一个简单的例子，将对函数f(1,2,3,4,5)的调用修改为等价的f(1,2)(3,4)(5,6)，后者包含三次调用，和每次调用相关的函数就是“不完全函数”。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现一个工具函数，将类数组（或对象）转换为真正的数组</span></span><br><span class="line"><span class="comment">//在后面的示例代码中用到了这个方法将arguments对象转换为真正的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">array</span>(<span class="params">a,n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(a,n||<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数的实参传递至左侧</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partialLeft</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;   <span class="comment">//保存外部的实参数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;      <span class="comment">//并返回这个函数</span></span><br><span class="line">        <span class="keyword">var</span> a = array(args,<span class="number">1</span>);  <span class="comment">//从第一个元素开始处理args</span></span><br><span class="line">        a = a.concat(array(<span class="built_in">arguments</span>)); <span class="comment">//然后增加所有的内部实参</span></span><br><span class="line">        <span class="keyword">return</span> f.apply(<span class="keyword">this</span>,a); <span class="comment">//然后基于这个实参列表调用f()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数的实参传递至右侧</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partialRight</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;   <span class="comment">//保存外部的实参数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;      <span class="comment">//并返回这个函数</span></span><br><span class="line">        <span class="keyword">var</span> a = array(<span class="built_in">arguments</span>);   <span class="comment">//从内部参数开始</span></span><br><span class="line">        a = a.concat(array(args,<span class="number">1</span>));    <span class="comment">//从第一个元素开始处理args</span></span><br><span class="line">        <span class="keyword">return</span> f.apply(<span class="keyword">this</span>,a); <span class="comment">//然后基于这个实参列表调用f()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数的实参传递至左侧</span></span><br><span class="line"><span class="comment">//如果参数为undefined,用后面的实参填充undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;   <span class="comment">//保存外部实参数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = array(args,<span class="number">1</span>);  <span class="comment">//从外部args开始</span></span><br><span class="line">        <span class="comment">//遍历args，从内部实参填充undefined值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i]===<span class="literal">undefined</span>) a[i] = <span class="built_in">arguments</span>[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//现在将剩下的内部实参都追加进去</span></span><br><span class="line">        a = a.concat(array(<span class="built_in">arguments</span>,j));</span><br><span class="line">        <span class="keyword">return</span> f.apply(<span class="keyword">this</span>,a);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数带有三个实参</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">x,y,z</span>)</span>&#123;<span class="keyword">return</span> x*(y-z);&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这三个不完全调用之间的区别</span></span><br><span class="line"><span class="built_in">console</span>.log(partialLeft(f,<span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>)); <span class="comment">//-2，绑定第一个实参：2*(3-4)</span></span><br><span class="line"><span class="built_in">console</span>.log(partialRight(f,<span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>));    <span class="comment">//6，绑定第一个实参：3*(4-2)</span></span><br><span class="line"><span class="built_in">console</span>.log(partial(f,<span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>));     <span class="comment">//-2，绑定第一个实参：2*(3-4)</span></span><br><span class="line"><span class="built_in">console</span>.log(partial(f,<span class="literal">undefined</span>,<span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>));   <span class="comment">//-6，绑定第一个实参：3*(2-4)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>记忆<br> 在函数式编程中，将上次计算的结果缓存起来，这种缓存技巧叫“记忆”(memorization)。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回f()带有记忆功能的版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//将实参转换为字符串形式，并将其用作缓存的键。</span></span><br><span class="line">        <span class="keyword">var</span> key = <span class="built_in">arguments</span>.length+<span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>,<span class="string">','</span>);</span><br><span class="line">        <span class="keyword">if</span>(key <span class="keyword">in</span> cache)&#123;<span class="keyword">return</span> cache[key]&#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="keyword">return</span> cache[key] = f.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2017/03/25/使用gulp移动打包的静态资源到java项目/" class="prev">上一篇</a><a href="/2017/03/11/javascripts权威指南笔记-6/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 - 2019 <a href="http://60kmlh.github.io">60kmlh</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/MikeCoder/hexo-theme-gandalfr" target="_blank">hexo-theme-gandalfr</a>.</p></div></footer></div><script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js" crossorigin="anonymous"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.js" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-147983033-1",'auto');ga('send','pageview');</script><script>$(document).ready(function() { hljs.configure({useBR: true}); $('pre').each(function(i, block) { hljs.highlightBlock(block); }); });</script></body></html>