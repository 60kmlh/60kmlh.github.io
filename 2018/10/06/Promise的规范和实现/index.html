<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Promise的规范和实现 · 60km/h</title><meta name="description" content="Promise的规范和实现 - 60kmlh"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/gandalfr.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/monokai.min.css"><link rel="search" type="application/opensearchdescription+xml" href="http://60kmlh.github.io/atom.xml" title="60km/h"></head><body><div class="wrap"><header><div class="title_wrap"><p>60km/h</p><span class="subtitle typing">好记性不如烂笔头</span></div><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Promise的规范和实现</h1><div class="tags"><a href="/tags/promise/" class="tag-title">#promise</a><a href="/tags/es6/" class="tag-title">#es6</a></div><div class="post-info">2018年10月6日</div><div class="post-content"><h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise ?"></a>什么是Promise ?</h2><p>Promise是JS异步编程中的重要概念，异步抽象处理对象，是目前比较流行Javascript异步编程解决方案之一<br><a id="more"></a></p>
<h2 id="Promises-A-规范"><a href="#Promises-A-规范" class="headerlink" title="Promises/A+ 规范"></a>Promises/A+ 规范</h2><p>为实现者提供一个健全的、可互操作的 JavaScript Promise 的开放标准。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>解决 (fulfill) : 指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 fulfill 来表示解决，但在后世的 promise 实现多以 resolve 来指代之。</li>
<li>拒绝（reject) : 指一个 promise 失败时进行的一系列操作。</li>
<li>拒因 (reason) : 也就是拒绝原因，指在 promise 被拒绝时传递给拒绝回调的值。</li>
<li>终值（eventual value） : 所谓终值，指的是 promise 被解决时传递给解决回调的值，由于 promise 有一次性的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。</li>
<li>Promise : promise 是一个拥有 then 方法的对象或函数，其行为符合本规范。</li>
<li>thenable : 是一个定义了 then 方法的对象或函数，文中译作“拥有 then 方法”。</li>
<li>异常（exception） : 是使用 throw 语句抛出的一个值。<h3 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h3></li>
</ul>
<ol>
<li>Promise 的状态</li>
</ol>
<p>一个 Promise 的当前状态必须为以下三种状态中的一种：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>等待状态 (Pending)</p>
<ul>
<li>可以迁移至执行态或拒绝态<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = FULFILLED || REJECTED ；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>执行状态 (Fulfilled)</p>
<ul>
<li>不能迁移至其他任何状态</li>
<li>必须拥有一个不可变的终值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.value = value;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>拒绝状态 (Rejected)</p>
<ul>
<li>不能迁移至其他任何状态</li>
<li>必须拥有一个不可变的拒因<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.reason = reason;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具有终止态的Promise的状态不能被再次改变</span></span><br><span class="line"><span class="keyword">var</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'fulfilled!'</span>)</span><br><span class="line">  reject(<span class="string">'rejected!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(promise1) </span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//Promise &#123;&lt;resolved&gt;: "fulfilled!"&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>Then方法</li>
</ol>
<p>一个 promise 必须提供一个 then 方法以访问其当前值、终值和拒因。</p>
<p>promise 的 then 方法接受两个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>参数可选<ul>
<li>onFulfilled 和 onRejected 都是可选参数</li>
<li>如果 onFulfilled 不是函数，其必须被忽略</li>
<li>如果 onRejected 不是函数，其必须被忽略</li>
</ul>
</li>
<li>onFulfilled 特性<ul>
<li>如果 onFulfilled 是函数：</li>
<li>当 promise 执行结束后其必须被调用，其第一个参数为 promise 的终值</li>
<li>在 promise 执行结束前其不可被调用</li>
<li>其调用次数不可超过一次</li>
</ul>
</li>
<li>onRejected 特性<ul>
<li>如果 onRejected 是函数：</li>
<li>当 promise 被拒绝执行后其必须被调用，其第一个参数为 promise 的拒因</li>
<li>在 promise 被拒绝执行前其不可被调用</li>
<li>其调用次数不可超过一次</li>
</ul>
</li>
<li>调用时机<ul>
<li>onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用</li>
</ul>
</li>
<li>调用要求<ul>
<li>onFulfilled 和 onRejected 必须被作为函数调用（即没有 this 值）</li>
</ul>
</li>
<li><p>多次调用</p>
<ul>
<li>then 方法可以被同一个 promise 调用多次</li>
<li>当 promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调</li>
<li>当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'fulfilled!'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise1.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'first '</span>,val)</span><br><span class="line">&#125;)</span><br><span class="line">promise1.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'second '</span>,val)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//first  fulfilled!</span></span><br><span class="line"><span class="comment">//second  fulfilled!</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="简易版的实现"><a href="#简易版的实现" class="headerlink" title="简易版的实现"></a>简易版的实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise的三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AjPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="comment">//当前状态</span></span><br><span class="line">    <span class="keyword">this</span>.state = PENDING</span><br><span class="line">    <span class="comment">//终值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//拒因</span></span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//成功态回调队列</span></span><br><span class="line">    <span class="keyword">this</span>.onFulfilledCallbackList = []</span><br><span class="line">    <span class="comment">//拒绝态回调队列</span></span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbackList = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成功态回调</span></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 使用macro-task机制(setTimeout),确保onFulfilled异步执行,且在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">          <span class="keyword">this</span>.state = FULFILLED</span><br><span class="line">          <span class="keyword">this</span>.value = value</span><br><span class="line">          <span class="keyword">this</span>.onFulfilledCallbackList.map(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = cb(<span class="keyword">this</span>.value)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拒绝态回调</span></span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 使用macro-task机制(setTimeout),确保onFulfilled异步执行,且在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">          <span class="comment">// pending(等待态)迁移至 fulfilled(拒绝态),保证调用次数不超过一次。</span></span><br><span class="line">          <span class="keyword">this</span>.state = REJECTED</span><br><span class="line">          <span class="comment">//拒因</span></span><br><span class="line">          <span class="keyword">this</span>.reason = reason</span><br><span class="line">          <span class="keyword">this</span>.onRejectedCallbackList.map(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.reason = cb(<span class="keyword">this</span>.reason)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">0</span>)      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行promise</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fn(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.onFulfilledCallbackList.push(onFulfilled)</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.onRejectedCallbackList.push(onRejected)</span><br><span class="line">    <span class="comment">// 返回this支持then 方法可以被同一个 promise 调用多次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, rejecte</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'yes!'</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;).then(</span><br><span class="line">  (value) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>,value)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(value)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, (e) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'e1'</span>,e)</span><br><span class="line">  <span class="keyword">return</span> e</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>,value)</span><br><span class="line">&#125;, (e) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'e2'</span>,e)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="进一步的规范"><a href="#进一步的规范" class="headerlink" title="进一步的规范"></a>进一步的规范</h2><ul>
<li><p>返回</p>
<ul>
<li>1.then 方法必须返回一个 promise 对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>
<ul>
<li>2.如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：<a href="promise2, x">[Resolve]</a></li>
<li>3.如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e</li>
<li>4.如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值</li>
<li>5.如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因</li>
</ul>
</li>
</ul>
<p>按照以上要求来一步一步完善then方法</p>
<ol>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.首先,then方法必须返回一个promise对象</span></span><br><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line">  <span class="keyword">let</span> newPromise;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">newPromise = <span class="keyword">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;&#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line">  <span class="keyword">let</span> newPromise;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">newPromise = <span class="keyword">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 2.如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[[Resolve]](promise2, x)</span></span><br><span class="line">    <span class="keyword">this</span>.onFulfilledCallbacks.push(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> x = onFulfilled(value);</span><br><span class="line">      <span class="comment">//解决过程 resolvePromise</span></span><br><span class="line">      resolvePromise(newPromise, x);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> x = onRejected(reason);</span><br><span class="line">      <span class="comment">//解决过程 resolvePromise</span></span><br><span class="line">      resolvePromise(newPromise, x);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解决过程</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line">  <span class="keyword">let</span> newPromise;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">newPromise = <span class="keyword">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//  3.如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e。</span></span><br><span class="line">    <span class="keyword">this</span>.onFulfilledCallbacks.push(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> x = onFulfilled(value);</span><br><span class="line">        resolvePromise(newPromise, x);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> x = onRejected(reason);</span><br><span class="line">        resolvePromise(newPromise, x);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4,5.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">then(onFulfilled, onRejected) &#123;  </span><br><span class="line">  <span class="keyword">let</span> newPromise;</span><br><span class="line">  <span class="comment">// 4.如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值。</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">  <span class="comment">// 5.如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因。</span></span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">newPromise = <span class="keyword">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.onFulfilledCallbacks.push(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> x = onFulfilled(value);</span><br><span class="line">        resolvePromise(newPromise, x);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> x = onRejected(reason);</span><br><span class="line">        resolvePromise(newPromise, x);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line">  <span class="keyword">let</span> newPromise;</span><br><span class="line"></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line">  <span class="comment">// 2.2.6规范 对于一个promise，它的then方法可以调用多次.</span></span><br><span class="line">  <span class="comment">// 当在其他程序中多次调用同一个promise的then时 由于之前状态已经为FULFILLED / REJECTED状态，则会走以下逻辑,</span></span><br><span class="line">  <span class="comment">// 所以要确保为FULFILLED / REJECTED状态后 也要异步执行onFulfilled / onRejected ,这里使用setTimeout</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6.不论 promise1 被 reject 还是被 resolve 时 promise2 都会被 resolve，只有出现异常时才会被 rejected。</span></span><br><span class="line">  <span class="comment">// 由于在接下来的解决过程中需要调用resolve,reject进行处理,处理我们在调用处理过程时,传入参数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state == FULFILLED) &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">newPromise = <span class="keyword">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">          resolvePromise(newPromise, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state == REJECTED) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">newPromise = <span class="keyword">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">          resolvePromise(newPromise, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">newPromise = <span class="keyword">new</span> AjPromise((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.onFulfilledCallbacks.push(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFulfilled(value);</span><br><span class="line">          resolvePromise(newPromise, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(reason);</span><br><span class="line">          resolvePromise(newPromise, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Promise 解决过程</li>
</ul>
<p>Promise 解决过程是一个抽象的操作，其需输入一个 promise 和一个值，我们表示为 <a href="promise, x">[Resolve]</a>，如果 x 有 then 方法且看上去像一个 Promise ，解决程序即尝试使 promise 接受 x 的状态；否则其用 x 的值来执行 promise 。</p>
<p>这种 thenable 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。</p>
<p>运行 <a href="promise, x">[Resolve]</a> 需遵循以下步骤：</p>
<ol>
<li>x 与 promise 相等</li>
</ol>
<ul>
<li>如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise</li>
</ul>
<ol start="2">
<li>x 为 Promise</li>
</ol>
<ul>
<li>如果 x 为 Promise ，则使 promise 接受 x 的状态 注4：</li>
<li>如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝</li>
<li>如果 x 处于执行态，用相同的值执行 promise</li>
<li>如果 x 处于拒绝态，用相同的据因拒绝 promise</li>
<li>x 为对象或函数</li>
</ul>
<ol start="3">
<li>如果 x 为对象或者函数：</li>
</ol>
<ul>
<li>把 x.then 赋值给 then</li>
<li>如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise</li>
<li>如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise:<ul>
<li>如果 resolvePromise 以值 y 为参数被调用，则运行 <a href="promise, y">[Resolve]</a></li>
<li>如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise</li>
<li>如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</li>
<li>如果调用 then 方法抛出了异常 e：<ul>
<li>如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之</li>
<li>否则以 e 为据因拒绝 promise</li>
</ul>
</li>
<li>如果 then 不是函数，以 x 为参数执行 promise</li>
</ul>
</li>
<li>如果 x 不为对象或者函数，以 x 为参数执行 promise</li>
</ul>
<p>如果一个 promise 被一个循环的 thenable 链中的对象解决，而 <a href="promise, thenable">[Resolve]</a> 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 TypeError 为据因来拒绝 promise。</p>
<p>加下来一步步处理不同的情况：</p>
<ol>
<li><p>x 与 promise 相等</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//x 与 promise 相等 </span></span><br><span class="line">  <span class="comment">//如果从onFulfilled中返回的x 就是promise2 就会导致循环引用报错</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise</span></span><br><span class="line">  <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>x 为 Promise</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// x 为 Promise</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (x <span class="keyword">instanceof</span> AjPromise) &#123;</span><br><span class="line">    <span class="comment">// 如果 x 为 Promise ，则使 promise 接受 x 的状态</span></span><br><span class="line">    <span class="comment">// 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝</span></span><br><span class="line">    <span class="keyword">if</span> (x.state === PENDING) &#123;</span><br><span class="line">      x.then(</span><br><span class="line">        y =&gt; &#123;</span><br><span class="line">          resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">        &#125;,</span><br><span class="line">        reason =&gt; &#123;</span><br><span class="line">          reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果 x 处于执行态，用相同的值执行 promise</span></span><br><span class="line">      <span class="comment">// 如果 x 处于拒绝态，用相同的据因拒绝 promise</span></span><br><span class="line">      x.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>x 为对象或函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> AjPromise) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x.state === PENDING) &#123;</span><br><span class="line">      x.then(</span><br><span class="line">        y =&gt; &#123;</span><br><span class="line">          resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">        &#125;,</span><br><span class="line">        reason =&gt; &#123;</span><br><span class="line">          reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'function'</span> || <span class="keyword">typeof</span> x === <span class="string">'object'</span>)) &#123;</span><br><span class="line">    <span class="comment">// 避免多次调用</span></span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//把 x.then 赋值给 then</span></span><br><span class="line">      <span class="keyword">let</span> then = x.then;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 then 是函数，将 x 作为函数的作用域 this 调用之。</span></span><br><span class="line">        <span class="comment">// 传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise</span></span><br><span class="line">        <span class="comment">// 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</span></span><br><span class="line">        then.call(</span><br><span class="line">          x,</span><br><span class="line">          <span class="comment">// 如果 resolvePromise 以值 y 为参数被调用，则运行[[Resolve]](promise, y)</span></span><br><span class="line">          y =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise</span></span><br><span class="line">          r =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 then 不是函数，以 x 为参数执行 promise</span></span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise</span></span><br><span class="line">      <span class="comment">// 如果调用 then 方法抛出了异常 e：</span></span><br><span class="line">      <span class="comment">// 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之</span></span><br><span class="line">      <span class="comment">// 否则以 e 为据因拒绝 promise</span></span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">      called = <span class="literal">true</span>;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 x 不为对象或者函数，以 x 为参数执行 promise</span></span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>到此，Promise的解决过程就实现了。</p>
<h2 id="Promise其他静态方法"><a href="#Promise其他静态方法" class="headerlink" title="Promise其他静态方法"></a>Promise其他静态方法</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise.all Promise进行并行处理</span></span><br><span class="line"><span class="comment"> * 参数: promise对象组成的数组作为参数</span></span><br><span class="line"><span class="comment"> * 返回值: 返回一个Promise实例</span></span><br><span class="line"><span class="comment"> * 当这个数组里的所有promise对象全部变为resolve状态的时候，才会resolve。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> done = gen(promises.length, resolve);</span><br><span class="line">        promises.forEach(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">            promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                done(index, value)</span><br><span class="line">            &#125;, reject)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span>(<span class="params">length, resolve</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> values = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">i, value</span>) </span>&#123;</span><br><span class="line">        values[i] = value;</span><br><span class="line">        <span class="keyword">if</span> (++count === length) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(values);</span><br><span class="line">            resolve(values);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Poomise-race"><a href="#Poomise-race" class="headerlink" title="Poomise.race"></a>Poomise.race</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise.race</span></span><br><span class="line"><span class="comment"> * 参数: 接收 promise对象组成的数组作为参数</span></span><br><span class="line"><span class="comment"> * 返回值: 返回一个Promise实例</span></span><br><span class="line"><span class="comment"> * 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理(取决于哪一个更快)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promises.forEach(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">           promise.then(resolve, reject);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">Promises/A+规范</a></li>
<li><a href="https://www.jianshu.com/p/459a856c476f" target="_blank" rel="noopener">Promise详解与实现（Promise/A+规范）</a></li>
<li><a href="https://juejin.im/post/5c2b34a15188257abf1d96eb" target="_blank" rel="noopener">实现一个Promise(基于Promise/A+规范)</a></li>
<li><a href="https://juejin.im/post/5c41297cf265da613356d4ec" target="_blank" rel="noopener">你能手写一个Promise吗？Yes I promise</a></li>
<li><a href="https://juejin.im/post/5afe6d3bf265da0b9e654c4b#heading-11" target="_blank" rel="noopener">Promise不会？？看这里！！！史上最通俗易懂的Promise！！！</a></li>
<li><a href="https://www.kancloud.cn/kancloud/promises-book" target="_blank" rel="noopener">JavaScript Promise迷你书</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/11/10/浏览器缓存原理/" class="prev">上一篇</a><a href="/2018/09/22/React高阶组件原理与应用/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 - 2019 <a href="http://60kmlh.github.io">60kmlh</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/MikeCoder/hexo-theme-gandalfr" target="_blank">hexo-theme-gandalfr</a>.</p></div></footer></div><script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js" crossorigin="anonymous"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.js" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-147983033-1",'auto');ga('send','pageview');</script><script>$(document).ready(function() { hljs.configure({useBR: true}); $('pre').each(function(i, block) { hljs.highlightBlock(block); }); });</script></body></html>