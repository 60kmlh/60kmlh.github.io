<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>React高阶组件的原理与应用 · 60km/h</title><meta name="description" content="React高阶组件的原理与应用 - 60kmlh"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/gandalfr.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/monokai.min.css"><link rel="search" type="application/opensearchdescription+xml" href="http://60kmlh.github.io/atom.xml" title="60km/h"></head><body><div class="wrap"><header><div class="title_wrap"><p>60km/h</p><span class="subtitle typing">好记性不如烂笔头</span></div><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">React高阶组件的原理与应用</h1><div class="tags"><a href="/tags/react/" class="tag-title">#react</a><a href="/tags/hoc/" class="tag-title">#hoc</a></div><div class="post-info">2018年9月22日</div><div class="post-content"><h2 id="什么是高阶组件"><a href="#什么是高阶组件" class="headerlink" title="什么是高阶组件"></a>什么是高阶组件</h2><ul>
<li>高阶函数</li>
</ul>
<p>如果一个函数 接受一个或多个函数作为参数或者返回一个函数 就可称之为 高阶函数。<br><a id="more"></a></p>
<ul>
<li>高阶组件</li>
</ul>
<p>如果一个函数 接受一个或多个组件作为参数并且返回一个组件 就可称之为 高阶组件。</p>
<p>当高阶组件中返回的组件是 无状态组件（Stateless Component） 时，该高阶组件其实就是一个 高阶函数，因为 无状态组件 本身就是一个纯函数。</p>
<h2 id="高阶组件的实现"><a href="#高阶组件的实现" class="headerlink" title="高阶组件的实现"></a>高阶组件的实现</h2><p><strong>React 中的高阶组件主要有两种形式：属性代理 和 反向继承。</strong></p>
<h3 id="属性代理（Props-Proxy）"><a href="#属性代理（Props-Proxy）" class="headerlink" title="属性代理（Props Proxy）"></a>属性代理（Props Proxy）</h3><p>一个函数接受一个 WrappedComponent 组件作为参数传入，并返回一个继承了 React.Component 组件的类，且在该类的 render() 方法中返回被传入的 WrappedComponent 组件。</p>
<p>此时，能对 render() 方法里的 WrappedComponent 组件进行一些处理：</p>
<ul>
<li><p>操作 props</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HigherOrderComponent</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        value: <span class="string">'defalut'</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>抽离 state<br>利用 props 和回调函数把 state 抽离出来：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withOnChange</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props);</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        value: <span class="string">''</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    onChange = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        value</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        value: <span class="keyword">this</span>.state.value,</span><br><span class="line">        onChange: <span class="keyword">this</span>.onChange,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过 ref 访问到组件实例</li>
</ul>
<p>在需要访问 DOM element （使用第三方 DOM 操作库）的时候就会用到组件的 ref 属性。它只能声明在 Class 类型的组件上，而无法声明在函数（无状态）类型的组件上。</p>
<p>不能在无状态组件（函数类型组件）上使用 ref 属性，因为无状态组件没有实例。<br>ref 的值可以是字符串（不推荐使用）也可以是一个回调函数，如果是回调函数的话，它的执行时机是：</p>
<ul>
<li>组件被挂载后（componentDidMount），回调函数立即执行，回调函数的参数为该组件的实例。</li>
<li>组件被卸载（componentDidUnmount）或者原有的 ref 属性本身发生变化的时候，此时回调函数也会立即执行，且回调函数的参数为 null。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HigherOrderComponent</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    executeInstanceMethod = <span class="function">(<span class="params">wrappedComponentInstance</span>) =&gt;</span> &#123;</span><br><span class="line">      wrappedComponentInstance.someMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; <span class="attr">ref</span>=<span class="string">&#123;this.executeInstanceMethod&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用其他元素包裹传入的组件 WrappedComponent</li>
</ul>
<p>给 WrappedComponent 组件包一层背景色为 #fafafa 的 div 元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withBackgroundColor</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div style=&#123;&#123; <span class="attr">backgroundColor</span>: <span class="string">'#fafafa'</span> &#125;&#125;&gt;</span><br><span class="line">            &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="反向继承（Inheritance-Inversion）"><a href="#反向继承（Inheritance-Inversion）" class="headerlink" title="反向继承（Inheritance Inversion）"></a>反向继承（Inheritance Inversion）</h3><p>一个函数接受一个 WrappedComponent 组件作为参数传入，并返回一个继承了该传入 WrappedComponent 组件的类，且在该类的 render() 方法中返回 super.render() 方法。</p>
<p>作用：</p>
<ul>
<li>操作 state</li>
</ul>
<p>高阶组件中可以读取、编辑和删除 WrappedComponent 组件实例中的 state。甚至可以增加更多的 state 项，但是 非常不建议这么做 因为这可能会导致 state 难以维护及管理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLogging</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h2&gt;Debugger Component Logging...&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">          &lt;p&gt;state:&lt;/</span>p&gt;</span><br><span class="line">          &lt;pre&gt;&#123;<span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.state, <span class="literal">null</span>, <span class="number">4</span>)&#125;&lt;<span class="regexp">/pre&gt;</span></span><br><span class="line"><span class="regexp">          &lt;p&gt;props:&lt;/</span>p&gt;</span><br><span class="line">          &lt;pre&gt;&#123;<span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.props, <span class="literal">null</span>, <span class="number">4</span>)&#125;&lt;<span class="regexp">/pre&gt;</span></span><br><span class="line"><span class="regexp">          &#123;super.render()&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>渲染劫持（Render Highjacking）</li>
</ul>
<p>渲染劫持 是因为高阶组件控制着 WrappedComponent 组件的渲染输出，通过渲染劫持我们可以：</p>
<ul>
<li>有条件地展示元素树（element tree）</li>
<li>操作由 render() 输出的 React 元素树</li>
<li>在任何由 render() 输出的 React 元素中操作 props</li>
<li>用其他元素包裹传入的组件 WrappedComponent （同 属性代理）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLoading</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.props.isLoading) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Loading</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">            &#125; else &#123;</span></span><br><span class="line"><span class="xml">                return super.render();</span></span><br><span class="line"><span class="xml">            &#125;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HigherOrderComponent</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">const</span> tree = <span class="keyword">super</span>.render();</span><br><span class="line">            <span class="keyword">const</span> newProps = &#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span> (tree &amp;&amp; tree.type === <span class="string">'input'</span>) &#123;</span><br><span class="line">                newProps.value = <span class="string">'something here'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> props = &#123;</span><br><span class="line">                ...tree.props,</span><br><span class="line">                ...newProps,</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">const</span> newTree = React.cloneElement(tree, props, tree.props.children);</span><br><span class="line">            <span class="keyword">return</span> newTree;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高阶组件存在的问题"><a href="#高阶组件存在的问题" class="headerlink" title="高阶组件存在的问题"></a>高阶组件存在的问题</h2><ul>
<li>静态方法丢失<br>因为原始组件被包裹于一个容器组件内，也就意味着新组件会没有原始组件的任何静态方法。</li>
</ul>
<p>须将静态方法做拷贝：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HigherOrderComponent</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Enhance</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 必须得知道要拷贝的方法</span></span><br><span class="line">  Enhance.staticMethod = WrappedComponent.staticMethod;</span><br><span class="line">  <span class="keyword">return</span> Enhance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>借助库 hoist-non-react-statics 来自动处理，它会 自动拷贝所有非 React 的静态方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistNonReactStatic <span class="keyword">from</span> <span class="string">'hoist-non-react-statics'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HigherOrderComponent</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Enhance</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line">  hoistNonReactStatic(Enhance, WrappedComponent);</span><br><span class="line">  <span class="keyword">return</span> Enhance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>refs 属性不能透传<br>高阶组件可以传递所有的 props 给包裹的组件 WrappedComponent，但是有一种属性不能传递，它就是 ref。与其他属性不同的地方在于 React 对其进行了特殊的处理。</li>
</ul>
<p>如果你向一个由高阶组件创建的组件的元素添加 ref 引用，那么 ref 指向的是最外层容器组件实例的，而不是被包裹的 WrappedComponent 组件。</p>
<p>React 为我们提供了一个名为 React.forwardRef 的 API 来解决这一问题（在 React 16.3 版本中被添加）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLogging</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Enhance</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    componentWillReceiveProps() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Current props'</span>, <span class="keyword">this</span>.props);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Next props'</span>, nextProps);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;forwardedRef, ...rest&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">      <span class="comment">// 把 forwardedRef 赋值给 ref</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...rest</span>&#125; <span class="attr">ref</span>=<span class="string">&#123;forwardedRef&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  // React.forwardRef 方法会传入 props 和 ref 两个参数给其回调函数</span></span><br><span class="line"><span class="xml">  // 所以这边的 ref 是由 React.forwardRef 提供的</span></span><br><span class="line"><span class="xml">  function forwardRef(props, ref) &#123;</span></span><br><span class="line">    return &lt;Enhance &#123;...props&#125; forwardRef=&#123;ref&#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return React.forwardRef(forwardRef);</span><br><span class="line">&#125;</span><br><span class="line">const EnhancedComponent = withLogging(SomeComponent);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>反向继承不能保证完整的子组件树被解析<br>如果渲染 elements tree 中包含了 function 类型的组件的话，这时候就不能操作组件的子组件了。<h2 id="遵循的约定"><a href="#遵循的约定" class="headerlink" title="遵循的约定"></a>遵循的约定</h2></li>
<li>props 保持一致<br>保持原有组件的 props 不受影响。</li>
<li>不要以任何方式改变原始组件 WrappedComponent<br>对原有组件产生了副作用，失去了组件复用的意义，所以请通过 纯函数（相同的输入总有相同的输出） 返回新的组件。</li>
<li>透传不相关 props 属性给被包裹的组件 WrappedComponent</li>
<li>不要再 render() 方法中使用高阶组件<br>调用高阶函数的时候每次都会返回一个新的组件，每次 render 的时候，都会使子对象树完全被卸载和重新渲染，重新加载一个组件会引起原有组件的状态和它的所有子组件丢失。</li>
<li><p>使用 compose 组合高阶组件<br>可以显著提高代码的可读性和逻辑的清晰度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要这么使用</span></span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))；</span><br><span class="line"><span class="comment">// 可以使用一个 compose 函数组合这些高阶组件</span></span><br><span class="line"><span class="comment">// lodash, redux, ramda 等第三方库都提供了类似 `compose` 功能的函数</span></span><br><span class="line"><span class="keyword">const</span> enhance = compose(withRouter, connect(commentSelector))；</span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = enhance(WrappedComponent)；</span><br></pre></td></tr></table></figure>
</li>
<li><p>包装显示名字以便于调试<br>高阶组件创建的容器组件在 React Developer Tools 中的表现和其它的普通组件是一样的。为了便于调试，可以选择一个显示名字，传达它是一个高阶组件的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getDisplayName = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> WrappedComponent.displayName || WrappedComponent.name || <span class="string">'Component'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HigherOrderComponent</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HigherOrderComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">  HigherOrderComponent.displayName = <span class="string">`HigherOrderComponent(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line">  <span class="keyword">return</span> HigherOrderComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h2><ul>
<li>权限控制<br>利用高阶组件的 条件渲染 特性可以对页面进行权限控制，权限控制一般分为两个维度：页面级别 和 页面元素级别。</li>
<li><p>组件渲染性能追踪<br>根据react父子组件的渲染顺序和父组件子组件生命周期规则捕获子组件的生命周期，可以方便的对某个组件的渲染时间进行记录：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withTiming</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props);</span><br><span class="line">      <span class="keyword">this</span>.start = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">this</span>.end = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillMount() &#123;</span><br><span class="line">      <span class="keyword">super</span>.componentWillMount &amp;&amp; <span class="keyword">super</span>.componentWillMount();</span><br><span class="line">      <span class="keyword">this</span>.start = <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="keyword">super</span>.componentDidMount &amp;&amp; <span class="keyword">super</span>.componentDidMount();</span><br><span class="line">      <span class="keyword">this</span>.end = <span class="built_in">Date</span>.now();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;WrappedComponent.name&#125;</span> 组件渲染时间为 <span class="subst">$&#123;<span class="keyword">this</span>.end - <span class="keyword">this</span>.start&#125;</span> ms`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withTiming(Home);</span><br></pre></td></tr></table></figure>
</li>
<li><p>页面复用<br>将多个页面不同的部分抽离到外部传入，从而实现页面的复用。</p>
<h2 id="Function-as-Child-Components"><a href="#Function-as-Child-Components" class="headerlink" title="Function as Child Components"></a>Function as Child Components</h2><p>另一种类似高阶组件的方式叫做 Function as Child Components。它的思路是将函数（执行结果是返回新的组件）作为子组件传入，在父组件的render方法中执行此函数，可以传入特定的参数作为子组件的props。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentWithAge</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      name: <span class="string">'小红'</span>,</span><br><span class="line">      age: <span class="number">25</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children(<span class="keyword">this</span>.state.name, <span class="keyword">this</span>.state.age)&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;StudentWithAge&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    (name, age) =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> studentName = name;</span><br><span class="line">      <span class="keyword">if</span> (age &gt; <span class="number">22</span>) &#123;</span><br><span class="line">          studentName = <span class="string">`大学毕业的<span class="subst">$&#123;studentName&#125;</span>`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Student</span> <span class="attr">name</span>=<span class="string">&#123;studentName&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">StudentWithAge</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>相比高阶组件的优点：</p>
<ol>
<li>代码结构上少掉了一层（返回高阶组件的）函数封装。<br>2.调试时组件结构更加清晰<br>3.从组件复用角度来看，父组件和子组件之间通过children连接，两个组件其实又完全可以单独使用，内部耦合较小。当然单独使用意义并不大，而且高阶组件也可以通过组合两个组件来做到。<br>缺点：</li>
<li>（返回子组件）函数占用了父组件原本的props.children；</li>
<li>（返回子组件）函数只能进行调用，无法劫持劫持原组件生命周期方法或取到static方法；</li>
<li>（返回子组件）函数作为子组件包裹在父组件中的方式看起来虽灵活但不够优雅；</li>
<li>由于子组件的渲染控制完全通过在父组件render方法中调用（返回子组件）函数，无法通过shouldComponentUpdate来做性能优化。</li>
</ol>
<p>所以这两种方式各有优劣，可根据具体场景选择。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">Higher-Order Components - React</a></li>
<li><a href="https://juejin.im/post/5c72b97de51d4545c66f75d5" target="_blank" rel="noopener">React 中的高阶组件及其应用场景</a></li>
<li><a href="https://juejin.im/post/59b36b416fb9a00a636a207e" target="_blank" rel="noopener">React高阶组件实践</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/10/06/Promise的规范和实现/" class="prev">上一篇</a><a href="/2018/08/11/React服务端渲染的实现/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 - 2019 <a href="http://60kmlh.github.io">60kmlh</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/MikeCoder/hexo-theme-gandalfr" target="_blank">hexo-theme-gandalfr</a>.</p></div></footer></div><script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js" crossorigin="anonymous"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.js" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-147983033-1",'auto');ga('send','pageview');</script><script>$(document).ready(function() { hljs.configure({useBR: true}); $('pre').each(function(i, block) { hljs.highlightBlock(block); }); });</script></body></html>